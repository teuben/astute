#!/usr/bin/env python
#
"""
This set of libraries, analysisUtils.py, is a collection of often useful
python and/or CASA related functions.  It is an open package for anyone
on the science team to add to and generalize (and commit).  A few
practices will allow us to keep this useful.

1) Write the routines as generally as you can.

2) Before fundamentally changing the default behavior of a function
or class, consider your coworkers.  Do not modify the default behavior
without extreme need and warning.  If you need to modify it quickly,
consider a separate version until the versions can be blended (but please
do try to do the blending!).

3) There is a comment structure within the routines.  Please keep this
for additions because the documentation is automatically generated from
these comments.
 
All examples assume you have imported the library to aU, as import
analysisUtils as aU. You can of course do whatever you like, but the
examples will thus have to be modified.

Thanks and good luck!  If you have any questions, bother Barkats or
Corder, then Robert.
 
S. Corder, 2010-11-07
"""

if 1 :
    import os
    import shutil
    import distutils.spawn # used in class linfit to determine if dvipng is present
    import sys
    import re
    from types import NoneType
    import telnetlib   
    import math
    import numpy as np
    import binascii # used for debugging planet()
    from mpfit import mpfit
    from pylab import *
    import pylab as pb
    import matplotlib.pyplot as plt
    from matplotlib.font_manager import FontProperties
    from numpy.fft import fft
    import fnmatch, pickle, traceback, copy as python_copy # needed for editIntents
    import scipy as sp
    import scipy.signal as spsig
    import scipy.special # for Bessel functions
    import scipy.spatial.distance as ssd
    import string
    import struct # needed for getPngWidthHeight
    import glob
    import readscans as rs
    import time as timeUtilities
    import datetime
    import tmUtils as tmu
    import compUtils  # used in class SQLD
    import pytz  # used in computeUTForElevation
    from scipy.special import erf, erfc  # used in class Atmcal
    from scipy import ndimage
    from scipy import polyfit
    from scipy import optimize # used by class linfit
    import random  # used by class linfit
    import matplotlib.ticker # used by plotWeather
    from matplotlib import rc # used by class linfit
    from matplotlib.figure import SubplotParams
    from matplotlib.ticker import MultipleLocator # used by plotPointingResults
    import commands  # useful for capturing stdout from a system call
    import warnings
    try:
        from asdm import ASDM
        asdmLibraryAvailable = True
    except:
        import au_noASDMLibrary
        asdmLibraryAvailable = False
    #
    # Beginning of casa stuff.
    # Set to False if you want to import analysisUtils outside of casa.
    # 
    if (os.getenv('CASAPATH') is not None):
        import plotbandpass3 as plotbp3
        import simutil # needed for obslist, has useful pad transforming functions
        from taskinit import *
        # This arrangement allows you to call casa commands by name: - T. Hunter
        from listobs_cli import listobs_cli as listobs
        from gencal_cli import gencal_cli as gencal
        from imview_cli import imview_cli as imview
        from plotms_cli import plotms_cli as plotms
        from imstat_cli import imstat_cli as imstat
        try:
            from imsubimage_cli import imsubimage_cli as imsubimage
            useImsubimage = True
        except:
            useImsubimage = False
        from imfit_cli import imfit_cli as imfit
        from imhead_cli import imhead_cli as imhead
        from gaincal_cli import gaincal_cli as gaincal
        from plotuv_cli import plotuv_cli as plotuv
        from immath_cli import immath_cli as immath # used by complexToSquare()
        from imregrid_cli import imregrid_cli as imregrid # used by complexToSquare()
        from exportfits_cli import exportfits_cli as exportfits # used by makeSimulatedImage()
        from casa import image as casaimage
        try:
            from predictcomp_cli import predictcomp_cli as predictcomp
            usePredictComp = True
        except:
            usePredictComp = False
        try:      # CASA 3.4
            from simobserve_cli import simobserve_cli as simobserve
            from simanalyze_cli import simanalyze_cli as simanalyze
        except:   # CASA 3.3
            from sim_observe_cli import sim_observe_cli as simobserve
            from sim_analyze_cli import sim_analyze_cli as simanalyze
        try:
            import solar_system_setjy as sss
            useSolarSystemSetjy = True
        except:
            useSolarSystemSetjy = False
        from importasdm import importasdm
        from plotcal import plotcal
        from sdplot import sdplot
        from split import split
        from setjy import setjy
        try:
            from plotxy import plotxy
            mymp = mp  # Check if the msplot tool is available, as it is needed by plotxy
            plotxyAvailable = True
        except:
            plotxyAvailable = False
        from fixvis import fixvis
        from fixplanets import fixplanets
        from bandpass import bandpass
        import casadef
        import viewertool
        from clearstat import clearstat
        if (casadef.casa_version >= '4.0.0'):
            defaultEphemeris = 'Butler-JPL-Horizons 2012'
        else:
            defaultEphemeris = 'Butler-JPL-Horizons 2010'
        # end of casa stuff
    else:
        defaultEphemeris = 'Butler-JPL-Horizons 2012'
     
    import fileIOPython as fiop
    from scipy.interpolate import splev, splrep
    from scipy.stats import scoreatpercentile, percentileofscore
    import types
    import operator
    import XmlObjectifier
    from xml.dom import minidom
    import subprocess
    import urllib2
    import itertools
    import calDatabaseQuery  # used by searchFlux
    import socket            # used by searchFlux to set tunnel default
    try:
        import pyfits # needed for getFitsBeam
        pyfitsPresent = True
    except:
        pyfitsPresent = False
"""
Constants that are sometimes useful.  Warning these are cgs, we might want to change them
to SI given the propensity in CASA to use SI.
"""
h=6.6260755e-27
k=1.380658e-16
c=2.99792458e10
c_mks=2.99792458e8
jy2SI=1.0e-26
jy2cgs=1.0e-23
pc2cgs=3.0857e18
au2cgs=1.4960e13
solmass2g=1.989e33
earthmass2g=5.974e27
solLum2cgs = 3.826e33
mH = 1.673534e-24
G  = 6.67259e-8
Tcmb = 2.725
ALMA_LONGITUDE=-67.7549
ALMA_LATITUDE=-23.0229
ARCSEC_PER_RAD=206264.80624709636

JPL_HORIZONS_ID = {'ALMA': '-7',
                   'VLA': '-5',
                   'GBT': '-9',
                   'MAUNAKEA': '-80',
                   'OVRO': '-81'
}
# Please keep these objects in this order (mean orbital radius from sun)
majorPlanets = ['SUN','MERCURY','VENUS','MOON','MARS','JUPITER','SATURN','URANUS','NEPTUNE','PLUTO']

bandDefinitions = {
    1  : [31.3e9, 45e9  ],
    2  : [67e9  , 90e9  ],
    3  : [84e9  , 116e9 ],
    4  : [125e9 , 163e9 ],
    5  : [163e9 , 211e9 ],
    6  : [211e9 , 275e9 ],
    7  : [275e9 , 373e9 ],
    8  : [385e9 , 500e9 ],
    9  : [602e9 , 720e9 ],
    10 : [787e9 , 950e9]
    }

casaRevisionWithAlmaspws = '26688'

def version():
    """
    Returns the CVS revision number.
    """
    myversion = "$Id$"
    return myversion

def help(match='', debug=False):
    """
    Print an alphabetized list of all the defined functions at the top level in
    analysisUtils.py.
    match: limit the list to those functions containing this string (case insensitive)
    -- Todd Hunter
    """
    myfile = __file__
    if (myfile[-1] == 'c'):
        if (debug): print "au loaded from .pyc file, looking at .py file instead"
        myfile = myfile[:-1]
    aufile = open(myfile,'r')
    lines = aufile.readlines()
    if (debug): print "Read %d lines from %s" % (len(lines), __file__)
    aufile.close()
    commands = []
    for line in lines:
        if (line.find('def ') == 0):
            commandline = line.split('def ')[1]
            tokens = commandline.split('(')
            if (len(tokens) > 1):
                command = tokens[0]
            else:
                command = commandline.strip('\n\r').strip('\r\n')
            if (match == '' or command.lower().find(match.lower()) >= 0):
                commands.append(command)
    commands.sort()
    for command in commands:
        print command
    
def getBand(freq) :
    """
    Converts a frequency into an ALMA band number.
    freq: can be given either as a floating point value in Hz, or a string
          with units at the end (GHz, MHz, kHz, or Hz).
    Todd Hunter
    """
    if (type(freq) == str):
        freq = parseFrequencyArgument(freq)
    for band in bandDefinitions.keys() :
        if ((freq <= bandDefinitions[band][1]) and (freq >= bandDefinitions[band][0])) :
            return band
    print "This frequency does not lie within any ALMA band."

# A useful sequence of 19 unique matplotlib colors to cycle through
overlayColors = [
      [0.00,  0.00,  1.00],
      [0.00,  0.50,  0.00],
      [1.00,  0.00,  0.00],
      [0.00,  0.75,  0.75],
      [0.75,  0.00,  0.75],
      [0.25,  0.25,  0.25],
      [0.75,  0.25,  0.25],
#      [0.95,  0.95,  0.00],  yellow
      [0.25,  0.25,  0.75],
      [1.00,  0.75,  0.75], # [0.75, 0.75, 0.75] is invisible on gray border
      [0.00,  1.00,  0.00],
      [0.76,  0.57,  0.17],
      [0.54,  0.63,  0.22],
      [0.34,  0.57,  0.92],
      [1.00,  0.10,  0.60],
      [0.70,  1.00,  0.70], # [0.88,  0.75,  0.73], hard to see on gray
      [0.10,  0.49,  0.47],
      [0.66,  0.34,  0.65],
      [0.99,  0.41,  0.23]]
overlayColors += overlayColors + overlayColors

def makeTimeStamp():
    return timeUtilities.strftime('%Y-%m-%dT%H:%M:%S')

def makeList(input) :
    if list not in [type(input)] : return [input]
    else : return input

def locate(msfile):
    """
    Script used to locate an ASDM or an MS file in the RADIO data directory tree.
    """
    host=os.getenv('HOSTNAME')
    if 'gns' in host:
        datadir='/groups/science/data/RADIO'
    elif 'red' in  host:
        datadir="/data/RADIO/"
    else:
        datadir="/data/RADIO/"
        
    if not msfile.find(':') == []:  msfile=msfile.replace('/','_').replace(':','_')
    print msfile

    # first search via locate utility
    a=os.popen('locate %s' %(msfile)).read()
    m=re.search('/data/RADIO/[A-Z]*/.*/[0-9].*/%s/' %msfile,a)
  
    if  type(m) is not(NoneType):
        location=m.group(0)
        print 'using Unix locate'
        location=makeList(location)
    else:
        print 'using Unix find'
        location=os.popen('find  %s -name %s' %(datadir,  msfile)).read().split('\n')
        
    if location != ['']:
        for i in range(size(location)):
            if ('ASDMBinary' not in location[i]):
                location=location[i]
                break
            else:
                print 'could not find this file in local dir or in /data/RADIO'
                return
        dir=location.strip(msfile)
        return [location, dir]
    else:
        print 'could not find this file in local dir or in /data/RADIO'
        return

def psd(d, fsample):
    
    # function to take the psd of a timestream and return also the freq axis and the phase. 
    # input should be 1D
    # fsample in Hz
    
    d = double(d)
    if floor(size(d) / 2) * 2 != size(d):
        d=d[1:]
        
    n = size(d) / 2
    transform = fft(d)
    transform=transform[0:n+1]
    freq = (fsample / 2.0) * (arange(n+1)) / n
    factor = repeat([2.0],n+1)
    factor[0]=1.
    factor[-1]=1.
    spec = sqrt(factor / freq[1]) * transform/ (2*n);
    spec = abs(spec);
        
    return freq,spec


def avpsd(d, fsample, fres,  deg=1):
    # %function [freq,spec,nrep]=avpsd(input, fsample, fres, med, deg)
    # make an average psd by averaging the psd from small segments of resolution fres
  
    n = size(d);
    nout = floor(fsample / fres)
    nrep = floor(n / nout)
    x=arange(nout)
    psdarr = zeros([nrep, nout/2+1])
    print "%i %i" %(nout, nrep)
    
    if (deg !=-1):
        for i in arange(nrep): 
            y=d[i*nout : (i+1)* nout]
            p =polyfit(x,y, deg);
            baseline=polyval(p,x);
            y=y-baseline;
            [freq,ps]=psd(y, fsample);        
            psdarr[i, :] = ps
    else:
        for i in arange(nrep):
            y=d[i*nout : (i+1) * nout]
            [freq,ps]=psd(y, fsample);
            psdarr[i, :] = ps;

    print shape(psdarr)
    spec=sqrt(mean(psdarr*psdarr,0));
    
    return freq, spec

def smooth(x, window_len=10, window='hanning'):
    """
    smooth the data using a window with requested size.
    
    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal 
    (with the window size) in both ends so that transient parts are minimized
    in the beginning and end part of the output signal.
    
    input:
        x: the input signal 
        window_len: the dimension of the smoothing window
        window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
            flat window will produce a moving average smoothing.

    output:
        the smoothed signal
        
    example:

    t = linspace(-2,2,0.1)
    x = sin(t)+random.randn(len(t))*0.1
    y = smooth(x)
    
    see also: 
    
    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
    scipy.signal.lfilter
 
    TODO: the window parameter could be the window itself if an array instead of a string   
    """

    if x.ndim != 1:
        raise ValueError, "smooth only accepts 1 dimension arrays."

    if x.size < window_len:
        raise ValueError, "Input vector needs to be bigger than window size."

    if window_len < 3:
        return x

    if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman', 'gauss']:
        raise ValueError, "Window is on of 'flat', 'hanning', 'hamming', 'bartlett', 'blackman', 'gauss'"

    s=np.r_[2*x[0]-x[window_len:1:-1], x, 2*x[-1]-x[-1:-window_len:-1]]
    #print(len(s))
    
    if window == 'flat': #moving average
        w = np.ones(window_len,'d')
    elif window == 'gauss':
        w=gauss_kern(window_len)
    else:
        w = getattr(np, window)(window_len)
    y = np.convolve(w/w.sum(), s, mode='same')
    return y[window_len-1:-window_len+1]


# some quick code I added.
def movingStD(a, w):
   """
   Moving standard deviation of array a calculated with window size w
   """
   res=[std(a[i:i+w]) for i in range(len(a)-w)]
   return res


def movStd(t,d, w,removeoutlier=True):
    trms=[]
    drms=[]

    #if removeoutlier:
    #    d = remove_outlier(d, sigma_th=10)
    
    s=size(d)
    #print s, pl.ceil(s/w)
    
    for i in range(s/w):

        
        x=arange(w-1)
        y=d[w*i:w*(i+1)-1]
        polycoeffs=polyfit(x, y, 2)
        yfit=polyval(polycoeffs, x)
        #pl.clf()
        #pl.plot(x,y)
        #pl.plot(x,yfit)
        y=y-yfit
        #pl.plot(x,y)
        #raw_input()
           
        trms.append(t[w*(i+1)])
        drms.append(std(y))

    return trms, drms


def gauss_kern(size):
    """ Returns a normalized 2D gauss kernel array for convolutions """
    size = int(size)
    x= np.mgrid[-size:size+1]
    g = np.exp(-(x**2/float(size)))
    return g / g.sum()

def onedgaussianplus(x, H,A,dx,w, r):
    #fit a 1D gaussian plus a linear term
    return H+A*np.exp(-(x-dx)**2/(2*w**2))+r*(x-dx)

def onedgaussian(x,H,A,dx,w):
    """
    Returns a 1-dimensional gaussian of form
    H+A*np.exp(-(x-dx)**2/(2*w**2))
    """
    return H+A*np.exp(-(x-dx)**2/(2*w**2))

def onedgaussfit(xax,data,err=None,params=[0,1,0,1,0],fixed=[False,False,False,False,False],limitedmin=[False,False,False,False,False],
        limitedmax=[False,False,False,False,False],minpars=[0,0,0,0,0],maxpars=[0,0,0,0,0],quiet=True,shh=True):
    """
    Inputs:
       xax - x axis
       data - y axis
       err - error corresponding to data

       params - Fit parameters: Height of background, Amplitude, Shift, Width, Linear
       fixed - Is parameter fixed?
       limitedmin/minpars - set lower limits on each parameter
       limitedmax/maxpars - set upper limits on each parameter
       quiet - should MPFIT output each iteration?
       shh - output final parameters?

    Returns:
       Fit parameters
       Model
       Fit errors
       chi2
    """

    def mpfitfun(x,y,err):
        if err == None:
            def f(p,fjac=None): return [0,(y-onedgaussianplus(x,*p))]
        else:
            def f(p,fjac=None): return [0,(y-onedgaussianplus(x,*p))/err]
        return f

    if xax == None:
        xax = np.arange(len(data))

    parinfo = [ {'n':0,'value':params[0],'limits':[minpars[0],maxpars[0]],'limited':[limitedmin[0],limitedmax[0]],'fixed':fixed[0],'parname':"HEIGHT",'error':0} ,
                {'n':1,'value':params[1],'limits':[minpars[1],maxpars[1]],'limited':[limitedmin[1],limitedmax[1]],'fixed':fixed[1],'parname':"AMPLITUDE",'error':0},
                {'n':2,'value':params[2],'limits':[minpars[2],maxpars[2]],'limited':[limitedmin[2],limitedmax[2]],'fixed':fixed[2],'parname':"SHIFT",'error':0},
                {'n':3,'value':params[3],'limits':[minpars[3],maxpars[3]],'limited':[limitedmin[3],limitedmax[3]],'fixed':fixed[3],'parname':"WIDTH",'error':0},
                {'n':4,'value':params[4],'limits':[minpars[4],maxpars[4]],'limited':[limitedmin[4],limitedmax[4]],'fixed':fixed[4],'parname':"LINEAR",'error':0}]
    
    mp = mpfit(mpfitfun(xax,data,err),parinfo=parinfo,quiet=quiet)
    mp.status
    mpp = mp.params
    mpperr = mp.perror
    chi2 = mp.fnorm

    if not shh:
        for i,p in enumerate(mpp):
            parinfo[i]['value'] = p
            print parinfo[i]['parname'],p," +/- ",mpperr[i]
        print "Chi2: ",mp.fnorm," Reduced Chi2: ",mp.fnorm/len(data)," DOF:",len(data)-len(mpp)

    return mpp,onedgaussianplus(xax,*mpp),mpperr,chi2


def almaToGeo(lon, lat, alma):
    """
    Convert the local (horizontal) coordinates into geocentric
    lon: longitude in radians (e.g. au.ALMA_LONGITUDE)
    lat: latitude in radians (e.g. au.ALMA_LATITUDE)
    alma: local coordinates: [E,N,U]
    """
    geo = [0, 0, 0]
    geo[0] = -math.sin(lon) * alma[0] \
             - math.cos(lon) * math.sin(lat) * alma[1] \
             + math.cos(lon) * math.cos(lat) * alma[2]
    geo[1] = math.cos(lon) * alma[0] \
             - math.sin(lon) * math.sin(lat) * alma[1] \
             + math.sin(lon) * math.cos(lat) * alma[2]
    geo[2] = math.cos(lat) * alma[1] + math.sin(lat) * alma[2]
    return geo

def geoToAlma(lon, lat, geo):
    """
    Convert the geocentric coordinates into the local (horizontal) ones.
    lon: longitude in radians (e.g. au.ALMA_LONGITUDE)
    lat: latitude in radians (e.g. au.ALMA_LATITUDE)
    geo: geocentric coordinates: [X,Y,Z]
    """
    alma = [0, 0, 0]
    alma[0] = -geo[0] * math.sin(lon) + geo[1] * math.cos(lon)
    alma[1] = -geo[0] * math.cos(lon) * math.sin(lat)  \
              - geo[1] * math.sin(lon) * math.sin(lat) \
              + geo[2] * math.cos(lat)
    alma[2] = geo[0] * math.cos(lon) * math.cos(lat) \
              + geo[1] * math.sin(lon) * math.cos(lat) \
              + geo[2] * math.sin(lat)
    return alma

def getChannelAverageData(inputms):
    tb.open(inputms)
    chanAvertb = tb.query('ANTENNA1==0 && ANTENNA2==1 && DATA_DESC_ID==1')
    chanAverData = chanAvertb.getcol('DATA')
    chanAverTime = chanAvertb.getcol('TIME')
    # single pol and single channel:
    visi = chanAverData[0][0]
    chanAverPhase = angle(visi)
    chanAverAmp = absolute(visi)
    tb.close()
    return [chanAverTime, chanAverAmp, chanAverPhase]

def getDataColumnName(inputms):
    """
    Gets the name of the data column of a measurement set: either 'DATA'
    or 'FLOAT_DATA'
    """
    mytb = createCasaTool(tbtool)
    mytb.open(inputms)
    colnames = mytb.colnames()
    if 'FLOAT_DATA' in colnames:
        data_query= 'FLOAT_DATA'
    else:
        data_query = 'DATA'
    mytb.close()
    return(data_query)

def getSpectralData(inputms, dd, scanum=[]):
    tb.open(inputms)
    if size(scanum) == 0:
        specTb = tb.query('ANTENNA1==0 && ANTENNA2==1 && DATA_DESC_ID==%d'%(dd))
    else:
        specTb = tb.query('ANTENNA1==0 && ANTENNA2==1 && DATA_DESC_ID==%d && SCAN_NUMBER == %d'%(dd,scanum))
    if 'FLOAT_DATA' in specTb.colnames():
        data_query= 'FLOAT_DATA'
    else:
        data_query='DATA'
    specData = specTb.getcol(data_query)
    specTime = specTb.getcol('TIME')
    date  = int(specTime[0]/ 86400)
    specTime = specTime - date*86400
    return [specTime, specData]

def getSpectralAutoData(inputms,iant, dd, scanum=[]):
    tb.open(inputms)
    if size(scanum) == 0:
        specTb = tb.query('ANTENNA1==%d && ANTENNA2==%d && DATA_DESC_ID==%d'%(iant, iant,dd))
    else:
        specTb = tb.query('ANTENNA1==%d && ANTENNA2==%d && DATA_DESC_ID==%d && SCAN_NUMBER == %d' % (iant, iant ,dd, scanum))
    if 'FLOAT_DATA' in specTb.colnames():
        data_query= 'FLOAT_DATA'
    else:
        data_query='DATA'
    specData = specTb.getcol(data_query)
    specTime = specTb.getcol('TIME')
    date  = int(specTime[0]/ 86400)
    specTime = specTime - date*86400
    return [specTime, specData]

#def getMeasFocus(msfile, aid, scanum):
#    """
#    Now obsolete
#    Look into EditfocusModel for more upto date versions
#    """
#    
#    try:
#        print "Focus values from actual measurements at start of Beam map."
#        if os.path.isdir(msfile+'/ASDM_FOCUS'):
#            tb.open(msfile+'/ASDM_FOCUS')
#            antid=tb.getcol('antennaId')
#            foc=tb.getcol('measuredFocusPosition')
#            asdmtime=tb.getcol('timeInterval')
#
#            q=find(antid== 'Antenna_%i' %aid)
#            asdmtime=asdmtime[0,q]
#            foc=foc[:,q]
#            
#            tb.open(msfile+'/ANTENNA')
#            antennas=tb.getcol('NAME')
#            tb.open(msfile)
#            scan=tb.getcol('SCAN_NUMBER')
#            t0=tb.getcol('TIME')
#            tb.close() 
#            f=find(scan==int(scanum))[0]
#            scanbeg=t0[f]
#           
#            # cross reference asdmtime and standard time for start of beam map.
#            asdmindex=find(asdmtime > scanbeg)[0]
#            focus=zeros([3])
#            um=1e6
#            antenna=antennas[aid]
#            focus[0]=foc[0,asdmindex]
#            focus[1]=foc[1,asdmindex]
#            focus[2]=foc[2,asdmindex]
#            print "%s (X  Y  Z)= (%.0f %.0f %.0f) microns " \
#                  % (antenna, focus[0]*um, focus[1]*um, focus[2]*um)
#            return focus
#        else:
#            print "The ms file is missing /ASDM_FOCUS table. Regenerate the MS file with that table. Using batchasdm2MS for exemple"
#
#    except:
#        return (NaN, NaN, NaN)



plotOption = {'0-1' : 'b.', '0-2' : 'r.'}
def getAllanVariance(vis,antenna1=None,antenna2=None,spwID=None,param='phase',scan=None,state=None,doPlot=True) :
    if param not in ['phase','real','imag'] : return 'you are a dumb fuck.'
    if spwID == None : spwID = getChanAverSpwIDBaseBand0(vis)
    if antenna2 == None : antenna2 = getAntennaNames(vis)
    else : antenna2 = makeList(antenna2)
    if antenna1 == None : antenna1 = getAntennaNames(vis)
    else : antenna1 = makeList(antenna1)
    data = Visibility(vis,antenna1=antenna1[0],antenna2=antenna2[0],spwID=spwID,scan=scan,state=state)
    aV = {}
    for i in antenna1 :
        for j in antenna2 :
            if i < j :
                data.setAntennaPair(i,j)
                aV[("%s-%s" % (i,j))] = allanVariance(data.phase,data.specTime,data.specFreq.mean())
                if doPlot : pb.plot(aV[("%s-%s" % (i,j))][:,0],np.log10(aV[("%s-%s" % (i,j))][:,1]),'.')
    return aV

def allanVariance(phase,time,ref_freq) :
    Nallan=[]
    ave=[]
    Ndata = len(time)
    Nmax = int(floor(Ndata/2))
    dt = (time[1:]-time[:-1]).mean()
    for i in range(1,Nmax):
        n=0
        y = []
        for j in range(Ndata):
            k=j+2*i
            if k > Ndata-1:
                break
            z=phase[:,:,k]-2*phase[:,:,i+j]+phase[:,:,j]
            y.append(z**2)
            n+=1
        ave.append(mean(y))
        Nallan.append(n)
    Ntau=len(ave)
    Allan=array(Ntau*[2*[0.0]],dtype=float)
    for i in range(Ntau):
        y=[]
        Allan[i][0]=dt*(i+1)
        Allan[i][1]=math.sqrt(ave[i]/2.0/(2*math.pi*ref_freq*Allan[i][0])**2)
    return Allan

def phaseClosure(vis, antenna1, antenna2, antenna3, spw, field, scan, vm=''):
     antennas=sorted([antenna1,antenna2,antenna3])
     antenna1=antennas[0]
     antenna2=antennas[1]
     antenna3=antennas[2]
     visVal=Visibility(vis,antenna1=antenna1,antenna2=antenna2,spwID=spw,field=field,scan=scan, vm=vm)
     phi01=visVal.phase
     visVal.setAntenna2(antenna3)
     phi02=visVal.phase
     visVal.setAntenna1(antenna2)
     phi12=visVal.phase
     close=phi01+phi02-phi12
     
     return close,visVal

def phaseClosureStats(msName='', scan='', intent='CALIBRATE_BANDPASS#ON_SOURCE', chanEdge=0.2):

    if msName == '': sys.exit('ERROR: no ms name specified.')

    if scan == '':
        if casadef.casa_version >= '4.1.0':
            msmd.open(msName)
            scan2 = msmd.scansforintent(intent).tolist()
            msmd.close()
        else:
            sys.exit('ERROR: no scan specified.')
    else:
        scan2 = scan.split(',')
        scan2 = [int(i) for i in scan2]

    tb.open(msName+'/ANTENNA')
    antIndex = range(tb.nrows())
    tb.close()

    es = stuffForScienceDataReduction()
    spwInfo = es.getSpwInfo(msName)
    spwIds = spwInfo.keys()

    tb.open(msName+'/DATA_DESCRIPTION')
    spwIds1 = tb.getcol('SPECTRAL_WINDOW_ID').tolist()
    tb.close()

    phase2 = {}

    tb.open(msName)

    for scan1 in scan2:

        phase2[scan1] = {}

        for i in spwIds:

            phase2[scan1][i] = {}

            tb1 = tb.query('SCAN_NUMBER == '+str(scan1)+' AND DATA_DESC_ID == '+str(spwIds1.index(i)))

            time1 = tb1.getcol('TIME')
            ant1 = tb1.getcol('ANTENNA1')
            ant2 = tb1.getcol('ANTENNA2')
            data1 = tb1.getcol('DATA')
            data2 = data1.swapaxes(0,2)
            flagrow1 = tb1.getcol('FLAG_ROW')
            flag1 = tb1.getcol('FLAG')
            flag2 = flag1.swapaxes(0,2)

            phase3 = []

            for time2 in np.unique(time1):

                ij = itertools.combinations(antIndex, 3)

                for j in ij:

                    j = sorted(j)

                    ij2 = []

                    for k in range(3):

                        ij1 = np.argwhere((time1 == time2) & (((ant1 == j[k%3]) & (ant2 == j[(k+1)%3])) | ((ant1 == j[(k+1)%3]) & (ant2 == j[k%3])))).flatten()
                        if len(ij1) == 1: ij2.append(ij1[0]*math.copysign(1, ant2[ij1[0]] - ant1[ij1[0]]))

                    if len(ij2) == 3:

                        if flagrow1[abs(ij2[0])] == 0 and flagrow1[abs(ij2[1])] == 0 and flagrow1[abs(ij2[2])] == 0:

                            k1 = int(len(data2[0]) * chanEdge)
                            k2 = int(len(data2[0]) * (1-chanEdge))

                            for kl in range(len(data2[0][0])):

                                phase1 = []
                                for k in range(k1, k2):
                                    if flag2[abs(ij2[0])][k][kl] == 0 and flag2[abs(ij2[1])][k][kl] == 0 and flag2[abs(ij2[2])][k][kl] == 0:
                                        phase4 = np.rad2deg(math.copysign(1, ij2[0])*np.angle(data2[abs(ij2[0])][k][kl]) + math.copysign(1, ij2[1])*np.angle(data2[abs(ij2[1])][k][kl]) - math.copysign(1, ij2[2])*np.angle(data2[abs(ij2[2])][k][kl]))
                                        phase4 = phase4 - round(phase4/360.)*360.
                                        phase1.append(phase4)

                                phase3.append(np.mean(phase1))

            phase2[scan1][i]['min'] = min(phase3)
            phase2[scan1][i]['max'] = max(phase3)
            phase2[scan1][i]['mean'] = np.mean(phase3)
            phase2[scan1][i]['stddev'] = np.std(phase3)

    tb.close()

#     pb.figure()
#     n, bins, patches = pb.hist( phase3, bins=range(int(np.ceil(max(phase3))+1)), histtype='bar')

    return phase2

class StuffToLieAbout:
    """
    """
    import os
    
    def __init__(self,calTable=None):
        if calTable <> None :
            self.calTable = calTable
            #self.calTableExplorer = CalTableExplorer(self.calTable,antenna=0,spwID=1)
            self.calTableExplorer = CalTableExplorer(self.calTable,antenna=0)
        else :
            self.calTable = None

    def setCalTable(self,calTable) :
        self.calTable = calTable
        self.calTableExplorer = CalTableExplorer(self.calTable,antenna=0,spwID=1)

    def getCalTable(self) : return self.calTable

    def tsysInSpectralWindow(self,badSpw,goodSpw=None,setValue=False) :
        inputMs  = self.calTableExplorer.inputMs
        badRaw   = Visibility(inputMs,spwID=badSpw, correctedData = False)
        if ((goodSpw == None) and (not setValue)) :
           goodSpw = list(self.calTableExplorer.getSpwID())
           goodSpw.remove(badSpw)[0]
           goodCorr = Visibility(inputMs,spwID=goodSpw,correctedData = True)
           goodRaw  = Visibility(inputMs,spwID=goodSpw,correctedData = False)
           tsysToApply = goodCorr.amp/goodRaw.amp
        elif setValue :
            tsysToApply = setValue*np.ones(tsysToApply.shape,'complex128')
        badCorr  = badRaw.amp*tsysToApply
        self.stuffVisInDataset(badCorr,badSpw)

    def TFBOffset(self,offsetFromOT,inputMs=None,spwIds=None) :
        if inputMs == None and self.calTable == none :
            return "Please identify a visibility dataset."
        elif inputMs == None :
            inputMs = self.calTableExplorer.intputMs
        if offsetFromOT < 1000.0 : return "Please input your offsetFromOT in MHz."        
        vm = ValueMapping(inputMs)
        if spwIds == None :
            spwIds = []
            print "I am assuming you want to fix all FDM modes by the same amount."
            for i in vm.spwInfo.keys() :
                if vm.spwInfo[i]["numChannels"] > 256 : spwIds.append(i)
        else :
            spwIds = makeList(spwIds)
        for i in spwIds :
            tb.open("%s/SPECTRAL_WINDOW" % inputMs,nomodify=False)
            delta = 3000.0-offsetFromOT
            correction = 2.0*delta*vm.spwInfo[i]["sideband"]*1e6
            newChanFreq = vm.spwInfo[i]["chanFreqs"]-correction
            print ("Subtracting %f to your channel frequencies in spectral window %i" % (correction,i) )
            print vm.spwInfo[i]["chanFreqs"].mean(),newChanFreq.mean()
            tb.putcell("CHAN_FREQ",i,newChanFreq)
        tb.close()
        vm.doSpwAndFrequency()

    def doTsysInfo(self) :
        return

    def stuffVisInDataset(self,badCorr) :
        inputMs = self.calTableExplorer.inputMs
        tb.open(inputMs,nomodify=False)
        for i in range(len(badCorr.subtable.rownumbers())) :
            tb.putcell('CORRECTED_DATA',badCorr.subtable.rownumbers()[i],badCorr.specData[...,i])
        tb.close()
    
    def gain(self,antennaToReplace,replacementAntenna=None) :
        if str(antennaToReplace).isdigit() :
            antennaToReplace = self.calTableExplorer.ValueMapping.antennaNamesForAntennaIds[int(antennaToReplace)]
        if replacementAntenna==None :
            antList = list(self.calTableExplorer.ValueMapping.antennaNamesForAntennaIds)
            antList.pop(antennaToReplace)
            replacementAntenna = antList[0]
        elif str(replacementAntenna).isdigit() :
            replacementAntenna = self.calTableExplorer.ValueMapping.antennaNamesForAntennaIds[int(replacementAntenna)]
        print antennaToReplace,replacementAntenna
        antennaToReplace = self.calTableExplorer.ValueMapping.getAntennaIdsForAntennaName(antennaToReplace)
        replacementAntenna = self.calTableExplorer.ValueMapping.getAntennaIdsForAntennaName(replacementAntenna)
        print antennaToReplace,replacementAntenna        
        tb.open(self.calTable,nomodify=False)
        retb  = tb.query('ANTENNA1 == %s' % replacementAntenna)
        rerow = retb.rownumbers()
        badtb = tb.query('ANTENNA1 == %s' % antennaToReplace)
        badrow = badtb.rownumbers()
        for i in range(len(badrow)) :
            _badrow = badrow[i]
            _rerow  = rerow[i]
            goodGain = tb.getcell('GAIN',_rerow)
            tb.putcell('GAIN',_badrow,goodGain)
        tb.close()


class ValueMapping:
    """
    Input: The name of an MS dataset as a string.
    Purpose: This class provides details on the mapping of various parameters to each other.  For example, if you would like to
             know which scans observed a given field source or over which time interval a scan was executed, this is the place to look.
             Included in that are functions which map antenna name to antenna id and field name to field id.  This is useful in building
             other routines that allow you to not require the user to input one or the other type of information.  It also gets unique
             lists of items, like antennas, field sources, scans, intents, etc.

    Responsible: S. Corder and other contributors
    Example: vm = aU.ValueMapping('myInputMS.ms')
    Suggested Improvements:
          (done, 06-04-2011, scorder)1) Change some of the get methods to do methods because they aren't really returning anything
          2) Add spectral window mapping information, spectral windows, spectral windows to fields, spectral windows to scans,
             spectral windows to frequency (central and channelized): Basically make a dictionary of all the spectral line info stuff,
             per spectral window.  Rework combination of SensitivityCalculator and VM....
          3) Add integration time calculator per source
          4) Do sensitivity calculator (maybe needs to be separate function/class that inhereits this)
    """
    def __init__(self,inputMs):
        """
        Instantiation of this class calls this, i.e., vm = aU.ValueMapping('myInputMS.ms').  The dataset name is the only allowed
        input.  It generates the mappings are part of this instantiation.
        """
        self.inputMs = inputMs
        self.setInputMs(self.inputMs)

    def getInputMs(self):
        """
        Input: None
        Output: The active measurement set in the class as a string
        Responsible: S. Corder
        Purpose: Return the name of the active dataset
        """
        return self.inputMs

    def setInputMs(self,inputMs):
        """
        Input: New measurement set that you wish to become the active one, as a string and activate that change to all other parameters
        Output: None
        Responsible: S. Corder
        Purpose: This changes the active dataset and remakes the relevant mappings.  The order of the functions is very
                 important.
        """
        self.inputMs = inputMs
        self.doScanTimeMapping()
        self.doFieldsAndSources()   ;  self.doStatesAndIntents()
        self.doAntennasAndNames()
        self.doScanStateMapping()   ;  self.doFieldTimeMapping() ;
        self.doAntennaTimeMapping() ;  self.doAntennaStateMapping()
        self.doDataDescId()         ; self.doSpwAndDataDescId()
        self.doPolarizations()
        self.doSpwAndFrequency()    
        self.doSpwScanMapping()     ;  self.doSpwFieldMapping()
        self.doSpwIntentMapping()

    def doSpwAndFrequency(self,ignoreWVR=True) :
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: Creates a dictionary (spwInfo) of spectral windows, with keys of the spectral window number.
                 For each spectral window, another dictionary is formed that has keys of bandwidth, sideband,
                 chanFreqs, chanWidth, numChannels, and meanFreq.
        """
        self.spwInfo = {}
        tb.open("%s/SPECTRAL_WINDOW" % self.inputMs)
        specWinIds = range(tb.nrows())
        junk = []
        for i in specWinIds :
            self.spwInfo[i] = {}
            self.spwInfo[i]["bandwidth"] = tb.getcell("TOTAL_BANDWIDTH",i)
            self.spwInfo[i]["chanFreqs"] = tb.getcell("CHAN_FREQ",i)
            self.spwInfo[i]["chanWidth"] = tb.getcell("CHAN_WIDTH",i)[0]
            self.spwInfo[i]["edgeChannels"] = [min(self.spwInfo[i]["chanFreqs"]),max(self.spwInfo[i]["chanFreqs"])]
            netSideband  = tb.getcell("NET_SIDEBAND",i)
            if netSideband == 2 : self.spwInfo[i]["sideband"] = 1
            else : self.spwInfo[i]["sideband"] = -1
            self.spwInfo[i]["meanFreq"]  = self.spwInfo[i]["chanFreqs"].mean()
            self.spwInfo[i]["numChannels"] = self.spwInfo[i]["chanFreqs"].shape[0]
            if ((ignoreWVR) and (self.spwInfo[i]['numChannels'] == 4)) :
                junk.append(i)
                self.spwInfo.pop(i)
        tb.close()
        if ignoreWVR:
            if (len(junk) > 0):
                print "Ignoring spectral window %s because it is WVR related" % junk

    def doSpwAndDataDescId(self) :
        tb.open("%s/DATA_DESCRIPTION" % self.inputMs)
        self.spwForDataDescId = tb.getcol('SPECTRAL_WINDOW_ID')
        tb.close()

    def doSpwFieldMapping(self) :
        tb.open("%s" % self.inputMs)
        self.fieldsForSpw = {}
        for i in self.spwForDataDescId :
            spw = self.spwForDataDescId[i]
            indices = np.where(self.dataDescId == i)
            self.fieldsForSpw[spw] = np.unique(self.fields[indices])
        tb.close()
        return

    def doDataDescId(self) :
        tb.open("%s" % self.inputMs)
        self.dataDescId = tb.getcol('DATA_DESC_ID')
        tb.close()

    def doPolarizations(self) :
        # Determine the number of polarizations for the first OBSERVE_TARGET intent.
        # Used by plotbandpass for BPOLY plots since the number of pols cannot be inferred
        # correctly from the caltable alone.  You cannot not simply use the first row, because
        # it may be a pointing scan which may have different number of polarizations than what
        # the TARGET and BANDPASS calibrator will have.
        # -- T. Hunter
        myscan = -1
        starttime = timeUtilities.time()
        for s in self.uniqueScans:
            intents = self.getIntentsForScan(s)
            for i in intents:
                if (i.find('OBSERVE_TARGET')>=0):
                    myscan = s
#                    print "First OBSERVE_TARGET scan = ", myscan
                    break
            if (myscan >= 0):
                break
        if (myscan == -1):
            # if there is no OBSERVE_TARGET, then just use the first scan
            myscan = 0
        self.getDataColumnNames()
        tb.open("%s" % self.inputMs)
        if (myscan == 0):
            # assume the first row in the table is for the first scan, to save time
            self.nPolarizations = np.shape(tb.getcell(self.dataColumnName,0))[0]
        else:
            scans = tb.getcol('SCAN_NUMBER')
            self.nPolarizations = 0
            for s in range(len(scans)):
                if (scans[s]==myscan):
                    self.nPolarizations = np.shape(tb.getcell(self.dataColumnName,s))[0]
                    break
        tb.close()
        donetime = timeUtilities.time()
#        print "doPolarizations took %.1f sec" % (donetime-starttime)

    def getDataColumnNames(self):
        tb.open(self.inputMs)
        colnames = tb.colnames()
        self.correctedDataColumnName = ''
        self.modelDataColumnName = ''
        if 'FLOAT_DATA' in colnames:
            self.dataColumnName = 'FLOAT_DATA'
            self.correctedDataColumnName = 'FLOAT_DATA'
        elif 'DATA' in colnames:
            self.dataColumnName = 'DATA'
        if 'CORRECTED_DATA' in colnames:
            self.correctedDataColumnName = 'CORRECTED_DATA'
        if 'MODEL_DATA' in colnames:
            self.modelDataColumnName = 'MODEL_DATA'
        tb.close()
        return

    def doSpwScanMapping(self) :
        tb.open("%s" % self.inputMs)
        self.scansForSpw = {}
        for i in self.spwForDataDescId :
            spw = self.spwForDataDescId[i]
            indices = np.where(self.dataDescId == i)
            self.scansForSpw[spw] = np.unique(self.scans[indices])
        tb.close()
        return
    
    def doSpwIntentMapping(self) :
        tb.open("%s" % self.inputMs)
        self.intentsForSpw = {}
        for i in self.spwForDataDescId :
            spw = self.spwForDataDescId[i]
            indices = np.where(self.dataDescId == i)
            statesForSpw = np.unique(self.states[indices])
            _intent = []
            for i in statesForSpw :
                __intent = []
# The 'if' statement is needed to support telescopes w/o intents. -T. Hunter
                if (len(self.intentsForStates) > 0):
                  for j in self.intentsForStates[i] :
#                    __map = j.split('#')[0]
                    __map = j
                    __intent.append(__map)
                  _intent += __intent
            self.intentsForSpw[spw] = np.unique(np.array(_intent))
        tb.close()


    def getSpwsForIntent(self,intent) :
        spwsForIntent = []
        for i in self.intentsForSpw.keys() :
            if (intent in self.intentsForSpw[i]) : spwsForIntent.append(i)
        return spwsForIntent

    def getIntentsForSpw(self,spw) :
        return self.intentsForSpw[spw]

    def getSpwsForField(self,field) :
        if not str(field).isdigit() : field = self.getFieldIdsForFieldName(field)
        spwsForField = []
        for i in self.fieldsForSpw.keys() :
            if (field in self.fieldsForSpw[i]) : spwsForField.append(i)
        return spwsForField

    def getFieldsForSpw(self,spw,returnName = True) :
        if returnName :
            return self.getFieldNamesForFieldId(np.unique(np.array(self.fieldsForSpw[spw])))
        else :
            return np.unique(np.array(self.fieldsForSpw[spw]))

    def getSpwsForScan(self,scan):
        spwsForScan = []
        for i in self.scansForSpw.keys() :
            if (scan in self.scansForSpw[i]) : spwsForScan.append(i)
        return spwsForScan

    def getScansForSpw(self,spw) :
        return self.scansForSpw[spw]

    def getAntennaNamesForAntennaId(self,id):
        """
        Input: Antenna id as an integer or string
        Output: Antenna name as a string
        Responsible: S. Corder
        Purpose: Allows translation between antenna id and antenna name.
        """

        return self.antennaNamesForAntennaIds[int(id)]

    def getAntennaIdsForAntennaName(self,antennaName):
        """
        Input: Antenna names as a string
        Output: Antenna index as an integer.
        Responsible: S. Corder
        Purpose: This allows translation between antenna name and antenna id
        """

        return np.where(self.antennaNamesForAntennaIds == antennaName)[0][0]

    def doStatesAndIntents(self):
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: This function defines two attributes, uniqueStates, which is a python list of the different intents present in the dataset,
                 and intentsForStates is another python list which give the intents for state id as a nested list.  The first index of
                 the intentsForStates is the state id.  If you choose a state id, then the result is a list of intents for that state.
        """
        tb.open("%s/STATE" % self.inputMs)
        intents = tb.getcol("OBS_MODE")
        tb.close()
        _intents = []
        for i in intents : _intents.append(i.split(','))
        self.intentsForStates = _intents
        self.uniqueIntents = []
        for i in self.intentsForStates : self.uniqueIntents.extend(i)
        self.uniqueIntents = np.unique(np.array(self.uniqueIntents))

    def doFieldsAndSources(self):
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: This function defines two attributes, uniqueField and fieldNamesForFieldIds.  For the time being these are identical.
                 fieldNamesForFieldIds is simply a numpy array where the index is the field id and the value is the name of the field source.
        """
        tb.open("%s/FIELD" % self.inputMs)
        self.fieldNamesForFieldIds = tb.getcol('NAME')
#        print '%d field names = '%len(self.fieldNamesForFieldIds), self.fieldNamesForFieldIds
        self.uniqueFields = self.fieldNamesForFieldIds
        tb.close()

    def doAntennasAndNames(self) :
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: This function defines two attributes, uniqueAntennas (which is a little excessive) and antennaNamesForAntennaIds.
                 antennaNamesForAntennaIds is a numpy array and has indices that are the antenna ids and values that are the antenna names.
        """
        tb.open("%s/ANTENNA" % self.inputMs)
        self.antennaNamesForAntennaIds = tb.getcol('NAME')
        self.uniqueAntennas = np.unique(self.antennaNamesForAntennaIds)
        self.numAntennas = len(self.uniqueAntennas)
        tb.close()

    def doScanStateMapping(self):
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: This function defines an attribute, statesForScans, that is the mapping between states and scan numbers.  It is
                 a python dictionary that has keys of the scan number and values, in a list, of the states used in that scan.
        """
        tb.open("%s" % self.inputMs)
        self.states = tb.getcol("STATE_ID")
        tb.close()
        self.statesForScans = {}
        for i in self.uniqueScans :
            indices = np.where(self.scans == i)
            self.statesForScans[i] = np.unique(self.states[indices])

    def doScanTimeMapping(self):
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: This function defines four attributes, scans, time, uniqueScans and scansForTiems.  scans and time are simply
                 the scan number and time table from the main data table as python arrays.  uniqueScans is a numpy array of the independent scans
                 in the table.  scansForTimes is a python dictionary with keys as scans and values as times in which data was taken
                 for that scan.
        """
        tb.open(self.inputMs)
        self.scans = tb.getcol('SCAN_NUMBER')
        self.time = tb.getcol('TIME')
        tb.close()
        self.uniqueScans = np.unique(self.scans)
        self.scansForTimes = {}
        for i in self.uniqueScans :
            indices = np.where(self.scans == i)
            self.scansForTimes[i] = self.time[indices]

    def doFieldTimeMapping(self):
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: This function defines two attributes, fields, a numpy array, and fieldsForTimes, a dictionary with keys of field name.
                 The fields is just the field id from the data table.  The values of fieldsForTimes are the times during which data was
                 collected for that field source.
        """
        
        tb.open(self.inputMs)
        self.fields = tb.getcol('FIELD_ID')
        tb.close()
        self.fieldsForTimes = {}
        for i in range(len(self.fieldNamesForFieldIds)) :
            indices = np.where(self.fields == i)
            self.fieldsForTimes[self.fieldNamesForFieldIds[i]] = self.time[indices]

    def doAntennaTimeMapping(self):
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: This function defines three attributes. antenna1 and antenna2 are numpy arrays containing the antenna1 and antenna2 columns
                 from the data table.  antennasForTimes defines the times over which data was collected for that antenna.  It is a python
                 dictionary with keys of baseline (using antenna names) and values of numpy array of times.
        """

        tb.open(self.inputMs)
        self.antennas1 = tb.getcol('ANTENNA1')
        self.antennas2 = tb.getcol('ANTENNA2')
        tb.close()
        self.antennasForTimes = {}
        for i in range(len(self.uniqueAntennas)) :
            for j in range(len(self.uniqueAntennas)) :
                if i <= j :
                    antennaKey = "%s-%s" % (str(self.uniqueAntennas[j]),str(self.uniqueAntennas[i]))
                    indices = np.where((self.antennas1 == self.uniqueAntennas[i] and self.antennas2 == self.uniqueAntennas[j]))
                    self.antennasForTimes[antennaKey] = self.time[indices]

    def doAntennaStateMapping(self):
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose: This function defines one attribute, antennasForStates, a python dictionary.  The keys are baselines (using
                 antenna names) and values are staes used for that baseline.  Usually the autocorrelations are most useful.
        """

        self.antennasForStates = {}
        for i in range(len(self.uniqueAntennas)) :
            for j in range(len(self.uniqueAntennas)) :
                if i <= j :
                    antennaKey = "%s-%s" % (str(self.uniqueAntennas[j]),str(self.uniqueAntennas[i]))
                    indices = np.where((self.antennas1 == self.uniqueAntennas[i] and self.antennas2 == self.uniqueAntennas[j]))
                    self.antennasForStates[antennaKey] = self.states[indices]

    
    def getScansForTime(self,time,fudge=0.0):
        """
        Input: Time stamp in CASA native units as a string or float
        Output: Scan number associated with that time stamp.
        Responsible: S. Corder
        Purpose: This function returns the scan number for a specific timestamp.  It allows tranlsation between time and scan.
        """
        for i in self.scansForTimes.keys() :
            if ((float(time) >= self.scansForTimes[i][0]-fudge) and (float(time) <= self.scansForTimes[i][-1]+fudge)) :
                return i

    def getTimesForScans(self,scans):
        """
        Input: Scan number as an integer or string
        Output: Time range over which data exists for that scan as a numpy array.
        Responsible: S. Corder, copied from getTimesForScan and modified by T. Hunter
        Purpose: Return the times associated with a given timestamp.  This allows translation between scan and time.
        """
        times = []
        if (type(scans) == int or type(scans) == np.int32):
            scans = [scans]
        for scan in scans:
            times.append(self.scansForTimes[int(scan)])
        return (times)

    def getTimesForScan(self,scan):
        """
        Input: Scan number as an integer or string
        Output: Time range over which data exists for that scan as a numpy array.
        Responsible: S. Corder
        Purpose: Return the times associated with a given timestamp.  This allows translation between scan and time.
        """
        return self.scansForTimes[int(scan)]

    def getScansForState(self,state):
        """
        Input: State id as an integer or string
        Output: The scan numbers, as a list, that use that specific state.
        Responsible: S. Corder
        Purpose: Return the scans that used a specific state.  This allos translation between state and scan.
        """

        scansForState = []
        for i in self.uniqueScans :
            if int(state) in self.statesForScans[i] : scansForState.append(i)
        return scansForState

    def getStatesForScan(self,scan):
        """
        Input: Scan number as a string or integer
        Output: States used during that scan.
        Responsible: S. Corder
        Purpose: Returns the states used during a given scan.  This allows translation between scan and state
        """

        return self.statesForScans[int(scan)]

    def getIntentsForScan(self,scan) :
        """
        Input: Scan as an integer or string.
        Output: Intent as a an array of strings with the names of the intents as values.
        Responsible: S. Corder
        Purpose: This returns the intents used in a specific scan allowing translation between scan and intent.
        """

        intentsForScan = []
        for i in range(len(self.intentsForStates)) :
            subIntents = self.intentsForStates[i]
            if int(scan) in self.getScansForState(i) : intentsForScan.extend(subIntents)
        return np.unique(intentsForScan)
            
    def getScansForIntent(self,intent) :
        """
        Input: Intent (as a string)
        Output: A numpy array of scans using the input intent.
        Responsible: S. Corder
        Purpose: This returns the scans using a specific intent.  This allows flagging based on intent and translation
                 between intent and scan.
        """

        scansForIntent = []
        for i in range(len(self.states)) :
            if intent in self.intentsForStates[self.states[i]] :
                scansForIntent.extend(self.getScansForState(self.states[i]))
        return np.unique(scansForIntent)
        
    def getScansForFieldID(self,field):
        """
        Input: Field, as an id.
        Output: Scans using that field
        Responsible: T. Hunter
        Purpose: This takes a field ID and tells you what scans it was used in.  It was
                 created to avoid a strange behavior of getScansForField for integer inputs.
        """
        indices = np.where(self.fields == field)
        return np.unique(self.scans[indices])
        
    def getScansForField(self,field):
        """
        Input: Field, as a name or id.
        Output: Scans using that field
        Responsible: S. Corder
        Purpose: This takes a field source and tells you what scans it was used in.
        """

        if not str(field).isdigit() : field = self.getFieldIdsForFieldName(field)
        indices = np.where(self.fields == field)
        return np.unique(self.scans[indices])

    def getFieldsForScans(self,scans,returnName=True):
        slist = []
        for scan in scans:
            slist.append(self.getFieldsForScan(scan))
        return([item for sublist in slist for item in sublist])
    
    def getFieldsForScan(self,scan,returnName=True):
        """
        Input: Scan as an integer or string
        Output: Field ids observed during that scan.
        Responsible: S. Corder
        Purpose: This takes a scan number and returns a field observed during that scan.  This allows translation between
                 scan and field.
        """

        indices = np.where(self.scans == int(scan))
        if returnName : return self.getFieldNamesForFieldId(np.unique(self.fields[indices]))
        else : return np.unique(self.fields[indices])

    def getFieldsForIntent(self,intent,returnName=True):
        """
        Input: intent as a string
        Output: field id as integer or array of names
        Responsible: S. Corder
        Purpose: This retrieves all of the fields that have been assigned a given intent during an observation.  
        """        
        _fields = []
        scans = self.getScansForIntent(intent)
        for i in scans :
            _field = self.getFieldsForScan(i)
            if _field not in _fields : _fields.append(_field)
        if returnName :
            return _fields
        else :
            return self.getFieldIdsForFieldName(_fields)
        
    def getFieldIdsForFieldName(self,sourceName):
        """
        Input: source name as string
        Output: field id as integer (actually it is returning the source id-Todd)
        Responsible: S. Corder
        Purpose: This translates between source/field name and field id.
        """
# The following fails because the case varies when .title() is applied: QSO vs. Qso, and TW Hya vs Tw Hya
#        return np.where(upper == sourceName.title())[0][0]
        if (type(sourceName) == list):
            sourceName = sourceName[0]
#        print "looking for %s in " % (sourceName), self.fieldNamesForFieldIds
        return np.where(self.fieldNamesForFieldIds == sourceName)[0]
        
    def getFieldNamesForFieldId(self,sourceId):
        """
        Input: field id (as string or integer)
        Output: field name
        Responsible: S. Corder
        Purpose: This translates between field id and field/source name.
        """
        if (type(sourceId) == int or type(sourceId) == np.int32 or type(sourceId) == np.int64 or type(sourceId) == str):
            if (len(self.fieldNamesForFieldIds) > int(sourceId)):
                # prevent "index out of bounds" error if field is not present 
                return self.fieldNamesForFieldIds[int(sourceId)]
            else:
                return (None)
        else:
            # Todd added this check which was necessary for the Antennae Band 7 mosaic
            return [self.fieldNamesForFieldIds[s] for s in sourceId]

    def getFieldsForTime(self,time,returnName=True):
        """
        Input: Time in casa native units, returnName (boolean).  If returnName is true, the name is returned, else the id is returned.
               Default is returnName=True
        Output: Field name or id (depending on value of returnName).
        Responsible: S. Corder
        Purpose: Allows the field id/name to be returned for a specific observation time.
        """

        for i in self.fieldsForTimes.keys() :
            if (time in self.fieldsForTimes[i]) :
                if returnName : return i
                else : return self.getFieldNamesForFieldId(i)

    def getTimesForField(self,field):
        """
        Input: Field name or id (as a string or integer)
        Output: Times as a numpy array over which that field was observed in casa native units.
        Responsible: S. Corder
        Purpose: This allows you to determine the data time stamps for observations of a specific field source.
        """

        if str(field).isdigit() : field = self.fieldNamesForFieldIds(int(field))
        return self.fieldsForTimes[field]


class TsysExplorer:
    """ Put something in about updating the Tsys on TDM observations in real time.  """
    def __init__(self,inputMs,antenna=None,spwID=None,autoSubtableQuery=True,queryString='',cross_auto_all='all'):
        if autoSubtableQuery==False and queryString=='' : return 'Must either automatically generate the (autoSubtableQuery=True) or provide a subtable query string (queryString)'
        self.inputMs = inputMs
        self.valueMapping = ValueMapping(inputMs)
        if antenna == None :
            antenna = self.valueMapping.getAntennaNamesForAntennaId(0)
        self.antenna = antenna
        self.checkAntenna()
        if spwID == None :
            spwID = getChanAverSpwIDBaseBand0(inputMs)
        self.spwID = spwID
        self.elevation = None
        self.time      = None
 #       self.tcal      = None
        self.trx       = None
        self.tsky      = None
        self.tsys      = None
        self.freq      = None
        self.elevTime  = None
        self.scan      = []
        self.field     = []
        self.autoSubtableQuery = autoSubtableQuery
        self.queryString = queryString
        if self.autoSubtableQuery == True : 
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def getScanAndField(self):
        for i in self.time : 
            self.scan.append(self.valueMapping.getScansForTime(i))
            self.field.append(self.valueMapping.getFieldsForTime(i))

    def restrictTimeField(self):
        return

    def getElevation(self) :
        tb.open("%s/POINTING" % self.inputMs)
        subtable = tb.query("ANTENNA_ID == %s" % self.antenna)
        tb.close()        
        self.elevation = subtable.getcol("DIRECTION")
        self.elevTime  = subtable.getcol("TIME")
        elev = []
        for i in self.time :
            diffTime = abs(self.elevTime - i)
            indy = np.where(diffTime == diffTime.min())
            elev.append(self.elevation[...,indy[0][0]]*180.0/math.pi)
        elev = np.array(elev)
#        print elev.shape,elev
        self.elevation = elev[:,1]

    def getFreq(self) :
        tb.open("%s/SPECTRAL_WINDOW" % self.inputMs)
        rows = tb.selectrows(self.spwID)
        freqs = rows.getcol("CHAN_FREQ")
        tb.close()
        self.freq = freqs
        
    def getTsysData(self) :
        self.time = self.subtable.getcol("TIME")-self.subtable.getcol("INTERVAL")/2.0
#        self.tcal = self.subtable.getcol("TCAL_SPECTRUM")
        self.trx  = self.subtable.getcol("TRX_SPECTRUM")
        self.tsky = self.subtable.getcol("TSKY_SPECTRUM")
        self.tsys = self.subtable.getcol("TSYS_SPECTRUM")

    def getAntenna(self) : return self.antenna

    def setAntenna(self,antenna) :
        self.antenna = antenna
        self.checkAntenna()
        if self.autoSubtableQuery == True : 
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def getInputMs(self) : return self.inputMs

    def setInputMs(self,inputMs) :
        self.inputMs = inputMs
        if self.autoSubtableQuery == True : 
            self.makeAutoSubtable()
        else : self.makeSubtable()
        self.ValueMapping.setInputMs(inputMs)

    def checkAntenna(self) :
        if self.antenna <> None : 
            self.antenna = str(self.antenna)
            if not self.antenna.isdigit() : self.antenna = getAntennaIndex(self.inputMs,self.antenna)

    def getSpwID(self) : return self.spwID

    def setSpwID(self,spwID) :
        self.spwID = spwID
        if self.autoSubtableQuery == True : 
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def makeSubtableQuery(self) :
        self.parameterList = []
        queryString = ''
        if self.antenna <> None : self.parameterList.append('ANTENNA_ID == %s' % self.antenna)
#        if self.field <> None    : self.parameterList.append('FIELD_ID == %s' % self.field)
        if self.spwID <> None    : self.parameterList.append('SPECTRAL_WINDOW_ID == %s' % self.spwID)
#        if self.state <> None    : self.parameterList.append('STATE_ID == %s' % self.state)
#        if self.scan <> None     : self.parameterList.append('SCAN_NUMBER == %s' % self.scan)
        for i in self.parameterList : queryString = self.appendQuery(queryString,i)
        self.queryString = queryString

    def appendQuery(self,queryString,additive) :
        if queryString == '' :
            if additive == '' : return queryString
            else : return additive
        else :
            if additive == '' : return queryString
            else : 
                queryString = queryString + ' && ' + additive
                return queryString

    def makeAutoSubtable(self) :
        self.checkAntenna()
        self.makeSubtableQuery()
        tb.open("%s/SYSCAL" % self.inputMs)
        self.subtable = tb.query(self.queryString)
        tb.close()
        self.getTsysData()
        self.getFreq()
        #self.getElevation()
        self.getScanAndField()

    def makeSubtable(self) :
        tb.open("%s/SYSCAL" % self.inputMs)
        self.subtable = tb.query(self.queryString)
        tb.close()
        self.getTsysData()
        self.getFreq()
        #self.getElevation()
        self.getScanAndField()

    def setAutoSubtableQuery(self,autoSubtableQuery) :
        self.autoSubtableQuery = autoSubtableQuery

    def getAutoSubtableQuery(self) : return self.autoSubtableQuery
        
def plotWeeklyTrx(uid,showPlots=False) :
    msFile=uid+'.ms'
    vm = ValueMapping(msFile)
    tsys = TsysExplorer(msFile,antenna=0,spwID=1)
    tsysSpw = vm.getSpwsForIntent('CALIBRATE_ATMOSPHERE#OFF_SOURCE')[1:]
    figureIndex = 0
    band = getBand(tsys.freq.mean())
    ObsDate=qa.time({'value' : vm.time[0],'unit': 's'}, form=['ymd'])
    fnDate=(''.join([str(l) for l in (ObsDate.split(':')[0].split('/'))]))
    fnDate2=(''.join([str(l) for l in ((''.join([str(l2) for l2 in (ObsDate.split('/'))])).split(':'))]))
    fDir=('/data/RADIO/TRX/AOS/%.8s' %(fnDate))
    if not os.path.exists(fDir): os.makedirs(fDir)
    F = open(fDir+'/TrxRB%s_%s.txt' %(band,fnDate2),'w')
    print >> F, ('%s %s ALMARB_%s' % (msFile, ObsDate, band))
    print >> F, ('Mean Freq. Mean Trx  Std. Dev.')
    print >> F, ('GHz.       K         K')
    badAnts = []
    for antenna in vm.uniqueAntennas :
        figureIndex +=1 
        if showPlots: pb.figure(figureIndex)
        meanVals = []
        meanFreq = []
        stdVals  = []
        for spw in tsysSpw :
            if vm.spwInfo[spw]['numChannels'] == 128 :
                tsys.setSpwID(int(spw))
                tsys.setAntenna(antenna)
                meanFreq.append(tsys.freq.mean())
                meanVals+=(list(tsys.trx[:,3:125].mean(1).transpose()[0]))
                stdVals+=(list(tsys.trx[:,3:125].std(1).transpose()[0]))
                if showPlots:
                    pb.plot(tsys.freq[3:125]/1e9,tsys.trx[0,3:125],'g.')
                    pb.plot(tsys.freq[3:125]/1e9,tsys.trx[1,3:125],'b.')
        print >> F, antenna
        print >> F,('\n'.join(['%6.2f'%round(float(l1/1e9),2)+"     "+'%6.2f'%round(float(l2),2)+"     "+'%6.2f'%round(float(l3),2) for (l1,l2,l3) in zip(meanFreq,meanVals,stdVals)]))
#        specVal100 = {3: 60, 6: 136, 7: 219, 9: 261} #This is specification over 100% of the bands
        specVal80 = {3: 45, 6: 83, 7: 147, 9: 175} #This is specification over 80% of the bands

        if band == 3 : spec = specVal80[3]
        elif band == 6 : spec = specVal80[6]
        elif band == 7 : spec = specVal80[7]
        elif band == 9 : spec = specVal80[9]
        else: return 'Not a valid weekly Trx testing Frequency'
        for i in meanVals :
            if i >= spec :
                badAnts.append(antenna)
        if showPlots:
            pb.plot((100*np.arange(len(meanFreq))),(spec*np.ones(len(meanFreq))),'r-')
            pb.xlim(meanFreq[0]/1e9-10,meanFreq[len(meanFreq)-1]/1e9+10)
            pb.xlabel('Frequency (GHz)')
            pb.ylabel('Trx (K)')
            pb.suptitle('%s %s %s' % (antenna,qa.time({'value' : vm.time[0],'unit': 's'},form=['ymd']),msFile), size='14')
            pb.title('Green--Pol0   Blue--Pol1   Red--Specification(80%)', size='12')
            pb.savefig(fDir+'/TrxRB%s%s_%s.png' % (band,antenna,fnDate2))
    print >> F, "Problematic Antennas: %s" % str(badAnts)
    F.close()    
    print "Antennas: %s seem to have problems." % str(badAnts)
    raw_input("Hit Return to quit: ")
#    pb.close('all')
#Keep on having problem with close all
    fig_numbers = [x.num
               for x in matplotlib._pylab_helpers.Gcf.get_all_fig_managers()]
    for n in fig_numbers: pb.close(n)

class CalTableExplorer:
    """Stuff: Only works for antenna based solutions"""
    """Stuff to add: start and end channels (started, but need to make it consaistent, good metrics for differences"""
    """plotting routines, interpolation? In freq and/or time?  Basics are done"""
    """I need to make the residual functions make sense, I think the names are screwy. """
    
    def __init__(self,inputTable,antenna=None,spwID=None,feed=None,scan=None,state=None,field=None,autoSubtableQuery=True,queryString='',startChan=None,endChan=None):
        self.inputTable   = inputTable
        self.inputMs      = self.getMS_NAME(self.inputTable)
        self.ValueMapping = ValueMapping(self.inputMs)
        self.antenna     = antenna
        self.checkAntenna()
        self.startChan   = startChan
        self.endChan     = endChan
        self.spwID        = spwID
        self.feed         = feed
        self.scan         = scan
        self.state        = state
        self.field        = field
        self.checkField()
        self.getCalDescSpwIDMapping()
        if spwID == None : self.spwID = self.calDescSpwIDMapping[0]
        self.autoSubtableQuery = autoSubtableQuery
        self.queryString  = queryString
        if self.autoSubtableQuery == True :
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def getFreq(self) :
        tb.open("%s/SPECTRAL_WINDOW" % self.inputMs)
        rows = tb.selectrows(self.spwID)
        freqs = rows.getcol("CHAN_FREQ")
        tb.close()
        self.freq = freqs

    def getTimeAndInterval(self) :
        self.time     = self.subtable.getcol("TIME")
        self.mjd      = mjdSecondsVectorToMJD(self.time)
        self.ut       = mjdVectorToUTHours(self.mjd)
        self.interval = self.subtable.getcol("INTERVAL")

    def getFit(self) :
        self.gain     = self.subtable.getcol("GAIN")
        self.solOkay  = self.subtable.getcol("SOLUTION_OK")
        self.flags    = self.subtable.getcol("FLAG")
        self.fit      = self.subtable.getcol("FIT")
        self.snr      = self.subtable.getcol("SNR")
        self.real     = np.real(self.gain)
        self.imag     = np.imag(self.gain)
        self.phase = np.arctan2(self.imag,self.real)
        self.amp   = abs(self.gain)

    def plotFit(self,pol,xtype=''):
        date = (mjdSecondsToMJDandUT(self.time[0])[1]).split()[0]
        if (xtype=='ut'):
            pb.plot(self.ut,self.gain[pol,:,:][0],'b.')
            pb.xlabel('UT (hours)')
        elif (xtype=='mjd'):
            pb.plot(self.mjd,self.gain[pol,:,:][0],'b.')
            pb.xlabel('MJD days')
        else:
            pb.plot(self.time,self.gain[pol,:,:][0],'b.')
            pb.xlabel('MJD seconds')
        pb.ylabel('Gain')
        pb.title(date)
        
    def timeAverageSolutions(self) :
        self.tavgGain  = self.gain.mean(-1)
        self.tavgReal  = self.tavgGain.real
        self.tavgImag  = self.tavgGain.imag
        self.tavgPhase = np.arctan2(self.tavgImag,self.tavgReal)
        self.tavgAmp   = abs(self.tavgGain)
        
    def freqAverageSolutions(self) :
        self.favgGain  = self.gain[...,self.startChan:self.endChan,...].mean(1)
        self.favgReal  = self.favgGain.real
        self.favgImag  = self.favgGain.imag
        self.favgPhase = np.arctan2(self.favgImag,self.favgReal)
        self.favgAmp   = abs(self.favgGain)

    def generateSpectralResiduals(self) :
        self.fresidGain = self.gain
        for i in range(self.gain.shape[-1]) :
            self.fresidGain[:,:,i] = self.fresidGain[:,:,i]-self.tavgGain
        self.fresidGain = self.fresidGain
        self.fresidReal = self.fresidGain.real
        self.fresidImag = self.fresidGain.imag
        self.fresidPhase = np.arctan2(self.fresidImag,self.fresidReal)
        self.fresidAmp   = abs(self.fresidGain)

    def unwrapPhase(self,simple=True) :
        from math import pi
        phaseShape = self.phase.shape
        for i in range(phaseShape[2]-1) :
            diff = self.phase[:,:,i]-self.phase[:,:,i+1]
            _diffg = (diff > 1.*pi)*2*pi
            _diffl = (diff < -1.*pi)*2*pi
            self.phase[:,:,i+1] = self.phase[:,:,i+1]+_diffg-_diffl

    def generateTimeResiduals(self) :
        self.tresidGain = self.gain
        for i in range(self.gain.shape[1]) :
            self.tresidGain[:,i,:] = self.tresidGain[:,i,:]-self.favgGain
        self.tresidGain = self.tresidGain[...,self.startChan:self.endChan,...]
        self.tresidFreq = self.freq[self.startChan:self.endChan]
        self.tresidReal = self.tresidGain.real
        self.tresidImag = self.tresidGain.imag
        self.tresidPhase = np.arctan2(self.tresidImag,self.tresidReal)
        self.tresidAmp   = abs(self.tresidGain)

    def getMS_NAME(self,inputTable) :
        tb.open("%s/CAL_DESC" % inputTable)
        msFiles = tb.getcol("MS_NAME")
        tb.close()
        return np.unique(msFiles)[0]

    def getCalDescForSpwID(self,calDesc) :
        try:
            return np.where(self.calDescSpwIDMapping[0] == self.spwID)[0][0]
        except:
            print 'The identified spwID does not have a solution in this table.'
            sys.exit()
        
    def getCalDescSpwIDMapping(self) :
        tb.open("%s/CAL_DESC" % self.inputTable)
        self.calDescSpwIDMapping = tb.getcol("SPECTRAL_WINDOW_ID")
        tb.close()

    def setField(self,field) :
        self.field = field
        self.checkField()
        if self.autoSubtableQuery : self.makeAutoSubtable()

    def getField(self) : return self.field

    def checkField(self) :
        if self.field <> None : 
            self.field = str(self.field)
            if not self.field.isdigit() : self.field = self.ValueMapping.getFieldIdsForFieldName(self.field)[0]

    def checkAntenna(self) :
        if self.antenna <> None : 
            self.antenna = str(self.antenna)
            if not self.antenna.isdigit() : self.antenna = getAntennaIndex(self.inputMs,self.antenna)

    def getAntenna(self) : return self.antenna

    def setAntenna(self,antenna) :
        self.antenna = antenna
        self.checkAntenna()
        if self.autoSubtableQuery == True : 
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def getInputTable(self) : return self.inputTable

    def setInputTable(self,inputMs) :
        self.inputTable = inputTable
        if self.autoSubtableQuery == True : 
            self.makeAutoSubtable()
        else : self.makeSubtable()
        self.ValueMapping.setInputMs(inputMs)

    def getSpwID(self) : return self.spwID

    def setSpwID(self,spwID) :
        self.spwID = spwID
        if self.autoSubtableQuery == True : 
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def setScan(self,scan) :
        self.scan = scan
        if self.autoSubtableQueyry == True :
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def setFeed(self,feed) :
        self.feed = feed
        if self.autoSubtableQueyry == True :
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def setState(self,state) : 
        self.state = state
        if self.autoSubtableQueyry == True :
            self.makeAutoSubtable()
        else : self.makeSubtable()

    def getScan(self) : return self.scan

    def getFeed(self) : return self.feed

    def getState(self) : return self.state

    def makeSubtableQuery(self) :
        self.parameterList = []
        queryString = ''
        if self.antenna <> None : self.parameterList.append('ANTENNA1 == %s' % self.antenna)
        if self.field <> None    : self.parameterList.append('FIELD_ID == %s' % self.field)
        if self.spwID <> None    : self.parameterList.append('CAL_DESC_ID == %s' % self.getCalDescForSpwID(self.spwID))
        if self.state <> None    : self.parameterList.append('STATE_ID == %s' % self.state)
        if self.scan <> None     : self.parameterList.append('SCAN_NUMBER == %s' % self.scan)
        if self.feed <> None     : self.parameterList.append('FEED_ID == %s' % self.feed)
        for i in self.parameterList : queryString = self.appendQuery(queryString,i)
        self.queryString = queryString

    def appendQuery(self,queryString,additive) :
        if queryString == '' :
            if additive == '' : return queryString
            else : return additive
        else :
            if additive == '' : return queryString
            else : 
                queryString = queryString + ' && ' + additive
                return queryString

    def makeAutoSubtable(self) :
        self.checkAntenna()
        self.makeSubtableQuery()
        tb.open("%s" % self.inputTable)
        self.subtable = tb.query(self.queryString)
        tb.close()
        self.getFreq()
        self.getTimeAndInterval()
        self.getFit()
#        self.freqAverageSolutions()
#        self.timeAverageSolutions()
#        self.generateSpectralResiduals()
#        self.generateTimeResiduals()

    def makeSubtable(self) :
        tb.open("%s" % self.inputTable)
        self.subtable = tb.query(self.queryString)
        tb.close()
        self.getFreq()
        self.getTimeAndInterval()
        self.getFit()
        self.freqAverageSolutions()
        self.timeAverageSolutions()
        self.generateFrequencyResiduals()
        self.generateTimeResiduals()

    def setAutoSubtableQuery(self,autoSubtableQuery) :
        self.autoSubtableQuery = autoSubtableQuery

    def getAutoSubtableQuery(self) : return self.autoSubtableQuery

class ScaleGainsClass(CalTableExplorer):
    
    def __init__(self,calTable) :
        self.calTable = calTable
        CalTableExplorer.__init__(self,self.calTable)
        self.vm      = ValueMapping(self.inputMs)

    def calculateGainsScaling(self,calfieldL,calfieldH,caltableL,caltableH):

        tb.open("%s" % caltableL,nomodify=False)
        tableRow = tb.selectrows(0,'table_junk')
        polgainshape=len(tableRow.getcol('GAIN'))
        tb.close()	
        
        ####### Setting up dictionaries for low frequency table ######

        # Initialising cal to spw mapping dictionary
        self.calSpwMapL = {}

        #open descriptor file
        tb.open("%s/CAL_DESC" % caltableL ,nomodify=False)

        for k in range(tb.nrows()):
            tableRow = tb.selectrows(k,'table_junk')
            self.calSpwMapL[k] = tableRow.getcol('SPECTRAL_WINDOW_ID')[...,0]
	       
        tb.close()
	
        #Delete file containing each table row    
        os.system('rm -rf table_junk')

        ####### Setting up dictionaries for high frequency table ######

        # Initialising cal to spw mapping dictionary
        self.calSpwMapH = {}

        #open descriptor file
        tb.open("%s/CAL_DESC" % caltableH ,nomodify=False)

        for k in range(tb.nrows()):
            tableRow = tb.selectrows(k,'table_junk')
            self.calSpwMapH[k] = tableRow.getcol('SPECTRAL_WINDOW_ID')[...,0]
	       
        tb.close()
	
        #Delete file containing each table row    
        os.system('rm -rf table_junk')

        phasediff = np.zeros([self.vm.uniqueAntennas.shape[0],len(self.calSpwMapL),polgainshape]) 

        for pol in range(polgainshape):
             for calid in self.calSpwMapL:
                for antname1 in self.vm.uniqueAntennas:
           
                    ant = self.vm.getAntennaIdsForAntennaName(antname1)
                    spw = self.calSpwMapL[calid]
                     
                    print "Antenna, spw, Corr", antname1, spw, pol

                    ###### Caltable low: read in and unwrap phases ######

                    ct = CalTableExplorer("%s" % caltableL,spwID=spw,field=calfieldL)
                    
                    ct.setAntenna(antname1)
                    
                    phaseLpol=ct.phase[pol,0,:]
                    sizeL=ct.phase[pol,0,:].shape
           
                    ct.unwrapPhase()
                    
                    timeL=ct.time

                    pLinterp=interp1d(timeL,phaseLpol,kind=1,bounds_error=False,fill_value=np.nan)
                    
                    ###### Caltable high: read in and unwrap phases ######

                    if spw+4 in self.calSpwMapH.values():

                        ct = CalTableExplorer("%s" % caltableH,spwID=spw+4,field=calfieldH)
                    
                        ct.setAntenna(antname1)

                        phaseHpol=ct.phase[pol,0,:]

                        ct.unwrapPhase()
                        
                        timeH =ct.time

                        # Find interpolated values of low frequency at high data times
                        phaseLtoH= pLinterp(timeH)

                    else:
                        phaseHpol=np.zeros(sizeL)
                        phaseLtoH=np.zeros(sizeL)

                    keep = ~np.isnan(phaseHpol) & ~np.isnan(phaseLtoH)
                    
                    phasediff[ant,spw,pol] = np.mean(phaseHpol[keep]-phaseLtoH[keep])
                    
        return phasediff


    def scaleGains(self,phasediff,newTable=None) :
        
        # Define table name
        if newTable == None :
            self.newTable = '%s.scaled' % self.calTable
        else :
            self.newTable = newTable
            
        # Create copy of table, deep=T copies all tables not just data
        tb.open(self.calTable,nomodify=False)
        tb.copy(self.newTable,deep=True,valuecopy=True)
        tb.close()
        
        # Initialising cal to spw mapping dictionary, and row holders
	self.calSpwMap = {}

	#open descriptor file
        tb.open("%s/CAL_DESC" % self.calTable,nomodify=False)

        #Initialise row holder
	descrowvals  = {}

        for k in range(tb.nrows()):
            tableRow = tb.selectrows(k,'table_junk')
	    #Convert row to a dictionary
	    for i in tableRow.colnames():
                descrowvals[i] = tableRow.getcol(i)[...,0]
            self.calSpwMap[k] = descrowvals['SPECTRAL_WINDOW_ID'][0]
	       
	    # Write out to new table
	    #self.reconstructRow(descrowvalsp,"%s" % self.newTable)

	tb.close()
	
	#Delete file containing each table row    
	os.system('rm -rf table_junk')

	#Open caltable, find number of rows in table
        tb.open("%s" % self.calTable,nomodify=False)
        numsoln=tb.nrows()
        tb.close()

	#Initialise row holder
	rowvals  = {}

        # Loop over rows/solutions in caltable
        for k in range(numsoln) :

            tb.open("%s" % self.calTable,nomodify=False)

            #Read each row and write it into table_junk
            tableRow = tb.selectrows(k,'table_junk')
            
	    #Convert row to a dictionary
            for i in tableRow.colnames():
	        if 'REF_' in i : continue
	        else:
                    rowvals[i] = tableRow.getcol(i)[...,0]

            tb.close()

            #Set atribute of this class = rowvals
            self.rowvals = rowvals
                            
	    #Copy parameters for a given solution
	    self.rowvalsp = rowvals.copy()
                              
            #initialise scaled phase and amp arrays         
	    sphase = np.zeros(self.rowvals['GAIN'].shape)
	    samp = np.zeros(self.rowvals['GAIN'].shape)

	    ant = self.rowvalsp['ANTENNA1']
	    spw = self.calSpwMap[int(self.rowvalsp['CAL_DESC_ID'])]

            sphase[:,:]=np.angle(self.rowvals['GAIN']) + phasediff[ant,spw][:,np.newaxis]
            samp[:,:]=np.abs(self.rowvals['GAIN'])
   
            self.rowvalsp['GAIN'] = samp * np.exp(sp.sqrt(-1.)*sphase)
       
	    # Write out result to new table
	    self.reconstructRow(self.rowvalsp,"%s" % self.newTable)
             
        tb.open("%s" % self.newTable,nomodify=False)
        tb.removerows(range(numsoln))
        tb.close()

        #Delete table_junk file            
        os.system("rm -rf table_junk")
        
        #Remove table locks
        os.system("rm -rf %s/table.lock" % self.calTable)
        os.system("rm -rf %s/CAL_DESC/table.lock" % self.calTable)

    def reconstructRow(self,rowVals,tableName,tableRow=None) :
        tb.open(tableName,nomodify=False)
        if tableRow == None :
            tb.addrows()
            rownum = tb.nrows()-1L
        else :
            rownum = tableRow
        for i in rowVals.keys() :
            if rowVals[i].shape == () : isRealArray = False
            else : isRealArray = True
            rownum,i,rowVals[i]
            try:
                dt = tb.coldatatype(i)
                if dt == 'boolean' :
                    if not isRealArray :
                        if not rowVals[i] :
                            tb.putcell(i,rownum,0)
                        else :
                            tb.putcell(i,rownum,1)
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                elif dt == 'double' :
                    if not isRealArray :
                        tb.putcell(i,rownum,float(rowVals[i]))
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                elif dt == 'float' :
                    if not isRealArray :
                        tb.putcell(i,rownum,float(rowVals[i]))
                    else :
                        junk = np.array(rowVals[i],dtype='float32')
                        tb.putcell(i,rownum,junk)                    
                elif dt == 'integer' :
                    if not isRealArray :
                        tb.putcell(i,rownum,int(rowVals[i]))
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                elif dt == 'string' :
                    if not isRealArray :
                        tb.putcell(i,rownum,str(rowVals[i]))
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                else :
                    tb.putcell(i,rownum,rowVals[i])
            except:
                print 'skipping'
        tb.close()
#                tb.putcell(i,rownum,rowVals[i])


class InterpolateTsys(CalTableExplorer):
    """The Flag "iKnowWhatIAmDoing" should be used with care.  It implies that the user knows very well that the
       ordering of the basebands vs frequency was proper and consistent between the tdm and fdm mode and that the
       tdm mode was listed in the OT ranging from BB1, BB2, BB3 and BB4, not some other order.  Failure to use this
       options will in some cases result in slightly poorer performance and slightly better in other cases...thus
       you should really know what you are doing before you use it.
    """
       
    def __init__(self,calTable) :
        self.calTable = calTable
        self.inputMs = self.getMS_NAME(calTable)
        #CalTableExplorer.__init__(self,self.calTable)
        self.vm      = ValueMapping(self.inputMs)

    def getMS_NAME(self,inputTable) :
        tb.open("%s/CAL_DESC" % inputTable)
        msFiles = tb.getcol("MS_NAME")
        tb.close()
        return np.unique(msFiles)[0]

    def setCalTable(self,calTable) :
        self.calTable = calTable
        CalTableExplorer.__init__(self.calTable)
        self.vm.setInputMs(self.inputMs)

    def correctBadTimes(self, force=False):
        tb.open(self.calTable,nomodify=False)
        time=tb.getcol('TIME')
        interval = tb.getcol('INTERVAL')
        if max(time) < 7.0e9 and force == False:
            return "This process appears to have been done already."
        else :
            corr_time = time-interval/2.0
            tb.putcol("TIME",corr_time)
        tb.close()
        os.system("rm -rf %s/table.lock" % self.calTable)

    def assignFieldAndScanToSolution(self, iKnowWhatImDoing=False) :
        tb.open(self.calTable,nomodify=False)
        fieldId = tb.getcol("FIELD_ID")
        scans   = tb.getcol("SCAN_NUMBER")
        times   = tb.getcol("TIME")
        linesToRemove = []
        for i in range(tb.nrows()):
            _scan = self.vm.getScansForTime(times[i],5e-6)
            if _scan != None:
                  fieldId[i] = self.vm.getFieldsForScan(_scan,False)
                  scans[i] = _scan
            else:
                  linesToRemove.append(i)
        if iKnowWhatImDoing:
              for i in sorted(linesToRemove, reverse=True):
                  fieldId = np.delete(fieldId, i)
                  scans = np.delete(scans, i)
                  tb.removerows(i)
        tb.putcol('FIELD_ID',fieldId)
        tb.putcol("SCAN_NUMBER",scans)
        tb.close()
        os.system("rm -rf %s/table.lock" % self.calTable)
        

    def getTdmFdmSpw(self,iKnowWhatIAmDoing=True):
        """
        Input: None
        Output: None
        Responsible: S. Corder
        Purpose:
        """
        tb.open("%s/SYSCAL" % self.inputMs)
        tsysTdmSpw = sorted(dict.fromkeys(tb.getcol('SPECTRAL_WINDOW_ID')).keys())
        tb.close()
        tb.open("%s/SPECTRAL_WINDOW" % self.inputMs)
        #self.tdm = tb.query("(NUM_CHAN == 128) or (NUM_CHAN == 256) or (NUM_CHAN == 64)")
        self.tdm = tb.selectrows([int(i) for i in tsysTdmSpw])
        self.tdmSpw = self.tdm.rownumbers()
        if self.tdm.nrows() == 1: self.tdmSpw = [self.tdmSpw]
        self.tdmBBC = self.tdm.getcol('BBC_NO')
        self.fdm = tb.query("(NUM_CHAN == 7680) or (NUM_CHAN == 3840) or (NUM_CHAN == 1920) or (NUM_CHAN == 4096)")
        self.fdmSpw = self.fdm.rownumbers()
        if self.fdm.nrows() == 1: self.fdmSpw = [self.fdmSpw]
        self.fdmBBC = self.fdm.getcol('BBC_NO')
        if iKnowWhatIAmDoing : self.fdmBBC.sort()
        fdmFreqs = self.fdm.getcol('CHAN_FREQ')
        tdmFreqs = self.tdm.getcol('CHAN_FREQ')
        self.fdmFreqs = fdmFreqs
        self.tdmFreqs = tdmFreqs
        tb.close()
        self.tdmFdmMap = {}
        self.fdmTdmMap = {}
        for i in range(len(fdmFreqs[0])) :
            for j in range(len(tdmFreqs[0])) :
                delT = abs(tdmFreqs[1,j]-tdmFreqs[0,j])   # Added by S. Corder 2012/5/18
                minF = np.min(fdmFreqs[:,i])
                maxF = np.max(fdmFreqs[:,i])
                minT = np.min(tdmFreqs[:,j])
                maxT = np.max(tdmFreqs[:,j])
#                if ((minF >= minT) and (maxF <= maxT)) :  # Change requested by S. Corder 2012/5/18
                if ((minF >= (minT-0.5*delT)) and (maxF <= (maxT+0.5*delT))) :
                    if self.fdmTdmMap.has_key(int(self.fdmSpw[i])) :
                        if self.fdmBBC[i] == self.tdmBBC[j] :
                           self.fdmTdmMap[self.fdmSpw[i]] = self.tdmSpw[j]
                    else :
                        self.fdmTdmMap[self.fdmSpw[i]] = self.tdmSpw[j]
        for k,v in self.fdmTdmMap.iteritems() :
            self.tdmFdmMap[v] = self.tdmFdmMap.get(v,[])
            self.tdmFdmMap[v].append(k)
        print '# Mapping of Tsys and science spws.'
        print '# Please check that you have only one science spw per Tsys spw.'
        print '# ' + str(self.tdmFdmMap)
            
    def interpolateTsys(self,newTable=None,interpType='linear') :
        self.badRows = []
        if newTable == None :
            self.newTable = '%s.fdm' % self.calTable
        else :
            self.newTable = newTable
        tb.open(self.calTable,nomodify=False)
        tb.copy(self.newTable,deep=True,valuecopy=True)
        tb.close()
        tb.open("%s/CAL_DESC" % self.calTable,nomodify=False)
        self.numCalSol = tb.nrows()
        self.calSpwMap = {}
        tb.close()
        noSpw = []
        for k in range(self.numCalSol) :
            tb.open("%s/CAL_DESC" % self.calTable,nomodify=False)            
            tableRow = tb.selectrows(k,'table_junk')
            rowvals  = self.extractRow(tableRow)
            x = self.fdmFreqs.shape[0]
            y = rowvals['CHAN_WIDTH'].shape[0]
            y1 = rowvals['CHAN_RANGE'].shape[0]
            self.calSpwMap[k] = rowvals['SPECTRAL_WINDOW_ID'][0]
            self.calSpwMap[tb.nrows()+k]  = self.fdmSpw[k]
            rowvals['MS_NAME'] = np.array(rowvals['MS_NAME'],'str')
            rowvals['JONES_TYPE'] = np.array(rowvals['JONES_TYPE'],'str')
            rowvals['NUM_CHAN'] = np.array([x],'int')
            rowvals['SPECTRAL_WINDOW_ID'] = np.array([self.fdmSpw[k]],'int')
            rowvals['CHAN_FREQ'] = np.zeros((1,x))
            rowvals['CHAN_WIDTH'] = np.zeros((1,x))
            rowvals['CHAN_RANGE'] = np.zeros((y1,1,x),'int')
            rowvals['POLARIZATION_TYPE'] = np.zeros((1,x),'str')
            if self.fdmSpw[k] in self.fdmTdmMap.keys() : self.reconstructRow(rowvals,"%s/CAL_DESC" % self.newTable)
            tb.close()
        os.system('rm -rf table_junk')
        tb.open("%s/CAL_DESC" % self.calTable)
        calIds = tb.getcol("SPECTRAL_WINDOW_ID")
        tb.close()
        tb.open("%s" % self.calTable,nomodify=False)
        self.calrows = tb.nrows()
        self.spwCalMap = {}
        tb.close()
        noData = []
        for k,v in self.calSpwMap.iteritems() :
            self.spwCalMap[v] = self.spwCalMap.get(v,[])
            self.spwCalMap[v].append(k)
        counter = 0
        countMe = 0
        for k in range(self.calrows) :
#            if self.calSpwMap.has_key(int(rowvals['CAL_DESC_ID'])):
            tb.open("%s" % self.calTable,nomodify=False)
            tableRow = tb.selectrows(k,'table_junk')
            tb.close()
            rowvals = self.extractRow(tableRow)
            self.rowvals = rowvals
            if 1:
                tdmSpwID = self.calSpwMap[int(rowvals['CAL_DESC_ID'])]
                tdmRow = self.tdmSpw.index(tdmSpwID)
                tdmFreq = self.tdmFreqs[:,tdmRow]
                self.tdmFreq = tdmFreq
                if self.tdmFdmMap.has_key(tdmSpwID):
                    for i in self.tdmFdmMap[tdmSpwID] :
                        fdmSpwID = i
                        fdmRow = self.fdmSpw.index(i)
                        fdmFreq = self.fdmFreqs[:,fdmRow]
                        self.fdmFreq = fdmFreq
                        rowvalsp = rowvals.copy()
                        self.rowvalsp = rowvalsp
                        self.rowvals  = rowvals
                        val = int(self.spwCalMap[i][0])-self.numCalSol
                        rowvalsp['CAL_DESC_ID'] = np.array(int(self.spwCalMap[i][0])-self.numCalSol,'int')
                        if interpType == 'cubicspline' :
                            _real = (self.interpSpline(tdmFreq,fdmFreq,np.real(rowvals['GAIN'])))
                            _imag = (self.interpSpline(tdmFreq,fdmFreq,np.imag(rowvals['GAIN'])))
                            rowvalsp['GAIN'] = np.zeros(_real.shape,'complex64')
                            for i in range(rowvalsp['GAIN'].shape[0]) :
                                for j in range(rowvalsp['GAIN'].shape[1]) :
                                    rowvalsp['GAIN'][i,j] = np.complex(_real[i,j],_imag[i,j])
#                            rowvalsp['GAIN'] = (self.interpSpline(tdmFreq,fdmFreq,np.real(rowvals['GAIN'])))
                            rowvalsp['SOLUTION_OK'] = np.ones((rowvals['SOLUTION_OK'].shape[0],x),'bool') #self.interpSpline(tdmFreq,fdmFreq,rowvals['SOLUTION_OK'])
                            rowvalsp['FIT'] = np.ones((1,x),'float32') #self.interpSpline(tdmFreq,fdmFreq,rowvals['FIT'])
                            rowvalsp['FIT_WEIGHT'] = np.ones((1,x),'float32') #self.interpSpline(tdmFreq,fdmFreq,rowvals['FIT_WEIGHT'])
                            rowvalsp['FLAG'] = np.zeros((rowvals['FLAG'].shape[0],x),'bool') #self.interpSpline(tdmFreq,fdmFreq,rowvals['FLAG'])
                            rowvalsp['SNR'] = np.ones((rowvals['SNR'].shape[0],x),'float32') #self.interpSpline(tdmFreq,fdmFreq,rowvals['SNR'])
                        elif interpType == 'linear' :
                            _real = (self.interpLinear(tdmFreq,fdmFreq,np.real(rowvals['GAIN'])))
                            _imag = (self.interpLinear(tdmFreq,fdmFreq,np.imag(rowvals['GAIN'])))
                            rowvalsp['GAIN'] = np.zeros(_real.shape,'complex64')
                            for i in range(rowvalsp['GAIN'].shape[0]) :
                                for j in range(rowvalsp['GAIN'].shape[1]) :
                                    rowvalsp['GAIN'][i,j] = np.complex(_real[i,j],_imag[i,j])
#                            rowvalsp['GAIN'] = (self.interpLinear(tdmFreq,fdmFreq,np.real(rowvals['GAIN'])))
                            rowvalsp['SOLUTION_OK'] = np.ones((rowvals['SOLUTION_OK'].shape[0],x),'bool') #self.interpLinear(tdmFreq,fdmFreq,rowvals['SOLUTION_OK'])
                            rowvalsp['FIT'] = np.ones((1,x),'float32') #self.interpLinear(tdmFreq,fdmFreq,rowvals['FIT'])
                            rowvalsp['FIT_WEIGHT'] = np.ones((1,x),'float32') #self.interpLinear(tdmFreq,fdmFreq,rowvals['FIT_WEIGHT'])
                            rowvalsp['FLAG'] = np.zeros((rowvals['FLAG'].shape[0],x),'bool') #self.interpLinear(tdmFreq,fdmFreq,rowvals['FLAG'])
                            rowvalsp['SNR'] = np.ones((rowvals['SNR'].shape[0],x),'float32') #self.interpLinear(tdmFreq,fdmFreq,rowvals['SNR'])
                        else :
                            return "Invalid interpType, please pick linear or cubicspline."
                        self.reconstructRow(rowvalsp,"%s" % self.newTable,counter)
                        counter+=1
#                        sys.stdin.readline()
                    countMe+=1
                else :
                    #self.nullRow("%s" % self.newTable,k)
                    noData.append(counter)
        os.system("rm -rf table_junk")
        print counter
        print noData
        tb.close()
        if noData <> [] : 
            if min(makeList(noData)) < self.calrows :
                while max(makeList(noData)) >= self.calrows :
                    noData.remove(max(makeList(noData)))
        os.system("rm -rf %s/table.lock" % self.newTable)    
        tb.open(self.newTable,nomodify=False)
        if noData <> [] : tb.removerows(noData)
        tb.close()
        os.system("rm -rf %s/CAL_DESC/table.lock" % self.newTable)
        tb.open("%s/CAL_DESC" % self.newTable,nomodify=False)
        tb.removerows(range(self.numCalSol))
        tb.close()
        os.system("rm -rf %s/table.lock" % self.calTable)
        os.system("rm -rf %s/CAL_DESC/table.lock" % self.calTable)
        os.system("rm -rf table_junk")

       
    def interpLinear(self,tmpFreq,newFreq,tmpData) :
        tmpFreq,tmpData,checker = self.checkOrder(tmpFreq,tmpData)
        if newFreq[1]-newFreq[0] < 0 : newFreq = newFreq[::-1]
        newData = np.zeros((tmpData.shape[0],newFreq.shape[0]))
        for i in range(tmpData.shape[0]) :
            newData[i,:] = np.interp(newFreq,tmpFreq,tmpData[i,:])
        if checker :
            return newData.transpose()[::-1].transpose()
        else :
            return newData

    def interpSpline(self,tmpFreq,newFreq,tmpData) :
        tmpFreq,tmpData,checker = self.checkOrder(tmpFreq,tmpData)        
        newData = np.zeros((tmpData.shape[0],newFreq.shape[0]))
        for i in range(tmpData.shape[0]) :
            tck = splrep(tmpFreq,tmpData[i,:],s=0)
            newData[i,:] = splev(newFreq,tck,der=0)
        if checker :
            return newData.transpose()[::-1].transpose()
        else :
            return newData

    def checkOrder(self,inpFreq,inpData) :
        if ((inpFreq[1]-inpFreq[0]) > 0) :
            return inpFreq,inpData,0
        else :
            return inpFreq[::-1],inpData.transpose()[::-1].transpose(),1
        
    def extractRow(self,row) :
        rowvals = {}
        for i in row.colnames() :
            try:
                rowvals[i] = row.getcol(i)[...,0]
            except:
                print "Unable to extract data for %s" % i
        return rowvals

    def reconstructRow1(self,tableName,tableRow=None) :
        tb.open(tableName,nomodify=False)
        if tableRow == None : tb.addrows()
        else :
            self.badRows.append(tableRow)
        tb.close()

    def nullRow(self,tableName,tableRow) :
        tb.open(tableName,nomodify=False)
        row = tb.selectrows(tableRow,'table_null')
        rowVals = self.extractRow(row)
        for i in rowVals.keys() :
            if rowVals[i].shape == () : isRealArray = False
            else : isRealArray = True
            row,i,rowVals[i]
            try:
                dt = tb.coldatatype(i)
                if dt == 'boolean' :
                    if not isRealArray :
                        if not rowVals[i] :
                            tb.putcell(i,rownum,0)
                        else :
                            tb.putcell(i,rownum,1)
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                elif dt == 'double' :
                    if not isRealArray :
                        tb.putcell(i,rownum,float(rowVals[i])*0)
                    else :
                        tb.putcell(i,rownum,rowVals[i]*0)
                elif dt == 'float' :
                    if not isRealArray :
                        tb.putcell(i,rownum,float(rowVals[i])*0)
                    else :
                        junk = np.array(rowVals[i]*0,dtype='float32')
                        tb.putcell(i,rownum,junk)                    
                elif dt == 'integer' :
                    if not isRealArray :
                        tb.putcell(i,rownum,int(rowVals[i]*0))
                    else :
                        tb.putcell(i,rownum,rowVals[i]*0)
                elif dt == 'string' :
                    if not isRealArray :
                        tb.putcell(i,rownum,str(rowVals[i]))
                    else :
                        tb.putcell(i,rownum,rowVals[i]*0)
                else :
                    tb.putcell(i,rownum,rowVals[i])
            except:
                print 'skipping'
        tb.close()
        os.system("rm -rf table_null")

    def reconstructRow(self,rowVals,tableName,tableRow=None) :
        tb.open(tableName,nomodify=False)
        if tableRow == None :
            tb.addrows()
            rownum = tb.nrows()-1L
        else :
            rownum = tableRow
        for i in rowVals.keys() :
            if rowVals[i].shape == () : isRealArray = False
            else : isRealArray = True
            rownum,i,rowVals[i]
            try:
                dt = tb.coldatatype(i)
                if dt == 'boolean' :
                    if not isRealArray :
                        if not rowVals[i] :
                            tb.putcell(i,rownum,0)
                        else :
                            tb.putcell(i,rownum,1)
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                elif dt == 'double' :
                    if not isRealArray :
                        tb.putcell(i,rownum,float(rowVals[i]))
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                elif dt == 'float' :
                    if not isRealArray :
                        tb.putcell(i,rownum,float(rowVals[i]))
                    else :
                        junk = np.array(rowVals[i],dtype='float32')
                        tb.putcell(i,rownum,junk)                    
                elif dt == 'integer' :
                    if not isRealArray :
                        tb.putcell(i,rownum,int(rowVals[i]))
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                elif dt == 'string' :
                    if not isRealArray :
                        tb.putcell(i,rownum,str(rowVals[i]))
                    else :
                        tb.putcell(i,rownum,rowVals[i])
                else :
                    tb.putcell(i,rownum,rowVals[i])
            except:
                print 'skipping'
        tb.close()
#                tb.putcell(i,rownum,rowVals[i])

class Visibility:
    """
    Instantiation requires the input MS file.  Also, if spwID is not
    set and there is more than one, beware as a failure will occur if
    the spw have different shapes.  If you create this instance, what
    you get is a structure with various attributes.  If you use the
    data.setX methods the table selection is redone,
    i.e. data.antenna1='DV01' (or 0, it interprets both, I am working
    on the same thing for field) will not make you a new table but
    data.setAntenna1('DV01') will make a new table with antenna1 as
    DV01 instead of whatever it was before.  You can also make the
    table not automatically create the subtable by setting
    autoSubtableQuery==False and then you can put in your own
    queryString.  cross_auto_all is set to 'all' by default but if you
    put in 'cross' or 'auto' it will select the relevant items.  There
    are a few functions that return the amplitude and phase (or
    recalculate them) and there is an unwrap and wrap phase option
    however, use this with caution as it depends on having alot of
    signal to noise in each measurement, i.e. it is not smart.  Let me
    know if you have questions, additions, or whatever...additions can
    just be made and a warning ;) Try to make changes backwards
    compatible...that'll make it ugly but it'll make it work!
    """
    
    def __init__(self,inputMs,antenna1=0,antenna2=0,spwID=None,field=None,state=None,scan=None,autoSubtableQuery=True,queryString='',cross_auto_all='all',correctedData=False, vm=''):
        if autoSubtableQuery==False and queryString=='' : return 'Must either automatically generate the (autoSubtableQuery=True) or provide a subtable query string (queryString)'
        if spwID == None :
            spwID = getChanAverSpwIDBaseBand0(inputMs)
        self.inputMs = inputMs
        if (casadef.casa_version >= '4.1.0'):
            self.mytb = createCasaTool(tbtool)
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(inputMs)
            self.fieldsforname = {}
            for f in range(mymsmd.nfields()):
                fname = mymsmd.namesforfields(f)[0]
                self.fieldsforname[fname] = f
            mymsmd.close()
        else:
            if vm == '':
                self.valueMap = ValueMapping(self.inputMs)
            else:
                self.valueMap = vm
        self.antenna1 = antenna1
        self.antenna2 = antenna2
        if self.antenna1 <> None : self.antenna1    = str(antenna1)
        if self.antenna2 <> None : self.antenna2    = str(antenna2)
        self.checkAntenna()
        if cross_auto_all.lower() in ['cross','auto','all'] :
            self.cross_auto_all = cross_auto_all
        else :
            return "Improper value for cross_auto_all, please select, cross, auto or all."
        self.spwID       = spwID
        self.field       = field
        self.checkField()
        self.correctedData = correctedData
        self.state       = state
        self.scan        = scan
        self.autoSubtableQuery = autoSubtableQuery
        self.queryString = queryString
        if self.autoSubtableQuery == True : 
            self.makeAutoSubtable()
        else : self.makeSubtable()
        self.getSpectralData()
        self.getAmpAndPhase()

    def checkAntenna(self) :
        if self.antenna1 <> None : 
            self.antenna1 = str(self.antenna1)
            if not self.antenna1.isdigit() : self.antenna1 = getAntennaIndex(self.inputMs,self.antenna1)
        if self.antenna2 <> None :
            self.antenna2 = str(self.antenna2)
            if not self.antenna2.isdigit() : self.antenna2 = getAntennaIndex(self.inputMs,self.antenna2)

    def makeAutoSubtable(self) :
        self.checkAntenna()
        self.makeSubtableQuery()
        tb.open(self.inputMs)
        self.subtable = tb.query(self.queryString)
        tb.close()
        self.getSpectralData()
        self.getAmpAndPhase()

    def makeSubtable(self) :
        tb.open(self.inputMs)
        self.subtable = tb.query(self.queryString)
        tb.close()

    def makeSubtableForWriting(self) :
        self.mytb.open(self.inputMs, nomodify=False)
        self.subtable = self.mytb.query(self.queryString)
        self.rowsToWrite = self.subtable.rownumbers()  

    def setAutoSubtableQuery(self,autoSubtableQuery) :
        self.autoSubtableQuery = autoSubtableQuery

    def getAutoSubtableQuery(self) : return self.autoSubtableQuery

    def setAntennaPair(self,antenna1,antenna2) :
        self.antenna1 = str(antenna1)
        self.antenna2 = str(antenna2)
        self.checkAntenna()
        if self.autoSubtableQuery : self.makeAutoSubtable()

    def setAntenna1(self,antenna1) :
        self.antenna1 = str(antenna1)
        self.checkAntenna()
        if self.autoSubtableQuery : self.makeAutoSubtable()

    def setAntenna2(self,antenna2) :
        self.antenna2 = str(antenna2)
        self.checkAntenna()
        if self.autoSubtableQuery : self.makeAutoSubtable()

    def getAntenna1(self) : return self.antenna1

    def getAntenna2(self) : return self.antenna2

    def getAntennaPair(self) :
        return [self.antenna1,self.antenna2]

    def setSpwID(self,spwID) :
        self.spwID = spwID
        if self.autoSubtableQuery : self.makeAutoSubtable()

    def getSpwID(self) : return self.spwID

    def setField(self,field) :
        self.field = field
        self.checkField()
        if self.autoSubtableQuery : self.makeAutoSubtable()

    def getField(self) : return self.field

    def checkField(self) :
        if self.field <> None : 
            self.field = str(self.field)
            if not self.field.isdigit(): 
                if (casadef.casa_version >= '4.1.0'):
                    self.field = self.fieldsforname[self.field]
                else:
                    self.field = self.valueMap.getFieldIdsForFieldName(self.field)[0]

    def setState(self,state) :
        self.state = state
        if self.autoSubtableQuery : self.makeAutoSubtable()
    
    def getState(self) : return self.state
    
    def setScan(self,scan) :
        self.scan = scan
        if self.autoSubtableQuery : self.makeAutoSubtable()
    
    def getScan(self) : return self.scan
    
    def makeSubtableQuery(self) :
        self.parameterList = []
        queryString = ''
        if self.antenna1 <> None : self.parameterList.append('ANTENNA1 == %s' % self.antenna1)
        if self.antenna2 <> None : self.parameterList.append('ANTENNA2 == %s' % self.antenna2)
        if self.field <> None    : self.parameterList.append('FIELD_ID == %s' % self.field)
        if self.spwID <> None    : self.parameterList.append('DATA_DESC_ID == %s' % getDataDescriptionId(self.inputMs,self.spwID))
        if self.state <> None    : self.parameterList.append('STATE_ID == %s' % self.state)
        if self.scan <> None     : self.parameterList.append('SCAN_NUMBER == %s' % self.scan)
        if self.cross_auto_all == 'cross' : self.parameterList.append('ANTENNA1 <> ANTENNA2')
        elif self.cross_auto_all == 'auto' : self.parameterList.append('ANTENNA1 == ANTENNA2')
        for i in self.parameterList : queryString = self.appendQuery(queryString,i)
        self.queryString = queryString

    def getSpectralData(self) :
        if 'FLOAT_DATA' in self.subtable.colnames() :
            if self.correctedData :
                self.specData = self.subtable.getcol('FLOAT_DATA')
            else :
                self.specData = self.subtable.getcol('FLOAT_DATA')
        else :
            if self.correctedData:
                self.specData = self.subtable.getcol('CORRECTED_DATA')
            else :
                self.specData = self.subtable.getcol('DATA')
        self.specTime = self.subtable.getcol('TIME')
        self.specFreq = getFrequencies(self.inputMs,self.spwID)
        self.tavgSpecData = self.specData.mean(-1)
        self.favgSpecData = self.specData.mean(-2)
            
    def putSpectralData(self, data, i):
        if 'FLOAT_DATA' in self.subtable.colnames() :
            if self.correctedData :
                self.mytb.putcell('FLOAT_DATA', self.rowsToWrite[i], data)
            else :
                self.mytb.putcell('FLOAT_DATA', self.rowsToWrite[i], data)
        else :
            if self.correctedData:
                self.mytb.putcell('CORRECTED_DATA', self.rowsToWrite[i], data)
            else :
                self.mytb.putcell('DATA', self.rowsToWrite[i], data)

    def getAmpAndPhase(self) :
        rData = self.specData.real
        rTavgData = self.tavgSpecData.real
        rFavgData = self.favgSpecData.real
        iData = self.specData.imag
        iTavgData = self.tavgSpecData.imag
        iFavgData = self.favgSpecData.imag
        self.phase = np.arctan2(iData,rData)
        self.amp   = (rData**2.0+iData**2.0)**0.5
        self.tavgPhase = np.arctan2(iTavgData,rTavgData)
        self.tavgAmp   = (rTavgData**2.0+iTavgData**2.0)**0.5
        self.favgPhase = np.arctan2(iFavgData,rFavgData)
        self.favgAmp   = (rFavgData**2.0+iFavgData**2.0)**0.5

    def wrapPhase(self,simple=True) :
        from math import pi
        phaseShape = self.phase.shape
        for i in range(phaseShape[2]) :
            if self.phase[:,:,i] <  -pi : self.phase[:,:,i]=self.phase[:,:,i]+2*pi
            elif self.phase[:,:,i] > pi : self.phase[:,:,i]=self.phase[:,:,i]-2*pi
        
    def unwrapPhase(self,simple=True) :
        from math import pi
        phaseShape = self.phase.shape
        for i in range(phaseShape[2]-1) :
            diff = self.phase[:,:,i]-self.phase[:,:,i+1]
            _diffg = (diff > 1.*pi)*2*pi
            _diffl = (diff < -1.*pi)*2*pi
            self.phase[:,:,i+1] = self.phase[:,:,i+1]+_diffg-_diffl

    def appendQuery(self,queryString,additive) :
        if queryString == '' :
            if additive == '' : return queryString
            else : return additive
        else :
            if additive == '' : return queryString
            else : 
                queryString = queryString + ' && ' + additive
                return queryString

def alignFunctions(xaxis1, intensity1, xaxis2, intensity2, points=None):
    """
    Takes any two functions and returns spline-fit versions sampled onto a common
    grid which is set to span the common range of their x-axes with at least as many
    points as the input function.
    points: the number of points desired in the output grid
    Returns:
    xaxis, function1, function2
    -Todd Hunter
    """
    newmin = np.max([np.min(xaxis1),np.min(xaxis2)])
    newmax = np.min([np.max(xaxis1),np.max(xaxis2)])
    if points == None:
        points = np.max([len(xaxis1), len(xaxis2)])
    xaxis = np.linspace(newmin,newmax,points)
    int1 = interpolateSpectrum(xaxis1, intensity1, xaxis)
    int2 = interpolateSpectrum(xaxis2, intensity2, xaxis)
    return xaxis, int1, int2
    
def interpolateSpectrum(inputFreq, inputSpec, outputFreq):
    """
    Interpolates a spectrum onto a finer grid of frequencies using a spline fit.
    If the inputFreq is narrower than the outputFreq, it will extrapolate the
    inputSpec with 'nearest' .
    Todd Hunter
    """
    tmpFreq, tmpData, checker = checkOrder(inputFreq, inputSpec)
#    print "len(tmpFreq)=%d, len(tmpData)=%d" % (len(tmpFreq), len(tmpData))
    tck = splrep(tmpFreq, tmpData, s=0)
    fdmSpectrum = splev(outputFreq, tck, der=0)
    return(fdmSpectrum)

def multiSingleDishSpectrum(vis,antenna=0,spw=None,field=None,offstate=None,
                            scan=None,pol=0,intent='OBSERVE_TARGET#ON_SOURCE',asdm=None,
                            tsystable=None, plotfile='', ut='', showMeanIntegration=True,
                            showMaxIntegration=False,plotEveryIntegration=False, ylimits=[0,0],
                            scaleFactor=1.0, smoothing=1, cleanup=True, onstate=None,
                            tsysvis=None,tsysspw=None,verbose=False,xlimits=[0,0],
                            xlimitsFdm=[0,0],removeMedian=False):
    tcal = []
    sd = []
    tsys = []
    meanTcal = []
    atmcal = None
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    antennaName = mymsmd.antennanames(antenna)[0]
    mymsmd.close()
    if (onstate == None):
        # find all the ON states
        a = singleDishSpectrum(vis,antenna,spw,field,offstate,
                               scan, pol, intent, asdm,
                               tsystable, plotfile, ut, showMeanIntegration,
                               showMaxIntegration, plotEveryIntegration, ylimits,
                               scaleFactor, smoothing, cleanup, onstate, atmcal=atmcal,
                               tsysvis=tsysvis,tsysspw=tsysspw,verbose=verbose,
                               xlimits=xlimits,xlimitsFdm=xlimitsFdm)
        onstate = a[5]
        attenuatorCorrectionFactor = a[7]
        scaleFactor = a[8]
        alpha = a[9]
        alphaFdm = a[10]
        print "all onstates = ", onstate
    for state in onstate:
        result = singleDishSpectrum(vis,antenna,spw,field,offstate,
                                    scan, pol, intent, asdm,
                                    tsystable, plotfile, ut, showMeanIntegration,
                                    showMaxIntegration, plotEveryIntegration, ylimits,
                                    scaleFactor, smoothing, cleanup,onstate=state,atmcal=atmcal,
                                    attenuatorCorrectionFactor=attenuatorCorrectionFactor,
                                    tsysvis=tsysvis,tsysspw=tsysspw,verbose=verbose,
                                    xlimits=xlimits,xlimitsFdm=xlimitsFdm,alpha=alpha,alphaFdm=alphaFdm)
                                    
        freq, tcalMethod, sdimagingMethod, meanTsysMethod, meanTcalMethod, allOnStates, atmcal, attenuatorCorrectionFactor, scaleFactor, alpha, alphaFdm = result
        tcal.append(tcalMethod)
        sd.append(sdimagingMethod)
        tsys.append(meanTsysMethod)
        meanTcal.append(meanTcalMethod)
    tcalMean = np.mean(tcal,axis=0)
    sdMean = np.mean(sd,axis=0)
    tsysMean = np.mean(tsys,axis=0)
    meanTcalMean = np.mean(meanTcal,axis=0)
    pb.clf()
    pb.subplots_adjust(hspace=0.20)
    pb.subplots_adjust(wspace=0.20)
    adesc = pb.subplot(221)
    print np.shape(freq), np.shape(tcalMean)
    mysize = 12
    if (tsysvis == None):
        pb.text(0,1.15,'%s %s'%(vis,antennaName), size=mysize, transform=adesc.transAxes)
    else:
        pb.text(0,1.15,'%s %s (Tsys=%s)'%(vis,antennaName,tsysvis), size=mysize-1, transform=adesc.transAxes)
    pb.plot(freq, tcalMean, 'k-')
    if (removeMedian):
        tcalMean -= computeYStatsForXLimits(freq, tcalMean, xlimits)['median']
        meanTcalMean -= computeYStatsForXLimits(freq, meanTcalMean, xlimits)['median']
        sdMean -= computeYStatsForXLimits(freq, sdMean, xlimits)['median']
        tsysMean -= computeYStatsForXLimits(freq, tsysMean, xlimits)['median']
    ylimits = np.array(computeYLimitsForXLimits(freq,sdMean,xlimits))*1.1
    pb.xlim(xlimits)
    pb.ylim(ylimits)
    pb.title('spectral Tcal method', size=mysize)
    ticksize = 10
    resizeFonts(adesc, ticksize)

    adesc = pb.subplot(222)
    pb.plot(freq, meanTcalMean, 'k-')
    pb.xlim(xlimits)
    pb.ylim(ylimits)
    pb.title('mean Tcal method', size=mysize)
    resizeFonts(adesc, ticksize)

    adesc = pb.subplot(223)
    pb.plot(freq, sdMean, 'k-')
    pb.xlim(xlimits)
    pb.ylim(ylimits)
    pb.title('spectral Tsys method (sdimaging)', size=mysize)
    pb.xlabel('Sky frequency (GHz)')
    resizeFonts(adesc, ticksize)

    adesc = pb.subplot(224)
    pb.plot(freq, tsysMean, 'k-')
    pb.xlim(xlimits)
    pb.ylim(ylimits)
    pb.xlabel('Sky frequency (GHz)')
    pb.title('mean Tsys method', size=mysize)
    resizeFonts(adesc, ticksize)

    pb.savefig('tcal_vs_sdimaging.png')

def computeYStatsForXLimits(x, y, xlimits):
    """
    Computes the Y-axis statistics (mean, std, median, min, max) over the specified
    x-axis range, rather than over the whole x-axis range.  Returns a dictionary.
    -Todd Hunter
    """
    idx0 = np.where(x >= xlimits[0])[0]
    idx1 = np.where(x <= xlimits[1])[0]
    idx = np.intersect1d(idx1,idx0)
    if (len(idx) < 1):
        print "No points match the x-range.  Using entire range."
        idx = range(len(y))
    return({'mean': np.mean(y[idx]), 'std': np.std(y[idx]), 'median': np.median(y[idx]),
            'min': np.min(y[idx]), 'max': np.max(y[idx])})
    
def computeYLimitsForXLimits(x, y, xlimits, verbose=False):
    """
    Computes the Y-axis limits to autorange over the specified x-axis range, rather
    than over the whole x-axis range, which is what pylab plot does by default.
    -Todd Hunter
    """
    mydict = computeYStatsForXLimits(x, y, xlimits)
    if (verbose):
        print "full ylimits: %f,%f   within x-range: %f,%f" % (np.min(y), np.max(y), mydict['min'], mydict['max'])
    ylimits = [mydict['min'], mydict['max']]
    return(ylimits)
                            
def singleDishSpectrum(vis,antenna=0,spw=None,field=None,offstate=None,
                       scan=None,pol=0,intent='OBSERVE_TARGET#ON_SOURCE',asdm=None,
                       tsystable=None, plotfile='', ut='', showMeanIntegration=False,
                       showMaxIntegration=False,plotEveryIntegration=False, ylimits=[0,0],
                       scaleFactor=1.0, smoothing=1, cleanup=True,onstate=None,
                       atmcal=None, attenuatorCorrectionFactor=None,tsysvis=None,
                       tsysspw=None,verbose=False,xlimits=[0,0],xlimitsFdm=[0,0],
                       alpha=None,alphaFdm=None):
    """
    Test function to try alternative SD calibration equations.
    vis: the measurement set containing the ON, OFF data
    tsysvis: the measurement set containing the Tsys scan to use
    asdm: the dataset corresponding to tsysvis
    antenna = antenna number as integer
    spw: spw number as integer
    field: field number as integer
    onstate: integer STATE_ID for the on source integration
    offstate: integer STATE_ID for the off source integration
    pol: 0 or 1
    ut: a string representing UT time '12:00:00' (date will be prepended)
    showMaxIntegration: if True, show the single integration with largest mean
                        if False, show the single integration closest to the requested UT
    showMeanIntegration: if True, show the mean of all integrations in a row/state_id,
                         if False, show the single integration closest to the requested UT
    plotEveryIntegration: make a plot for every dump rather than the mean, and build PDF
    scaleFactor: the factor by which to multiply Robert's formula
    cleanup: if True, remove the png files if multiple ones were made
    attenuatorCorrectionFactor: the value to multiply the ON and OFF spectrum by
    xlimits: the x-axis limits for the Tcal/Tsys spectra (in GHz)
    xlimitsFdm: the x-axis limits for the FDM data spectra (in GHz)
    Returns: 10 items:
      chanfreqs, spectrum using Tcal method, spectrum using Tsys method, spectrum using mean Tsys
      method, list of all on-source state IDs, atmcal instance, attenuatorCorrectionFactor,
      scaleFactor, alpha, alphaFdm
    
    Todd Hunter
    """
    if (type(onstate) == list):
        print "onstate must be an integer, not a list"
        return
    if (asdmLibraryAvailable == False):
        print "The ASDM bindings library is not available on this machine."
        return
    from almahelpers_localcopy import tsysspwmap
    if (tsysvis == None):
        tsysvis = vis
    if (asdm == None):
        asdm = tsysvis.split('.')[0]
    if (tsystable == None):
        tsystable = tsysvis+'.tsys'
    if (os.path.exists(tsystable) == False):
        print "Running gencal to create the tsys caltable."
        gencal(tsysvis, caltype='tsys', caltable=tsystable)
    if (atmcal == None):
        atmcal = Atmcal(tsysvis)
    mymsmd = createCasaTool(msmdtool)
    mjdsec = 0
    if (ut != ''):
        mydate = getObservationStartDate(vis).split()[0]
        mydate = mydate + ' ' + ut
        mjdsec = dateStringToMJDSec(mydate)
        print "Finding closest data to %s = %f" % (mydate, mjdsec)
    mymsmd.open(vis)
    antennaName = mymsmd.antennanames(antenna)[0]
    if (spw == None):
        spws = spwsforintent_nonwvr_nonchanavg(mymsmd, intent)
        if (len(spws) < 1):
            print "No spws match this intent"
            return
        spw = spws[0]
        print "Picking spw = %d" % (spw)
    if (field == None):
        fields = mymsmd.fieldsforintent(intent)
        if (len(fields) < 1):
            print "No fields match this intent"
            return
        field = fields[0]
        fieldName = mymsmd.namesforfields(field)[0]
        print "Picking field = %d = %s" % (field, fieldName)
    fieldName = mymsmd.namesforfields(field)[0]
    if (scan == None):
        scans = np.intersect1d(mymsmd.scansforintent(intent), mymsmd.scansforfield(field))
        if (len(scans) < 1):
            print "No scans match this intent+field"
            return
        scan = scans[0]
        print "Picking data scan = ", scan
    chanfreqs = mymsmd.chanfreqs(spw) * 1e-9
    meantime = np.mean(mymsmd.timesforscan(scan))
    mymsmd.close()
    atmcalscan = atmcal.nearestCalScan(meantime)
    print "Picking ATMCal scan = ", atmcalscan
    if (tsysspw == None):
        tcalSpw = tsysspwmap(vis, tsystable)[spw]
    else:
        tcalSpw = tsysspw
        if (tcalSpw not in atmcal.datadescids.keys()):
            print "spw %d is not an ATMCal spw in %s" % (tcalSpw, tsysvis)
            return
    skyLoad = atmcal.getSpectrum(atmcalscan, tcalSpw, pol, 'sky', antenna)
    ambLoad = atmcal.getSpectrum(atmcalscan, tcalSpw, pol, 'amb', antenna)
    hotLoad = atmcal.getSpectrum(atmcalscan, tcalSpw, pol, 'hot', antenna)
    if (verbose):
        print "Calling readTcal('%s', %d, %d, %f)" % (asdm, antenna, tcalSpw,meantime)
    tcal, tcalTime = readTcal(asdm, antenna, tcalSpw, meantime, verbose=verbose)
    if (verbose):
        print "Calling readTcal('%s', %d, %d, %f, spectrum='tsys')" % (asdm, antenna, tcalSpw,meantime)
    tsys, tsysTime = readTcal(asdm, antenna, tcalSpw, meantime, spectrum='tsys', verbose=verbose)
    tcal = tcal[pol]
    tsys = tsys[pol]
    mymsmd.open(tsysvis)
    tcalChanfreqs = mymsmd.chanfreqs(tcalSpw) * 1e-9
    mymsmd.close()
    if (verbose):
        print "%d chanfreqs: %f-%f,  %d tcalChanfreqs: %f-%f" % (len(chanfreqs),chanfreqs[0],chanfreqs[-1],
                                                                 len(tcalChanfreqs),tcalChanfreqs[0],tcalChanfreqs[-1])
    tcalFdm = interpolateSpectrum(tcalChanfreqs, tcal, chanfreqs)
    tsysFdm = interpolateSpectrum(tcalChanfreqs, tsys, chanfreqs)
    meanTsysFdm = computeYStatsForXLimits(chanfreqs,tsysFdm,xlimits)['mean']
    skyLoadFdm = interpolateSpectrum(tcalChanfreqs, skyLoad, chanfreqs)
    ambLoadFdm = interpolateSpectrum(tcalChanfreqs, ambLoad, chanfreqs)
    hotLoadFdm = interpolateSpectrum(tcalChanfreqs, hotLoad, chanfreqs)
    
    mytb = createCasaTool(tbtool)
    mytb.open(vis)
    allstates = mytb.getcol('STATE_ID')
    myt = mytb.query('ANTENNA1==%d and ANTENNA2==%d and DATA_DESC_ID==%d and FIELD_ID==%d and SCAN_NUMBER==%d' % (antenna,antenna,spw,field,scan))
    rows = myt.rownumbers()
    times = myt.getcol('TIME')
    print "%d matching rows: %s" % (len(rows), str(rows))
    if (len(rows) == 0):
        return
    states = myt.getcol('STATE_ID')
    myt.close()
    mytb.close()

    mytb.open(vis+'/STATE')
    obsMode = mytb.getcol('OBS_MODE')
    allOnStates = []
    if (onstate == None):
        if (mjdsec > 0):
            # Pick the closest row in time
            mindiff = 1e20
            for row in range(len(rows)):
                if (obsMode[allstates[rows[row]]].find('ON_SOURCE') >= 0):
                    deltaTime = abs(times[row]-mjdsec)
                    if (deltaTime < mindiff):
                        mindiff = deltaTime
#                        print "New mindiff on = ", mindiff
                        onstate = states[row]
                        onstateTime = times[row]
        else:            
            # Pick the first row that contains ON_SOURCE
            for row in range(len(rows)):
                if (obsMode[allstates[rows[row]]].find('ON_SOURCE') >= 0):
                    onstate = states[row]
                    onstateTime = times[row]
#                    print "onstate = ", onstate
                    break
    else:
        row = np.where(states == onstate)[0][0]
        onstateTime = times[row]
    # Just do this so I can return the value for other usage.
    for myrow in range(len(rows)):
        if (obsMode[allstates[rows[myrow]]].find('ON_SOURCE') >= 0):
            allOnStates.append(states[myrow])
    on_intents = obsMode[allstates[rows[row]]]
    print "on source intents = %s" % (str(on_intents))
    if (offstate == None):
        if (mjdsec > 0):
            # Pick the closest row in time
            mindiff = 1e20
            for row in range(len(rows)):
                if (obsMode[allstates[rows[row]]].find('OFF_SOURCE') >= 0):
                    deltaTime = abs(times[row]-mjdsec)
                    if (deltaTime < mindiff):
                        mindiff = deltaTime
                        offstate = states[row]
                        offsourceRow = row
        else:            
            # Pick the row closest to the ON_SOURCE in time
            mindiff = 1e20
            for row in range(len(rows)):
                if (obsMode[allstates[rows[row]]].find('OFF_SOURCE') >= 0):
                    deltaTime = abs(times[row]-onstateTime)
                    if (deltaTime < mindiff):
                        mindiff = deltaTime
                        offstate = states[row]
                        offsourceRow = row
    else:
        row = np.where(states == offstate)[0][0]
        offsourceRow = row

    row = offsourceRow
    off_intents = obsMode[allstates[rows[row]]]
    print "offsource row = ", row
    print "offsource rows[row] = ", rows[row]
    print "allstates[rows[row]] = ", allstates[rows[row]]    
    print "offstate = ", offstate
    print "offsource intents = %s" % (str(off_intents))
    v = Visibility(vis, antenna, antenna, spw, field, onstate, scan, cross_auto_all='auto')

    if (plotEveryIntegration):
        dumps = range(len(v.specTime))
        on_spectrum = []
        for dump in dumps:
            on_spectrum.append(np.abs(v.specData[pol,:,dump]))
        on_time = v.specTime[:]
        on_duration = v.specTime[1] - v.specTime[0]
    elif (showMeanIntegration == False):
        if (showMaxIntegration):
            peakspec = -1e10
            for s in range(len(v.specData[pol][0])):
                spec = v.specData[pol,:,s]
                meanspec = np.mean(spec)
                if (meanspec > peakspec):
                    peakspec = meanspec
                    pick = s
        elif (mjdsec > 0):
            # pick the one closest to the requested UT time
            nearestTime = 1e10
            for s in range(len(v.specData[pol][0])):
                deltaTime = abs(v.specTime[s]-mjdsec)
                if (deltaTime < nearestTime):
                    nearestTime = deltaTime
                    pick = s
        else:
            # Just pick the first one
            pick = 0
        on_spectrum = [np.abs(v.specData[pol,:,pick])]
        on_time = [v.specTime[pick]]
        if (pick == 0):
            on_duration = v.specTime[pick+1] - v.specTime[pick]
        else:
            on_duration = v.specTime[pick] - v.specTime[pick-1]
        dumps = [0]
    else:
        dumps = [0]
        on_spectrum = [np.mean(v.specData[pol],axis=1)]
        on_time = [np.mean(v.specTime)]
        on_duration = np.max(v.specTime) - np.min(v.specTime)
            
    v.setState(offstate)
    off_time = np.mean(v.specTime)
    off_spectrum = np.mean(v.specData[pol],axis=1)
    off_duration = np.max(v.specTime) - np.min(v.specTime)
    off_spectrum = abs(off_spectrum)
    
    channels = np.intersect1d(np.where(tcalChanfreqs >= np.min(chanfreqs))[0], np.where(tcalChanfreqs <= np.max(chanfreqs))[0])
    print "Channels to average = %d-%d" % (channels[0], channels[-1])
    if (attenuatorCorrectionFactor == None):
        attenuatorCorrectionFactor = np.mean(skyLoad[channels]) / np.mean(off_spectrum)  
    off_spectrum *= attenuatorCorrectionFactor
    print "TDM/FDM plus attenuator correction factor = %f = %f dB" % (attenuatorCorrectionFactor, 10*np.log10(attenuatorCorrectionFactor))
    if (alpha==None):
        jSky, jAmb, jHot, frequency, jatmDSB, jspDSB, jbg, tauA, alpha, gb = atmcal.computeJs(atmcalscan, antenna, pol, tcalSpw, computeJsky=True)
        alphaFdm =  interpolateSpectrum(tcalChanfreqs, np.array(alpha), chanfreqs)
    mysize = 10
    if (plotEveryIntegration):
        rows = 2
        cols = 1
        ticksize = 9
    else:
        rows = 3
        cols = 3
        ticksize = 7
    pnglist = []
    for dump in dumps:
      on_spectrum[dump] = abs(on_spectrum[dump]) * attenuatorCorrectionFactor
      pb.clf()
      pb.subplots_adjust(hspace=0.30)
      pb.subplots_adjust(wspace=0.40)
      scale = 1e8
      if (xlimits == [0,0]):
          xlimits = [np.min([np.min(tcalChanfreqs),np.min(chanfreqs)]), np.max([np.max(tcalChanfreqs),np.max(chanfreqs)])]
      if (xlimitsFdm == [0,0]):
          xlimitsFdm = [np.min(chanfreqs), np.max(chanfreqs)]
      if (plotEveryIntegration == False):
        adesc = pb.subplot(rows,cols,5)
        pb.plot(chanfreqs, on_spectrum[dump]/scale, 'k-', chanfreqs, off_spectrum/scale, 'r-')
        pb.xlim(xlimitsFdm)
        resizeFonts(adesc, ticksize)
        pb.ylabel('Raw data / %.0e'%(scale),size=mysize)
        print "Mean ON-OFF = %f,  Mean ON/OFF = %f" % (np.mean(on_spectrum[dump]-off_spectrum),
                                                       np.mean(on_spectrum[dump])/np.mean(off_spectrum))
        pb.title('ON=black, OFF=red',size=mysize)
        
      if (plotEveryIntegration == False):
        adesc = pb.subplot(rows,cols,1)
        pb.plot(tcalChanfreqs, tcal, 'k-', chanfreqs, tcalFdm, 'r-')
        pb.xlim(xlimits)
        resizeFonts(adesc, ticksize)
#        pb.title('Tcal at %s (spw %d, %d)' % (mjdsecToUTHMS(tcalTime), tcalSpw, spw), size=mysize)
        pb.title('Tcal at %s (spw %d, %d)' % (mjdsecToUT(tcalTime), tcalSpw, spw), size=mysize)
        pb.ylabel('Temperature (K)',size=mysize)
        pb.text(-0.10*cols,1.17,vis + ', ant%02d=%s, spw=%02d, field=%d=%s, scan=%d, onstate=%d, offstate=%d'%(antenna, antennaName, spw, field, fieldName, scan, onstate, offstate), transform=adesc.transAxes, size=mysize)
    
      if (plotEveryIntegration == False):
        adesc = pb.subplot(rows,cols,2)
        pb.plot(tcalChanfreqs, tsys, 'k-', chanfreqs, tsysFdm, 'r-')
        pb.xlim(xlimits)
        pb.text(0.1,0.85,'mean=%.1f' % (meanTsysFdm),size=mysize+1-cols,transform=adesc.transAxes)
        resizeFonts(adesc, ticksize)
        pb.title('Tsys',size=mysize) # at %s (spw %d, %d)' % (mjdsecToUTHMS(tcalTime), tcalSpw, spw), size=mysize)
        pb.ylim(computeYLimitsForXLimits(tcalChanfreqs, tsys, xlimits))
        pb.ylabel('Temperature (K)',size=mysize)
        if ((rows-1)*cols < 3):
            pb.xlabel('Sky frequency (GHz)',size=mysize)
    
      if (plotEveryIntegration == False):
        adesc = pb.subplot(rows,cols,4)
        pb.plot(tcalChanfreqs, ambLoad/scale,'k-', tcalChanfreqs, hotLoad/scale,'k-',
                chanfreqs, ambLoadFdm/scale,'r-', chanfreqs, hotLoadFdm/scale,'r-',
                tcalChanfreqs, skyLoad/scale, 'k-', chanfreqs, skyLoadFdm/scale,'r-')
        pb.ylim([np.min(ambLoad/scale), np.max(hotLoad/scale)])
        resizeFonts(adesc, ticksize)
        pb.xlim(xlimits)
        pb.title('Ambient, Hot load, Sky', size=mysize)
        pb.ylabel('Raw data / %.0e'%scale,size=mysize)
        pb.text(0.05,0.28, 'C=mean(skyLoad/OFF)=%.2f' % (attenuatorCorrectionFactor),
                size=7, transform=adesc.transAxes)
    
      if (plotEveryIntegration == False and False):
        adesc = pb.subplot(rows,cols,5)
        yaxis = skyLoad/scale
        pb.plot(tcalChanfreqs, yaxis, 'k-', chanfreqs, skyLoadFdm/scale,'r-')
        resizeFonts(adesc, ticksize)
        pb.xlim(xlimits)
        pb.ylim(computeYLimitsForXLimits(tcalChanfreqs, yaxis, xlimits))
        pb.title('Sky load', size=mysize)
        pb.text(0.05,0.88, 'C=mean(skyLoad/OFF)=%.2f' % (attenuatorCorrectionFactor),
                size=7, transform=adesc.transAxes)
        pb.ylabel('Raw data / %.0e'%scale,size=mysize)
    
      if (plotEveryIntegration == False):
        adesc = pb.subplot(rows,cols,3)
        pb.plot(tcalChanfreqs, alpha,'k-', chanfreqs, alphaFdm, 'r-')
        resizeFonts(adesc, ticksize)
        pb.xlim(xlimits)
        pb.title('Alpha (red=interpolated to FDM)', size=mysize)
        pb.ylabel('Unitless',size=mysize)
    
      if (plotEveryIntegration == False):
          panel = 8
      else:
          panel = 1
      adesc = pb.subplot(rows,cols,panel)
      if (plotEveryIntegration):
          pb.text(-0.10*cols,1.17,vis + ', ant%02d=%s, spw=%02d, field=%d=%s, scan=%d, onstate=%d, offstate=%d'%(antenna, antennaName, spw, field, fieldName, scan, onstate, offstate), transform=adesc.transAxes, size=mysize)
          pb.text(-0.08*cols,-0.08*rows,'ON: %s (%.2f sec duration)  OFF: %s (%.2f sec duration)' % (mjdsecToUTHMS(on_time[dump],prec=8), on_duration,
                                                                                                mjdsecToUTHMS(off_time,prec=8), off_duration),
                  transform=adesc.transAxes, size=mysize)
          pb.text(0.9,-0.08*rows, '%2d/%d'%(dump+1,len(dumps)), transform=adesc.transAxes, size=mysize)
      print "mean(alpha) = %f, mean(tcalFdm)=%f" % (np.mean(alphaFdm), np.mean(tcalFdm))
      print "mean(ambLoad) = %e, mean(hotLoad) = %e, mean(OFF) = %e" % (np.mean(ambLoadFdm), np.mean(hotLoadFdm), np.mean(off_spectrum))
      onoff_sdimaging = tsysFdm * (on_spectrum[dump] - off_spectrum) / off_spectrum
      onoff_meanTsys = meanTsysFdm * (on_spectrum[dump] - off_spectrum) / off_spectrum
      onoff_cso = atmcal.loadTemperatures[antenna][atmcalscan]['amb'] * (on_spectrum[dump] - off_spectrum) / (ambLoadFdm - off_spectrum)
      if (True):
          # original posting to CSV-2986
          onoff = scaleFactor * tcalFdm * (on_spectrum[dump] - off_spectrum) / ((1-alphaFdm)*hotLoadFdm + alphaFdm*ambLoadFdm - off_spectrum)
          onoff_meanTcal = scaleFactor * np.mean(tcalFdm) * (on_spectrum[dump] - off_spectrum) / ((1-alphaFdm)*hotLoadFdm + alphaFdm*ambLoadFdm - off_spectrum)
          if (scaleFactor != 1.0):
              pb.title('%g*C*Tcal*(ON-OFF)/((1-alpha)*HOT+alpha*AMB-C*OFF)' % (scaleFactor), size=8)
          else:
              scaleFactor = computeYStatsForXLimits(chanfreqs,onoff_sdimaging,xlimits)['mean']/computeYStatsForXLimits(chanfreqs,onoff,xlimits)['mean']
              scaleFactor = np.round(scaleFactor*10)/10.0
              pb.title('C*Tcal*(ON-OFF)/((1-alpha)*HOT+alpha*AMB-C*OFF)', size=8)
      else:
          onoff = tcalFdm * (on_spectrum[dump] - off_spectrum) / ((1-alphaFdm)*ambLoadFdm + alphaFdm*hotLoadFdm - off_spectrum) 
          pb.title('C*Tcal*(ON-OFF)/((1-alpha)*AMB+alpha*HOT-C*OFF)', size=8)
      if (smoothing > 1):
          onoff = smooth(onoff, window_len=smoothing, window='flat')
          onoff_cso = smooth(onoff_cso, window_len=smoothing, window='flat')
          onoff_meanTcal = smooth(onoff_meanTcal, window_len=smoothing, window='flat')
          onoff_sdimaging = smooth(onoff_sdimaging, window_len=smoothing, window='flat')
          onoff_meanTsys = smooth(onoff_meanTsys, window_len=smoothing, window='flat')

      pb.plot(chanfreqs, onoff,'k-')
      pb.text(0.1,0.9,'mean=%.2f, std=%.3f'%(computeYStatsForXLimits(chanfreqs,onoff,xlimits)['mean'],
                                             computeYStatsForXLimits(chanfreqs,onoff,xlimits)['std']),
                                             size=mysize+1-cols, transform=adesc.transAxes)
      resizeFonts(adesc, ticksize)
      pb.xlim(xlimitsFdm)
      if (ylimits == [0,0] or ylimits == []):
          ylimits = [np.min([np.min(onoff_sdimaging), np.min(onoff)]), np.max([np.max(onoff_sdimaging),np.max(onoff)])]
          ylimits = [ylimits[0]-0.1*ylimits[1], ylimits[1]*1.1]
          if (ylimits[0] > 0): ylimits[0] = 0
      pb.ylim(ylimits)
      pb.ylabel('Temperature (K)',size=mysize)

      if (plotEveryIntegration == False):
        adesc = pb.subplot(rows,cols,6)
        # CSO method
        pb.plot(chanfreqs, onoff_cso,'k-')
        pb.title('CSO method = Tamb*(ON-OFF)/(AMB-SKY)', size=mysize-1)
        pb.ylabel('Temperature (K)',size=mysize)
        resizeFonts(adesc, ticksize)
        pb.xlim(xlimitsFdm)
        pb.ylim(ylimits)
        pb.text(0.1,0.9,'mean=%.2f, std=%.3f'%(computeYStatsForXLimits(chanfreqs,onoff_cso,xlimits)['mean'],
                                               computeYStatsForXLimits(chanfreqs,onoff_cso,xlimits)['std']),
                size=mysize+1-cols, transform=adesc.transAxes)
        pb.text(0.1,0.1,'Tamb=%.2fK'%(atmcal.loadTemperatures[antenna][atmcalscan]['amb']),
                size=mysize+1-cols, transform=adesc.transAxes)
    
      if (plotEveryIntegration == False):
        adesc = pb.subplot(rows,cols,7)
        if (False):
            onoff = (on_spectrum[dump] - off_spectrum) / off_spectrum
            pb.plot(chanfreqs, onoff,'k-')
            pb.title('(ON-OFF)/OFF', size=mysize)
            pb.ylabel('Raw data',size=mysize)
            pb.text(0.1,0.9,'mean=%.2f, std=%.3f'%(computeYStatsForXLimits(chanfreqs,onoff,xlimits)['mean'],
                                                   computeYStatsForXLimits(chanfreqs,onoff,xlimits)['std']),
                    size=mysize+1-cols, transform=adesc.transAxes)
        else:
            pb.plot(chanfreqs, onoff_meanTsys, 'k-')
            pb.title('mean(Tsys)*(ON-OFF)/OFF', size=mysize-2)
            pb.ylim(ylimits)
            pb.ylabel('Temperature (K)',size=mysize)
            pb.text(0.1,0.9,'mean=%.2f, std=%.3f'%(computeYStatsForXLimits(chanfreqs,onoff_meanTsys,xlimits)['mean'],
                                                   computeYStatsForXLimits(chanfreqs,onoff_meanTsys,xlimits)['std']),
                    size=mysize+1-cols, transform=adesc.transAxes)
        resizeFonts(adesc, ticksize)
        pb.xlim(xlimitsFdm)
        pb.text(-0.08*cols,-0.08*rows,'ON: %s (%.2f sec duration)  OFF: %s (%.2f sec duration)' % (mjdsecToUTHMS(on_time[dump],prec=8), on_duration,
                                                                                     mjdsecToUTHMS(off_time,prec=8), off_duration),
                transform=adesc.transAxes, size=mysize)
    
      adesc = pb.subplot(rows,cols,panel+1)
      pb.plot(chanfreqs, onoff_sdimaging,'k-')
      pb.text(0.1,0.9,'mean=%.2f, std=%.3f'%(computeYStatsForXLimits(chanfreqs,onoff_sdimaging,xlimits)['mean'],
                                             computeYStatsForXLimits(chanfreqs,onoff_sdimaging,xlimits)['std']),
              size=mysize+1-cols, transform=adesc.transAxes)
      resizeFonts(adesc, ticksize)
      pb.xlim(xlimitsFdm)
      pb.ylim(ylimits)
      pb.title('Tsys*(ON-OFF)/OFF', size=mysize)
      pb.ylabel('Temperature (K)',size=mysize)
      pb.xlabel('Sky frequency (GHz)',size=mysize)
      print "mean of sdimaging / Robert = ", computeYStatsForXLimits(chanfreqs,onoff_sdimaging,xlimits)['mean']/computeYStatsForXLimits(chanfreqs,onoff,xlimits)['mean']
      pb.draw()
      if (plotfile != ''):
          if (plotfile == True):
              if (len(dumps) > 1):
                  png = vis+'.%s.%s.spw%02d.pol%d.dump%02d.png' % (fieldName,antennaName,spw,pol,dump)
                  pb.savefig(png)
                  pnglist.append(png)
              else:
                  pb.savefig(vis+'.%s.%s.spw%02d.pol%d.png' % (fieldName,antennaName,spw,pol))
          else:
              pb.savefig(plotfile)
    if (len(pnglist) > 0):
        if (smoothing > 1):
            pdf = vis+'.%s.%s.spw%02d.pol%d.pdf' % (fieldName,antennaName,spw,pol)
        else:
            pdf = vis+'.%s.%s.spw%02d.pol%d.smooth%g.pdf' % (fieldName,antennaName,spw,pol,smoothing)
        buildPdfFromPngs(pnglist, pdf)
        if (cleanup):
            for png in pnglist:
                os.system('rm -f %s' % png)
    else:
        if (len(allOnStates) > 0):
            print "on states = ", np.unique(allOnStates)
        return(chanfreqs, onoff, onoff_sdimaging, onoff_meanTsys, onoff_meanTcal,
               np.unique(allOnStates), atmcal, attenuatorCorrectionFactor,scaleFactor,
               alpha, alphaFdm)

def getAntennaIndex(msFile,antennaName) :
    """
    Returns the index number of the specified antenna in the specified ms.
    The antennaName must be a string, e.g. DV01.  Obsoleted by msmd.antennaids('DV01')[0].
    """
    if str(antennaName).isdigit() : 
        return antennaName
    else :
        ids = getAntennaNames(msFile)
        if (antennaName not in ids):
            print "Antenna %s is not in the dataset.  Available antennas = %s" % (antennaName, str(ids))
            return(-1)
        return np.where(ids == antennaName)[0][0]

def getAntennaName(msFile,antennaID) :
    """
    Returns the antenna name of the specified antenna in the specified ms.
    The antennaID must be an integer.Obsoleted by msmd.antennanames(1)[0].
    Todd Hunter
    """
    names = getAntennaNames(msFile)
    if (antennaID >= 0 and antennaID < len(names)):
        return (names[antennaID])
    else:
        print "This antenna ID (%d) is not in the ms." % (antennaID)
        return ('')

def getAntennaNames(msFile) :
    """
    Returns the list of antenna names in the specified ms.
    Obsoleted by msmd.antennanames(range(msmd.nantennas())).
    """
    mytb = createCasaTool(tbtool)
    mytb.open(msFile+'/ANTENNA')
    names = mytb.getcol('NAME')
    mytb.close()
    return names

def convertTimeStamps(timesIn) :
    timesIn = makeList(timesIn)
    timesOut = []
    for i in timesIn :
        timesOut.append(convertTimeStamp(i))
    return timesOut

def convertTimeStamp(timeIn) :
    conv   = timeIn.split('T')
    date   = conv[0].split('-')
    time   = conv[1].split(':')
    year   = float(date[0])
    month  = float(date[1])
    day    = float(date[2])
    hour   = float(time[0])
    minute = float(time[1])
    second = float(time[2])
    ut=hour+minute/60+second/3600
    if (100*year+month-190002.5)>0:
        sig=1
    else:
        sig=-1
    return 367*year - int(7*(year+int((month+9)/12))/4) + int(275*month/9) + day + 1721013.5 + ut/24 - 0.5*sig +0.5

def parseTrx(antennaSel,polSel=0,bandNumberSel=3,filename='/data/checkTrx.txt') :
    data = fiop.readcolPy(filename,'s,f,s,f,i,s,f,f,f,f,f')
    recTime = np.array(data[0])
    elev    = np.array(data[1])
    jdTime  = recTime
    for i in range(len(recTime)) : jdTime[i] = convertTimeStamp(recTime[i])-2455198
    antenna = np.array(data[2])
    freq    = np.array(data[3])*1e9
    pol     = np.array(data[4])
    chan    = np.array(data[5])
    trx     = np.array(data[6])
    errtrx  = np.array(data[7])
    gain    = np.array(data[8])
    errgain = np.array(data[9])
    tsys    = np.array(data[10])
    indexAnt  = np.where(antenna == antennaSel)[0]
    indexPol  = np.where(pol == polSel)[0]
    indexFreqLow = np.where(freq <= bandDefinitions[bandNumberSel][1])[0]
    indexFreqHigh = np.where(freq >= bandDefinitions[bandNumberSel][0])[0]
    indexVal = list((set(indexAnt) & set(indexPol) & set(indexFreqLow) & set(indexFreqHigh)))
    return jdTime[indexVal],elev[indexVal],recTime[indexVal],chan[indexVal],trx[indexVal],errtrx[indexVal],gain[indexVal],errgain[indexVal],freq[indexVal],tsys[indexVal]

def parseTrxInfo(antennaList=['DV01','DV02','DV03','DV04','DV05','PM02','PM03'],polList=[0,1],bandList=[3,6],filename=None) :
    if filename == None : filename='/data/checkTrx.txt'
    info = {}
    for i in antennaList :
        info[i] = {}
        for j in bandList :
            info[i][j] = {}
            for k in polList :
                info[i][j][k] = {'jdTime' : [], 'recTime' : [], 'chan' : [], 'trx' : [], 'errtrx' : [], 'gain' : [], 'errgain' : [], 'freq' : [],'elev' : [],'tsys':[]}
                info[i][j][k]['jdTime'],info[i][j][k]['elev'],info[i][j][k]['recTime'],info[i][j][k]['chan'],info[i][j][k]['trx'],info[i][j][k]['errtrx'],info[i][j][k]['gain'],info[i][j][k]['errgain'],info[i][j][k]['freq'],info[i][j][k]['tsys'] = parseTrx(i,k,j,filename)
    return info


def plotTrxInfo(antennaList=['DV01','DV02','DV03','DV04','DV05','PM02','PM03'],polList=[0,1],bandList=[3,6],filename=None) :
    if filename == None : filename='/data/checkTrx.txt'
    antennaList = makeList(antennaList)
    polList = makeList(polList)
    bandList = makeList(bandList)
    colorList = ['b','g','r','c','m','y','k']
    pointList = ['x','.','o','^','<','>','s','+',',','D','1','2','3','4','h','H','o','|','_']
    info = parseTrxInfo(antennaList,polList,bandList,filename)
    clf()
    limits = {3 : 100, 6: 100, 7:300, 9:500}
    spec = {3 : 30, 6: 70, 7:137, 9: 500}
    subplot(len(bandList),1,1)
    hold(True)
    rcParams['font.size'] = 9.0
    for i in range(len(antennaList)) :
        for j in range(len(bandList)) :
            subplot(len(bandList),1,j+1)
            for k in range(len(polList)) :
                legendInfo = 'Antenna %s' % (antennaList[i])
                time = info[antennaList[i]][bandList[j]][polList[k]]['jdTime']
                trx  = info[antennaList[i]][bandList[j]][polList[k]]['trx']
                err  = info[antennaList[i]][bandList[j]][polList[k]]['errtrx']
                psym = colorList[i]+pointList[k]
#                errorbar(time,trx,yerr=err,fmt=None)
                try:
                   if k==0 : plot(time,trx,psym,label=legendInfo)
                   else : plot(time,trx,psym)
                except:
                    print len(info[antennaList[i]][bandList[j]][polList[k]]['trx'])
                    print 'invalid data for antenna %s, polarization %i, band %i' % (antennaList[i],polList[k],bandList[j])
                print len(time),spec[bandList[j]]
                try: plot(time,[spec[bandList[j]]]*len(time),'k-')
                except: continue
            legend(loc=0)
            title('Trx vs time')
            xlabel('Julian Date')
            ylabel('Receiver Temperature (K)')
            ylim(0,limits[bandList[j]])
#    legend(loc=1)
    show()

def makeSpecTrx(freq,band) :
    newSpec = []
    for i in freq :
        low = (bandDefinitions[band][1]-bandDefinitions[band][0])*0.1/1e9+bandDefinitions[band][0]/1e9+6
        high = -(bandDefinitions[band][1]-bandDefinitions[band][0])*0.1/1e9+bandDefinitions[band][1]/1e9-6
        print low,high
        if band == 3 :
            if (i < low) or (i > high) : alpha = 10
            else : alpha = 6
        if band == 6 :
            if (i < low) or (i > high) : alpha = 10
            else : alpha = 6
            alpha = 6
        if band == 7 :
            if (i < low) or (i > high) : alpha = 12
            else : alpha = 8
        if band == 9 :
            if (i < low) or (i > high) : alpha = 15
            else : alpha = 10
        newSpec.append(0.048*alpha*i+4)
    return newSpec
                     
def plotTrxFreq(antennaList=['DV01','DV02','DV03','DV04','DV05','PM02','PM03'],polList=[0,1],bandList=[3,6],filename=None) :
    if filename == None : filename='/data/checkTrx.txt'
    
    antennaList = makeList(antennaList)
    polList = makeList(polList)
    bandList = makeList(bandList)
    colorList = ['b','g','r','c','m','y','k']
    pointList = ['x','o','.','^','<','>','s','+',',','D','1','2','3','4','h','H','o','|','_']
    info = parseTrxInfo(antennaList,polList,bandList,filename)
    clf()
    subplot(len(bandList),1,1)
    limits = {3 : 100, 6: 150, 7:300, 9:500}
    rcParams['font.size'] = 9.0
    hold(True)
    for i in range(len(antennaList)) :
        for j in range(len(bandList)) :
            subplot(len(bandList),1,j+1)
            legendInfo = 'Antenna %s, Band %s' % (antennaList[i],bandList[j])
            for k in range(len(polList)) :
                freq = info[antennaList[i]][bandList[j]][polList[k]]['freq']/1e9
                trx  = info[antennaList[i]][bandList[j]][polList[k]]['trx']
                err  = info[antennaList[i]][bandList[j]][polList[k]]['errtrx']
                psym = colorList[j]+pointList[i] ; print psym,len(trx),len(freq)
                plot(freq,trx,psym)
                newSpec = makeSpecTrx(freq,bandList[j])
                newSpec = np.array(newSpec)
                freq = np.array(freq)
                print newSpec.shape,freq.shape
                freq.sort()
                newSpec.sort()
                plot(freq,newSpec,'k-')
                ylim(0,limits[bandList[j]])
        legend(loc=0)
        title('Trx vs Frequency')
        xlabel('Frequency (GHz)')
        ylabel('Receiver Temperature (K)')
#    ylim(20,200)
    subplot(len(bandList),1,1)
    title('Trx vs Frequency')
    show()
    return newSpec

class MakeTable: 
    def __init__(self,inputMs,queryString='') :
        self.inputMs = inputMs
        self.queryString = queryString
        self.makeSubtable()
        self.data = {}
        for i in self.subtable.colnames() : self.data[i] = self.subtable.getcol(i)
        tb.close()

    def makeSubtable(self) :
        tb.open(self.inputMs)
        self.subtable = tb.query(self.queryString)
        tb.close()

#class SkyDip(MakeTable):
#    def __init__(self,inputMs,pressureCut=700,location='AOS'):
#        return


class Weather(MakeTable):
    def __init__(self,inputMs,pressureCut=700,location='AOS'):
        queryString = ("PRESSURE < %s" % pressureCut)
        MakeTable.__init__(self,"%s/WEATHER" % inputMs,queryString)
        self.location      = location
        self.getAtmProfile()
        self.data['ATM_TEMP'] = self.getAtmProfile()
        
    def getAtmProfile(self) :
        if self.location == 'AOS'   : alt = casac.Quantity(5000.0,'m')
        elif self.location == 'OSF' : alt = casac.Quantity(3000.0,'m')
        tatm = []
        tProfile = []
        for i in range(len(self.data["REL_HUMIDITY"])) : 
            tmp = casac.Quantity(self.data['TEMPERATURE'][i],'K')
            pre = casac.Quantity(self.data['PRESSURE'][i],'mbar')
            maxA = casac.Quantity(48.0,'km')
            hum = self.data["REL_HUMIDITY"][i]
            myatm   = at.initAtmProfile(alt,tmp,pre,maxA,hum)
            tempPro = at.getProfile()['temperature'] 
            tProfile.append(np.array(tempPro.value))
            tatm.append(sum(tempPro.value)/len(tempPro.value))
        return np.array(tatm)
        
class InterpolateTableTime: #I think this also would work for Frequency without trying at all, just have to fix verbage?  I also think the call in Tsys is wrong..and probably giving me all sorts of errors.
    def __init__(self,table,timeSeries=None,nonRealInterp='nearest',realInterp='linear',ifRepeat='average',tableQuery=None) :
        print """Warning: Interpolation of many variables may be inaccurate, be careful of using anything interpolated."""
        if nonRealInterp <> 'nearest' and nonRealInterp <> 'change' :
            print """You must enter nearetst or change for the nonRealInterp value.  Nearest is nearest neighbor, change
                     is the same value is repeated until the boolean changes values."""
            return
        else :
            self.nonrealInterpType = nonRealInterp
        if realInterp <> 'linear' and realInterp <> 'cubicspline' :
            print """You must enter linear or cubicspline for the nonRealInterp value.  Nearest is nearest neighbor, change
                     is the same value is repeated until the boolean changes values."""
            return
        else :
            self.realInterpType = realInterp
        self.table = table
        print self.table
        self.colNames = table.data.keys()
        if "TIME" not in self.colNames :
            print """CRITICAL: Time must be a component of the table to use this function."""
            return
        self.time = self.table.data["TIME"]
        self.oldData = self.table.data.copy()
        self.oldTime = self.oldData.pop("TIME")
        self.colNames.remove('TIME')
        self.timeSeries = timeSeries
        
    def interpolateData(self,timeSeries,quiet=False) :
        self.newTime = timeSeries
        self.newData = {}
        self.newTime.sort()
        if self.newTime.shape <> np.unique(self.newTime).shape :
            if not quiet : print "Removing repeated times."
            self.newTime = np.unique(self.newTime)

        for i in self.colNames :
            if not quiet : print "Doing parameter %s" % i
            if 'float' in str(self.oldData[i].dtype) or 'complex' in str(self.oldData[i].dtype) :
                if self.oldTime.shape <> np.unique(self.oldTime).shape :
                    tmpTime,tmpData = self.handleTimeRepeats(i)
                else :
                    tmpTime = self.oldTime ;  tmpData = self.oldData[i]
                tuppleMax  = self.oldData[i].shape[:-1]
                indexList  = np.ndindex(tuppleMax)
                _newTmp = []
                for j in indexList :
                    _tmpData = np.transpose(tmpData)[j][:]
                    if self.realInterpType == 'cubicspline' : _new = self.interpSpline(tmpTime,_tmpData)
                    elif self.realInterpType == 'linear' : _new = self.interpLinear(tmpTime,_tmpData)
                    _newTmp.append(np.transpose(_new))
                self.newData[i] = np.array(_newTmp)
                for j in range(len(self.newTime)) :
                    if self.oldTime[0]-self.newTime[j] > 0 :
                        self.newData[i][...,j] = self.oldData[i][...,0]
            else :
                if self.nonrealInterpType == 'change' : self.interpChange(i)
                elif self.nonrealInterpType == 'nearest' : self.interpNearest(i)
            self.newData[i] = np.squeeze(self.newData[i])

    def handleTimeRepeats(self,colname) : 
        tmpTime = []
        tmpData = []
        for j in np.unique(self.oldTime) :
            locos = np.where(self.oldTime == j)
            tmpTime.append(np.mean(self.oldTime[locos]))
            tmpData.append(np.mean(self.oldData[colname][...,locos],-1))
        tmpTime = np.array(tmpTime)
        tmpData = (np.squeeze(np.array(tmpData)))
        return tmpTime,tmpData

    def interpLinear(self,tmpTime,tmpData) :
        return np.interp(self.newTime,tmpTime,tmpData)

    def interpSpline(self,tmpTime,tmpData) :
        tck = splrep(tmpTime,tmpData,s=0)
        return splev(self.newTime,tck,der=0)

    def interpChange(self,colname) :
        self.newData[colname] = []
        for j in self.newTime :
            timeDiff = self.oldTime-j
            goodIndex = max(np.where(timeDiff < 0)[0])
            self.newData[colname].append(self.oldData[colname][goodIndex])
            self.newData[colname] = np.array(self.newData[colname])

    def interpNearest(self,colname) :
        self.newData[colname] = []
        for j in self.newTime :
            timeDiff = (self.oldTime-j)
            indexCount = abs(timeDiff).min()
            locos      = np.where(abs(timeDiff) == indexCount)
            self.newData[colname].append(np.mean(self.oldData[colname][locos]))
        self.newData[colname] = np.array(self.newData[colname])        

def getSourceFieldMapping(inputMs) :
    tb.open("%s/FIELD" % (inputMs) )
    sourceNames = tb.getcol('NAME')
    sourceIds = {}
    for i in range(len(sourceNames)) :
        sourceIds[sourceNames[i]] = i
    tb.close()
    return sourceIds,sourceNames

def getSourceScans(inputMs,sourceName) :
    if str(sourceName).isdigit() : fieldId = sourceName
    else:
        sourceIds,sourceNames = getSourceFieldMapping(inputMs)
        try:
            fieldId = sourceIds[sourceName]
        except:
            return 'What you talking about Willis?'
    tb.open(inputMs)
    scans = tb.getcol('SCAN_NUMBER')
    fields = tb.getcol('FIELD_ID')
    list1 = where(fields == fieldId)
    fieldscans = scans[list1]
    return np.unique(fieldscans)

def getBasebandNumber(inputMs,spwId) :
    """
    Returns the number of the baseband for the specified spw in the specified ms.
    """
    if (os.path.exists(inputMs) == False):
        print "measurement set not found"
        return -1
    mytb = createCasaTool(tbtool)
    mytb.open("%s/SPECTRAL_WINDOW" % inputMs)
    if ('BBC_NO' in mytb.colnames()):
        bbNums = mytb.getcol("BBC_NO")
    else:
        return -1
    mytb.close()
    return bbNums[spwId]

def getBasebandNumbers(inputMs) :
    """
    Returns the baseband numbers associated with each spw in the specified ms.
    Todd Hunter
    """
    if (os.path.exists(inputMs) == False):
        print "measurement set not found"
        return -1
    mytb = createCasaTool(tbtool)
    mytb.open("%s/SPECTRAL_WINDOW" % inputMs)
    if ("BBC_NO" in mytb.colnames()):
        bbNums = mytb.getcol("BBC_NO")
    else:
        return(-1)
    mytb.close()
    return bbNums

def getFrequencies(inputMs,spwId) :
    """
    Returns the list of channel frequencies in the specified spw in the
    specified ms.
    """
    tb.open("%s/SPECTRAL_WINDOW" % inputMs)
    chanFreq = tb.getcol("CHAN_FREQ",startrow=spwId,nrow=1)
    tb.close()
    return chanFreq
    
def getChanAverSpwIDBaseBand0(inputMs) :
    tb.open("%s/SPECTRAL_WINDOW" % inputMs)
    bbc_no = tb.getcol('BBC_NO')
    ind1 = np.where(bbc_no == 1)[0]
    num_chan = tb.getcol('NUM_CHAN')
    ind2 = np.where(num_chan == 1)[0]
    return np.intersect1d(ind1,ind2)[0]

def getDataDescriptionId(inputMs,spwId) :
    tb.open("%s/DATA_DESCRIPTION" % inputMs)
    spectralWindows = tb.getcol("SPECTRAL_WINDOW_ID")
    tb.close()
    ids = np.where(spectralWindows == spwId)[0]
    return int(ids)

def getSpectralWindowId(inputMs,dataDesId) :
    tb.open("%s/DATA_DESCRIPTION" % inputMs)
    spectralWindows = tb.getcol("SPECTRAL_WINDOW_ID")
    tb.close()
    return spectralWindows[dataDesId]
    
def getFlux(inputMs,spwID=None,jyPerK=33,badAntennas=[],useCorrected=False) :
    if spwID == None :
        spwID = getChanAverSpwIDBaseBand0(inputMs)
    sourceIds,sourceNames = getSourceFieldMapping(inputMs)
    antennas = getAntennaNames(inputMs)
    tsys = Tsys(inputMs,spwID=spwID)
    sourceFlux = {}
    averageFlux = {}
    for i in range(len(badAntennas)) :
        badAntennas[i] = getAntennaIndex(inputMs,badAntennas[i])
    for i in range(len(sourceIds)) :
        fieldId = sourceIds[sourceNames[i]]
        sourceName = sourceNames[i]
        sourceFlux[sourceName] = {}
        averageFlux[sourceName] = {}
        sourceScans = getSourceScans(inputMs,fieldId)
        for k in range(len(sourceScans)/2) :
            tsysScan = sourceScans[2*k]
            sourceScan = sourceScans[2*k+1]
            tsys_ = {}
            sourceFlux[sourceName][sourceScan] = {}
            for j in range(len(antennas)) :
#                print antennas[j]
                tsys_[antennas[j]] = tsys.sysInfo[antennas[j]][tsysScan]['Tsys']['value']
            averageFlux[sourceName][sourceScan] = {'Flux' : np.zeros(tsys_[tsys.sysInfo.keys()[0]].shape)}
            for j in range(len(antennas)) :
                for m in range(len(antennas)) :
                    if j < m :
                        if j in badAntennas or m in badAntennas :
                            continue
                        else :
                            sourceFlux_ = Visibility(inputMs,antenna1=j,antenna2=m,spwID=spwID,field=fieldId,scan=sourceScan,correctedData=useCorrected)
                            flux_  = ((tsys_[antennas[j]]*tsys_[antennas[m]])**0.5)*sourceFlux_.amp.mean(-1)*jyPerK
                            dflux_ = ((tsys_[antennas[j]]*tsys_[antennas[m]])**0.5)*sourceFlux_.amp.std(-1)*jyPerK/sourceFlux_.amp.shape[-1]**0.5
                            baseline = ('%i-%i' % (j,m))
                            sourceFlux[sourceName][sourceScan][baseline] = {'Flux' : flux_, 'Error' : dflux_}
            for j in sourceFlux[sourceName][sourceScan].keys() :
                averageFlux[sourceName][sourceScan]['Flux'] = averageFlux[sourceName][sourceScan]['Flux']+sourceFlux[sourceName][sourceScan][j]['Flux']/len(sourceFlux[sourceName][sourceScan].keys())
    return sourceFlux,tsys,averageFlux


class Tsys(Weather):
    def __init__(self,inputMs,spwID=None,tau=0.05,etaF=0.99,doRefSub=False):
        if spwID == None :
            spwID = getChanAverSpwIDBaseBand0(inputMs)
        Weather.__init__(self,inputMs)
        self.inputMs = inputMs
        self.atm = AtmStates(inputMs)
        self.loads = self.atm.antennaInfo[self.atm.antennaNames[0]].keys()
        self.spwID = spwID
        self.tau = tau
        self.etaF = etaF
        interTab = InterpolateTableTime(self,self.spwID)
        tb.open("%s/SPECTRAL_WINDOW" % inputMs)
        self.freq = tb.getcol("REF_FREQUENCY")[self.spwID]
        tb.close()
        self.specFreq = getFrequencies(inputMs,spwID)
        self.atmRes = {}
        for i in self.atm.antennaNames :
#            print i
            _visVal = Visibility(inputMs,spwID=spwID,antenna1=i,antenna2=i)
            scanNums = np.unique(_visVal.subtable.getcol('SCAN_NUMBER'))
            self.atmRes[i] = {}
            noScan = []
            for m in scanNums :
                self.atmRes[i][m] = {}
                for j in self.loads :
                    stateVal = self.atm.antennaInfo[i][j]['state']
                    self.atmRes[i][m][j] = {}
                    for k in stateVal :
                        try:
                            visVal = Visibility(inputMs,spwID=spwID,antenna1=i,antenna2=i,scan=m,state=k)
                            self.atmRes[i][m][j]['power'] = np.mean(visVal.amp,len(visVal.amp.shape)-1)
                            self.atmRes[i][m][j]['error'] = np.std(visVal.amp,len(visVal.amp.shape)-1)
                            self.atmRes[i][m][j]['time']  = np.mean(visVal.subtable.getcol("TIME"))
                            if j in ["HOT","AMB"] :
                                states = self.atm.antennaInfo[i][j]['state']
                                loadTemps = self.atm.antennaInfo[i][j]['loadTemp']
                                checker = states.index(k)
                                self.atmRes[i][m][j]['loadTemp'] = loadTemps[checker]
                        except:
                            continue
                if self.atmRes[i][m]["AMB"].keys() == [] : noScan.append(m)
            noScan = np.unique(np.array(noScan))
            for m in noScan :
                self.atmRes[i].pop(m)
            counter = 0
            for m in self.atmRes[i].keys() :
                try:
                    if self.atmRes[i][m]['REF'].keys() == [] : self.atmRes[i][m]['REF'] = self.atmRes[i][scanNums[counter-1]]['REF']
                    if self.atmRes[i][m]['HOT'].keys() == [] : self.atmRes[i][m]['HOT'] = self.atmRes[i][scanNums[counter-1]]['HOT']
                    counter+=1
                except:
                    continue
        self.sysInfo = {}
        for i in self.atmRes.keys() :
            self.sysInfo[i] = {}
            for m in self.atmRes[i].keys() :
                print m,i
                self.sysInfo[i][m] = {}
                pHot = self.atmRes[i][m]['HOT']['power']
                eHot = self.atmRes[i][m]['HOT']['error']
                timetHot = self.atmRes[i][m]['HOT']['time']
                tHot = jVal(self.freq,self.atmRes[i][m]['HOT']['loadTemp'])
                pAmb = self.atmRes[i][m]['AMB']['power']
                eAmb = self.atmRes[i][m]['AMB']['error']
                timeAmb = self.atmRes[i][m]['AMB']['time']
                tAmb = jVal(self.freq,self.atmRes[i][m]['AMB']['loadTemp'])
#                print self.atmRes[i][m]['AMB']
                try:
                    pRef = self.atmRes[i][m]['REF']['power']
                    eRef = self.atmRes[i][m]['REF']['error']
                    timeRef = self.atmRes[i][m]['REF']['time']
                except:
                    pRef = np.zeros(self.atmRes[i][m]['AMB']['power'].shape)
                    eRef = pRef
                    timeRf = self.atmRes[i][m]['AMB']['time']
                pSky = self.atmRes[i][m]['SKY']['power']
                eSky = self.atmRes[i][m]['SKY']['error']
                timeSky = self.atmRes[i][m]['SKY']['time']
                tCmb = jVal(self.freq,Tcmb)
                Gain,dGain,Trx,dTrx,Tsky,dTsky,y,dy = calcTrxGain(pHot,pAmb,pSky,tHot,tAmb,pRef,eHot,eAmb,eRef,doRefSub=doRefSub)
                meanTime = (timeAmb+timeSky)/2.0
                interTab.interpolateData(np.array(meanTime),quiet=True)
                tOut = interTab.newData['TEMPERATURE'].mean()
                tAtm = interTab.newData['ATM_TEMP'].mean()
                alph = solveAlpha(tHot,tAmb,tAtm,tOut,etaF)
                tCal,tSys = solveTsys(tAtm,pHot,pAmb,pSky,tCmb,alph,pRef,doRefSub=doRefSub)
                self.sysInfo[i][m]['gain'] = {'value' : Gain, 'error' : dGain}
                self.sysInfo[i][m]['Trx']  = {'value' : Trx, 'error' : dTrx}
                self.sysInfo[i][m]['Tsky'] = {'value' : Tsky, 'error' : dTsky}
                self.sysInfo[i][m]['y']    = {'value' : y, 'error' : dy}
                self.sysInfo[i][m]['Tcal'] = {'value' : tCal, 'error' : 0}
                self.sysInfo[i][m]['Tsys'] = {'value' : tSys, 'error' : 0}
                self.sysInfo[i][m]['Time'] = {'value' : meanTime, 'error' : 0}
#                self.sysInfo[i][m]['Freq'] = {'value' : , 'error' : 0}

def solveTsys(tAtm,pHot,pAmb,pSky,tCmb,alpha,pRef,doRefSub=False) :
    if not doRefSub : pRef = pRef-pRef
    tCal  = tAtm-tCmb
    pLoad = alpha*pHot+(1-alpha)*pAmb
    tSys  = tCal*(pSky-pRef)/(pLoad-pSky)
    return tCal,tSys

def calcTrxGain(pHot,pAmb,pSky,tHot,tAmb,pRef=0,eHot=0,eAmb=0,eSky=0,eRef=0,etHot=0,etAmb=0,Gain=None,dGain=None,Trx=None,dTrx=None,doRefSub=False) :
    if not doRefSub : pRef = pRef-pRef
    if Gain == None  : Gain  = (pHot-pAmb)/(tHot-tAmb)
    if dGain == None : dGain = (((eHot**2.0+eAmb**2.0)/(tHot-tAmb)**2.0)+((pHot-pAmb)**2.0/(tHot-tAmb)**4.0)*(etHot**2.0+etAmb**2.0))**0.5
    if Trx == None   : Trx   = ((pHot-pRef)/Gain)-tHot
    if dTrx == None  : dTrx  = ((eHot/Gain)**2.0+(eRef/Gain)**2.0+((pHot-pRef)*dGain/Gain**2.0)**2.0 + etHot**2.0)**0.5
    Tsky  = tAmb-(pAmb-pSky)/Gain
    dTsky = ((eAmb/Gain)**2.0+(eSky/Gain)**2.0+((pAmb-pSky)*dGain/Gain**2.0)**2.0+etAmb**2.0)**0.5
    y     = (pHot-pRef)/(pAmb-pRef)
    dy    = ((eHot/(pAmb-pRef))**2.0+((pHot-pRef)*eAmb/(pAmb-pRef)**2.0)**2.0+(eRef/(pAmb-pRef)+(pAmb*eRef)/(pAmb-pRef)**2.0)**2.0)**0.5
    return Gain,dGain,Trx,dTrx,Tsky,dTsky,y,dy

def solveAlpha(tHot,tAmb,tAtm,tOut,etaF) :
    return (etaF*tAtm-tAmb+(1-etaF)*tOut)/(tHot-tAmb)

def jVal(freq,temp) :
    import math as m
    x = h*freq/k
    return x*(m.exp(x/temp)-1)**(-1)

def djVal(freq,temp,detemp) :
    x = h*freq*1e9/k
    return abs(x*(m.exp(x/temp)-1)**(-2)*(x*dtemp/temp**2.0)*m.exp(x/temp))

def overlayTsys(vis1,vis2,antenna=0,spw=1,scan=1,pol=0,plotrange=[0,0,0,0],overlayTelcal=True):
    """
    Calls the Atmcal class to overlay a Tsys result from one scan of two different DelayCal
    measurement sets.  It was written to compare TDM and FDM Tsys spectra.
    -Todd Hunter
    """
    a1 = Atmcal(vis1)
    tsys1, freqHz1, trec, tsky, tcal = a1.computeTsys(antenna=antenna, spw=spw, scan=scan, pol=pol)
    a2 = Atmcal(vis2)
    tsys2, freqHz2, trec, tsky, tcal = a2.computeTsys(antenna=antenna, spw=spw, scan=scan, pol=pol)
    pb.clf()
    adesc = pb.subplot(111)
    freqHz1 *= 1e-9
    freqHz2 *= 1e-9
    if (overlayTelcal):
        tsys1_telcal = a1.getTelcalTsys(antenna,spw,scan,pol) 
        tsys2_telcal = a2.getTelcalTsys(antenna,spw,scan,pol) 
        pb.plot(freqHz1, tsys1, 'k-', freqHz2, tsys2, 'k-', lw=3)
        pb.hold(True)
    pb.plot(freqHz1, tsys1, 'r-', freqHz2, tsys2, 'r-')
    
    pb.xlabel('Frequency (GHz)')
    pb.ylabel('Tsys (K)')
    if (plotrange != [0,0,0,0]):
        if (plotrange[0] != 0 or plotrange[1] != 0):
            pb.xlim(plotrange[:2])
        if (plotrange[2] != 0 or plotrange[3] != 0):
            pb.ylim(plotrange[2:])
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')
    antennaName = a1.antennaNames[antenna]
    pb.title('%s / %s  %s  scan=%d  spw=%d  pol=%d' % (vis1,vis2,antennaName, scan, spw, pol), fontsize=10)
    pb.text(0.1,0.95,'Black = TelCal,  Red = au.Atmcal().computeTsys', transform=adesc.transAxes)
    pb.text(84.1, 57, "TDM")
    pb.text(84.1, 71, "FDM")
    pb.draw()
    png = '%s_%s.%s.scan%d.spw%d.pol%d.tsys.png' % (vis1, vis2, antennaName,scan,spw,pol)
    pb.savefig(png)

def repairSidebandRatio(asdm, scan, showplot=False):
    """
    Prepares an ASDM for running offline casapy-telcal's tc_sidebandratio() command
    to regenerate the CalAtmosphere.xml table.  Useful for computing sideband ratios
    if the values in the ASDM are simply the default values, yet sideband_ratio data
    exists in the ASDM. Renames the CalAtmosphere.xml and .bin tables (to *.old), sets the
    number CalAtmosphere rows to zero in the ASDM.xml table, then
    runs tc_sidebandratio on one scan at a time (if the command is available).
    scan: list of scans, e.g. '1,2,3' or [1,2,3]
    -Todd Hunter
    """
    if (type(scan) == str):
        scan = scan.split(',')
    elif (type(scan) == int):
        scan = [scan]
    if (os.path.exists(asdm) == False):
        print "Could not find ASDM"
        return
    f = open(asdm+'/ASDM.xml')
    fc = f.read()
    f.close()
    asdmBlockList = re.findall('<Table>.*?</Table>', fc, re.DOTALL|re.MULTILINE)
    if len(asdmBlockList) == 0:
        print 'Found 0 blocks.'
        return
    for i in range(len(asdmBlockList)):
        if re.search('<Name> *CalAtmosphere *</Name>', asdmBlockList[i]) != None or re.search('<Name> *CalAtmosphere *</Name>', asdmBlockList[i]) != None:
            asdmBlockList1 = re.sub('<NumberRows> *[0-9]+ *</NumberRows>', '<NumberRows> 0 </NumberRows>', asdmBlockList[i])
            fc = re.sub(asdmBlockList[i], asdmBlockList1, fc)

    f = open(asdm+'/ASDM.xml', 'w')
    f.write(fc)
    f.close()
    if (os.path.exists(asdm+'/CalAtmosphere.xml')):
        os.system('mv '+asdm+'/CalAtmosphere.xml '+asdm+'/CalAtmosphere.xml.old')
    if (os.path.exists(asdm+'/CalAtmosphere.bin')):
        os.system('mv '+asdm+'/CalAtmosphere.bin '+asdm+'/CalAtmosphere.bin.old')
    try:
        from tc_sidebandratio_cli import tc_sidebandratio_cli as tc_sidebandratio
        for s in scan:
            print "Running tc_sidebandratio('%s', dataorigin='avercross', calresult='%s', showplot=%s, scans='%s')" % (asdm,asdm,showplot,str(s))
            tc_sidebandratio(asdm, dataorigin='avercross', calresult=asdm, showplot=showplot, scans=str(s))
    except:
        print "Now you can start casapy-telcal and run the following on each sideband_ratio scan:"
        print "tc_sidebandratio('%s', dataorigin='avercross', calresult='%s', showplot=False, scans='')" % (asdm,asdm)
        print "(Note: At present, the scans parameter of tc_sidebandratio only accepts one scan number.)"

def getAtmcalStateIDsFromASDM(asdm):
    """
    Reads the State.xml file of an ASDM and returns a dictionary of the form:
    {'AMBIENT_LOAD': 'State_1', 'HOT_LOAD': 'State_2', 'NONE': 'State_0'}
    -Todd Hunter
    """
    if (os.path.exists(asdm) == False):
        print "Could not find ASDM."
        return
    f = open(asdm + '/State.xml', 'r')
    lines = f.readlines()
    f.close()
    mydict = {}
    for line in lines:
        if (line.find('<stateId>') >= 0):
            stateId = line.split('<stateId>')[1].split('</stateId>')[0]
        if (line.find('<calDeviceName>') >= 0):
            mydict[line.split('<calDeviceName>')[1].split('</calDeviceName>')[0]] = stateId
    return(mydict)
            
def repairAtmcalStateIDs(asdm, dryrun=False):
    """
    Replaces <stateId> entries in the Main.xml file of an ASDM for all the
    AtmCal scans, so that offline casapy-telcal can then be run in order
    to regenerate the SysCal.xml file.  It forces all appearances of
    "State_0" to be "State_X" such that X = the stateId from the State.xml table
    corresponding to load for the subscan number (1=NONE, 2=AMBIENT, 3=HOT for
    a 3-subscan AtmCal, and 1=NONE, 2=NONE, 3=AMBIENT, 4=HOT for a 4-subscan Atmcal.
    asdm: the name of the ASDM
    dryrun: if True, then simply print the scans that would be changed, do not change them
    -Todd Hunter
    """
    if (os.path.exists(asdm) == False):
        print "Could not find ASDM."
        return
    calscans, nsubscans = getScanNumbersFromASDM(asdm,'CALIBRATE_ATMOSPHERE')
    AtmcalStateIds = getAtmcalStateIDsFromASDM(asdm)
    print "AtmcalStateIds = ", AtmcalStateIDs
    f = open(asdm + '/Main.xml', 'r')
    if (not dryrun):
        o = open(asdm + '/Main.xml.new', 'w')
    lines = f.readlines()
    f.close()
    scan = 0
    subscan = 0
    changed = 0
    scansToFix = []
    print "Read %d lines from Main.xml" % (len(lines))
    for line in lines:
        originalLine = line[:]
        if (line.find('<scanNumber>') >= 0):
            scan = int(line.split('>')[1].split('<')[0])
        elif (line.find('<subscanNumber>') >= 0):
            subscan = int(line.split('>')[1].split('<')[0])
        elif (line.find('<stateId>') >= 0):
            if (scan in calscans):
                if (nsubscans[calscans.index(scan)] == 3):
                    if (subscan == 1):
                        for state in range(3):
                            line = line.replace('State_%d'%state,AtmcalStateIds['NONE'])
                    elif (subscan == 2):  
                        for state in range(3):
                            line = line.replace('State_%d'%state,AtmcalStateIds['AMBIENT_LOAD'])
                    elif (subscan == 3):
                        for state in range(3):
                            line = line.replace('State_%d'%state,AtmcalStateIds['HOT_LOAD'])
                else:
                    if (subscan == 1 or subscan == 2):  
                        for state in range(4):
                            line = line.replace('State_%d'%state,AtmcalStateIds['NONE'])
                    elif (subscan == 3):  
                        for state in range(4):
                            line = line.replace('State_%d'%state,AtmcalStateIds['AMBIENT_LOAD'])
                    elif (subscan == 4):
                        for state in range(4):
                            line = line.replace('State_%d'%state,AtmcalStateIds['HOT_LOAD'])
        if (line != originalLine):
            changed += 1
            scansToFix.append(scan)
        if not dryrun:
            o.write(line)
        
    if dryrun:
        if (len(scansToFix) > 0):
            print "Scans that need fixing: ", np.unique(scansToFix)
        else:
            print "No scans need fixing."
    else:
        print "Changed %d lines" % (changed)
        o.close()
        os.rename(asdm + '/Main.xml', asdm + '/Main.xml.old') 
        os.rename(asdm + '/Main.xml.new', asdm + '/Main.xml') 
        
def repairSysCal(asdm, sidebandgainoption='observed', showplot=False, 
                 sidebandgain=-1, water='', tsysmode='ALPHA', verbose=True):
    """
    Prepares an ASDM for running offline casapy-telcal's tc_atmosphere() command
    to regenerate the SysCal.xml table.  It first moves the SysCal.xml table to
    Syscal.xml.old, then sets the number of SysCal rows to zero in the ASDM.xml
    table.  It then tries to run that task if you are running casapy-telcal.
    This task is useful for computing Tsys solutions that are missing in the
    ASDM.  Based on Neil Phillips' posting to PRTSIR-305.  Before running
    tc_atmosphere, it preserves the other .xml files and copies them back to
    avoid issues with flagcmd.
    sidebandgainoption: 'observed' or 'fixed' or 'userdefined'
    sidebandgain: use this for 'userdefined'
    water: PWV (in meters) pass this to tc_atmosphere
    tsysmode: either 'WVR' or 'ALPHA' (default)
    -Todd Hunter
    """
    if (os.path.exists(asdm) == False):
        print "Could not find ASDM"
        return
    f = open(asdm+'/ASDM.xml')
    fc = f.read()
    f.close()
    asdmBlockList = re.findall('<Table>.*?</Table>', fc, re.DOTALL|re.MULTILINE)
    if len(asdmBlockList) == 0:
        print 'Found 0 blocks.'
        return
    for i in range(len(asdmBlockList)):
        if re.search('<Name> *SysCal *</Name>', asdmBlockList[i]) != None or re.search('<Name> *CalAtmosphere *</Name>', asdmBlockList[i]) != None:
            asdmBlockList1 = re.sub('<NumberRows> *[0-9]+ *</NumberRows>', '<NumberRows> 0 </NumberRows>', asdmBlockList[i])
            fc = re.sub(asdmBlockList[i], asdmBlockList1, fc)

    f = open(asdm+'/ASDM.xml', 'w')
    f.write(fc)
    f.close()
    newdir = asdm + '.originalxml'
    print "Creating directory ", newdir
    if (os.path.exists(newdir) == False):
        os.mkdir(newdir)
    print "Copying all .xml files to %s..." % (newdir)
    os.system('cp %s/*.xml %s/' % (asdm, newdir))
    modifiedFiles = ['SysCal.xml','ASDM.xml']
    print "...except ", modifiedFiles
    for mF in modifiedFiles:
        if (os.path.exists(newdir+'/'+mF)):
            os.remove(newdir+'/'+mF)              
    if (os.path.exists(asdm+'/SysCal.xml')):
        os.system('mv '+asdm+'/SysCal.xml '+asdm+'/SysCal.xml.old')
#    print "CASA_TELCAL = ", os.getenv('CASA_TELCAL')
#    tasksum = {}  # needed to prevent exception with execfile
#    execfile(os.getenv('CASA_TELCAL')) # still fails upon tc_atmosphere
    try:
        from tc_atmosphere_cli import tc_atmosphere_cli as tc_atmosphere
        print "Running tc_atmosphere('%s', dataorigin='specauto', calresult='%s', showplot=%s, sidebandgainoption='%s', sidebandgain=%f, water='%s', tsysmode='%s',verbose=%s)" % (asdm,asdm, showplot, sidebandgainoption, sidebandgain, water, tsysmode, verbose)
        tc_atmosphere(asdm, dataorigin='specauto', calresult=asdm, 
                      showplot=showplot, sidebandgainoption=sidebandgainoption,
                      sidebandgain=sidebandgain, water=water,tsysmode=tsysmode,
                      verbose=verbose)
        print "Copying the original .xml files back to the ASDM."
        os.system('cp %s/*.xml %s/' % (newdir,asdm))
        print "Done"
    except:
        print "Now you can start casapy-telcal and run:"
        print "execfile(os.getenv('CASA_TELCAL'))"
        print "tc_atmosphere('%s', dataorigin='specauto', calresult='%s', showplot=False, sidebandgainoption='%s', sidebandgain=%f, water='%s', tsysmode='%s', verbose=%s)" % (asdm,asdm,sidebandgainoption,sidebandgain,water,tsysmode,verbose)

def importandlist(asdmlist, suffix='.listobs', outpath='./', asis='*'):
    """
    Run importasdm (if necessary) followed by listobs on a list of ASDMs
    asdmlist: either a list ['uid1','uid2'] or a wildcard string 'uid*')
    Todd Hunter
    """
    if (type(asdmlist) == str):
        asdmlist = glob.glob(asdmlist)
    vislist = []
    for asdm in asdmlist:
        if (asdm[-1] == '/'): asdm = asdm[:-1]
        if (asdm[-3:] == '.ms' or asdm[-8:] == '.listobs' or
            asdm[-13:] == '.flagversions' or asdm[-8:] == '_cmd.txt'): continue
        if (os.path.exists(asdm+'.ms') == False):
            print "Running importasdm('%s', asis='%s')" % (asdm,asis)
            importasdm(asdm, asis=asis)
        vislist.append(asdm+'.ms')
    listobslist(vislist)
    
def listobslist(vislist, suffix='.listobs', outpath='./'):
    """
    Run listobs on a list of measurement sets
    vislist: either a list ['a.ms','b.ms'] or a wildcard string '*.ms')
    Todd Hunter
    """
    if (type(vislist) == str):
        vislist = glob.glob(vislist)
    for vis in vislist:
        if (os.path.exists(outpath+vis+suffix) == False):
            print "Running listobs('%s', listfile='%s')" % (vis, outpath+vis+suffix)
            listobs(vis,listfile=outpath+vis+suffix)

class CrossScan:
    def __init__(self, vis, intent='CALIBRATE_POINTING#ON_SOURCE'):
        self.vis = vis
        self.myms = createCasaTool(mstool)
        self.myms.open(self.vis)
        self.mymsmd = createCasaTool(msmdtool)
        self.mymsmd.open(self.vis)
        self.scans = self.mymsmd.scansforintent(intent)
        self.spws = self.mymsmd.spwsforintent(intent)
        try:
            self.sqldspws = np.intersect1d(self.mymsmd.almaspws(sqld=True), self.spws)
        except:
            self.sqldspws = np.intersect1d(self.mymsmd.chanavgspws(), self.spws)
        self.mymsmd.close()
        print "Scans for %s = %s" % (intent, self.scans)
        print "Spws for %s = %s" % (intent, self.spws)
        print "SQLDs for %s = %s" % (intent, self.sqldspws)
        self.datadescids = {}
        for spw in self.spws:
            self.datadescids[spw]=spw  # assume this is true for now, use msmd in casa 4.3

    def onMinusOffOverOff(self, antenna, spw, scan, subscan, pol=0, verbose=False):
        includeDate = False
        result = computeDurationOfScan(scan, vis=self.vis, returnSubscanTimes=True, 
                                       verbose=verbose,includeDate=includeDate)
        self.timestamps = {}
        self.timestamps[scan] = result[2]
        print "Found %d subscans" % (len(self.timestamps[scan]))
        self.myms.selectinit(datadescid=self.datadescids[spw])
        self.myms.select({'time':self.timestamps[scan][subscan],
                          'antenna1':antenna, 'antenna2':antenna})
        data0 = self.myms.getdata(['amplitude'])['amplitude']  # keyed by pol: 0, 1
        pb.clf()
        print "shape(self.timestamps[scan][subscan]=%s, shape(data0[pol])=%s" % (np.shape(self.timestamps[scan][subscan]), np.shape(data0[pol]))
        pb.plot(self.timestamps[scan][subscan], data0[pol])
        pb.draw()

def sqldspws(vis):
    """
    Return the SQLD spws for version of casa prior to 26688 which do 
    not have msmd.almaspws().  - Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/SPECTRAL_WINDOW')
    names = mytb.getcol('NAME')
    mytb.close()
    sqld = []
    for i,name in enumerate(names):
        if (name.find('#SQLD')>0):
            sqld.append(i)
    return(sqld)

class SQLD():
    def __init__(self, vis, copy_ms=False, gettmcdb=False, outpath='./', verbose=False, dbm=True):
        """
        vis: the measurement set to operate with
        copy_ms: if set to True, it will first copy vis.ms into vis.sqld in the pwd
                 and then operate on that dataset instead of vis.ms
        gettmcdb: if True, then also get the BB detector values from the TMC DB
        outpath: the path to write the TMC DB data (default = './')
        dbm: if True, convert TMC DB values to dBm;  if False, convert to mW
        """
        if not os.path.exists(vis):
            print "Could not find measurement set."
            return
        if not os.path.exists(vis+'/table.dat'):
            print "This does not appear to be a measurement set."
            return
        if copy_ms:
            basename = vis.rstrip('.ms')
            newname = os.path.basename(basename)
            if (os.path.exists(newname+'.sqld')):
                print "Removing existing .sqld directory"
                shutil.rmtree(newname+'.sqld')
            cmd = 'rsync -au %s/ %s.sqld' % (vis, newname)
            print "Running: %s" % (cmd)
            os.system(cmd)
            vis = newname + '.sqld'
            print "Setting vis=%s" % (vis)
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        self.vis = vis

        if (casadef.subversion_revision < casaRevisionWithAlmaspws):
            self.sqldspws = sqldspws(self.vis)
        else:
            self.sqldspws = mymsmd.almaspws(sqld=True)
        if (casadef.subversion_revision >= '27137'):
            self.antennaNames = mymsmd.antennanames() 
        else:
            self.antennaNames = getAntennaNames(self.vis)
        self.intents = mymsmd.intents()
        if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in self.intents):
            self.atmcalscans = []
        else:
            self.atmcalscans = mymsmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
        if ('OBSERVE_TARGET#ON_SOURCE' not in self.intents):
            self.observeTargetScans = []
        else:
            self.observeTargetScans = mymsmd.scansforintent('OBSERVE_TARGET#ON_SOURCE')
        if (len(self.sqldspws) == 0):
            print "There are no SQLD spws in this dataset."
            if (not gettmcdb):
                gettmcdb = True
                print "Setting gettmcdb to True"
        self.datadescIDs = {}
        self.basebands = {}
        self.pols = [0,1]  # call findNumberOfPolarizations
        self.date = getObservationStartDate(self.vis).split()[0]  # YYYY-MM-DD
        self.yyyymmdd = self.date
        if (self.yyyymmdd < '2013-05-29' and gettmcdb):
            gettmcdb = False
            print "These data are too old to have BB detector values stored in the TMCDB."
        self.yyyymmdd2 = getObservationStopDate(self.vis).split()[0]
        if (self.yyyymmdd != self.yyyymmdd2):
            print "WARNING: This dataset spans two UT days, which is not yet fully supported."
        self.IFProc = {}
        self.startTime = np.min(mymsmd.timesforscan(mymsmd.scannumbers()[0]))
        self.endTime =   np.max(mymsmd.timesforscan(mymsmd.scannumbers()[-1]))
        self.scanTimes = {}
        self.intents = {}
        for scan in mymsmd.scannumbers():
            self.scanTimes[scan] = [np.min(mymsmd.timesforscan(scan)),
                                    np.mean(mymsmd.timesforscan(scan)),
                                    np.max(mymsmd.timesforscan(scan))]
            self.intents[scan] = mymsmd.intentsforscan(scan)
        for spw in self.sqldspws:
            try:
                self.datadescIDs[spw] = mymsmd.datadescids(spw)
            except:
                self.datadescIDs[spw] = spw
            self.basebands[spw] = mymsmd.baseband(spw)
        self.sqldData = {}
        self.sqldDataDBm = {}
        self.sqldDataUTC = {}
        self.dbm = dbm
        if (gettmcdb):
            print "Retrieving the periodic measurements from TMCDB."
            self.getTMCDBData(outpath=outpath, verbose=verbose)
        mymsmd.close()

    def plotTMCDB(self, antenna='', pol='', basebands='', wholeDay=False, 
                  labelscans=True, labelintents=True, plotfile=True, yrange=[0,5],
                  verbose=False, markdbm=[+2.4,+3.8], timeBuffer=40):
        """
        antenna: integer, string, or list of antenna IDs or names
        pol: 0, 1 or [0,1] (default)
        basebands: string or list of basebands numbers to plot (1..4)
        wholeDay: if True, plot the whole day of data, not just during the dataset
        labelscans: if True, demarcate and label the scan numbers
        labelintents: if True, label ATM, POI, SID, OBS intent scans
        plotfile: path and name of png to produce, or True for automatic
        yrange: the y-axis plotrange: [y0,y1]
        markdbm: draw a horizontal line at the specified level(s), set to None for none
        timeBuffer: value in seconds to widen the beginning and end of the dataset
        """
        if (pol==''):
            polList = [0,1]
        antennaList = parseAntenna(self.vis, antenna)
        pb.clf()
        pb.hold(True)
        if (basebands == ''):
            basebands = self.sqldDataDBm[self.antennaNames[antennaList[0]]][polList[0]].keys()
        else:
            basebands = parseBasebandArgument(basebands)
        linestyles = ['.-','.--']
        for baseband in basebands:
            if (len(basebands) == 1):
                desc = pb.subplot(1,1,1)
                nplots = 1
                nrows = 1
                column = 1
                row = 1
            else:
                desc = pb.subplot(2,2,baseband)
                nplots = 4
                nrows = 2
                if (baseband % 2 == 1):
                    column = 1
                else:
                    column = 2
                if (baseband < 3):
                    row = 1
                else:
                    row = 2
            pb.title('Baseband %d' % (baseband))
            for antennaID in antennaList:
                antenna = self.antennaNames[antennaID]
                if (verbose): print "Working on antenna %s baseband %d" % (antenna, baseband)
                for pol in polList:
                    if (wholeDay):
                        timeStamps = pb.date2num(mjdSecondsListToDateTime(list(self.sqldDataUTC[antenna][pol])))
                        day = mjdsecToUT(self.sqldDataUTC[antenna][pol][0]).split()[0]
                        pb.plot_date(timeStamps, self.sqldDataDBm[antenna][pol][baseband], linestyles[pol], color=overlayColors[antennaID])
                        setXaxisTimeTicks(desc, np.min(self.sqldDataUTC[antenna][pol]),
                                          np.max(self.sqldDataUTC[antenna][pol]))
                    else:
                        idx1 = np.where(self.sqldDataUTC[antenna][pol] >= self.startTime-timeBuffer)[0]
                        idx2 = np.where(self.sqldDataUTC[antenna][pol] <= self.endTime+timeBuffer)[0]
                        idx = np.intersect1d(idx1,idx2)
                        timeStamps = pb.date2num(mjdSecondsListToDateTime(list(np.array(self.sqldDataUTC[antenna][pol])[idx])))
                        day = mjdsecToUT(self.sqldDataUTC[antenna][pol][idx[0]]).split()[0]
                        pb.plot_date(timeStamps, self.sqldDataDBm[antenna][pol][baseband][idx], 
                                     linestyles[pol], color=overlayColors[antennaID])
                        setXaxisTimeTicks(desc, self.startTime, self.endTime, verbose=False)
                if (nplots==1 or baseband==2):
                    pb.text(1.02,1.04-antennaID*0.025*nrows, antenna, size=9,
                            transform=desc.transAxes,color=overlayColors[antennaID])
                    pb.text(0.5, 1.08, os.path.basename(self.vis))
            if (column == 1):
                if (self.dbm):
                    pb.ylabel('Power (dBm)')
                else:
                    pb.ylabel('Power (mW)')
                if (row == 2):
                    pb.xlabel(os.path.basename(self.vis))
            if (yrange != [0,0]):
                pb.ylim(yrange)
            if (labelscans):
                y0 = pb.ylim()[1]-(pb.ylim()[1]-pb.ylim()[0])*0.04*nrows
                for scan in self.scanTimes.keys():
                    myTimes = pb.date2num(mjdSecondsListToDateTime([self.scanTimes[scan][0],self.scanTimes[scan][0]]))
                    pb.plot(myTimes, pb.ylim(), ':', color='k')
                    if (scan == self.scanTimes.keys()[-1]):
                        myTimes = pb.date2num(mjdSecondsListToDateTime([self.scanTimes[scan][2],self.scanTimes[scan][2]]))
                        pb.plot(myTimes, pb.ylim(), ':', color='k')

                    pb.text(mjdSecondsListToDateTime([self.scanTimes[scan][1]])[0], y0, str(scan), size=8)
                pb.xlim(pb.date2num(mjdSecondsListToDateTime([self.startTime-timeBuffer, self.endTime+timeBuffer])))
            if (yrange != [0,0]):
                pb.ylim(yrange)
            if (labelintents):
                for scan in self.scanTimes.keys():
                    for intent in ['ATM','SIDEBAND','POINTING','OBSERVE','AMPLI','FLUX','BANDPASS']:
                        y0 = pb.ylim()[1]-(pb.ylim()[1]-pb.ylim()[0])*0.11*nrows
                        if (','.join(self.intents[scan]).find(intent) > 0):
                            pb.text(mjdSecondsListToDateTime([self.scanTimes[scan][1]])[0], y0, intent[:5], size=7, rotation='vertical', ha='left', va='bottom')
                            break  # be sure only one intent is written per scan
            if (self.dbm):
                if (markdbm != None and markdbm != []):
                    if (type(markdbm) != list):
                        markdbm = [markdbm]
                    for mrk in markdbm:
                        pb.plot(pb.xlim(), [mrk,mrk], 'k:')
            else:
                if (markdbm != None and markdbm != []):
                    if (type(markdbm) != list):
                        markdbm = [markdbm]
                    for mrk in markdbm:
                        pb.plot(pb.xlim(), [10**(mrk*0.1),10**(mrk*0.1)], 'k:')
            if (nrows == 2):
                pb.setp(desc.get_xticklabels(), fontsize=8)
                pb.setp(desc.get_yticklabels(), fontsize=8)
            if (yrange != [0,0]):
                pb.ylim(yrange)
        pb.xlabel('Time (UT on %s)'%(day))        
        yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
        desc.yaxis.set_major_formatter(yFormat)
        pb.draw()
        if (plotfile != ''):
            if (plotfile == True):
                if (self.dbm):
                    plotfile = self.vis.replace('.sqld','') + '.sqld.dBm.png'
                else:
                    plotfile = self.vis.replace('.sqld','') + '.sqld.mW.png'
            dirname = os.path.dirname(plotfile)
            if (dirname == ''):
                dirname = './'
            if (os.access(dirname,os.W_OK) == False):
                plotfile = '/tmp/' + os.path.basename(plotfile)
            pb.savefig(plotfile)
            print "Plot left in: ", plotfile

    def convertTMCDBtoPower(self, calibration='auto', verbose=False):
        """
        convert self.sqldData from voltage to dBm
        into self.sqldDataDBm.  The structure of sqldDataDBm is:
        [antenna][pol][baseband: 'A','B','C','D'][list of voltages vs. time]
        """
        query = False
        basebands = [0, 'A','B','C','D']
        if (self.IFProc == {}):  # contains the calibration coefficients
            query = True
        else:
            for antenna in self.antennaNames:
                if (antenna not in self.IFProc.keys()):
                    query = True
        if (query):
            for i,antenna in enumerate(self.antennaNames):
                if (antenna not in self.IFProc.keys()):
                    if (antenna not in self.sqldDataDBm.keys()):
                        self.sqldDataDBm[antenna] = {}
                        self.sqldDataUTC[antenna] = {}
                    self.IFProc[antenna] = self.readSQLDCalibration(antenna, calibration)
                    if (verbose):
                        print "Antenna %2d = %s: " % (i,antenna), self.IFProc[antenna]
                    for pol in self.pols:
                        self.sqldDataUTC[antenna][pol] = self.sqldData[antenna][pol][0]
                        self.sqldDataDBm[antenna][pol] = {}
                        for channel, baseband in enumerate(np.unique(self.basebands.values())):  # need unique in case multiple groups of 4 SQLD spws
                            basebandLetter = basebands[baseband]
                            inputPowerAtZeroVoltage = self.IFProc[antenna][pol][basebandLetter]['icept']
                            # Scale by the gain slope, then add the offset
#                            print "shape(sqldData) = ", np.shape(self.sqldData[antenna][pol][1])
#                            print "len(shape(sqldData)) = ", len(np.shape(self.sqldData[antenna][pol][1]))
                            if (len(np.shape(self.sqldData[antenna][pol][1])) < 2):
                                print "There is a problem with the TMCDB data for %s pol %d (probably missing)" % (antenna,pol)
                                break
                            else:
                                voltages = np.transpose(np.array(self.sqldData[antenna][pol][1]))
                                self.sqldDataDBm[antenna][pol][baseband] = voltages[channel]*self.IFProc[antenna][pol][basebandLetter]['slope']+self.IFProc[antenna][pol][basebandLetter]['icept']
                                if (self.dbm):
                                    self.sqldDataDBm[antenna][pol][baseband] = 10*np.log10(self.sqldDataDBm[antenna][pol][baseband])
        return
        
    def getTMCDBData(self, outpath='./', verbose=False):
        monitorPoint = 'DATA_MONITOR_2'  # BB SQLDs  (_1=SB SQLDs)
        self.sqldData = {}
        for antenna in self.antennaNames:
            self.sqldData[antenna] = {}
            for pol in self.pols:  
                # need to get file for second date if necessary
                localfile = tmu.retrieve_daily_tmc_data_file_name_only(antenna,'IFProc'+str(pol), monitorPoint, self.yyyymmdd, outpath=outpath)
                if (os.path.exists(localfile)):
                    tmcfile_ifproc = localfile
                else:
                    try:
                        mydict=tmu.get_tmc_data(antenna,'IFProc'+str(pol),monitorPoint, self.yyyymmdd, self.yyyymmdd, outpath=outpath)
                        tmcfile_ifproc = mydict['files'][0]
                        self.tmcfile_ifproc = tmcfile_ifproc
                    except:
                        print "Failed to retrieve data for antenna %s" % (antenna)
                        continue
                self.sqldData[antenna][pol] = self.readIFProcBBSQLDs(tmcfile_ifproc, pol)
        self.convertTMCDBtoPower(verbose=verbose)
        return

    def readIFProcBBSQLDs(self, tmcfile, pol=0):
        """
        Returns 2 lists: dateTimeStamp in MJD second, and SQLD readings
        """
        loc = tmcfile.find('IFProc')+6
        if (loc > 0):
            tmcfile = tmcfile[:loc] + str(pol) + tmcfile[loc+1:]
            print "Using existing file = ", tmcfile
        if (os.path.exists(tmcfile) == False):
            print "Could not open IF Proc TMC database file"
            return
        tmclines = open(tmcfile,'r').readlines()
        dateTimeStamp = []
        voltages = []
        for line in tmclines:
            tokens = line.split()
            if (len(tokens) == 0):
                print "len(tokens) = %d" % (len(tokens))
            dateTimeStamp.append(dateStringToMJDSec(tokens[0],verbose=False))
            voltages.append([float(x) for x in tokens[1:]])
        return(dateTimeStamp, voltages)

    def convertSQLDtodBm(self, antenna='', calibration='auto', spw='',
                         zeroLevel=-20, verbose=False):
        """
        Converts the amplitude data in the SQLD spws of an ALMA measurement set
        from counts to dBm.
        Inputs:
        * vis: the measurement set
        Optional inputs:
        * calibration: a text file that contains the slope and intercept values
                 for each of the IF channels (A,B,C,D for each sideband)
        * antenna: the list of antenna names or IDs to convert
        * spw: the list of spws to convert (default is all SQLD spws)
        * zeroLevel: what value (in dBm) to assign to data points with 0 counts
        Theory:
        a) convert from counts to mV using (counts/65536)*2.5
        b) apply the slope and intercept to convert to mW
        d) convert from mW to dBm by 10*log10(mW)
        -Todd Hunter
        """
        if (len(self.sqldspws) == 0):
            print "There are no SQLD spws in this dataset!"
            return
        antennaList = parseAntenna(self.vis, antenna)
        query = False
        if (self.IFProc == {}):
            query = True
        else:
            for antenna in antennaList:
                if (antenna not in self.IFProc.keys()):
                    query = True
        if (query):
            for antenna in antennaList:
                if (antenna not in self.IFProc.keys()):
                    self.IFProc[antenna] = self.readSQLDCalibration(self.antennaNames[antenna], calibration)
                    print "Antenna %2d = %s: " % (antenna,self.antennaNames[antenna]), self.IFProc[antenna]
        basebands = [0, 'A','B','C','D']
        channel = 0
        if (spw == ''):
            spws = self.sqldspws
        else:
            spws = [int(x) for x in spw.split(',')]
        dataColumnName = getDataColumnName(self.vis)
        myt = createCasaTool(tbtool)
        myt.open(self.vis, nomodify=False)
        history = []
        for spw in spws:
            for antenna in antennaList:
                ddid = self.datadescIDs[spw]
                print "Working on spw %d (DD=%d), antenna %d (%s)" % (spw, ddid, antenna, self.antennaNames[antenna])
                mytb = myt.query('DATA_DESC_ID==%d and ANTENNA1==%d and ANTENNA2==%d' % (ddid,antenna,antenna))
                complexData = mytb.getcol(dataColumnName)
                baseband = basebands[self.basebands[spw]]
                for pol in range(len(complexData)):
                    if (verbose):
                        print "min/max of spw=%d, pol=%d is %f/%f" % (spw,pol,np.min(np.real(complexData[pol][channel])), np.max(np.real(complexData[pol][channel])))
                        print "complexData[pol][channel] = ", str(complexData[pol][channel])
                    inputPowerAtZeroVoltage = self.IFProc[antenna][pol][baseband]['icept']
                    # Scale by the gain slope, then add the offset
                    arg = (complexData[pol][channel]*2.5/65536.)*self.IFProc[antenna][pol][baseband]['slope']+self.IFProc[antenna][pol][baseband]['icept']
                    if verbose:
                        print "    inputPowerAtZeroVoltage level = %f mW" % (inputPowerAtZeroVoltage)
                        if (len(np.where(np.real(arg)<=inputPowerAtZeroVoltage)[0]) > 0):
                            print "Replacing %d/%d zero values in pol 0 with -20dBm" % (len(np.where(np.real(arg)<=inputPowerAtZeroVoltage)[0]),len(arg))
                    if (self.dbm):
                        if (dataColumnName == 'DATA'):
                            arg[np.where(np.real(arg) <= inputPowerAtZeroVoltage)[0]] = np.complex(10**(zeroLevel*0.1),0)  # i.e. convert -20 to 1e-2
                        else: # FLOAT_DATA
                            arg[np.where(np.real(arg) <= inputPowerAtZeroVoltage)[0]] = 10**(zeroLevel*0.1)
                        complexData[pol][channel] = 10*np.log10(arg)
                    else:
                        complexData[pol][channel] = arg
                        
                    if (verbose):
                        print "    after scaling, min/max is %f/%f" % (np.nanmin(np.real(complexData[pol][channel])), 
                                                                       np.nanmax(np.real(complexData[pol][channel])))
                mytb.putcol(dataColumnName,complexData)
                mytb.close()
                history.append('Scaled antenna %2d SQLD spw %2d data into dBm' % (antenna,spw))
        myt.close()
        myms = createCasaTool(mstool)
        myms.open(self.vis, nomodify=False)
        for h in history:
            myms.writehistory(h)
        myms.listhistory()
        myms.close()

    def plotms(self, antenna='*&&&', scan='', spw='', coloraxis='spw',
               correlation='XX', iteraxis='antenna', avgtime='1s',
               plotrange=[0,0,0,0], intent='OBSERVE_TARGET',
               plotfile='', buildpdf=False, overwrite=True):
        """
        Runs plotms on a measurement set with useful parameters
        scan: if '', then plot all scans with specified intent(s)
        spw: if '', then find all SQLD spws
        intent: a list of intents, as a comma-delimited string
        buildpdf: if True, build a PDF of all antennas, one per page
                  if False, use iteraxis='antenna'
        """
        if (scan == '' and intent != ''):
            targetscans = []
            if (intent.find('OBSERVE_TARGET')>=0):
                scan = ','.join([str(i) for i in self.observeTargetScans])
                targetscans = scan
            if (intent.find('CALIBRATE_ATMOSPHERE')>=0):
                scan = ','.join(targetscans+[str(i) for i in self.atmcalscans])
                    
        if (spw == ''):
            spw = ','.join([str(i) for i in self.sqldspws])
        if (buildpdf == False):
            showgui = True
            if (antenna.find('&&&') < 0):
                antenna += '&&&'
            print "Running plotms('%s', antenna='%s', coloraxis='%s', yaxis='real', xaxis='time', correlation='%s', ylabel='Power', spw='%s', scan='%s', iteraxis='%s', avgtime='%s', plotrange=%s, plotfile='%s', overwrite=%s, showgui=%s)" % (self.vis,antenna,coloraxis,correlation,spw,scan,iteraxis,avgtime,str(plotrange),plotfile,str(overwrite),showgui)
            plotms(self.vis, antenna=antenna, coloraxis=coloraxis, yaxis='real',
                   xaxis='time',correlation=correlation,ylabel='Power',
                   spw=spw, scan=scan, iteraxis=iteraxis, avgtime=avgtime, showgui=showgui,
                   plotrange=plotrange, plotfile=plotfile, overwrite=overwrite)
        else:
            plotfiles = []
            showgui = False
            for antname in self.antennaNames:
                plotfile = self.vis + '.' + antname + '.png'
                ant = antname + '&&&'
                mytitle = os.path.basename(self.vis) + ' ' + antname + ' ' + correlation + ' Power vs. time'
                print "Running plotms('%s', antenna='%s', coloraxis='%s', yaxis='real', xaxis='time', correlation='%s', ylabel='Power (dBm)', spw='%s', scan='%s', avgtime='%s', plotrange=%s, plotfile='%s', showgui=%s, overwrite=%s, title='%s')" % (self.vis,ant,coloraxis,correlation,spw,scan,avgtime,str(plotrange),plotfile,showgui,str(overwrite),mytitle)
                plotms(self.vis, antenna=ant, coloraxis=coloraxis, yaxis='real',
                       xaxis='time',correlation=correlation,ylabel='Power (dBm)',
                       spw=spw, scan=scan, avgtime=avgtime, title=mytitle,
                       plotrange=plotrange, plotfile=plotfile, showgui=showgui,
                       overwrite=overwrite)
                plotfiles.append(plotfile)
            pdfname = self.vis + '.pdf'
            buildPdfFromPngs(plotfiles, pdfname=pdfname)
            
    def readSQLDCalibration(self, antenna, calibration='auto',overwrite=False,verbose=False):
        """
        Reads the gains (slope and intercept) of the SQLDs from a
        container log text file.
        calibration: if 'auto', then retrieve the files from the computing web server
                     if '', then use the default values for DA64 on April 1, 2014
                     if a filename, then search for values in it
        overwrite: if False (default), then check if the files have already
                   been retrieved in the current working directory
                   if True, then re-retrieve them
        -Todd Hunter
        """
        if (calibration == 'auto'):
            cal = open(compUtils.retrieve_abm_container_data_files(antenna, self.date, overwrite, verbose=False), 'r')
            lines = cal.readlines()
            cal.close()
        else:
            if not os.path.exists(calibration):
                print "Could not find calibration table. Using defaults."
                calibration = ''
            if (calibration==''):
                lines = ['2014-03-31T22:40:08.142   IFProc0:\n',
                     '<DET ch="A" slope="1.645000" icept="-0.140000"/>\n',
                     '<DET ch="B" slope="1.585000" icept="-0.122000"/>\n',
                     '<DET ch="C" slope="1.515000" icept="-0.099200"/>\n',
                     '<DET ch="D" slope="1.490000" icept="-0.122000"/> \n',
                     '2014-03-31T22:40:33.310   IFProc1:\n',
                     '<DET ch="USB" slope="0.004900" icept="-0.000440"/>\n',
                     '<DET ch="LSB" slope="0.005900" icept="-0.000585"/>\n',
                     '<DET ch="A" slope="1.595000" icept="-0.140000"/>\n',
                     '<DET ch="B" slope="1.555000" icept="-0.113000"/>\n',
                     '<DET ch="C" slope="1.460000" icept="-0.115000"/>\n',
                     '<DET ch="D" slope="1.560000" icept="-0.118000"/>\n']
            else:
                cal = open(calibration,"r")
                lines = cal.readlines()
                cal.close()
        processor = -1
        IFProc = {}
        for line in lines:
            if (line.find('IFProc0') >= 0):
                processor = 0
            if (line.find('IFProc1') >= 0):
                processor = 1
            if (processor >= 0):
                if (line.find('DET ch=') >= 0 and line.find('SB') < 0):
                    a,b,c,d = line.split()
                    if (processor not in IFProc.keys()):
                        IFProc[processor] = {}
                    if (b[4] not in IFProc[processor].keys()):
                        IFProc[processor][b[4]] = {}
                    IFProc[processor][b[4]]['slope'] = float(c.split('"')[1])
                    IFProc[processor][b[4]]['icept'] = float(d.split('"')[1])
        return(IFProc)
    
class Atmcal:
    """
    This class examines the CAL_ATMOSPHERE scans in a measurement set and
    determines the time ranges associated with the sky, ambient and hot load
    in each scan based on the data itself, and checks it for sanity against
    the subscan order specified in the STATE table.  It also has methods to
    independently compute and/or plot the Trx and Tsys, with an option to
    overlay the TelCal result.  It can also compute and apply the FDM 
    quantization correction.
    -Todd Hunter
    """
    def __init__(self,vis,verbose=False,showSummary=False,readAttenuatorSettings=False,
                 decimalDigits=2, includeDate=False, restoreBackup=False, outpath='./',
                 includeSQLD=False, maxscans=0):
        self.vis = vis
        self.visBasename = os.path.basename(vis)
        # Remove the following line once everything works well in fixSyscalTable.
        if (os.path.exists(self.vis+'/SYSCAL.backup') and restoreBackup):
            print "Copying the SYSCAL backup  into place"
            os.system('rm -rf %s' % (self.vis+'/SYSCAL'))
            os.system('rsync -vau %s %s' % (self.vis+'/SYSCAL.backup/', self.vis+'/SYSCAL'))

        startTime = timeUtilities.time()
        if (outpath == ''): outpath = './'
        if (outpath[-1] != '/'): outpath += '/'
        self.sidebands = [1,2]
        self.polarizations = [0,1]
        self.verbose = verbose
        if (os.path.exists(vis) == False):
            print "Cannot find this measurement set."
            return
        if (os.path.exists(vis+'/table.dat') == False):
            print "No table.dat.  This does not appear to be an ms."
            return
        print "Dataset begins at %s. Analyzing the ATM cals may take a few minutes..." % (mjdsecToUT(getObservationStart(self.vis)))
        if (verbose): print "Reading the STATE table"
        self.readStateTable()
        if (verbose): print "Finding the cal scans"
        self.findCalScans(includeDate,includeSQLD,maxscans)
        if (verbose): print "Distinguishing the load data"
        self.distinguishLoadData(verbose)
        if (verbose): print "Finding scans in the SYSCAL table"
        self.findSyscalScans(maxscans)
        if (showSummary): self.printCalScans(decimalDigits, includeDate)
        self.initializeAttenuatorDictionaries()
        if (readAttenuatorSettings):
            if (verbose): print "Reading the attenuator settings"
            if (self.readAttenuatorSettings(outpath=outpath) == False):
                print "Stopping"
                return
        else:
            if (verbose): print "Not reading the attenuator settings (to do this: set readAttenuatorSettings=True)"
        stopTime = timeUtilities.time()
        print "Initialization completed in %.0f seconds" % (stopTime-startTime)

    # The following six functions are from R. Amestica (Nov 2013)
    def afun(self, sigma1, sigma2):
        """
        Compute 'a' parameter as defined in memo 583, section 7.3. Input values must be 
        3 bits sigma levels.
        """
        s1 = 0.
        s2 = 0.
        for i in range(1, 4):
            s1 += exp(- (i ** 2) / (2 * double(sigma1) ** 2))
            s2 += exp(- (i ** 2) / (2 * double(sigma2) ** 2))
        return (pi * sigma1 * sigma2) / (2 * (1. + 2 * s1) * (1. + 2 * s2))
    
    def bfun(self, sigma1, sigma2):
        """
        Compute 'b' parameter as defined in memo 583, section 7.3. Input values must be 3 bits sigma levels.
        """ 
        return self.afun(sigma1, sigma2) * self.R0(sqrt(sigma1 * sigma2), 8) - sigma1 * sigma2
    
    def STAR2(self, x):
        """
        Just a helper artifact.
        """
        return x * x
    
    def sign(self, a, b):
        """
        Just a helper artifact.
        """
        if b < 0.0:
            return -fabs(a)
        return fabs(a)
    
    def R0(self, sigma, n):
        """
        Equation 4 in memo 583.
        """
    
        ret = 0.
        for k in range(1, n / 2 - 1 + 1):
            ret += k * erf(k / (sqrt(2) * sigma))
        return (n - 1) ** 2 - 8. * ret 
    
    def sigma(self, zerolag, n):
        """
        Inverse of equation 4 in memo 583.
        """
        x = 0.0
        SQRT_05_PI = sqrt(2.0 / pi)
        M_SQRT2 = sqrt(2.0)
        if n % 2 == 0:
            x = 1.
        itmax = 30
        tol = 1.0e-8
        for i in range(itmax):
            f = zerolag
            fp = 0.0
            if n % 2 == 1:
                for k in range((n - 1) / 2):
                    kd = double(k + 1)
                    f = f - (2.0 * kd - 1.0) * erfc((2.0 * kd - 1.0) * x / M_SQRT2)
                    fp = fp + SQRT_05_PI * self.STAR2(2.0 * kd - 1.0) * exp(-0.5 * self.STAR2((2.0 * kd - 1.0) * x));
            else:
                f = f - double(1)
                for k in range((n - 1) / 2):
                    kd = double(k + 1)
                    f = f - 8 * kd * erfc(kd * x / M_SQRT2);
                    fp = fp + 8.0 * self.STAR2(kd) * SQRT_05_PI * exp(-0.5 * self.STAR2(kd * x));
            deltax = -f / fp
            deltax = self.sign(1.0, deltax) * fmin(0.5, fabs(deltax));
            x += deltax;
            if n % 2 == 1:
                x = fmax(0, x);
            if fabs(deltax / x) < tol:
                break
        return 1. / x;
    # The preceeding six functions are from R. Amestica (Nov 2013)

    def correctVisibilities(self, fdmscan, tdmscan=None, tdm=None, dataFraction=[0.0,1.0], 
                            ignoreFlags=False, useGetSpectrum=True):
        """
        Corrects cross-correlation FDM data for quantization on the basis of TDM 
        auto-correlation on the two antennas.
        fdmscan: the scan number to correct in the current Atmcal instance
        tdmscan: the scan number to use as the total power (default=same as fdmscan, but
                     in different measurement set)
        tdm: the name of the measurement set to get the TDM data from, or the Atmcal
               instance created from this different measurement set
        dataFraction: the portion of the subscan to use
        ignoreFlags: set to True to ignore the flag column
        useGetSpectrum: set to False to use Visibility class to get TDM data
        """
        warnings.simplefilter("ignore", np.ComplexWarning)
        if (tdm == None):
            tdm = self  # the TDM data are in the same MS as the FDM data
        else:
            # the TDM data are in a different MS from the FDM data
            if (type(tdm) == str):
                # the name of the TDM measurement set was passed as 'tdm'
                tdm = Atmcal(tdm)
        tdmv = Visibility(tdm.vis)
        fdmv = Visibility(self.vis)
        fdmv.autoSubtableQuery = False
        if (tdmscan == None): tdmscan = fdmscan
        print "tdm.spwsforscan_nonchanavg = ", tdm.spwsforscan_nonchanavg
        if (tdmscan not in tdm.spwsforscan_nonchanavg):
            print "tdmscan=%d is not an Atmcal scan" % (tdmscan)
            return
        tdmspws = tdm.spwsforscan_nonchanavg[tdmscan]
        if (fdmscan not in self.spwsforallscans_nonchanavg):
            print "fdmscan=%d is not an Atmcal scan" % (fdmscan)
        fdmspws = self.spwsforallscans_nonchanavg[fdmscan]
        nBaselines = len(self.antennas)*(len(self.antennas)-1)/2
        for spw in range(len(tdmspws)):
            baseline = 0
            for ant1 in self.antennas[:-1]:
                for ant2 in range(ant1+1, len(self.antennas)):
                    baseline += 1
                    print "Applying TDM spw %d to FDM spw %d for baseline %02d-%02d (%d/%d)" % (tdmspws[spw], fdmspws[spw], ant1, ant2, baseline, nBaselines)
                    tdm1spectrum = []
                    for pol in range(2):
                        if (useGetSpectrum):
                            tdm1spectrum.append(tdm.getSpectrum(tdmscan,tdmspws[spw],pol,'sky',ant1,dataFraction,ignoreFlags=ignoreFlags))
                        else:
                            tdmv.setAntennaPair(ant1,ant1)
                            tdmv.setSpwID(tdmspws[spw])
                            tdmv.setScan(tdmscan)
                            tdm1spectrum.append(np.mean(np.abs(tdmv.specData)[pol],axis=1))
                    tdm2spectrum = []
                    for pol in range(2):
                        if (useGetSpectrum):
                            tdm2spectrum.append(tdm.getSpectrum(tdmscan,tdmspws[spw],pol,'sky',ant2,dataFraction,ignoreFlags=ignoreFlags))
                        else:
                            tdmv.setAntennaPair(ant2,ant2)
                            tdm2spectrum.append(np.mean(np.abs(tdmv.specData)[pol],axis=1))
                    fdmv.setAntennaPair(ant1,ant2)
                    fdmv.setSpwID(fdmspws[spw])
                    fdmv.setScan(fdmscan)
                    fdmv.makeSubtableQuery()
                    fdmv.makeSubtableForWriting()
                    fdmv.getSpectralData()
                    fdmSpectra = fdmv.specData

                    # need to get individual integrations, not the average, so cannot use getSpectrum
                    nSpectra = len(fdmSpectra[0][0])
#                    print "Got %d spectra, shape = %s" % (nSpectra, np.shape(fdmv.specData))
                    npol = len(fdmv.specData)
                    for i in np.arange(nSpectra):
                        fdmSpectra = []
                        for pol in range(npol):
                            fdmSpectra.append([])
                            fdmSpectrum = fdmv.specData[pol][:][i]
                            fdmSpectra[pol] = self.applyCorrectionToFDMSpectrum(fdmSpectrum, tdm1spectrum[pol],
                                                                                tdm2spectrum[pol])
                        fdmv.putSpectralData(fdmSpectra, i)
        fdmv.subtable.close()
        fdmv.mytb.close() # write out the changes

    def applyCorrectionToFDMSpectrum(self, spectrum, TDM_X, TDM_Y, useZeroLagsBinaryAttachment=False):
        """
        spectrum: the spectrum to be corrected
        TDM_X: TDM spectrum for antenna X
        TDM_Y: TDM spectrum for antenna Y
        """
#        print "applyCorrectionToFDMSpectrum(): np.shape(spectrum) = ", np.shape(spectrum)
        if (useZeroLagsBinaryAttachment):
            print "Not yet implemented"
            sigma4_X = self.sigma(R4_X0, 4)
            sigma4_Y = self.sigma(R4_Y0, 4)
        else:
            sigma4_X = sqrt(np.mean(TDM_X))
            sigma4_Y = sqrt(np.mean(TDM_Y))
        sigma8_X = 2*sigma4_X
        sigma8_Y = 2*sigma4_Y
        a = self.afun(sigma8_X, sigma8_Y)
        b = self.bfun(sigma8_X, sigma8_Y)
#        print "a=%f, b=%f" % (a,b)
        if (type(spectrum[0]) == np.complex128):
            correctedSpectrum = []
            for chan in spectrum:
                correctedSpectrum.append(np.complex(np.real(spectrum[chan])*a - b, np.imag(spectrum[chan])))
        else:
            correctedSpectrum = spectrum*a - b
        return(correctedSpectrum)
        
    def initializeAttenuatorDictionaries(self):
        self.IFProc = {}
        self.IFSwitch = {}
        self.IFProcMin = {}
        self.IFProcMax = {}
        self.IFSwitchMin = {}
        self.IFSwitchMax = {}
        for a in self.antennas:
            self.IFProc[a] = {}
            self.IFSwitch[a] = {}
            self.IFProcMin[a] = {}
            self.IFProcMax[a] = {}
            self.IFSwitchMin[a] = {}
            self.IFSwitchMax[a] = {}
            for pol in self.polarizations:
                self.IFProc[a][pol] = None
                self.IFSwitch[a][pol] = {}
                self.IFSwitchMin[a][pol] = {}
                self.IFSwitchMax[a][pol] = {}
                for sb in self.sidebands:
                    self.IFSwitch[a][pol][sb] = None

    def fixSyscalTable(self, scan, dataFraction=[0.0,1.0], ignoreFlags=False):
        """
        Copies the existing SYSCAL table and appends entries calculated offline in casa
        for the specified scan.
        scan: which scan number to process
        dataFraction: which part of each load scan to use in the calculations
        """
        if (self.unrecognizedScan(scan)): return
        startTime = timeUtilities.time()
        originalName = self.vis+'/SYSCAL.old'
        os.system('cp -r %s %s' % (self.vis+'/SYSCAL', originalName))
        calscandict = buildCalDataIdDictionary(self.vis)
        mytb = createCasaTool(tbtool)
        mytb.open(self.vis+'/SYSCAL', nomodify=False)
        nrows = len(mytb.getcol('ANTENNA_ID'))
        originalRows = nrows
        for antenna in self.antennas:
            spws = self.spwsforscan_nonchanavg[scan]
            for spw in spws:
                print "-------- Working on scan=%d  antenna=%d/%d=%s, spw=%d(%d/%d) ----------" % (scan, antenna,len(self.antennas),self.antennaNames[antenna],spw,list(spws).index(spw)+1,len(spws))
                mytb.addrows(1)
                mytb.putcell('ANTENNA_ID',nrows,antenna)
                mytb.putcell('SPECTRAL_WINDOW_ID',nrows,spw)
                mytb.putcell('FEED_ID',nrows,0)
                mytb.putcell('TIME',nrows,self.meantime[scan]+0.5*self.interval[scan])
                mytb.putcell('INTERVAL',nrows,self.interval[scan])
                result_pol0 = self.computeTsys(scan,antenna,0,spw,altscan='auto',
                                               dataFraction=dataFraction,
                                               ignoreFlags=ignoreFlags,calscandict=calscandict)
                result_pol1 = self.computeTsys(scan,antenna,1,spw,altscan='auto',
                                               dataFraction=dataFraction,
                                               ignoreFlags=ignoreFlags,calscandict=calscandict)
                if (result_pol0 != None and result_pol1 != None):
                    tsys0, freqHz, trx0, tsky0, tcal0 = result_pol0
                    tsys1, freqHz, trx1, tsky1, tcal1 = result_pol1
                    mytb.putcell('TCAL_SPECTRUM',nrows,np.array([tcal0,tcal1]))
                    mytb.putcell('TRX_SPECTRUM',nrows,np.array([trx0,trx1]))
                    mytb.putcell('TSKY_SPECTRUM',nrows,np.array([tsky0,tsky1]))
                    mytb.putcell('TSYS_SPECTRUM',nrows,np.array([tsys0,tsys1]))
                else:
                    print "Stopping due to missing data.  Try removing the online flags."
                    mytb.close()
                    return
                mytb.putcell('TANT_SPECTRUM',nrows,np.array([],np.float))
                mytb.putcell('TANT_TSYS_SPECTRUM',nrows,np.array([],np.float))
                mytb.putcell('TCAL_FLAG',nrows,1)
                mytb.putcell('TRX_FLAG',nrows,1)
                mytb.putcell('TSKY_FLAG',nrows,1)
                mytb.putcell('TSYS_FLAG',nrows,1)
                mytb.putcell('TANT_FLAG',nrows,0)
                mytb.putcell('TANT_TSYS_FLAG',nrows,0)
                nrows += 1
        mytb.addreadmeline('Table has been modified by au.Atmcal().fixSyscalTable')
        mytb.close()
        print "Added %d rows.  The original table was moved to %s" % (nrows-originalRows,os.path.basename(originalName))
        stopTime = timeUtilities.time()
        print "Task completed in %.0f seconds" % (stopTime-startTime)
        
    def nearestCalScan(self, mjdsec):
        mindiff=1e38
        for scan in self.scans:
            mydiff = abs(self.meantime[scan]-mjdsec)
            if (mydiff < mindiff):
                mindiff = mydiff
                myscan = scan
        return myscan
    
    def findSyscalScans(self, maxscans=0):
        mytb = createCasaTool(tbtool)
        mytb.open(self.vis+'/SYSCAL')
        times = mytb.getcol('TIME')
        interval = mytb.getcol('INTERVAL')
        times -= 0.5*interval
#        print "times-0.5*interval: min=%f=%s max=%f=%s" % (np.min(times), mjdsecToUTHMS(np.min(times)), np.max(times), mjdsecToUTHMS(np.max(times)))
#        print "interval: min=%f max=%f" % (np.min(interval), np.max(interval))
        mytb.close()
        times = np.unique(times)
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(self.vis)
        scans = []
        timestamps = []
        for t in times:
            scan = self.nearestCalScan(t)
            if scan not in scans:
                scans.append(scan)
                timestamps.append(mjdsecToUTHMS(t))
        print "scans = %s" % (str(scans))
        print "times = %s" % (str(timestamps))
        self.syscalScans = scans
        if (maxscans > 0):
            self.syscalScans = scans[:maxscans]
        missingScans = np.setdiff1d(self.scans, scans)
        if (len(missingScans) > 0):
            print "There are %d atmcal scans missing from the SYSCAL table: %s" % (len(missingScans),str(missingScans))
            spwString = ''
            for scan in missingScans:
                spwString += str(np.setdiff1d(np.setdiff1d(mymsmd.spwsforscan(scan),mymsmd.wvrspws()),
                                              mymsmd.chanavgspws()))
            print "They correspond to spws: %s" % (spwString)
        mymsmd.close()
        
    def getScans(self):
        return(self.scans)
            
    def distinguishLoadData(self, verbose=False):
        myms = createCasaTool(mstool)
        myms.open(self.vis)
        # Just use the first scan and first spw and first antenna
        antenna = 0
        datadescid = self.datadescids[self.spws[0]]
        myms.selectinit(datadescid=datadescid)
        print "Found scans: %s" % (str(sorted(self.timestamps.keys())))
        scan = sorted(self.timestamps.keys())[0]
        if (verbose):
            print "Timerange = %s" % (mjdsecToTimerange(self.timestamps[scan][self.loadsubscans[0]]))
            print "Timerange = ", self.timestamps[scan][self.loadsubscans[0]]
        myms.select({'time':self.timestamps[scan][self.loadsubscans[0]], 'antenna1':antenna, 'antenna2':antenna})
        data0 = myms.getdata(['amplitude'])['amplitude']
        myms.selectinit(datadescid=datadescid)
        myms.select({'time':self.timestamps[scan][self.loadsubscans[1]], 'antenna1':antenna, 'antenna2':antenna})
        data1 = myms.getdata(['amplitude'])['amplitude']
        Yfactor = []
        
        for pol in range(len(data0)):
            if (np.median(data0[pol]) < np.median(data1[pol])):
                Yfactor.append(np.median(data1[pol])/np.median(data0[pol]))
                self.target[self.loadsubscans[1]] = 'hot'
                self.target[self.loadsubscans[0]] = 'amb'
            else:
                Yfactor.append(np.median(data0[pol])/np.median(data1[pol]))
                self.target[self.loadsubscans[0]] = 'hot'
                self.target[self.loadsubscans[1]] = 'amb'
        self.targetInverse[self.target[self.loadsubscans[0]]] = self.loadsubscans[0]
        self.targetInverse[self.target[self.loadsubscans[1]]] = self.loadsubscans[1]
        print "Information from scan %d:" % (scan)
        print "Y-factors for pol %s: %s" % (range(len(data0)), str(Yfactor))
        if (len(Yfactor) > 1):
            if ((Yfactor[0] < 1 and Yfactor[1] > 1) or (Yfactor[0] > 1 and Yfactor[1] < 1)):
                print "The two polarizations do not agree on the order of the subscans (ambient vs. hot load)"
            else:
                loadlist = ''
                durationlist = ''
                totalDuration = 0
                for t in range(len(self.sub_scan_unique)):
                    if (t>0):
                        loadlist += ','
                        durationlist += ','
                    loadlist += self.target[self.sub_scan_unique[t]]
                    myduration = self.timestamps[scan][self.sub_scan_unique[t]][1] - \
                                 self.timestamps[scan][self.sub_scan_unique[t]][0] + \
                                 self.integrationTime[scan]  # because need to add 1/2 integration time on each end
                    durationlist += '%.2f' % (myduration)
                    totalDuration += myduration
                print "Standard order of the load subscans is confirmed (%s)" % (loadlist)
                print "Subscan durations: %ss; total=%.2fs; integration=%.3fs" % (durationlist,totalDuration,self.integrationTime[scan])
        myms.close()
        
    def readStateTable(self):
        mytb = createCasaTool(tbtool)
        mytb.open('%s/STATE' % self.vis)
        sub_scan = mytb.getcol('SUB_SCAN')
        obs_mode = mytb.getcol('OBS_MODE')
        sig = mytb.getcol('SIG')
        mytb.close()
        calatm_rows = []
        self.stateID_off_source = []
        for row in range(len(obs_mode)):
            om = obs_mode[row]
            if (om.find('CALIBRATE_ATMOSPHERE') >= 0):
                calatm_rows.append(row)
                if (om.find('OFF_SOURCE') >= 0 and sig[row]==0):
                    self.stateID_off_source.append(row)
        self.sub_scan = sub_scan[calatm_rows]
        self.sub_scan_unique = np.unique(self.sub_scan)
        self.obs_mode = obs_mode[calatm_rows]
        self.loadsubscans = []
        self.refsubscan = None
        for i in range(len(self.obs_mode)):
            if (self.obs_mode[i].find('OFF_SOURCE')>=0):
                self.skysubscan = self.sub_scan[i]
            elif (self.obs_mode[i].find('REFERENCE')>=0):
                self.refsubscan = self.sub_scan[i]
            else:
                self.loadsubscans.append(self.sub_scan[i])
        self.loadsubscans = np.unique(self.loadsubscans)
        self.nsubscans = len(self.sub_scan_unique)
        self.target = dict.fromkeys(self.sub_scan_unique)
        self.targetInverse = {}
        for i in self.sub_scan_unique:
            if (i in self.loadsubscans):
                self.target[i] = 'load'
            elif (i==self.refsubscan):
                self.target[i] = 'ref'
                self.targetInverse['ref'] = i
            else:
                self.target[i] = 'sky'
                self.targetInverse['sky'] = i

    def findCalScans(self, includeDate, includeSQLD=False, maxscans=0):
        self.loadTemperatures = getLoadTemperatures(self.vis)
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(self.vis)
        self.antennas = range(mymsmd.nantennas())
        self.antennaNames = mymsmd.antennanames(self.antennas)
        self.basebands = getBasebands(mymsmd)
        self.observationStart = getObservationStart(self.vis)
        self.observationStop = np.max(mymsmd.timesforscan(mymsmd.scannumbers()[-1]))
        self.telescopeName = mymsmd.observatorynames()[0]
        self.yyyymmdd = mjdSecondsToMJDandUT(mymsmd.timesforscans(1)[0])[1].split()[0]
        self.intentsforscan = {}
        for scan in mymsmd.scannumbers():
            self.intentsforscan[scan] = mymsmd.intentsforscan(scan)
        self.scans = mymsmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
        if (len(self.scans) == self.scans[-1]):
            self.attenuatorTest = True
        else:
            self.attenuatorTest = False
        self.spws = spwsforintent_nonwvr_nonchanavg(mymsmd, 'CALIBRATE_ATMOSPHERE#ON_SOURCE',includeSQLD)
        print "Found spws: ", self.spws
        self.nchan = mymsmd.nchan(self.spws[0]) # assume all are the same
        self.datadescids = {}
        self.meanfreq = {}
        self.sidebandsforspw = {}
        self.chanfreqs = {}
        for spw in self.spws:
            self.datadescids[spw]=spw  # assume this is true for now, but may not be someday
            self.meanfreq[spw] = mymsmd.meanfreq(spw)
            self.chanfreqs[spw] = mymsmd.chanfreqs(spw)
            if (mymsmd.sideband(spw) < 0):
                self.sidebandsforspw[spw] = 1
            else:
                self.sidebandsforspw[spw] = 2
        self.timestamps = {}
        self.timestampsString = {}
        self.timerangeString = {}
        self.timerange = {}
        self.meantime = {}
        self.interval = {}
        self.meantimestring = {}
        self.integrationTime = {}
        self.spwsforscan = {}
        self.spwsforscan_nonchanavg = {}
        self.spwsforallscans_nonchanavg = spwsForScan(mymsmd)
        if (maxscans > 0):
            self.scans = self.scans[:maxscans]
        for scan in self.scans:
            t = mymsmd.timesforscan(scan)
            result = computeDurationOfScan(scan, t, vis=self.vis, returnSubscanTimes=True, verbose=self.verbose,includeDate=includeDate)
            if (result[1] != len(self.sub_scan_unique)):
                print "Found %d subscans in scan %d instead of %d!" % (result[1], scan, len(self.sub_scan_unique))
                line = '     '
                for mysubscan in range(result[1]):
                    line += result[3][mysubscan+1] + ', '
                print line
            else:
                print "Working on scan %d" % (scan)
            self.timestamps[scan] = result[2]
            self.timestampsString[scan] = result[3]
            self.integrationTime[scan] = getIntegrationTime(self.vis, scan=scan, intent='CALIBRATE_ATMOSPHERE#ON_SOURCE', verbose=False)
            self.timerange[scan] = [result[2][1][0], result[2][len(result[2])][1]]
            self.timerangeString[scan] = [mjdsecToUTHMS(result[2][1][0]), mjdsecToUTHMS(result[2][len(result[2])][1])]
            self.meantime[scan] = np.mean(self.timerange[scan])
            self.meantimestring[scan] = mjdsecToUTHMS(self.meantime[scan])
            self.spwsforscan[scan] = np.setdiff1d(mymsmd.spwsforscan(scan),mymsmd.wvrspws())  # get rid of WVR spws
            self.spwsforscan_nonchanavg[scan] = np.setdiff1d(self.spwsforscan[scan],mymsmd.chanavgspws())
        for scan in self.scans:
            if (scan < self.scans[-1]):
                nextscan = self.scans[list(self.scans).index(scan)+1]
                self.interval[scan] = self.meantime[nextscan]-self.meantime[scan]
            else:
                self.interval[scan] = 3600
        mymsmd.close()    

    def getSubscanTimes(self, scan, stringFormat=False, decimalDigits=2, includeDate=False):
        # currently not used
        timestamps = {}
        timestamp = self.timestamps[scan]
        for subscan in timestamp.keys():
            if (stringFormat):
                timestamps[self.target[subscan]] = mjdsecToTimerange(timestamp[subscan][0],
                                                                     timestamp[subscan][1],
                                                                     decimalDigits,includeDate)
            else:
                timestamps[self.target[subscan]] = timestamp[subscan]
        return(timestamps)
    
    def printCalScans(self, decimalDigits=1, includeDate=False):
        for scan in sorted(self.timestamps.keys()):
            timestamp = self.timestamps[scan]
            for subscan in timestamp.keys():
                print '%2d: %d: %4s %s [%.2f,%.2f]' % (scan, subscan, self.target[subscan],
                                              mjdsecToTimerange(timestamp[subscan][0],
                                                                timestamp[subscan][1],
                                                                decimalDigits,
                                                                includeDate),
                                              timestamp[subscan][0], timestamp[subscan][1]
                                              )
            print ""

    def getSpectrum(self, scan, spw, pol, target, antenna, 
                    dataFraction=[0.0,1.0],
                    median=False, ignoreFlags=False, antenna2=None):
        """
        Uses the ms tool to retrieve the average spectrum over all 
        integrations in the specified scan, for the subscan corresponding 
        to the target, and the specified spw, polarization and antenna.
        scan: integer
        spw: integer
        pol: integer
        target: 'hot', 'sky', amb'
        antenna: the antenna ID
        """
        scan = int(scan)
        spw = int(spw)
        pol = int(pol)
        antenna = int(antenna)
        myms = createCasaTool(mstool)
        myms.open(self.vis)
        subscan = self.targetInverse[target]
        myms.selectinit(datadescid=self.datadescids[spw])
        # normally, one could just bass 'time':self.timestamps[scan][subscan]
        # but here I give the option to use only part of the subscan
        endtime = self.timestamps[scan][subscan][1]
        starttime = self.timestamps[scan][subscan][0]
        timerange = [starttime+(endtime-starttime)*dataFraction[0],
                     starttime+(endtime-starttime)*dataFraction[1]]
        # because need to add 1/2 integration time on each end
        duration = timerange[1]-timerange[0]+self.integrationTime[scan]  
        if (antenna2 == None):
            antenna2 = antenna
        myms.select({'time':timerange,'antenna1':antenna, 'antenna2':antenna2})
        datadict = myms.getdata(['amplitude'])
        if ('amplitude' not in datadict.keys()):
            print "no amplitude in ms.getdata result: %s" % (str(datadict.keys()))
            return([0])
        data = datadict['amplitude']
        datamean = np.zeros(len(data[pol]))
        flag = myms.getdata(['flag'])['flag']
        myms.close()
        print "%s flags: %d/%d" % (target, np.sum(flag[pol].flatten()),
                                   len(flag[pol].flatten()))
        try:
            if (ignoreFlags):
                datamean = np.mean(data[pol], 1)
            else:
                datamean = np.ma.average(data[pol], 1, 
                                      weights=1.0-flag[pol].astype(float))
                # The following fails if the weights sum to zero
                # datamean = np.average(data[pol], 1, 
                # weights=1.0-flag[pol].astype(float))
        except:
            datamean = -1
            print "This subscan data (scan=%d, spw=%d, pol=%d, antenna=%d) is either missing or totally flagged." % (scan,spw,pol,antenna)
        return(datamean)
        
    def computeMeanSpectrum(self, spw, pol, target, antenna, dataFraction=[0.0,1.0], median=False):
        """
        antenna: the antenna ID
        """
        means = []
        myms = createCasaTool(mstool)
        myms.open(self.vis)
        subscan = self.targetInverse[target]
        for i in range(len(self.scans)):
            # produce a mean spectrum for each scan
            scan = self.scans[i]
            myms.selectinit(datadescid=self.datadescids[spw])
            endtime = self.timestamps[scan][subscan][1]
            starttime = self.timestamps[scan][subscan][0]
            timerange = [starttime+(endtime-starttime)*dataFraction[0], starttime+(endtime-starttime)*dataFraction[1]]
            duration = timerange[1]-timerange[0]
            myms.select({'time':timerange, 'antenna1':antenna, 'antenna2':antenna})
            data = myms.getdata(['amplitude'])['amplitude']
            if (median):
                datamean = np.median(data[pol], 1)
                means.append(datamean/np.median(datamean))
            else:
                datamean = np.mean(data[pol], 1)
                means.append(datamean/np.mean(datamean))
        myms.close()
        # compute the mean spectrum over all scans
        if (median):
            return(np.median(means,0),duration)
        else:
            return(np.mean(means,0),duration)

    def readIFProcAttenuatorSettings(self, tmcfile, pol=0):
        """
        Returns 2 lists: dateTimeStamp in MJD second, and attenuation in dB
        """
        loc = tmcfile.find('IFProc')+6
        if (loc > 0):
            tmcfile = tmcfile[:loc] + str(pol) + tmcfile[loc+1:]
            print "Using file = ", tmcfile
        if (os.path.exists(tmcfile) == False):
            print "Could not open IF Proc TMC database file"
            return
        tmclines = open(tmcfile,'r').readlines()
        dateTimeStamp = []
        dB = []
        for line in tmclines:
            tokens = line.split()
            if (len(tokens) == 0):
                print "len(tokens) = %d" % (len(tokens))
            dateTimeStamp.append(dateStringToMJDSec(tokens[0],verbose=False))
            dB.append([float(x) for x in tokens[1:]])
        return(dateTimeStamp, dB)

    def readIFSwitchAttenuatorSettings(self, tmcfile_ifswitch, pol=0, sideband=1):
        """
        Returns the timestamp and (single) value for the specified polarization and sideband.
        """
        tmcfile = tmcfile_ifswitch[sideband]
        loc = tmcfile.find('CHANNEL')+7
        if (loc > 0):
            tmcfile = tmcfile[:loc] + str(pol) + str(sideband) + tmcfile[loc+2:]
            print "Using file = ", tmcfile
        if (os.path.exists(tmcfile) == False):
            print "Could not open IF Switch TMC database file"
            return
        tmclines = open(tmcfile,'r').readlines()
        dateTimeStamp = []
        dB = []
        for line in tmclines:
            tokens = line.split()
            dateTimeStamp.append(dateStringToMJDSec(tokens[0],verbose=False))
            dB.append(float(tokens[1]))
        return(dateTimeStamp, dB)

    def getAttenuatorSettings(self, antenna=0, pol=0, tmcfile_ifswitch=None, tmcfile_ifproc=None):
        if (self.IFProc[antenna][pol] == None or self.IFSwitch[antenna][pol][1] == None):
            self.readAttenuatorSettings(antenna,pol,tmcfile_ifswitch,tmcfile_ifproc)
        return(self.IFProc[antenna][pol], self.IFSwitch[antenna][pol])

    def plotAttenuatorSettings(self, antenna=0, pol=0, dateTimeStamp=None, dB=None):
        """
        Plot the IF Proc attenuator settings.
        """
        if (self.IFProc == {}):
            print "You must first readAttenuatorSettings()"
            return
        if (dateTimeStamp == None or dB == None):
            dateTimeStamp, dB = self.readIFProcAttenuatorSettings(self.tmcfile_ifproc, pol)
            idx0 = np.where(dateTimeStamp < self.observationStop)[0]
            idx1 = np.where(dateTimeStamp > self.observationStart)[0]
            indices = np.intersect1d(idx0,idx1)
            dateTimeStamp = np.array(dateTimeStamp)[indices]
            print "np.shape(dB) = ", np.shape(dB)
            print "np.shape(dB[0]) = ", np.shape(dB[0])
            dB[0] = np.array(dB[0])[indices]
            print "np.shape(dB) = ", np.shape(dB)
        timeStamps = pb.date2num(mjdSecondsListToDateTime(list(dateTimeStamp)))
        for bb in range(1):
            print "bb=%d: len(timeStamps)=%d, len(dB[bb])=%d" % (bb, len(timeStamps), len(dB[bb]))
            pb.plot_date(timeStamps, dB[bb], color=overlayColors[bb])
            pb.hold(True)
        pb.ylabel('dB')
        pb.xlabel('Universal time')
        pb.title('%s: Antenna %d, pol %d' % (os.path.basename(self.vis), antenna, pol))
        png = os.path.basename(self.vis) + '.ifproc.ant%d.pol%d.png' % (antenna,pol)
        pb.savefig(png)
        pb.draw()
        return(dateTimeStamp, dB)
                               
    def readAttenuatorSettings(self, antenna=0, pol=0, tmcfile_ifswitch=None, tmcfile_ifproc=None, outpath='./'):
        # Example: tmu.get_tmc_data('DA62','FrontEnd_IFSwitch','CHANNEL01_ATTENUATION','2013-07-23','2013-07-23')
        if (tmcfile_ifproc==None):
            localfile = tmu.retrieve_daily_tmc_data_file_name_only(self.antennaNames[antenna],'IFProc'+str(pol),
                                                                   'GAINS', self.yyyymmdd, outpath=outpath)
            if (os.path.exists(localfile)):
                tmcfile_ifproc = localfile
            else:
                try:
                    mydict=tmu.get_tmc_data(self.antennaNames[antenna],'IFProc'+str(pol),'GAINS', self.yyyymmdd, self.yyyymmdd, outpath=outpath)
                    tmcfile_ifproc = mydict['files'][0]
                    self.tmcfile_ifproc = tmcfile_ifproc
                except:
                    return False
        if (tmcfile_ifswitch==None):
            tmcfile_ifswitch = {}
            for sideband in self.sidebands:
                localfile = tmu.retrieve_daily_tmc_data_file_name_only(self.antennaNames[antenna],'FrontEnd_IFSwitch',
                                                                       'CHANNEL%d%d_ATTENUATION'%(pol,sideband), self.yyyymmdd, outpath=outpath)
                if (os.path.exists(localfile)):
                    tmcfile_ifswitch[sideband] = localfile
                else:
                    mydict = tmu.get_tmc_data(self.antennaNames[antenna],'FrontEnd_IFSwitch',
                                       'CHANNEL%d%d_ATTENUATION'%(pol,sideband), self.yyyymmdd, self.yyyymmdd, outpath=outpath)
                    tmcfile_ifswitch[sideband] = mydict['files'][0]
        else:
            print "tmcfile_ifswitch is not None = ", tmcfile_ifswitch
            
        self.associateAttenuatorSettingsToScans(tmcfile_ifproc, tmcfile_ifswitch, antenna, pol)
        print "Range of attenuator settings for pol %d: IFproc=%4.1f-%4.1f, IFswitch:sb1=%4.1f-%4.1f, sb2=%4.1f-%4.1f" % (pol, self.IFProcMin[antenna][pol],
                                                                              self.IFProcMax[antenna][pol],
                                                                              self.IFSwitchMin[antenna][pol][1],
                                                                              self.IFSwitchMax[antenna][pol][1],
                                                                              self.IFSwitchMin[antenna][pol][2],
                                                                              self.IFSwitchMax[antenna][pol][2]
                                                                                             )
        return(True)

    def associateAttenuatorSettingsToScans(self, tmcfile_ifproc,
                                           tmcfile_ifswitch=None,
                                           antenna=0, pol=0, debug=False,
                                           subscan=2, verbose=False):
        """
        Builds two dictionaries, keyed by scan number, and baseband number:
        (1) IFProcessor attenuator settings: a vector of 4 values (one for each baseband).
        (2) IFSwitch attenuator settings: a single value
        pol: 0 or 1
        """
        if (pol != 0 and pol != 1):
            print "Invalid pol, must be 0 or 1"
            return
        dateTimeStamp, dB = self.readIFProcAttenuatorSettings(tmcfile_ifproc, pol)
        self.IFProc[antenna][pol] = {}     # start with empty list of scans
        self.IFSwitch[antenna][pol][1] = {}
        self.IFSwitch[antenna][pol][2] = {}
        alldB = []
#        print "IF Proc TMC timestamps range from %f to %f" % (dateTimeStamp[0], dateTimeStamp[-1])
        for scan in self.scans:
            startTime = self.timestamps[scan][1][0]
            endTime = self.timestamps[scan][self.nsubscans][-1]
            # Look for the attenuator measurements after the start time of the first subscan.
            indices1 = np.where(dateTimeStamp > startTime+1)[0]
            # Look for the attenuator measurements before the end of the last subscan.
            indices2 = np.where(dateTimeStamp < endTime-2.5)[0]
            if (debug): print "startTime-endTime = %s-%s" % (mjdsecToUTHMS(startTime+1), mjdsecToUTHMS(endTime-2.5))
            indices = np.intersect1d(indices1,indices2)
            if (len(indices) < 1):
                print "The IFProc TMC file (%s) does not contain data within scan %d (%s-%s)." % (tmcfile_ifproc,scan,mjdsecToUTHMS(startTime),mjdsecToUTHMS(endTime))
                self.IFProc[antenna][pol][scan] = -1
            if (verbose):
                outline = "Found %d %s IF proc pol%d attenuator measurements during scan %2d.  " % (len(indices),self.antennaNames[antenna],pol,scan)
            else:
                outline = ''
            if (len(indices) > 1):
                for bb in range(4):
                    if (dB[indices[0]][bb] != dB[indices[-1]][bb]):
                        outline += "The IFProc pol%d:bb%d attenuator value changed from %4.1f to %4.1f during scan %d!" % (pol,bb+1,dB[indices[0]][bb], dB[indices[-1]][bb], scan)
                if (verbose==False and len(outline)>0):
                    print outline
                    for j in range(len(indices)):
                        print "start = %.1f    end = %.1f" % (startTime, endTime)
                        print "%s dB at %.1f (%.1f--%.1f sec)\n" % (str(dB[indices[j]]),
                                                                    dateTimeStamp[indices[j]],
                                                                    dateTimeStamp[indices[j]]-startTime,
                                                                    endTime-dateTimeStamp[indices[j]]
                                                                    )
                else:
                    outline += "No inconsistencies seen."
            if (verbose):
                print outline
            if (len(indices) > 0):
                firstIndex = indices[0]
                self.IFProc[antenna][pol][scan] = dB[firstIndex]
                alldB += dB[firstIndex]
        if (len(alldB) < 1):
            self.IFProcMin[antenna][pol] = -1
            self.IFProcMax[antenna][pol] = -1
        else:
            self.IFProcMin[antenna][pol] = np.min(alldB)
            self.IFProcMax[antenna][pol] = np.max(alldB)
        # Build baseband keys
        for bb in range(4):
            self.IFProc[antenna][pol]['bb%d'%(bb+1)] = []
            for scan in self.scans:
                if (scan in self.IFProc[antenna][pol]):
                    if (self.IFProc[antenna][pol][scan] != -1):
                        self.IFProc[antenna][pol]['bb%d'%(bb+1)].append(self.IFProc[antenna][pol][scan][bb])
                    else:
                        print "Scan %d is not in the IFProc dictionary" % (scan)
                else:
                    print "Scan %d is not in the IFProc dictionary" % (scan)
        if (tmcfile_ifswitch != None):
          for sideband in self.sidebands:
            dateTimeStamp, dB = self.readIFSwitchAttenuatorSettings(tmcfile_ifswitch, pol, sideband)
            alldB = []
            for scan in self.scans:
                startTime = self.timestamps[scan][1][0]
                endTime = self.timestamps[scan][self.nsubscans][-1]
                # Look for the attenuator measurements after the start time of the first subscan
                if (debug): print "startTime of scan %d = %f" % (scan,startTime)
                indices1 = np.where(dateTimeStamp > startTime+1)[0]
                # Look for the attenuator measurements before then end of the last subscan
                indices2 = np.where(dateTimeStamp < endTime-2.5)[0]
                indices = np.intersect1d(indices1,indices2)
                if (len(indices) < 1):
                    print "The IFSwitch TMC file does not contain data during scan %d (%s-%s)." % (scan,mjdsecToUTHMS(startTime+1), mjdsecToUTHMS(endTime-2.5))
                    self.IFSwitchMin[antenna][pol][sideband] = -1
                    self.IFSwitchMax[antenna][pol][sideband] = -1
                if (verbose):
                    outline = "Found %d %s IF switch pol%d:sb%d attenuator measurements during scan %2d.  " % (len(indices),self.antennaNames[antenna],pol,sideband,scan)
                else:
                    outline = ''
                if (len(indices) > 1):
                    if (dB[indices[0]] != dB[indices[-1]]):
                        outline += "The attenuation changed from %.1f to %.1f during scan %d!" % (dB[indices[0]], dB[indices[-1]],scan)
                        if (verbose==False and len(outline)>0):
                            print outline
                            for j in range(len(indices)):
                                print "start = %.1f    end = %.1f" % (startTime, endTime)
                                print "%s dB at %.1f (%.1f--%.1f sec)\n" % (str(dB[indices[j]]),
                                                                    dateTimeStamp[indices[j]],
                                                                    dateTimeStamp[indices[j]]-startTime,
                                                                    endTime-dateTimeStamp[indices[j]]
                                                                    )
                    else:
                        outline += "No inconsistencies seen."
                if (verbose): print outline
                if (len(indices) > 0):
                    firstIndex = indices[0]
                    self.IFSwitch[antenna][pol][sideband][scan] = dB[firstIndex]
                    alldB.append(dB[firstIndex])
            if (len(indices) > 0):
                self.IFSwitchMin[antenna][pol][sideband] = np.min(alldB)
                self.IFSwitchMax[antenna][pol][sideband] = np.max(alldB)
            # Build baseband keys
            self.IFSwitch[antenna][pol][sideband]['bb0'] = []
            for scan in self.scans:
                if (scan in self.IFSwitch[antenna][pol][sideband]):
                    self.IFSwitch[antenna][pol][sideband]['bb0'].append(self.IFSwitch[antenna][pol][sideband][scan])
                else:
                    print "Scan %d not in IFSwitch dictionary" % (scan)

    def computeBitRanges(self, delta=1.0):
        """
        returns a matrix:  len=64 levels, nBits entries for each
        and its transpose: len=nBits, 64 entries for each
        and a dictionary keyed by each possible attenuation value with the value being
           the number of bits that must be changed when the increment is delta from there.
        """
        a = np.arange(64.0)
        atten = a*0.5
        levels = [16,8,4,2,1,0.5]  # dB
        attenlevels = []  # will hold 0 or 1 for each of the bit levels
        for a in range(len(atten)):
            i = atten[a]
            levs = []
            att = i
            for l in levels: 
                if (i >= l):
                    levs.append(1)
                    i = i-l
                else:
                    levs.append(0)
            attenlevels.append(levs)  # 0->0dB, 1->0.5dB
        deltaBits = {}
        if (delta > 0):
            start = 0
            end = 32-delta
            inc = 0.5
        else:
            start = 32
            end = 0-delta
            inc = -0.5
        for a in np.arange(start,end,inc):
            # deltaBits = how many bits changed when going from the key dB
            #             to key+delta dB
            startBits = attenlevels[int(a*2)]
            endBits = attenlevels[int((a+delta)*2)]
            deltaBits[a] = abs(np.array(startBits)-np.array(endBits)).sum()
#            print "%4.1f dB: startBits=%s, endBits=%s, deltaBits=%d" % (a, startBits, endBits, deltaBits[a])
            
        bitstatus = np.transpose(attenlevels) # len=nBits, each entry=64 levels
        return(attenlevels, bitstatus, deltaBits)

    def plotCalScansAll(self, target=['sky','amb','hot'],
                        normalize='meanspectrum', plotfile=True,
                        startdBm=4.0, incrementdBm=-1.0, plotSlopes=True,
                        maxSlope=20, edge=5, xaxis='dB', 
                        pdfname=None, tmcfile_ifswitch=None,
                        tmcfile_ifproc=None, xlim=[8,26], y_autoscale=True,
                        dataFraction=[0.0, 1.0], logPower=False, median=False,
                        printSlopes=False, debug=False,ylimitsForRatio=[0.9,1.1]):
        """
        Calls plotCalScans repeatedly for each antenna, pol, spw.
        dataFraction: use this range of the each integration
        median: normalize by the median rather than the mean spectrum
        """
        pngs = []
        for antenna in self.antennas:
            for pol in self.polarizations:
                for spw in self.spws:
                    png = self.plotCalScans(spw=spw, pol=pol, antenna=antenna,
                                            target=target,
                                            normalize=normalize,
                                            plotfile=plotfile,
                                            startdBm=startdBm,
                                            incrementdBm=incrementdBm,
                                            plotSlopes=plotSlopes,
                                            maxSlope=maxSlope, edge=edge,
                                            xaxis=xaxis,
                                            tmcfile_ifswitch=tmcfile_ifswitch,
                                            tmcfile_ifproc=tmcfile_ifproc,
                                            xlim=xlim, y_autoscale=y_autoscale,
                                            dataFraction=dataFraction, logPower=logPower,
                                            median=median, printSlopes=printSlopes,debug=debug,
                                            ylimitsForRatio=ylimitsForRatio)
                    pngs.append(png)
        if (normalize==''):
            normalize = 'raw'
        if (pdfname == None):
            if (dataFraction != [0.0,1.0]):
                pdfname = self.vis + '.%s.%.1f-%.1f.plotCalScans.pdf' % (normalize,dataFraction[0],dataFraction[1])
            else:
                pdfname = self.vis + '.%s.plotCalScans.pdf' % (normalize)
        mystatus = buildPdfFromPngs(pngs, pdfname=pdfname)
        print mystatus
        
    def plotCalScans(self, spw=0, pol=0, antenna=0, target='hot',
                     normalize=False, plotfile=None, startdBm=4.0,
                     incrementdBm=-1.0, plotSlopes=False,
                     maxSlope=20, edge=5, xaxis='dB',
                     tmcfile_ifswitch=None, tmcfile_ifproc=None, xlim=None,
                     y_autoscale=True, dataFraction=[0.0,1.0], logPower=False,
                     median=False, printSlopes=False, debug=False,
                     ylimitsForRatio=[0.9,1.1], fontsize=12, overlay=False):
        """
        Plot the atm cal subscans for a specified spw/pol/antenna combination,
        and the specified subscans.
        
        plotSlopes: if True, make 2 rows of plots, with the slope vs. scan
                    on the bottom row
        edge: number of edge channels to ignore when fitting a linear slope
        maxSlope: use this to set the +-y axis range when plotSlopes=True
        xlim: use this to set the x axis range when plotSlopes=True
        xaxis: 'dB' to put the IFProc attenuator setting on the x-axis
               (otherwise, use scan#)
        y_autoscale: True will set y-axis range to automatic
                     False will set y-axis range to [min(all_targets),max(all_targets)]
        dataFraction: use this range of the each integration
        logPower: if True, show the power spectra in log units instead of linear
        overlay: if True, show all on the same panel
        target: 'hot', 'sky', amb' or lists:  ['hot','sky','amb']
        fontsize: for tick labels, axis labels and target labels
        """
        loadNames = {'amb': 'ambient load', 'hot': 'hot load', 'sky': 'sky'}
        spw = int(spw)
        antenna = int(antenna)
        if (self.unrecognizedSpw(spw)): return
        if (self.unrecognizedAntenna(antenna)): return
        pb.clf()
        pb.hold(True)
        if (type(target) != list):
            target = [target]
        if (plotSlopes):
            nx = 2
            if (normalize==False):
                normalize = 'meanspectrum'
                print "Since plotSlopes=True, set normalize to '%s'" % (normalize)
        else:
            nx = 1
            if (normalize==False or normalize==''):
                normalize = 'raw'
        if (not overlay):
            adesc = pb.subplot(nx,len(target),1)
        else:
            adesc = pb.subplot(1,1,1)
            pb.hold(True)
        if (y_autoscale):
            wspace=0.15
        else:
            wspace=0.1
        pb.subplots_adjust(wspace=wspace, right=0.85, hspace=0.2)
        data0max = 0
        data0min = 1e38
        for t in range(len(target)):
            mytarget = target[t]
            if (not overlay):
                adesc = pb.subplot(nx,len(target),t+1)
            adesc.xaxis.grid(True,which='major')
            adesc.yaxis.grid(True,which='major')
            if (mytarget not in self.targetInverse):
                print "The %s subscan is not in this dataset (valid targets = %s)." % (mytarget,str(self.targetInverse))
                return
            subscan = self.targetInverse[mytarget]
            if (normalize == 'meanspectrum'):
                self.meanspectrum,duration = self.computeMeanSpectrum(spw,pol,mytarget,
                                                             antenna,dataFraction,median)
            myms = createCasaTool(mstool)
            myms.open(self.vis)
            if (overlay):
                pb.text(0.1,0.9-t*0.1,loadNames[mytarget],size=fontsize,
                        transform=adesc.transAxes,color=overlayColors[t])
            else:
                pb.text(0.1,0.9,loadNames[mytarget],size=fontsize,transform=adesc.transAxes)
            slopes = []
            for i in range(len(self.scans)):
                scan = self.scans[i]
                myms.selectinit(datadescid=self.datadescids[spw])
                myms.select({'time':self.timestamps[scan][subscan],
                             'antenna1':antenna, 'antenna2':antenna})
                data0 = myms.getdata(['amplitude'])['amplitude']
                data0mean = np.median(data0[pol], 1)
                if (normalize == 'meanvalue'):
                    if (median):
                        data0mean /= np.median(data0mean)
                    else:
                        data0mean /= np.mean(data0mean)
                elif (normalize == 'meanspectrum'):
                    if (median):
                        data0mean /= np.median(data0mean)
                    else:
                        data0mean /= np.mean(data0mean)
                    data0mean /= self.meanspectrum
                if ((i < len(self.scans)/2) or (normalize=='raw')):
                    ls = '-'
                else:
                    ls = '--'
                if (logPower):
                    yaxisData = 10*np.log10(data0mean)
                else:
                    yaxisData = data0mean
                if (overlay):
                    colorIndex = t # i*len(target)+t
                else:
                    colorIndex = i
                pb.plot(range(len(data0mean)), yaxisData, ls=ls,
                        color=overlayColors[colorIndex],
                        markerfacecolor=overlayColors[colorIndex], lw=2.0)
                resizeFonts(adesc,fontsize)
                pb.xlim([-2, len(data0mean)+1])
                data0max = np.max([data0max,np.max(data0mean)])
                data0min = np.min([data0min,np.min(data0mean)])
                if (overlay):
                    if (data0min > 0): data0min = 0
                slope,intercept = linfit().linfit(range(len(data0mean[edge:-edge])),
                                                  data0mean[edge:-edge],
                                                  data0mean[edge:-edge]*0.0001)
                slopes.append(slope)
#                print "%4s %2d = %+f" % (mytarget, scan, slope*1000)
            # end for 'i'
            baseband = self.basebands[spw]
            antspwpol= self.antennaNames[antenna]+'.spw%02d.bb%d.pol'%(spw,baseband)+str(pol)
            titleString = mytarget+'.'+antspwpol
            pb.title(titleString,size=13-len(target))
            if (normalize == 'meanvalue' or normalize=='meanspectrum'):
                pb.ylim(ylimitsForRatio)
                if (t != 0 and not overlay):
                    adesc.set_yticklabels([])
            if (t==0):
                obsdateString = mjdsecToUT(getObservationStart(self.vis))
                pb.text(0.1,1+0.05*nx,self.vis + '  ' + obsdateString + ' %.3fGHz'%(self.meanfreq[spw]*1e-9),transform=adesc.transAxes)
                if (normalize == 'meanvalue'):
                    pb.ylabel('Normalized amplitude', size=fontsize)
                elif (normalize == 'meanspectrum'):
                    if (plotSlopes):
                        pb.ylabel('Normalized_Amp / Mean_of_all_scans', size=fontsize)
                    else:
                        pb.ylabel('Normalized_Amplitude / Mean_of_all_scans', size=fontsize)
                else:  # raw
                    if (logPower):
                        pb.ylabel('Relative Amplitude (dB)', size=fontsize)
                    else:
                        pb.ylabel('Amplitude', size=fontsize)

            pb.xlabel('Channel', size=fontsize)
            if (t==len(target)-1):
                font0 = FontProperties()
                font = font0.copy()
                font.set_weight('heavy')
                if (self.attenuatorTest):
                    heading = 'Scan=ReqPower'
                else:
                    heading = 'Scan'
                pb.text(1+0.02*len(target), 1.06, heading,
                        transform=adesc.transAxes, size=9)
                pb.text(1+0.02*len(target), 1.13, 'nsubscans=%d'%self.nsubscans,
                        transform=adesc.transAxes, size=9)
                for j in range(len(self.scans)):
                    if (startdBm == None or self.attenuatorTest==False):
                        mytext = str(self.scans[j])
                    else:
                        mytext = str(self.scans[j]) + "=%+.1fdBm"%(startdBm+j*incrementdBm)
                    if ((j < len(self.scans)/2) or (normalize=='raw')):
                        mytext = mytext
                    else:
                        mytext = ":" + mytext
                    pb.text(1+0.01*len(target), 1-j*0.04*nx, mytext,
                            color=overlayColors[j], size=9,
                            transform=adesc.transAxes, fontproperties=font)
            if (plotSlopes):
                adesc = pb.subplot(nx,len(target),t+1+len(target))
                slopes = np.array(slopes)*100*self.nchan
                bitranges,bitstatus,deltaBits = self.computeBitRanges()
                baseband = self.basebands[spw]
                for i in range(len(self.scans)):
                    if (xaxis=='dB'):
                        self.getAttenuatorSettings(tmcfile_ifswitch=tmcfile_ifswitch,
                                                   tmcfile_ifproc=tmcfile_ifproc, pol=pol, antenna=antenna)
                        if (debug):
                            print "self.IFProc[antenna][pol] = ", self.IFProc[antenna][pol]
                            print "self.IFProc[antenna][pol][self.scans[i]] = ", self.IFProc[antenna][pol][self.scans[i]]
                            print "baseband = ", baseband
                        dB = self.IFProc[antenna][pol][self.scans[i]][baseband-1]
                        if (debug):
                            print "spw%d: bb%d: dB = %f, slope=%f" % (spw, self.basebands[spw], dB, slopes[i])
                        pb.plot(dB, slopes[i], 'o',markerfacecolor=overlayColors[i],
                                markeredgecolor=overlayColors[i])
                        if (i>0):
                            pb.text(dB, slopes[i]+1.2, str(deltaBits[previousAttenuation]),
                                    color=overlayColors[i], size=9)
                        previousAttenuation = dB
                    else:
                        pb.plot(self.scans[i],slopes[i],'o',markerfacecolor=overlayColors[i],
                                markeredgecolor=overlayColors[i])
                    if (printSlopes and t==len(target)-1):
                        print "slopes(hot) = ", slopes[i]
                resizeFonts(adesc,9)
                if (xaxis=='dB'):
                    adesc.xaxis.set_minor_locator(MultipleLocator(1.0))
                    adesc.xaxis.grid(True,which='minor')
                    pb.xlabel('IFProc%d:bb%d atten (dB)' % (pol,baseband))
                    # draw a square waveform corresponding to the status of each bit
                    yrange = 2*maxSlope
                    if (xlim == None):
                        startdB = self.IFProcMin[antenna][pol]-1
                        stopdB =  self.IFProcMax[antenna][pol]+1
                    else:
                        startdB, stopdB = xlim
                    pb.xlim([startdB,stopdB])
                    for i in range(len(bitstatus)):
                        xlevel = np.arange(self.IFProcMin[antenna][pol], self.IFProcMax[antenna][pol]+0.6, 0.5)
                        # 0dB --> 0,  0.5dB --> 1, 1dB--> 2
                        ylevel = bitstatus[i][(xlevel*2).astype(int)]*0.015*yrange + (maxSlope-yrange*(0.11+0.05*(i-1)))
                        xlevel -= 0.25
                        pb.plot(xlevel, ylevel, 'k-', drawstyle='steps-post')
                        dB = [16,8,4,2,1,0.5][i]
                        pb.text(stopdB+0.25, np.min(ylevel), str(dB), size=8)
                        if (t == len(target)-1):
                            if (dB < 1):
                                pb.text(stopdB+0.5+0.6*(3), np.min(ylevel)-0.3, 'off', size=5)
                                pb.text(stopdB+0.5+0.6*(3), np.min(ylevel)+0.8, 'on', size=5)
                            else:
                                pb.text(stopdB+0.5+0.6*(1+dB/10), np.min(ylevel)-0.3, 'off', size=5)
                                pb.text(stopdB+0.5+0.6*(1+dB/10), np.min(ylevel)+0.8, 'on', size=5)
                            if (i==0):
                                pb.text(stopdB+0.5, 5, 'duration=%.1f sec' % (duration), size=8)
                                pb.text(stopdB+0.5, 2.5, '(%.1f-%.1f)' % (dataFraction[0],dataFraction[1]), size=8)
                                pb.text(stopdB+0.5, -0.5, 'colored digits', size=8)
                                pb.text(stopdB+0.5, -3, 'denote the number', size=8)
                                pb.text(stopdB+0.5, -6, 'of bits changed', size=8)
                                pb.text(stopdB+0.5, -9, 'when switching', size=8)
                                pb.text(stopdB+0.5, -12, 'to this level', size=8)
                                pb.text(stopdB+0.5, -16, 'IFswSB1:%.1f-%.1fdB'%(self.IFSwitchMin[antenna][pol][1],
                                                                                    self.IFSwitchMax[antenna][pol][1]),size=8)
                                pb.text(stopdB+0.5, -19, 'IFswSB2:%.1f-%.1fdB'%(self.IFSwitchMin[antenna][pol][2],
                                                                                    self.IFSwitchMax[antenna][pol][2]),size=8)
                    pb.xlim([startdB,stopdB])
                else:
                    pb.xlabel('scan number')
                if (t == 0):
                    pb.ylabel('fitted slope (% per BW)')
                else:
                    adesc.set_yticklabels([])
                pb.ylim([-maxSlope, maxSlope])
            # endif plotSlopes
            resizeFonts(adesc,fontsize)
            myms.close()
        #end 'for' t in range(len(target)):
        # set the ylimits for the amp. vs channel plots
        for t in range(len(target)):
            if (not overlay):
                adesc = pb.subplot(nx,len(target),t+1)
            if (y_autoscale == False):
                if (logPower==False):
                    pb.ylim([data0min,data0max])
                else:
                    pb.ylim([np.min(10*np.log10(data0min)),np.max(10*np.log10(data0max))])
                if (t > 0 and not overlay):
                    adesc.set_yticklabels([])
        pb.draw()
        if (plotfile != None):
            if (plotfile == True):
                png = '.'.join(target) + '.' + antspwpol
                if (normalize != ''):
                    png += '.%s' % (normalize)
                png += '.png'
            else:
                png = plotfile
            pb.savefig(png)
            print "plot saved to %s" % (png)
            return(png)

    def getAntenna(self, antenna):
        if (antenna in self.antennaNames):
            antennaName = antenna
            antennaId = self.antennaNames.index(antennaName)
        elif (antenna in self.antennas or antenna in [str(a) for a in self.antennas]):
            antennaId = int(antenna)
            antennaName = self.antennaNames[antennaId]
        else:
            print "Antenna %s is not in the dataset" % (str(antenna))
            return None
        return(antennaId, antennaName)

    def getTelcalTrx(self, antenna, spw, scan, pol):
        return(self.getTelcalTspectrum('TRX_SPECTRUM', antenna, spw, scan, pol))
        
    def getTelcalTsys(self, antenna, spw, scan, pol):
        return(self.getTelcalTspectrum('TSYS_SPECTRUM', antenna, spw, scan, pol))
        
    def getTelcalTsky(self, antenna, spw, scan, pol):
        return(self.getTelcalTspectrum('TSKY_SPECTRUM', antenna, spw, scan, pol))
        
    def getTelcalTspectrum(self, tspec, antenna, spw, scan, pol):
        if (self.unrecognizedAntenna(antenna)): return
        if (self.unrecognizedScan(scan)): return
        if (self.unrecognizedSpw(spw)): return
        antennaId, antennaName = self.getAntenna(antenna)
        mytb = createCasaTool(tbtool)
        mytb.open(self.vis+'/SYSCAL')
        myt = mytb.query('ANTENNA_ID == %s and SPECTRAL_WINDOW_ID == %d' % (antennaId,spw))
        times = myt.getcol('TIME')
        trx = myt.getcol(tspec)
        myt.close()
        mytb.close()
        mindiff = 1e38
        pickrow = -1
        if (scan in self.syscalScans):
            for row in range(len(times)):
                diff = abs(times[row] - self.meantime[scan])
                if (diff < mindiff):
                    mindiff = diff
                    pickrow = row
        if (pickrow < 0):
            print "There are no TelCal-generated Trx/Tsys spectra found for this spw/antenna/pol/scan."
            return None
        else:
            return(trx[pol,:,pickrow])

    def unrecognizedAntenna(self, antenna):
        if (antenna not in self.antennas and antenna not in self.antennaNames and
            antenna not in [str(a) for a in self.antennas]):
            print "antenna %s is not available.  valid antennas = %s, %s" % (str(antenna), str(self.antennas), str(self.antennaNames))
            return(True)
        return(False)

    def unrecognizedSpw(self, spw):
        if (spw not in self.spws):
            print "spw %d is not available.  valid spws = %s" % (spw, str(self.spws))
            return(True)
        return(False)

    def unrecognizedScan(self, scan):
        if (type(scan) != int and type(scan) != np.int32):
            if (scan.isdigit()):
                scan = int(scan)
            else:
                print "The scan number must be an integer or integer string."
                return(False)
        if (int(scan) not in self.scans):
            print "Scan %d is not a cal scan.  Available scans = %s" % (int(scan), str(self.scans))
            return(True)
        return(False)

    def plotTsys(self, scan, antenna, pol, spw, tdmspw=None, asdm=None, etaF=0.98, lo1=None,
                 dataFraction=[0.0, 1.0], parentms=None, verbose=False,
                 siteAltitude_m=5000, computeJsky=True, altscan=None, overlayTelcal=True,
                 plotrange=[0,0,0,0], fdmCorrection=False, tdmscan=None, tdmdataset=None, plotfile='',
                 showAttenuators=False, takeLoadsFromTdmDataset=False):
        """
        Computes and plots the newly-calculated Tsys.
        See also plotTsysTrec2 to plot both Tsys and Trec2.
        """
        spw = int(spw)
#        if ((tdmspw != None or tdmdataset != None or tdmspw != None) and takeLoadsFromTdmDataset==False):
#            if (fdmCorrection == False): print "Setting fdmCorrection to True"
#            fdmCorrection = True
        if (self.unrecognizedAntenna(antenna)): return
        if (self.unrecognizedScan(scan)): return
        if (spw == 'auto'):
            spw = self.spwsforscan[scan][0]
            print "Choosing spw = %d" % (spw)
        if (self.unrecognizedSpw(spw)): return
        antennaId, antennaName = self.getAntenna(antenna)
        startTime = timeUtilities.time()
        result = self.computeTsys(scan, antenna, pol, spw, tdmspw, asdm, etaF, lo1,
                                  dataFraction, parentms, verbose,
                                  siteAltitude_m, computeJsky, altscan, fdmCorrection=fdmCorrection,
                                  tdmscan=tdmscan, tdmdataset=tdmdataset,
                                  takeLoadsFromTdmDataset=takeLoadsFromTdmDataset)
        stopTime = timeUtilities.time()
        if (stopTime-startTime > 5):
            print "Computation required %.1f seconds" % (stopTime-startTime)
        if (result == None):
            return
        tsys, freqHz, trec, tsky, tcal = result
        pb.clf()
        pol = int(pol)
        adesc = pb.subplot(111)
        freqHz = self.chanfreqs[spw]
        pb.plot(freqHz*1e-9, tsys, 'k-')
        if (verbose):
            print "len(freqHz) = %d,  shape(tsys) = %s" % (len(freqHz), str(np.shape(tsys)))
        if (overlayTelcal):
            if (fdmCorrection):
                lw = 1
            else:
                lw = 3
            tsys_telcal = self.getTelcalTsys(antenna,spw,scan,pol)  # TelCal's result
            if (tsys_telcal == None):
                print "No Tsys result is available from TelCal "
                overlayTelcal = False
            else:
                pb.plot(freqHz*1e-9, tsys_telcal, 'g-', lw=lw)
                y0,y1 = pb.ylim()
                pb.ylim([y0,y1+(y1-y0)*0.2])
                if (fdmCorrection):
                    mylabel = ' FDM'
                else:
                    mylabel = ''
                pb.text(0.05,0.95,'TelCal'+mylabel,color='g',transform=adesc.transAxes) # ,weight='extra bold')
                pb.text(0.42,0.95,'casa'+mylabel,color='k',transform=adesc.transAxes)
                pb.text(0.05,0.80, 'HotLoad = %.2fK' % (self.loadTemperatures[antennaId][scan]['hot']),
                        transform=adesc.transAxes,color='g')
                pb.text(0.05,0.75, 'AmbLoad = %.2fK' % (self.loadTemperatures[antennaId][scan]['amb']),
                        transform=adesc.transAxes,color='g')
                if (showAttenuators):
                    if (self.IFProc[antennaId][pol] == None or self.IFSwitch[antennaId][pol][1] == None):
                        self.readAttenuatorSettings(antennaId,pol)
                    if (scan in self.IFProc[antennaId][pol]):
                      if (self.IFProc[antennaId][pol][scan] != -1):
                        pb.text(0.05,0.85,'IFSw %.1fdB, IFPr %.1fdB'%(self.IFSwitch[antennaId][pol][self.sidebandsforspw[spw]][scan],
                                                       self.IFProc[antennaId][pol][scan][self.basebands[spw]-1]),
                            color='g',transform=adesc.transAxes)
                pb.hold(True)
            if (fdmCorrection or takeLoadsFromTdmDataset):
                if (tdmspw == None): tdmspw = spw
                if (tdmscan == None): tdmscan = scan
                if (tdmdataset == None):
                    tdmdataset = self
                tsys = tdmdataset.getTelcalTsys(antenna,tdmspw,tdmscan,pol)  # TelCal's result for the TDM spectrum
                freqHz = tdmdataset.chanfreqs[tdmspw]
                pb.plot(freqHz*1e-9, tsys, 'r-')
                y0,y1 = pb.ylim()
                pb.ylim([y0,y1+(y1-y0)*0.2])
                pb.text(0.65,0.95, 'TelCal TDM (%s)' % (mjdsecToUTHMS(np.mean(tdmdataset.timerange[tdmscan]))),
                        color='r', transform=adesc.transAxes)
                pb.text(0.60,0.90, tdmdataset.visBasename, color='r', transform=adesc.transAxes)
                tdmAntennaId, antennaName = tdmdataset.getAntenna(antenna)
                pb.text(0.60,0.80, 'HotLoad = %.2fK' % (tdmdataset.loadTemperatures[tdmAntennaId][tdmscan]['hot']),transform=adesc.transAxes,color='r')
                pb.text(0.60,0.75, 'AmbLoad = %.2fK' % (tdmdataset.loadTemperatures[tdmAntennaId][tdmscan]['amb']),transform=adesc.transAxes,color='r')
                if (showAttenuators):
                    if (tdmdataset.IFProc[antennaId][pol] == None or tdmdataset.IFSwitch[antennaId][pol][1] == None):
                        tdmdataset.readAttenuatorSettings(antennaId,pol)
#                    print "tdmdataset.IFSwitch[antennaId=%d][pol=%d] = %s" % (antennaId,pol,str(tdmdataset.IFSwitch[antennaId][pol]))
                    if (tdmscan in tdmdataset.IFProc[antennaId][pol]):
                      if (tdmdataset.IFProc[antennaId][pol][tdmscan] != -1):
                        pb.text(0.65,0.85,'IFSw %.1fdB, IFPr %.1fdB'%(tdmdataset.IFSwitch[antennaId][pol][tdmdataset.sidebandsforspw[spw]][tdmscan],
                                                       tdmdataset.IFProc[antennaId][pol][tdmscan][tdmdataset.basebands[spw]-1]),
                            color='r',transform=adesc.transAxes)
        pb.xlabel('Frequency (GHz)')
        pb.ylabel('Tsys (K)')
        if (plotrange != [0,0,0,0]):
            if (plotrange[0] != 0 or plotrange[1] != 0):
                pb.xlim(plotrange[:2])
            if (plotrange[2] != 0 or plotrange[3] != 0):
                pb.ylim(plotrange[2:])
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        ut = mjdsecToUTHMS(self.meantime[scan])
        pb.title('%s  %s  scan=%d  spw=%d  pol=%d  mean_time=%s' % (os.path.basename(self.vis), antennaName, scan, spw, pol, ut), fontsize=11)
        pb.draw()
        if (plotfile == '' or plotfile==True):
            png = os.path.basename(self.vis) + '.%s.scan%02d.spw%02d.pol%d.tsys.png' % (antennaName,scan,spw,pol)
        else:
            png = plotfile
        pb.savefig(png)
        print "Result left in ", png
        return png

    def plotTsysTrec2(self, scan, antenna, pol, spw, tdmspw=None, asdm=None, etaF=0.98,
                      lo1=None, dataFraction=[0.0, 1.0], parentms=None, verbose=False,
                      siteAltitude_m=5000, computeJsky=True, altscan=None,
                      overlayTelcal=True,
                      plotrange=[0,0,0,0], fdmCorrection=False, tdmscan=None,
                      tdmdataset=None,
                      plotfile='', showAttenuators=False, trxDifferences=None,
                      tsysDifferences=None, takeLoadsFromTdmDataset=False):
        """
        Plots Tsys in one panel and Trec2 in another panel on the same page.
        """
        spw = int(spw)
#        if ((tdmspw != None or tdmdataset != None or tdmspw != None) and takeLoadsFromTdmDataset==False):
#            if (fdmCorrection == False): print "Setting fdmCorrection to True"
#            fdmCorrection = True
        if (self.unrecognizedAntenna(antenna)): return
        if (self.unrecognizedScan(scan)): return
        if (spw == 'auto'):
            spw = self.spwsforscan[scan][0]
            print "Choosing spw = %d" % (spw)
        if (self.unrecognizedSpw(spw)): return
        antennaId, antennaName = self.getAntenna(antenna)
        antenna = antennaId
        startTime = timeUtilities.time()
        result = self.computeTsys(scan, antenna, pol, spw, tdmspw, asdm, etaF, lo1,
                                  dataFraction, parentms, verbose,
                                  siteAltitude_m, computeJsky, altscan, fdmCorrection=fdmCorrection,
                                  tdmscan=tdmscan, tdmdataset=tdmdataset,
                                  takeLoadsFromTdmDataset=takeLoadsFromTdmDataset)
        stopTime = timeUtilities.time()
        if (stopTime-startTime > 5):
            print "Computation required %.1f seconds" % (stopTime-startTime)
        if (result == None):
            return
        tsys, freqHz, trec, tsky, tcal = result
        pb.clf()
        pol = int(pol)
        freqHz = self.chanfreqs[spw]
        adesc = pb.subplot(211)
        pb.plot(freqHz*1e-9, trec, 'k-', lw=2)
#        print "Median Trec (black) = ", np.median(trec)
        if (verbose):
            print "len(freqHz) = %d,  shape(trec) = %s" % (len(freqHz), str(np.shape(trec)))
        if (overlayTelcal):
            trx_telcal = self.getTelcalTrx(antenna,spw,scan,pol)  # TelCal's result
            if (trx_telcal == None):
                print "No Trx result is available from TelCal "
                overlayTelcal = False
            else:
                pb.plot(freqHz*1e-9, trx_telcal, 'g-', lw=1)
                y0,y1 = pb.ylim()
                pb.ylim([y0,y1+(y1-y0)*0.2])
                if (fdmCorrection):
                    mylabel = ' FDM'
                else:
                    mylabel = ''
                pb.text(0.05,0.92,'TelCal'+mylabel,color='g',transform=adesc.transAxes) # ,weight='extra bold')
                pb.text(0.42,0.92,'casa'+mylabel,color='k',transform=adesc.transAxes)
                pb.hold(True)
                if (showAttenuators):
                    if (self.IFProc[antenna][pol] == None or self.IFSwitch[antenna][pol][1] == None):
                        self.readAttenuatorSettings(antenna,pol)
                    if (scan in self.IFProc[antenna][pol]):
                      if (self.IFProc[antenna][pol][scan] != -1):
                        pb.text(0.05,0.84,'IFSw %.1fdB, IFPr %.1fdB'%(self.IFSwitch[antenna][pol][self.sidebandsforspw[spw]][scan],
                                                       self.IFProc[antenna][pol][scan][self.basebands[spw]-1]),
                            color='g',transform=adesc.transAxes)
            if (fdmCorrection or takeLoadsFromTdmDataset):
                if (tdmspw == None): tdmspw = spw
                if (tdmscan == None): tdmscan = scan
                if (tdmdataset == None):
                    tdmdataset = self
                trx = tdmdataset.getTelcalTrx(antenna,tdmspw,tdmscan,pol)  # TelCal's result for the TDM spectrum
                freqHzTDM = tdmdataset.chanfreqs[tdmspw]
                pb.plot(freqHzTDM*1e-9, trx, 'r-')
                pb.text(0.65,0.92, 'TelCal TDM (%s)' % (mjdsecToUTHMS(np.mean(tdmdataset.timerange[tdmscan]))),
                        color='r', transform=adesc.transAxes)
                pb.text(0.65,0.84, tdmdataset.vis,color='r',transform=adesc.transAxes)
                trxDiff = np.median(trx)-np.median(trec)
                pb.text(0.42,0.84, 'diff %.1fK'%(trxDiff),color='k',transform=adesc.transAxes)
                if (showAttenuators):
                    if (tdmdataset.IFProc[antenna][pol] == None or tdmdataset.IFSwitch[antenna][pol][1] == None):
                        tdmdataset.readAttenuatorSettings(antenna,pol)
                    print "tdmdataset.IFSwitch[antenna][pol] = ", tdmdataset.IFSwitch[antenna][pol]
                    print "tdmdataset.IFProc[antenna][pol] = ", tdmdataset.IFProc[antenna][pol]
                    if (tdmscan in tdmdataset.IFProc[antenna][pol]):
                      if (tdmdataset.IFProc[antenna][pol][tdmscan] != -1):
                        pb.text(0.65,0.84,'IFSw %.1fdB, IFPr %.1fdB'%(tdmdataset.IFSwitch[antenna][pol][tdmdataset.sidebandsforspw[spw]][tdmscan],
                                                       tdmdataset.IFProc[antenna][pol][tdmscan][tdmdataset.basebands[spw]-1]),
                            color='r',transform=adesc.transAxes)
                        if (scan in self.IFProc[antenna][pol] and
                            scan in self.IFSwitch[antenna][pol][self.sidebandsforspw[spw]]):
                          if ((tdmdataset.IFSwitch[antenna][pol][tdmdataset.sidebandsforspw[spw]][tdmscan] ==
                             self.IFSwitch[antenna][pol][self.sidebandsforspw[spw]][scan]) and
                            (tdmdataset.IFProc[antenna][pol][tdmscan][tdmdataset.basebands[spw]-1] ==
                             self.IFProc[antenna][pol][scan][self.basebands[spw]-1])):
                            if (trxDifferences != None):
                                if (antenna not in trxDifferences['antenna'].keys()):
                                    trxDifferences['antenna'][antenna] = []
                                if (spw not in trxDifferences['spw'].keys()):
                                    trxDifferences['spw'][spw] = []
                                trxDifferences['antenna'][antenna].append(trxDiff)
                                trxDifferences['spw'][spw].append(trxDiff)
        pb.xlabel('Frequency (GHz)')
        pb.ylabel('Trec2 (K)')
        if (plotrange != [0,0,0,0]):
            if (plotrange[0] != 0 or plotrange[1] != 0):
                pb.xlim(plotrange[:2])
            if (plotrange[2] != 0 or plotrange[3] != 0):
                pb.ylim(plotrange[2:])
        else:
            if (fdmCorrection or takeLoadsFromTdmDataset):
                pb.xlim([np.min(freqHzTDM)*1e-9, np.max(freqHzTDM)*1e-9])
                # trec, trx_telcal  and if fdmCorrection, you have trx 
                pb.ylim([np.min([np.min(trec), np.min(trx), np.min(trx_telcal)]), np.max([np.max(trec),np.max(trx),np.max(trx_telcal)])])
            else:
                pb.xlim([np.min(freqHz)*1e-9, np.max(freqHz)*1e-9])
                pb.ylim([np.min([np.min(trec), np.min(trx_telcal)]), np.max([np.max(trec), np.max(trx_telcal)])])
            y0,y1 = pb.ylim()
            if (y0 < 0 and y0 > -100000 and np.median(trec)>0 and np.median(trx_telcal)>0): y0 = 0
            pb.ylim([y0,y1+(y1-y0)*0.2])

        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        ut = mjdsecToUTHMS(self.meantime[scan])
        pb.title('%s  %s  scan=%d  spw=%d  pol=%d  mean_time=%s' % (os.path.basename(self.vis), antennaName, scan, spw, pol, ut), fontsize=11)

        adesc = pb.subplot(212)
        pb.plot(freqHz*1e-9, tsys, 'k-')
        if (verbose):
            print "len(freqHz) = %d,  shape(tsys) = %s" % (len(freqHz), str(np.shape(tsys)))
        if (overlayTelcal):
            tsys_telcal = self.getTelcalTsys(antenna,spw,scan,pol)  # TelCal's result
            if (tsys_telcal == None):
                print "No Tsys result is available from TelCal "
                overlayTelcal = False
            else:
                pb.plot(freqHz*1e-9, tsys_telcal, 'g-', lw=1)
                if (fdmCorrection):
                    mylabel = ' FDM'
                else:
                    mylabel = ''
                pb.text(0.05,0.92,'TelCal'+mylabel,color='g',transform=adesc.transAxes) # ,weight='extra bold')
                pb.text(0.42,0.92,'casa'+mylabel,color='k',transform=adesc.transAxes)
                pb.hold(True)
            if (fdmCorrection or takeLoadsFromTdmDataset):
                if (tdmspw == None): tdmspw = spw
                if (tdmscan == None): tdmscan = scan
                if (tdmdataset == None):
                    tdmdataset = self
                tsysTDM = tdmdataset.getTelcalTsys(antenna,tdmspw,tdmscan,pol)  # TelCal's result for the TDM spectrum
                freqHzTDM = tdmdataset.chanfreqs[tdmspw]
                pb.plot(freqHzTDM*1e-9, tsysTDM, 'r-')
                pb.text(0.65,0.92, 'TelCal TDM (%s)' % (mjdsecToUTHMS(np.mean(tdmdataset.timerange[tdmscan]))),
                        color='r', transform=adesc.transAxes)
                tsysDiff = np.median(tsysTDM)-np.median(tsys)
                pb.text(0.42,0.84, 'diff %.1fK'%(tsysDiff),color='k',transform=adesc.transAxes)
                if (tsysDifferences != None):
                  if (scan in self.IFProc[antenna][pol] and
                      scan in self.IFSwitch[antenna][pol][self.sidebandsforspw[spw]]):
                    if ((tdmdataset.IFSwitch[antenna][pol][tdmdataset.sidebandsforspw[spw]][tdmscan] ==
                         self.IFSwitch[antenna][pol][self.sidebandsforspw[spw]][scan]) and
                        (tdmdataset.IFProc[antenna][pol][tdmscan][tdmdataset.basebands[spw]-1] ==
                         self.IFProc[antenna][pol][scan][self.basebands[spw]-1])):
                        if (antenna not in tsysDifferences['antenna'].keys()):
                            tsysDifferences['antenna'][antenna] = []
                        if (spw not in tsysDifferences['spw'].keys()):
                            tsysDifferences['spw'][spw] = []
                        tsysDifferences['antenna'][antenna].append(tsysDiff)
                        tsysDifferences['spw'][spw].append(tsysDiff)

        pb.xlabel('Frequency (GHz)')
        pb.ylabel('Tsys (K)')
        if (plotrange != [0,0,0,0]):
            if (plotrange[0] != 0 or plotrange[1] != 0):
                pb.xlim(plotrange[:2])
            if (plotrange[2] != 0 or plotrange[3] != 0):
                pb.ylim(plotrange[2:])
        else:
            if (fdmCorrection or takeLoadsFromTdmDataset):
                pb.xlim([np.min(freqHzTDM)*1e-9, np.max(freqHzTDM)*1e-9])
                pb.ylim([np.min([np.min(tsys), np.min(tsys_telcal), np.min(tsysTDM)]), np.max([np.max(tsys),np.max(tsys_telcal),np.max(tsysTDM)])])
            else:
                pb.xlim([np.min(freqHz)*1e-9, np.max(freqHz)*1e-9])
                pb.ylim([np.min([np.min(tsys), np.min(tsys_telcal)]), np.max([np.max(tsys),np.max(tsys_telcal)])])
            y0,y1 = pb.ylim()
            if (y0 < 0 and y0 > -100000): y0 = 0
            pb.ylim([y0,y1+(y1-y0)*0.2])
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        ut = mjdsecToUTHMS(self.meantime[scan])
        pb.draw()
        if (plotfile == '' or plotfile==True):
            png = os.path.basename(self.vis) + '.%s.scan%02d.spw%02d.pol%d.tsys_trx.png' % (antennaName,scan,spw,pol)
        else:
            png = plotfile
        pb.savefig(png)
        print "Result left in ", png
        return png

    def computeTsys(self, scan, antenna, pol, spw, tdmspw=None, asdm=None, etaF=0.98, lo1=None,
                    dataFraction=[0.0, 1.0], parentms=None, verbose=False,
                    siteAltitude_m=5000, computeJsky=True, altscan=None, ignoreFlags=False,
                    calscandict=None, fdmCorrection=False, tdmscan=None, tdmdataset=None,
                    takeLoadsFromTdmDataset=False, showplot=False):
        """
        tdmspw:  the spw from which to get the total power in order to apply fdmCorrection
        tdmscan: the scan from which to get the data from the tdmspw in order to apply fdmCorrection
        tdmdataset: the Atmcal instance for the dataset containing the TDM scans
        takeLoadsFromTdmDataset: set to True to use the hot/amb from one dataset, and sky from another
            So, to compute new TDM Tsys for dataset1 using the TDM hot/amb from dataset2,
            set tdmdataset=Atmcal(dataset2), self=Atmcal(dataset1), with fdmCorrection=False.
        """
        spw = int(spw)
        if (spw == 'auto'):
            spw = self.spwsforscan[scan][0]
            print "Choosing spw = %d" % (spw)
        if (self.unrecognizedAntenna(antenna)): return
        if (self.unrecognizedScan(scan)): return
        if (self.unrecognizedSpw(spw)): return
        if (spw not in self.spwsforscan[scan]):
            print "spw %d is not in scan %d.  Available spws are: %s" % (spw, scan, str(self.spwsforscan[scan]))
            return
        result = self.computeTrec2(scan, antenna, pol, spw, tdmspw,
                                   asdm, etaF, lo1,dataFraction,
                                   parentms, verbose, siteAltitude_m,
                                   computeJsky, altscan,ignoreFlags=ignoreFlags,
                                   calscandict=calscandict, fdmCorrection=fdmCorrection,
                                   tdmscan=tdmscan, tdmdataset=tdmdataset,
                                   takeLoadsFromTdmDataset=takeLoadsFromTdmDataset, showplot=showplot)
        if (result == None):
            print "No result from computeTrec2()"
            return(None)
        trec, gain, tsky, freqHz, tcal, tsys = result
        return(tsys, freqHz, trec, tsky, tcal)

    def computeTrec2(self, scan, antenna, pol, spw, tdmspw=None, asdm=None, etaF=0.98, lo1=None,
                     dataFraction=[0.0, 1.0], parentms=None, verbose=False,
                     siteAltitude_m=5000, computeJsky=False, altscan=None,ignoreFlags=False,
                     calscandict=None, fdmCorrection=False, tdmscan=None, tdmdataset=None,
                     takeLoadsFromTdmDataset=False, showplot=False):
        """
        compute Trec and saturation parameter from a 2-load measurement
        the formula is
        p = G * (tRec+t)
        """
        spw = int(spw)
        # Need to check if this table is present before getting the spectrum, because 
        # there is no point if it will fail later.
        mytable = self.vis+'/ASDM_CALATMOSPHERE'
        if (os.path.exists(mytable) == False):
            print "Could not find table = %s" % (mytable)
            print "Did you importasdm with asis='CalAtmosphere' ?"
            return
        if (self.unrecognizedAntenna(antenna)): return
        if (self.unrecognizedScan(scan)): return
        if (self.unrecognizedSpw(spw)): return
        antennaId, antennaName = self.getAntenna(antenna)
        p0 = self.getSpectrum(scan,spw,pol,'amb',antennaId,dataFraction,ignoreFlags=ignoreFlags)
        p1 = self.getSpectrum(scan,spw,pol,'hot',antennaId,dataFraction,ignoreFlags=ignoreFlags)
        sky = self.getSpectrum(scan,spw,pol,'sky',antennaId,dataFraction,ignoreFlags=ignoreFlags)
        if (takeLoadsFromTdmDataset):
            tdmAntennaId, antennaName = tdmdataset.getAntenna(antennaName)
            print "Translated %s from id=%d in one dataset to %d in the other (%s)" % (antennaName,antennaId,tdmAntennaId,antennaName)
            amb = tdmdataset.getSpectrum(tdmscan,tdmspw,pol,'amb',tdmAntennaId,dataFraction,ignoreFlags=ignoreFlags)
            hot = tdmdataset.getSpectrum(tdmscan,tdmspw,pol,'hot',tdmAntennaId,dataFraction,ignoreFlags=ignoreFlags)
            scalingFactor = np.median(amb)/np.median(p0)
            p0 = amb
            p1 = hot
            print "Applying scaling factor %f = %.2f dB to the sky subscan." % (scalingFactor, 10*np.log10(scalingFactor))
            sky *= scalingFactor
        if (fdmCorrection):
            if (tdmscan == None): tdmscan = scan
            if (tdmspw == None): tdmspw = spw
            if (tdmdataset == None):
                tdmdataset = self
            tdmSpectrumAmb = tdmdataset.getSpectrum(tdmscan,tdmspw,pol,'amb',antennaId,dataFraction,ignoreFlags=ignoreFlags)
            tdmSpectrumHot = tdmdataset.getSpectrum(tdmscan,tdmspw,pol,'hot',antennaId,dataFraction,ignoreFlags=ignoreFlags)
            tdmSpectrumSky = tdmdataset.getSpectrum(tdmscan,tdmspw,pol,'sky',antennaId,dataFraction,ignoreFlags=ignoreFlags)
            p0 = self.applyCorrectionToFDMSpectrum(p0, tdmSpectrumAmb, tdmSpectrumAmb)
            p1 = self.applyCorrectionToFDMSpectrum(p1, tdmSpectrumHot, tdmSpectrumHot)
            sky = self.applyCorrectionToFDMSpectrum(sky, tdmSpectrumSky, tdmSpectrumSky)
        if (type(p0) != np.ndarray and type(p0) != np.ma.core.MaskedArray):
            print "type(p0) = %s, len(p0) = %d" % (str(type(p0)), len(p0))
            return None
        result = self.computeJs(scan, antenna, pol, spw, asdm, etaF, lo1,
                                dataFraction, parentms, verbose, siteAltitude_m,
                                computeJsky, altscan=altscan, calscandict=calscandict)
        if (result == None):
            return None
        if (computeJsky):
            skyResult, t0, t1, freqHz, jatmDSB, jspDSB, jbg, tauA, alpha, gb = result
            tcal, tsys = self.solveTsys(p1,p0,sky, jatmDSB, jbg, gb, alpha, tauA)
        else:
            skyResult, t0, t1, freqHz = result
        a = t1*p0-t0*p1
        c = p1-p0
        b = t1-t0
        trec = a/c
        gain = c/b
        tsky = sky/gain - trec
        if (showplot):
            freqGHz = freqHz*1e-9
            pb.clf()
            pb.plot(freqGHz, sky, 'b-', freqGHz, p0, 'k-', freqGHz, p1, 'r-')
            pb.xlabel('Frequency (GHz)')
            pb.ylabel('Counts')
            pb.title('blue = sky,  red = hot_load,  black = ambient_load')
            pb.draw()
        if (computeJsky):
            return(trec, gain, tsky, freqHz, tcal[0], tsys[0])
        else:
            return(trec, gain, tsky, freqHz)

    def plotTrec2All(self, spw, tdmspw=None, asdm=None, etaF=0.98, lo1=None,
                     dataFraction=[0.0, 1.0], parentms=None, siteAltitude_m=5000):
        spw = int(spw)
        pngs = []
        if (self.unrecognizedSpw(spw)): return
        for scan in self.scans:
            print "Working on scan ", scan
            for antenna in self.antennas:
                print "Working on antenna %d/%d" % (antenna+1,len(self.antennas))
                for pol in range(2):
                    png = self.plotTrec2(scan,antenna,pol,spw, tdmspw, asdm, etaF, lo1,
                                         dataFraction, parentms, siteAltitude_m=siteAltitude_m)
                    if (png != None):
                        pngs.append(png)
        buildPdfFromPngs(pngs, pdfname='%s.trec2.pdf'%(self.vis))
                     
    def plotTsysTrec2All(self, spw=None, tdmspw=None, asdm=None, antennas=None, etaF=0.98, lo1=None,
                         dataFraction=[0.0, 1.0], parentms=None, siteAltitude_m=5000,
                         fdmCorrection=False, tdmscan=None, tdmdataset=None, showAttenuators=False):
        if (spw != None):
            spw = int(spw)
            if (self.unrecognizedSpw(spw)): return
            spws = [spw]
        else:
            spws = self.spws
        pngs = []
        if (antennas==None):
            antennas = self.antennas
        trxDifferences = {'antenna': {}, 'spw':{}}
        tsysDifferences = {'antenna': {}, 'spw':{}}
        for spw in spws:
          for scan in self.scans:
            print "Working on scan ", scan
            for antenna in antennas:
                print "Working on spw %d antenna %s (%d/%d)" % (spw, self.antennaNames[antenna], antenna+1,len(self.antennas))
                for pol in range(2):
                    png = self.plotTsysTrec2(scan,antenna,pol,spw, tdmspw, asdm, etaF, lo1,
                                             dataFraction, parentms, siteAltitude_m=siteAltitude_m,
                                             fdmCorrection=fdmCorrection, tdmscan=tdmscan,
                                             tdmdataset=tdmdataset, showAttenuators=showAttenuators,
                                             trxDifferences=trxDifferences, tsysDifferences=tsysDifferences)
                    if (png != None):
                        pngs.append(png)
        buildPdfFromPngs(pngs, pdfname='%s.tsys_trx.pdf'%(self.vis))
        for spw in spws:
          if (spw in trxDifferences['spw']):
            print "               25%ile  median  75%ile"
            print "Trx: spw %02d = %.2f  %.2f  %.2fK" % (spw,scoreatpercentile(trxDifferences['spw'][spw],25),
                                                         np.median(trxDifferences['spw'][spw]),
                                                         scoreatpercentile(trxDifferences['spw'][spw],75))
            print "Tsys spw %02d = %.2f  %.2f  %.2fK" % (spw,scoreatpercentile(tsysDifferences['spw'][spw],25),
                                                         np.median(tsysDifferences['spw'][spw]),
                                                         scoreatpercentile(tsysDifferences['spw'][spw],75))
        for antenna in antennas:
          if (antenna in trxDifferences['antenna']):
            print "Trx: antenna %02d (%s) = %.2f  %.2f  %.2fK" % (antenna,self.antennaNames[antenna],
                                                                  scoreatpercentile(trxDifferences['antenna'][antenna],25),
                                                                  np.median(trxDifferences['antenna'][antenna]),
                                                                  scoreatpercentile(trxDifferences['antenna'][antenna],75))
            print "Tsys antenna %02d (%s) = %.2f  %.2f  %.2fK" % (antenna,self.antennaNames[antenna],
                                                                  scoreatpercentile(tsysDifferences['antenna'][antenna],25),
                                                                  np.median(tsysDifferences['antenna'][antenna]),
                                                                  scoreatpercentile(tsysDifferences['antenna'][antenna],75))
                                                                  
        return(trxDifferences, tsysDifferences)
    
    def plotTrec2(self, scan, antenna, pol, spw, tdmspw=None, asdm=None, etaF=0.98,
                  lo1=None, dataFraction=[0.0, 1.0], parentms=None, 
                  siteAltitude_m=5000, altscan=None, overlayTelcal=True,
                  fdmCorrection=False, tdmscan=None, tdmdataset=None, plotfile='',
                  showAttenuators=False):
#        if (tdmspw != None or tdmdataset != None or tdmspw != None):
#            fdmCorrection = True
        spw = int(spw)
        if (self.unrecognizedAntenna(antenna)): return
        if (self.unrecognizedScan(scan)): return
        if (spw == 'auto'):
            spw = self.spwsforscan[scan][0]
            print "Choosing spw = %d" % (spw)
        if (self.unrecognizedSpw(spw)): return
        antennaId, antennaName = self.getAntenna(antenna)
#        pb.text(0.65, 0.93, 'fractional portion of subscan used', transform=adesc.transAxes)
        if (overlayTelcal):
            trx = self.getTelcalTrx(antenna,spw,scan,pol)  # TelCal's result
            if (trx == None):
                overlayTelcal = False
        result = self.computeTrec2(scan, antenna, pol, spw, tdmspw, asdm=None,
                                   etaF=etaF, lo1=None, dataFraction=dataFraction,
                                   parentms=None, siteAltitude_m=5000, altscan=altscan,
                                   fdmCorrection=fdmCorrection, tdmscan=tdmscan,
                                   tdmdataset=tdmdataset)
        if (result == None):
            return(None)
        trec, gain, tsky, freqHz = result 
        pb.clf()
        adesc = pb.subplot(111)
        freqHz = self.chanfreqs[spw]
        pb.plot(freqHz*1e-9, trec, 'k-')
        pb.text(0.82, 0.85-c*0.07, '[%.2f,%.2f]' % (dataFraction[0],dataFraction[1]),
                color='k', transform=adesc.transAxes)
        pb.xlabel('Frequency (GHz)')
        pb.ylabel('Trec2(K)')
        ylims=pb.ylim()
#        if (ylims[0] < 0):
#            pb.ylim([0,ylims[1]])
        if (overlayTelcal):
            pb.hold(True)
            if (fdmCorrection):
                lw = 1
            else:
                lw = 3
            pb.plot(freqHz*1e-9, trx, 'g-', lw=lw)
            print "mean residual = ", np.mean(trx-trec)
            if (fdmCorrection):
                mylabel = ' FDM'
            else:
                mylabel = ''
            pb.text(0.05,0.95, 'TelCal'+mylabel, color='g', transform=adesc.transAxes)
            pb.text(0.42,0.95, 'casa'+mylabel, color='k', transform=adesc.transAxes)
            if (showAttenuators):
                if (self.IFProc[antenna][pol] == None or self.IFSwitch[antenna][pol][1] == None):
                    self.readAttenuatorSettings(antenna,pol)
                if (scan in self.IFProc[antenna][pol]):
                  if (self.IFProc[antenna][pol][scan] != -1):
                    pb.text(0.05,0.85,'IFSw %.1fdB, IFPr %.1fdB'%(self.IFSwitch[antenna][pol][self.sidebandsforspw[spw]][scan],
                                                   self.IFProc[antenna][pol][scan][self.basebands[spw]-1]),
                        color='g',transform=adesc.transAxes)
            if (fdmCorrection):
                if (tdmspw == None): tdmspw = spw
                if (tdmscan == None): tdmscan = scan
                if (tdmdataset == None):
                    tdmdataset = self
                trx = tdmdataset.getTelcalTrx(antenna,tdmspw,tdmscan,pol)  # TelCal's result for the TDM spectrum
                freqHz = tdmdataset.chanfreqs[tdmspw]
                pb.plot(freqHz*1e-9, trx, 'r-')
                y0,y1 = pb.ylim()
                if (y0 < 0 and y0 > -100000): y0 = 0
                pb.ylim([y0,y1+(y1-y0)*0.2])
                pb.text(0.65,0.95, 'TelCal TDM (%s)' % (mjdsecToUTHMS(np.mean(tdmdataset.timerange[tdmscan]))),
                        color='r', transform=adesc.transAxes)
                if (showAttenuators):
                    if (tdmdataset.IFProc[antenna][pol] == None or tdmdataset.IFSwitch[antenna][pol][1] == None):
                        tdmdataset.readAttenuatorSettings(antenna,pol)
                    if (tdmscan in tdmdataset.IFProc[antenna][pol]):
                      if (tdmdataset.IFProc[antenna][pol][tdmscan] != -1):
                        pb.text(0.65,0.85,'IFSw %.1fdB, IFPr %.1fdB'%(tdmdataset.IFSwitch[antenna][pol][tdmdataset.sidebandsforspw[spw]][tdmscan],
                                                       tdmdataset.IFProc[antenna][pol][tdmscan][tdmdataset.basebands[spw]-1]),
                            color='r',transform=adesc.transAxes)
        ut = mjdsecToUTHMS(self.meantime[scan])
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        pb.title('%s  %s  scan=%d  spw=%d  pol=%d  mean_time=%s' % (os.path.basename(self.vis), antennaName, scan, spw, pol, ut), fontsize=11)
        if (plotfile == '' or plotfile==True):
            png = '%s.%s.scan%02d.spw%02d.pol%d.trec2.png' % (os.path.basename(self.vis), antennaName, scan, spw, pol)
        else:
            png = plotfile
        print "Result left in ", png
        pb.savefig(png)
        pb.draw()
        return(png)
                  
    def computeTrec3(self, scan, antenna, pol, spw, asdm=None, etaF=0.98, lo1=None,
                     dataFraction=[0.0, 1.0], parentms=None, verbose=False,
                     altscan=None, calscandict=None):
        """
        This function is not really used in TelCal.
        Trec and saturation parameter from a 3-load measurement.
        the formula is
             p = G * (tRec+t) / (1+s*t)
        """
        spw = int(spw)
        if (self.unrecognizedAntenna(antenna)): return
        if (self.unrecognizedScan(scan)): return
        if (self.unrecognizedSpw(spw)): return
        antennaId, antennaName = self.getAntenna(antenna)
        t0, t1, t2, freqHz = self.computeJs(scan, antenna, pol, spw, asdm, etaF, lo1,
                                            dataFraction, parentms, verbose,
                                            computeJsky=True, altscan=altscan, calscandict=calscandict)
        
        p0 = self.getSpectrum(scan,spw,pol,'sky',antennaId,dataFraction)
        p1 = self.getSpectrum(scan,spw,pol,'amb',antennaId,dataFraction)
        p2 = self.getSpectrum(scan,spw,pol,'hot',antennaId,dataFraction)
        a = p0*p1*t2*(t0-t1) + p1*p2*t0*(t1-t2) + p2*p0*t1*(t2-t0)
        c = p0*p1*(t1-t0) + p1*p2*(t2-t1) + p2*p0*(t0-t2)
        b = p0*t0*(t2-t1) + p1*t1*(t0-t2) + p2*t2*(t1-t0)
        d = p0*(t1-t2) + p1*(t2-t0) + p2*(t0-t1)
        # taken from aos-gns:/alma/ACS-12.0/ACSSW/Sources/xercesc/src/xerces-c-src_2_8_0/tests/XSValueTest/XSValueTest.cpp
        if (True):
            trec = a/c
            gain = c/b
            saturation = d/b
        else:
            DBL_MIN = 2.2250738585072014e-308
            if (fabs(c)>DBL_MIN):
                trec = a/c
            else:
                trec=999999
                gain=DBL_MIN
            if (fabs(b)>DBL_MIN and fabs(c)>DBL_MIN):
                saturation    = d/b
                gain = c/b
            else:
                saturation = 0
                gain = DBL_MAX
        pb.clf()
        adesc = pb.subplot(111)
        trx = self.getTelcalTrx(antenna,spw,scan,pol)
        pb.plot(freqHz*1e-9, trec, 'k-', freqHz*1e-9, trx, 'r-')
        pb.xlabel('Frequency (GHz)')
        pb.ylabel('Trec3(K)')
        print "Median Trx=%f" % (np.median(trec))
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(self.vis)
        ut = mjdsecToUTHMS(np.mean(mymsmd.timesforscan(scan)))
        mymsmd.close()
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        pb.title('Trec3  %s  %s  scan=%d  pol=%d  time=%s' % (os.path.basename(self.vis), antennaName, scan, pol, ut), fontsize=11)
        pb.text(0.5,0.95,'red=TelCal result', transform=adesc.transAxes)
        pb.text(0.5,0.9,'mean=%f'%(np.mean(trec)),transform=adesc.transAxes)
        pb.savefig('%s.scan%d.pol%d.trec3.png' % (os.path.basename(self.vis), scan,pol))
        pb.draw()
        return(trec, saturation, gain)

    def solveTsys(self, pHot,pAmb,pSky,jatm,jbg,gb,alpha,tauA) :
        pRef = 0
        tCal  = jatm-jbg
        if (len(jatm) > 1):
            tCal += (gb[1]/gb[0])*np.exp(-tauA[1]+tauA[0])*(jatm[1]-jbg[1])
        pLoad = alpha*pHot+(1-alpha)*pAmb
        tSys  = tCal*(pSky-pRef)/(pLoad-pSky)
        return tCal,tSys
        
    def solveAlpha(self, jHot, jAmb, jAtm, jspDSB, etaF):
        alpha = (etaF*jAtm-jAmb+(1-etaF)*jspDSB) / (jHot-jAmb)
        return(alpha)
        
    def computeJs(self, scan, antenna, pol, spw, asdm=None, etaF=0.98, lo1=None,
                  dataFraction=[0.0, 1.0], parentms=None, verbose=False,
                  siteAltitude_m=5000, computeJsky=False, altscan=None, calscandict=None):
        """
        compute Jamb, Jhot, and optionally Jsky
        """
        numSideband = 2
        antennaId, antennaName = self.getAntenna(antenna)
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(self.vis)
        baseband = mymsmd.baseband(spw)
        result = getCalAtmosphereInfo(self.vis, scan=scan, antenna=antennaName, pol=pol,
                                      baseband=baseband, debug=verbose, altscan=altscan,
                                      calscandict=calscandict)
        if (result == None and altscan == 'auto'):
            scanlist = sorted(list(self.scans))
            scanindex = scanlist.index(scan)
            if (scanindex==0):
                altscan = scanlist[1]
            else:
                altscan = scanlist[scanindex-1]
            print "Choosing altscan=%d" % (altscan)
            result = getCalAtmosphereInfo(self.vis, scan=scan, antenna=antennaName, pol=pol,
                                          baseband=baseband, debug=verbose, altscan=altscan,
                                          calscandict=calscandict)
        if (result == None): return
        myIndex = result[10]
        if (len(myIndex) > 1):
            print "More than 1 row returned.  Be more specific in your selection"
            return
        if (len(myIndex) == 0):
            print "No rows match these values."
            return
        sbGains = result[0]
        gb = [sbGains, 1-sbGains]  # signal, image
        mjdsec = result[4]
        row = 0
        net_sideband = mymsmd.sideband(spw)
        field = mymsmd.fieldsfortimes([mjdsec[row]])[0]
        freq_signal_tdm = mymsmd.chanfreqs(spw)
        if (casadef.casa_version >= '4.2.0'):
            tdm_chanwidth = mymsmd.chanwidths(spw)[0]
        else:
            if (len(freq_signal_tdm) == 1):
                tdm_chanwidth = 2e9
            else:
                tdm_chanwidth = freq_signal_tdm[1]-freq_signal_tdm[0]
        refFreq = freq_signal_tdm[0]-0.5*tdm_chanwidth
#        if (highres):
#            fdm_chanwidth = abs(mymsmd.chanfreqs(fdmspw)[1]-mymsmd.chanfreqs(fdmspw)[0]) * tdm_chanwidth/abs(tdm_chanwidth)
#            freq_signal_fdm = np.arange(refFreq, freq_signal_tdm[-1]+0.5*tdm_chanwidth, fdm_chanwidth)
#            chans_fdm = range(len(freq_signal_fdm))
        mymsmd.close()
        
        chans_tdm = range(len(freq_signal_tdm))
        mydirection = getRADecForField(self.vis, field)
        myazel = computeAzElFromRADecMJD(mydirection, mjdsec[row]/86400., self.telescopeName, verbose=False)
        airmass = elevationToAirmass(myazel[1]*180./np.pi)
        if (verbose):
            print "Using airmass = %f" % (airmass)
        water = result[6]
        pwv = water[row]
        antenna_id = result[1][row]
        if (antenna_id != antennaName):
            print "Mismatch in antenna ID!  antenna_id=%s, antennaId=%s" % (str(antenna_id), antennaName)
            return
        groundPressure = result[7][row]
        groundTemperature = result[8][row]
        groundRelHumidity = result[9][row]
        Tatm = groundTemperature
        frequency = []
        tebbsky = []
        if (computeJsky):
#            if (highres):
#                freq, chans, transmission, tebb, opacity = \
#                      CalcAtmosphere(chans_fdm, freq_signal_fdm*1e-9, pwv, 
#                                     refFreq, net_sideband, groundPressure,
#                                     groundRelHumidity, Tatm, airmass, siteAltitude_m=siteAltitude_m)
#            else:
            freq, chans, transmission, tebb, opacity = \
                      CalcAtmosphere(chans_tdm, freq_signal_tdm*1e-9, pwv, 
                                     refFreq, net_sideband, groundPressure,
                                     groundRelHumidity, Tatm, airmass, siteAltitude_m=siteAltitude_m)
            tauA = []
            tebbsky.append(tebb)
            tauA.append(opacity)
            frequency.append(freq*1e9)
        else:
            frequency.append(freq_signal_tdm)
        getLOsStatus = getLOs(self.vis)
        if (getLOsStatus != []):
            lo1s = interpretLOs(self.vis, parentms)
            if (lo1s == None): return
            if (spw not in lo1s):
                print "spw map returned by interpretLOs is suspect!"
                LO1 = lo1s[lo1s.keys()[-1]]
            else:
                LO1 = lo1s[spw]
            if (verbose):
                print "Found LO1 = %f" % (LO1)
        elif (lo1 != None):
            LO1 = lo1
        else:
            print "Could not find LO1"
            return
        refFreq_image = 2*LO1 - refFreq
        freq_image_tdm = 2*LO1 - freq_signal_tdm
        if (computeJsky):
#            if (highres):
#                freq_image_fdm = 2*LO1 - freq_signal_fdm
#                freq, chans, transmission, tebb, opacity = \
#                      CalcAtmosphere(chans, freq_image_fdm*1e-9, pwv,
#                                     refFreq_image, net_sideband, groundPressure,
#                                     groundRelHumidity, Tatm, airmass, siteAltitude_m=siteAltitude_m)
#            else:
            freq, chans, transmission, tebb, opacity = \
                      CalcAtmosphere(chans, freq_image_tdm*1e-9, pwv,
                                     refFreq_image, net_sideband, groundPressure,
                                     groundRelHumidity, Tatm, airmass, siteAltitude_m=siteAltitude_m)
            frequency.append(freq*1e9)
            tebbsky.append(tebb)
            tauA.append(opacity)  # tauA means tau(Zenith)*Airmass
            jem = frequency*0 # initialize an array to zero
        else:
            frequency.append(freq_image_tdm)
        frequency = np.array(frequency)
        jSky = 0; jAmb = 0; jHot = 0
        jatmDSB = 0
        jspDSB = 0
        jbg = frequency*0 # initialize an array to zero
        jem = frequency*0 # initialize an array to zero
        jsp = frequency*0 # initialize an array to zero
        jatm = frequency*0 # initialize an array to zero
        cosmicBackgroundTemp = Tcmb
        ambLoad = self.loadTemperatures[antennaId][scan]['amb']
        hotLoad = self.loadTemperatures[antennaId][scan]['hot']
        for iside in range(numSideband):
            hvk = h*np.mean(frequency[iside])/k  # telcal uses the frequency of the middle channel
            if (computeJsky):
                expMinusTau = np.exp(-tauA[iside])
                jebb = hvk/(np.exp(hvk/tebbsky[iside])-1)
                jbg[iside] = hvk/(np.exp(hvk/cosmicBackgroundTemp)-1)
                jem[iside] = jebb - jbg[iside]*expMinusTau
                jsp[iside] = hvk/(np.exp(hvk/groundTemperature)-1)
                jatm[iside] = (jebb - jbg[iside]*expMinusTau) / (1.-expMinusTau)
                jSky += gb[iside]*(etaF*jem[iside] + (1.-etaF)*jsp[iside])
                jatmDSB += gb[iside]*jatm[iside]
                jspDSB += gb[iside]*jsp[iside]
            jAmb += gb[iside]*hvk/(np.exp(hvk/ambLoad)-1)
            jHot += gb[iside]*hvk/(np.exp(hvk/hotLoad)-1)
        if (verbose):
            print "gainratio=%f, ambLoad=%f, hotLoad=%f, means: jSky=%f, jAmb=%f, jHot=%f" % (gb[0], ambLoad, hotLoad, np.mean(jSky),np.mean(jAmb),np.mean(jHot))
        if (computeJsky):
            alpha = self.solveAlpha(jHot, jAmb, jatmDSB, jspDSB, etaF)
            return(jSky, jAmb, jHot, frequency[0], jatmDSB, jspDSB, jbg, tauA, alpha, gb)
        else:
            return(jSky, jAmb, jHot, frequency[0])
        # end of computeJs()
# end of class Atmcal

def checkSamplers(vis, state_id=None, ac=None, spws=None, threshold1=1.25, threshold2=2.0,
                  maxChannel=3, maxScan=None, useMedian=False):
    """
    Gets the TDM full-resolution spws for a dataset, finds the sky subscan timerange
    of each ATM cal scan, and computes the ratio of channel zero to the median (or
    minimum) of channels 1-3 (or otherwise specified).  Ratios above the specified
    threshold are indicated with asterisks.

    state_id: the state_id number to use for the sky subscan (default: row with REF=1,SIG=0)
    ac: the Atmcal instance to use (default=None which means create a new one)
    spws: the spws to consider (default=None which means use all spws)
    threshold1: if ratio is above this, then print one pair of asterisks
    threshold2: if ratio is above this, then print two pairs of asterisks
    maxChannel: adjust the upper bound of the block of channels to take the median of
    maxScan: the highest scan number to consider (default=None which means use all scans)
    useMedian: default=False, if True, then take the median of channels 1..maxChannel as
               the denominator of the ratio, otherwise take the mininum
    Return values:
    dictionary of ratios, keyed by antenna name, then baseband number (1..4)
    -Todd Hunter
    """
    if (ac == None):
        ac = Atmcal(vis)
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    if (spws == None):
        if (casadef.subversion_revision < casaRevisionWithAlmaspws):
            index1 = mymsmd.tdmspws()
            index2 = mymsmd.chanavgspws()
            index1 = np.setdiff1d(index1,index2)
        else:
            index1 = mymsmd.almaspws(tdm=True)
        index2 = mymsmd.spwsforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
        spws = np.intersect1d(index1,index2)
    elif (type(spws) == int):
        spws = [spws]
    print "Processing spws = ", spws
    scans = []
    band = getBand(mymsmd.chanfreqs(spws[0])[0])
    field = mymsmd.fieldsforspw(spws[0])[0]
    antennaNames = mymsmd.antennanames(range(mymsmd.nantennas()))
    basebands = {}
    uniqueBasebands = []
    scansforspw = {}
    for spw in spws:
        index1 = mymsmd.scansforspw(spw)
        index2 = mymsmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
        scansforspw[spw] = list(np.intersect1d(index1,index2))
        scans += scansforspw[spw]
        basebands[spw] = mymsmd.baseband(spw)
        if (basebands[spw] not in uniqueBasebands):
            uniqueBasebands.append(basebands[spw])
    scans = np.unique(np.array(scans))
    if (maxScan != None):
        scans = list(scans[np.where(scans <= maxScan)[0]])
        if (len(scans) < 1):
            print "No scans within the specified value of maxScan=%d" % (maxScan)
            return
    print "Processing scans = ", scans
    mymsmd.close()
    timerange = ''
    for scan in scans:
        if (scan in ac.timestampsString.keys()):
            if (len(timerange) > 0):
                timerange += ','
            timerange += ac.timestampsString[scan][ac.skysubscan]
    scan=','.join([str(a) for a in scans])
    spw = ','.join([str(a) for a in spws])
    if (state_id == None):
        state_id = str(ac.stateID_off_source[0])
    elif (state_id == []):
        state_id = None
    else:
        state_id = str(state_id)
    v = Visibility(vis,antenna1=0,antenna2=0,spwID=spws[0],correctedData=False,
                   scan=scans[0],cross_auto_all='auto',autoSubtableQuery=True,
                   state=state_id)
    print "using state id = ", v.getState()
    ratio = {}
    pols = [0,1] # assume both are present (for now)
    for ant1 in range(len(antennaNames)):
        ratio[ant1] = {}
        for baseband in uniqueBasebands:
            ratio[ant1][baseband] = {}
            for pol in pols:
                ratio[ant1][baseband][pol] = []
            
    for ant1 in range(len(antennaNames)):
        print "Working on antenna %d/%d" % (ant1+1,len(antennaNames))
        v.autoSubtableQuery = False
        v.setAntennaPair(ant1,ant1)
        for spwID in spws:
            v.autoSubtableQuery = False
            v.setSpwID(spwID)
            myscans = np.intersect1d(scans,scansforspw[spwID])
            for scan in myscans:
              v.autoSubtableQuery = True
              try:
                v.setScan(scan)
                d = v.amp
                if (len(d) < 1):
                    print "ant%d spw%d scan%d has zero length data" % (ant1,spwID,scan)
                else:
                    for pol in pols:
                        if (len(d[pol]) < 1):
                            print "ant%d  spw%d scan%d pol%d has zero length data" % (ant1,spwID,scan,pol)
                        else:
                            if (useMedian):
                                myratio = d[pol][0] / np.median(d[pol][1:maxChannel+1])
                            else:
                                myratio = d[pol][0] / np.min(d[pol][1:maxChannel+1])
                            ratio[ant1][basebands[spwID]][pol].append(myratio)
              except:
                  print "Antenna %d, spw %d: no data for scan " % (ant1,spwID), scan
                  continue
    print "Band %d   %s   %s" % (band,os.path.basename(vis),getObservationStartDate(vis))
    print "Ratio of Channel 0 to the median of channels 1~%d in auto-correlation spectra" % (maxChannel)
    outline = "Antenna "
    for baseband in uniqueBasebands:
        for pol in pols:
            outline += " BB%dpol%d  " % (baseband-1,pol)
    print outline
    mydict = {}
    for ant1 in range(len(antennaNames)):
        mydict[antennaNames[ant1]] = {}
        outline = "%2d=%4s" % (ant1,antennaNames[ant1])
        for baseband in uniqueBasebands:
            mydict[antennaNames[ant1]][baseband] = []
            for pol in pols:
                myratio = np.median(ratio[ant1][baseband][pol])
                mydict[antennaNames[ant1]][baseband].append(myratio)
                npts = len(ratio[ant1][baseband][pol])
                outline += " "
                if (myratio > threshold2):
                    if (myratio >= 100):
                        outline += "**%4.1f**" % (myratio)
                    else:
                        outline += "**%5.2f**" % (myratio)
                elif (myratio > threshold1):
                    if (myratio >= 100):
                        outline += " *%4.1f* " % (myratio)
                    else:
                        outline += " *%5.2f* " % (myratio)
                else:
                    outline += "  %5.2f  " % (myratio)
        print outline
    return(mydict)
    # end of class AtmCal
    
class AtmStates:
    """
    This class is essentially defunct since the table contents were changed
    circa 2011. See the new class Atmcal.
    -Stuartt Corder
    """
    def __init__(self,inputMs):
        self.inputMs = inputMs
        tb.open('%s/STATE' % self.inputMs)
        self.loadTemps    = tb.getcol("LOAD")+273.15
        self.stateIntents = tb.getcol("OBS_MODE")
        tb.close()
        self.atmSky = []
        self.atmRef = []
        self.atmHot = []
        self.atmAmb = []
        self.atmScans = []
        self.antennaNames = getAntennaNames(self.inputMs)
        self.antennaInfo  = {}
        self.numAtmCals = 0
        for i in self.antennaNames:
            self.antennaInfo[i] = {'AMB' : {'state' : [], 'loadTemp' : []},
                                   'HOT' : {'state' : [], 'loadTemp' : []},
                                   'REF' : {'state' : []},
                                   'SKY' : {'state' : []}
                                   }
        self.getAtmCalTargetStates()
        self.associateStateWithAntenna()

    def getAtmCalTargetStates(self) :
        for i in range(len(self.stateIntents)) :
            if "CALIBRATE_ATMOSPHERE.OFF_SOURCE" in self.stateIntents[i]:
                self.atmSky.append(i)
            if "CALIBRATE_ATMOSPHERE.REFERENCE"  in self.stateIntents[i]:
                self.atmRef.append(i)
            if "CALIBRATE_ATMOSPHERE.ON_SOURCE"  in self.stateIntents[i] and self.loadTemps[i] > 330 : self.atmHot.append(i)
            if "CALIBRATE_ATMOSPHERE.ON_SOURCE"  in self.stateIntents[i] and self.loadTemps[i] < 330 : self.atmAmb.append(i)

    def associateStateWithAntenna(self) :
        self.antennaInfo  = {}
        for i in self.antennaNames:
            self.antennaInfo[i] = {'AMB' : {'state' : [], 'loadTemp' : []},
                                   'HOT' : {'state' : [], 'loadTemp' : []},
                                   'REF' : {'state' : []},
                                   'SKY' : {'state' : []}
                                   }
        visTemp = Visibility(self.inputMs,antenna1=None,antenna2=None,
                             spwID=None,state=None)

        for i in self.atmAmb :
            try:
                visTemp.setState(i)
                ant1 = visTemp.subtable.getcol('ANTENNA1')
                ant2 = visTemp.subtable.getcol('ANTENNA2')
                goodIndex = np.where(ant1 == ant2)[0]
                goodIndex = list(goodIndex)
                antennaIds = np.unique(ant1[goodIndex])
                for j in antennaIds :
                    antName = self.antennaNames[j]
                    antName = getAntennaNames(self.inputMs)[j]
                    self.antennaInfo[antName]['AMB']['state'].append(i)
                    self.antennaInfo[antName]['AMB']['loadTemp'].append(self.loadTemps[i])
            except:
                continue
        for i in self.atmHot :
            try:
                visTemp.setState(i)
                ant1 = visTemp.subtable.getcol('ANTENNA1')
                ant2 = visTemp.subtable.getcol('ANTENNA2')
                goodIndex = np.where(ant1 == ant2)[0]
                goodIndex = list(goodIndex)
                antennaIds = np.unique(ant1[goodIndex])
                for j in antennaIds :
                    antName = self.antennaNames[j]
                    self.antennaInfo[antName]['HOT']['state'].append(i)
                    self.antennaInfo[antName]['HOT']['loadTemp'].append(self.loadTemps[i])
            except:
                continue
        for i in self.atmRef :
            try:
                visTemp.setState(i)
                ant1 = visTemp.subtable.getcol('ANTENNA1')
                ant2 = visTemp.subtable.getcol('ANTENNA2')
                goodIndex = np.where(ant1 == ant2)[0]
                goodIndex = list(goodIndex)
                antennaIds = np.unique(ant1[goodIndex])
                for j in antennaIds :
                    antName = self.antennaNames[j]
                    self.antennaInfo[antName]['REF']['state'].append(i)
            except:
                continue
        for i in self.atmSky :
            try:
               visTemp.setState(i)
               ant1 = visTemp.subtable.getcol('ANTENNA1')
               ant2 = visTemp.subtable.getcol('ANTENNA2')
               goodIndex = np.where(ant1 == ant2)[0]
               goodIndex = list(goodIndex)
               antennaIds = np.unique(ant1[goodIndex])
               for j in antennaIds :
                   antName = self.antennaNames[j]
                   self.antennaInfo[antName]['SKY']['state'].append(i)
            except:
                continue

class processDVTiltMeter:
    def __init__(self,dvTiltmeterFile,outFile=None):
        self.dvTiltmeterFile = dvTiltmeterFile
        self.fulltable = fiop.fileToTable(dvTiltmeterFile,keepType=True)
        self.columns   = fiop.getInvertTable(self.fulltable)
        self.oldtime   = self.columns[0]
        self.time = np.array(convertTimeStamps(self.columns[0]))
        self.time = self.time-self.time[0]
        self.antenna = self.columns[1]
        self.an0    = np.array(self.columns[2])
        self.aw0    = np.array(self.columns[3])
        self.x     = np.array(self.columns[4])
        self.y     = np.array(self.columns[5])
        self.t1    = np.array(self.columns[6])
        self.t2    = np.array(self.columns[7])
        if outFile <> None :
            self.outFile = outFile
            self.fitT2Trend()
            self.removeTrend()
            self.writeResiduals()

    def fitT1Trend(self) :
        self.px = polyfit(self.t1,self.x,1)
        self.py = polyfit(self.t1,self.y,1)
        self.newX=polyval(self.px,self.t1)
        self.newY=polyval(self.py,self.t1)

    def fitT2Trend(self) :
        self.px = polyfit(self.t2,self.x,1)
        self.py = polyfit(self.t2,self.y,1)
        self.newX=polyval(self.px,self.t2)
        self.newY=polyval(self.py,self.t2)

    def removeTrend(self) :
        self.x = self.newX-self.x
        self.y = self.newY-self.y

    def restoreTrend(self) :
        self.x = self.x+self.newX
        self.y = self.y+self.newY

    def plotTime(self) :
        return
    def plotT1(self) :
        return
    def plotT2(self) : 
        return

    def writeResiduals(self) :
        f = open(self.outFile,'w')
        for i in range(len(self.antenna)) :
            f.write("%s %s %f %f %f %f %f %f\n" % (self.oldtime[i],self.antenna[i],self.an0[i],self.aw0[i],self.newX[i],self.newY[i],self.t1[i],self.t2[i]) )
        f.close()
        
def fixMyDelays(asdm,caltableName=None,vis=None,doImport=True,sign=1) :
    """
    This function will extract the TelCal solutions for delay and generate a
    calibration table, which is useful if the solutions were not applied during
    observations.
    This version will handle single or multiple receiver bands in the ASDM.
    There are two main use cases for this command:
      1) If you have already run importasdm with asis='*', then you don't 
         need to specify the asdm, only the ms:
         fixMyDelays('','my.delaycal',vis='uid.ms',False)
     2) If you want to use this function as a wrapper for importasdm, then 
        you can say:  fixMyDelays('uid__blah_blah',None,None,True)
     The optional 'sign' parameter can be used to flip the sign if and when 
     someone changes the sign convention in TelCal.
    - Todd Hunter
    """
    asis = '*'
    if (len(asdm) > 0):
        [asdm,dir] = locate(asdm)
        print "asdm = %s" % (asdm)
    if (vis == None):
        vis = "%s.ms" % asdm.split('/')[-1]
        print "vis = %s" % (vis)
    elif (len(vis) < 1):
        vis = "%s.ms" % asdm.split('/')[-1]
        print "vis = %s" % (vis)
    if (caltableName == None) or (len(caltableName) < 1):
        if (len(asdm) == 0):
            caltableName = "%s.delaycal" % (vis)
        else:
            caltableName = "%s.delaycal" % asdm.split('/')[-1]
    if doImport : importasdm(asdm=asdm,asis=asis,vis=vis,overwrite=True)
    antennaIds = getAntennaNames(vis)
    bbands     = getBasebandAndBandNumbers(vis)
#    print bbands
    tb.open("%s/ASDM_CALDELAY" % vis)
    antennaNames = tb.getcol("antennaName")
    if (len(antennaNames) < 1):
        print "The ASDM_CALDELAY table has no data.  Delay correction cannot be done."
        return
    delayOffsets = tb.getcol("delayOffset")
    basebands    = tb.getcol("basebandName") # format is 'BB_1'
#    print "basebands = ", basebands
    rxbands    = tb.getcol("receiverBand")    # format is 'ALMA_RB_%02d'
#    print "rxbands = ", rxbands
    polList = tb.getcol("polarizationTypes")  # e.g. X or Y or ...
    tb.close()
    outList = []
    spwNames = []
    rxBands = []
    for j in bbands:
        rxName = "ALMA_RB_%02d" % (j[0])
        rxBands.append(j[0])
        bbName = "BB_%i" % (j[1])
        spwNames.append("%d"%j[2])
#        print "bbName=%s, rxName=%s" % (bbName, rxName)
        for i in antennaIds :
#            print "ith antenna = ", i
            ant = np.where(antennaNames == i)
            bb  = np.where(basebands == bbName)
            rx  = np.where(rxbands == rxName)
#            ind = np.intersect1d_nu(ant,bb)
            newlist = np.intersect1d(ant[0],bb[0])
            newlist = np.intersect1d(newlist,rx[0])
#            print "newlist = ", newlist
            ind = np.unique(newlist)
#            print "ind = ", ind
            if (sign < 0):
                print "Applying the reverse sign of the delays to %s, ant %s" %(bbName,i)
            p  = sign*delayOffsets[:,ind].mean(1)*1e9
            for k in p :
                outList.append(k)
    parameter = outList
    pol = ''
    print "polList[:,0] = ", polList[:,0]
    print "spws = ", spwNames
    print "rx bands = ", rxBands
    for k in range(len(polList[:,0])):
        pol += "%s," % (polList[:,0][k])
    pol = pol[:-1]
    
    antenna   = ",".join(np.unique(antennaNames))
    spw       = ",".join(spwNames)
    print "Removing any old caltable = %s." % (caltableName)
    os.system('rm -rf %s'%(caltableName))
    print "Calling gencal('%s','%s','sbd','%s','%s','%s')" % (vis,caltableName,spw,antenna,pol)
    gencal(vis=vis,caltable=caltableName,caltype='sbd',spw=spw,antenna=antenna,pol=pol,parameter=parameter)
    # end of fixMyDelays
            
def getUniqueBasebandNumbers(inputMs) :
    """
    Returns the list of baseband numbers in the specified ms.
    """
    tb.open("%s/SPECTRAL_WINDOW" % inputMs)
    bb = tb.getcol("BBC_NO")
    tb.close()
    return np.unique(bb)

def freqToBand(freq):
    """
    Returns the ALMA band integer that can observe the specified frequency.
    It will accept either a single frequency or a list (in Hz).
    It is kind of a kludge until something better is devised.
    Called only by getBasebandAndBandNumbers and plotMosaic.
    See also getBand().
    """
    band = []
    if (type(freq) != list):
        freq = [freq]
    for f in freq:
        if (f > 750e9):
            band.append(10)
        elif (f > 550e9):
            band.append(9)
        elif (f > 379e9):
            band.append(8)
        elif (f > 275e9):
            band.append(7)
        elif (f > 211e9):
            band.append(6)
        elif (f > 163e9):
            band.append(5)
        elif (f > 120e9):
            band.append(4)
        elif (f > 84e9):
            band.append(3)
        elif (f > 60e9):
            band.append(2)
        elif (f > 30e9):
            band.append(1)
    return(band)
        
def getBasebandAndBandNumbers(inputMs) :
# new experimental version to try to deal with band 6/9 phase transfer data
# which uses a bit of a kludge to convert freq to receiverBand
# return orderedlist:  rxBand, baseBand, spw
    tb.open("%s/SPECTRAL_WINDOW" % inputMs)
    bb = tb.getcol("BBC_NO")
    freq = tb.getcol("REF_FREQUENCY")
    numchan = tb.getcol("NUM_CHAN")
    tbw = tb.getcol("TOTAL_BANDWIDTH")
    band = freqToBand(freq)
    pair = []
    for i in range(len(band)):
        # remove the channel-average spws and the WVR spws
        if (numchan[i] > 1 and tbw[i] < 7e9):
            pair.append((band[i],bb[i],i))
    tb.close()
    return np.unique(pair)

def getSpwsForBaseband(mymsmd,bb):
    """
    This emulates msmd.spwsforbaseband() for older versions of casa that
    do not contain this method.  
    mymsmd: either an instance of an existing msmd tool, or the name of a
            measurement set
    bb: baseband number
    -Todd Hunter
    """
    needToClose = False
    if (type(mymsmd) == str):
        vis = mymsmd
        if (os.path.exists(vis) == False):
            print "First argument must be either an msmd instance or the name of a measurement set."
            return
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        needToClose=True
    if (casadef.subversion_revision >= '25612'):
        spws = mymsmd.spwsforbaseband(bb)
    else:
        spws = []
        for spw in range(mymsmd.nspw()):
            if (bb == mymsmd.baseband(spw)):
                spws.append(spw)
    if (needToClose):
        mymsmd.close()
    return(spws)
    
def getBasebands(mymsmd):
    """
    Takes an msmd tool instance and builds a list of basebands corresponding 
    to the list of spws.
    Todd Hunter
    """
    basebands = []
    for spw in range(mymsmd.nspw()):
        basebands.append(mymsmd.baseband(spw))
    return(basebands)
        
def getBasebandAndBandNumbersTest(inputMs) :
# New experimental version to try to deal with band 6/9 phase transfer data
# which tries to determine receiverBand properly, but seems to be impossible.
# return orderedlist:  rxBand, baseBand, spw
# Todd Hunter
    tb.open("%s/SPECTRAL_WINDOW" % inputMs)
    bb = tb.getcol("BBC_NO")
    numchan = tb.getcol("NUM_CHAN")
    tbw = tb.getcol("TOTAL_BANDWIDTH")
    tb.close()
    tb.open("%s/ASDM_RECEIVER" % inputMs)
    spws = tb.getcol('spectralWindowId')
    bands = tb.getcol('frequencyBand')
    tb.close()
    pair = []
    band = []
    for i in range(len(numchan)):
      window = ('SpectralWindow_%d'%(i))
      print "window = ", window
      findspw = np.where(spws==window)
      if (len(findspw) > 0):
        print "findspw = ", findspw
        band.append(bands[findspw[0][0]])
        # remove the channel-average spws and the WVR spws
        if (numchan[i] > 1 and tbw[i] < 7e9):
            pair.append((band[i],bb[i],i))
    return np.unique(pair)

def printLOs(ms, parentms='', showWVR=False,
             showCentralFreq=False, verbose=False, alsoReturnLO2=False):
    """
    Print the LO settings for an MS.
    Options:
    showCentralFreq: if True, then show the mean frequency of each spw,
                     otherwise show the frequency of the first channel
    showWVR: include the WVR spw in the list
    parentms:  if the dataset has been split from a parent dataset, then
               you may also need to specify the name of the parent ms.
    alsoReturnLO2: if True, return a second dictionary of the LO2 values
    
    Returns: a dictionary of the LO1 values (in Hz) for each spw, keyed by
             integer.  This function will warn if the Band 6 YIG can leak
             into the spw (i.e. LO2 between 10.5-11.3 GHz).
             
    For further help and examples, see:
         https://safe.nrao.edu/wiki/bin/view/ALMA/PrintLOs
    - Todd Hunter
    """
    return(interpretLOs(ms, parentms, showWVR, showCentralFreq, 
                        verbose, show=True, alsoReturnLO2=alsoReturnLO2))

def interpretLOs(ms, parentms='', showWVR=False,
                 showCentralFreq=False, verbose=False, show=False, alsoReturnLO2=False):
    """
    Interpret (and optionally print) the LO settings for an MS.
    Options:
    showCentralFreq: if True, then show the mean frequency of each spw,
                     otherwise show the frequency of the first channel
    showWVR: include the WVR spw in the list
    parentms:  if the dataset has been split from a parent dataset, then
               you may also need to specify the name of the parent ms.
    alsoReturnLO2: if True, return a second dictionary of the LO2 values
    
    Returns: a dictionary of the LO1 values (in Hz) for each spw, keyed by
             integer.  

    A typical band 7 TDM dataset (prior to splitting) looks like this:
    SPECTRAL_WINDOW table has 39 rows:   row
           WVR                           0
           8 band 3 windows (pointing)   1-8
           8 band 7 windows              9-16
           22 WVR windows                17-38
    The corresponding ASDM_RECEIVER table has only 18 rows:
           WVR                           0
           8 band 3 windows              1-8
           WVR                           9          
           8 band 7 windows              10-17
    After splitting, the ASDM_RECEIVER table remains the same, but the 
    SPECTRAL WINDOW table then has only 4 rows, as the pointing spws and 
    the channel-averaged data are dropped:
           4 band 7 windows               

    Todd Hunter
    """
    lo1s = {} # initialize dictionary to be returned
    lo2s = {}
    try:
        retval =  getLOs(ms)
        [LOs,bands,spws,names,sidebands,receiverIds,spwNames] = retval
#        spws typically is =  [0,1,2,3,4,5,6,7,8,0,9,10,11,12,13,14,15,16]
    except:
        print "getLOs failed"
        return(retval)
    if (verbose): print "len(spws) = %d: %s" % (len(spws), str(spws))
    # find gap in spectralWindowId numbering in ASDM_RECEIVER
    gap = 0
    maxSpw = np.max(spws)
    for i in range(len(spws)):
        if (spws[i] > 0):
            if (verbose): print "Found gap at i=%d" % (i)
            gap = spws[i] - i
            break
    if (verbose): print "gap = ", gap
    for i in range(len(spws)):
        if (spws[i] > 0):
            if (verbose):
                print "Renaming spw%d to spw%d" % (spws[i],spws[i]-gap)
            spws[i] -= gap
    index = range(len(spws))

    tb.open(ms+'/SPECTRAL_WINDOW')
    # If the data have been split into an ms with fewer spws, then this 
    # table will be smaller (in rows) than the parent MS's table.
    spwNames = tb.getcol('NAME')
    tb.close()
    splitted = False
    if (maxSpw != len(spwNames)-1):
        splitted = True
        if (verbose): 
            print "maxSpw=%d != len(spwNames)=%d)" % (maxSpw, len(spwNames))
        if (parentms == '' or parentms == None):
            print "You appear to have split these data.  Please provide the parentms as an argument."
            return
        tb.open(parentms+'/SPECTRAL_WINDOW')
        parentSpwNames = tb.getcol('NAME')
        tb.close()
        extractedRows = []
        index = []
        for s in range(len(spwNames)):
            if (len(spwNames[s]) == 0):
                print "This is an old dataset lacking values in the NAME column of the SPECTRAL_WINDOW table."
                return
            if (verbose): 
                print "Checking for %s in " % (spwNames[s]), parentSpwNames
            extractedRows.append(np.where(parentSpwNames == spwNames[s])[0][0])
            index.append(spws.index(extractedRows[-1]))
            if (verbose): 
                print "spw %d came from spw %d" % (s, extractedRows[-1])
# extractedRows = the row of the parent SPECTRAL_WINDOW table that matches 
#                 the split-out spw
#     index = the row of the ASDM_RECEIVER table that matches the split-out spw
        ms = parentms
    if (verbose): 
        print "spwNames = ", spwNames
        print "spws = ", spws
        print "bands = ", bands
        output = "LOs = "
        for LO in LOs:
            output += "%.3f, " % (LO[0]*1e-9)
        print output
        print "names = ", names
        print "index = ", index

    bbc = getBasebandNumbers(ms)
    if (show): 
        print 'Row refers to the row number in the ASDM_RECEIVER table (starting at 0).'
        if (showCentralFreq):
            print 'Row spw BB RxBand CenFreq Nchan LO1(GHz) LO2(GHz) Sampler YIG(GHz) TFBoffset(MHz)'
        else:
            print 'Row spw BB RxBand Ch1Freq Nchan LO1(GHz) LO2(GHz) Sampler YIG(GHz) TFBoffset(MHz)'

    # Loop over all rows in the ASDM_RECEIVER table, unless we've split, in 
    # which case this will loop over the N spws in the table.
    if (casadef.casa_version >= '4.1.0'):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(ms)
    for i in range(len(index)):
        if (verbose): 
            print "index[%d]=%d" % (i,index[i])
            print "spws[%d] = %d" % (index[i], spws[index[i]])
        myspw = spws[index[i]]
        if (casadef.casa_version >= '4.1.0'):
            freqs = mymsmd.chanfreqs(myspw)
            meanFreqGHz = mymsmd.meanfreq(myspw) * (1e-9)
        else:
            freqs = getFrequencies(ms,myspw) * (1e-9)
            meanFreqGHz = np.mean(freqs)
        if (bands[index[i]].split('_')[-1].isdigit()):
            rxband = bands[index[i]].split('_')[-1]
        elif (showWVR):
            rxband = 'WVR'
        else:
            continue
        line = "%2d  %2d  %d %3s " % (spws.index(myspw), myspw, bbc[myspw], rxband)
        if (showCentralFreq):
            line += "%10.6f %4d " % (meanFreqGHz,len(freqs))
        else:
            line += "%10.6f %4d " % (freqs[0],len(freqs))
        if (receiverIds[index[i]] != 0):
            # receiverIds > 0 seem to be bogus repeats of spws
            continue
        if (LOs[index[i]][0] < 0):
            print line
            continue
        if (bbc[myspw] > 0):
            if (splitted):
                lo1s[i] = LOs[index[i]][0]
                lo2s[i] = LOs[index[i]][1]
            else:
                lo1s[myspw] = LOs[index[i]][0]
                lo2s[myspw] = LOs[index[i]][1]
            for j in range(len(LOs[index[i]])):
                if (j != 2):
                    line = line + '%10.6f' % (LOs[index[i]][j]*1e-9)
                else:
                    line = line + '%5.2f' % (LOs[index[i]][j]*1e-9)
        yig = LOs[index[i]][0] / yigHarmonic(bands[index[i]])
        if (yig > 0):
            line = line + ' %.6f' % (yig*1e-9)
        if (len(freqs) > 256):
            # work out what LO4 must have been
            LO1 = LOs[index[i]][0]
            LO2 = LOs[index[i]][1]
            LO3 = LOs[index[i]][2]
            if (sidebands[index[i]][0] == 'USB'):
                IFlocation = LO3 - (LO2 - (meanFreqGHz*1e9 - LO1))
            else:
                IFlocation = LO3 - (LO2 - (LO1 -  meanFreqGHz*1e9))
            LO4 = 2e9 + IFlocation
            TFBLOoffset = LO4-3e9
            line += '%9.3f %+8.3f' % (LO4 * 1e-6,  TFBLOoffset * 1e-6)
            
        if (bands[index[i]] == 'ALMA_RB_06' or bands[index[i]] == 'ALMA_RB_09'):
            if (len(LOs[index[i]]) > 1):
                if (LOs[index[i]][1] < 11.3e9 and LOs[index[i]][1] > 10.5e9):
                    line = line + ' leakage of LO2 undesired sideband may degrade dynamic range'
                    if (bands[index[i]] == 'ALMA_RB_06'):
                        line += ' (and YIG may leak in)'
                    yigLeakage = LOs[index[i]][0] + (LOs[index[i]][1] - LOs[index[i]][2]) + (yig - LOs[index[i]][1])
                    if (yigLeakage > 0):
                        line = line + ' at %.6f' % (yigLeakage*1e-9)
        if (show): print line
    if (casadef.casa_version >= '4.1.0'):
        mymsmd.done()
    if (alsoReturnLO2):
        return(lo1s, lo2s)
    else:
        return(lo1s)

def yigHarmonic(bandString):
    """
    Returns the YIG harmonic for the specified ALMA band, given as a string 
    used in casa tables, or an integer.
    For example:  yigHarmonic('ALMA_RB_03')  returns the integer 6.
    Todd Hunter
    """
    # remove any leading spaces
    #bandString = bandString[bandString.find('ALMA_RB'):]
    if (bandString in [3,4,6,7,8,9]):
        bandString = 'ALMA_RB_%02d' % bandString
    harmonics = {'ALMA_RB_03':6, 'ALMA_RB_04':6, 'ALMA_RB_06': 18, 
                 'ALMA_RB_07': 18, 'ALMA_RB_08':18, 'ALMA_RB_09':27}
    try:
        harmonic = harmonics[bandString]
    except:
        harmonic = -1
    return(harmonic)

def printLOsFromASDM(sdmfile, spw='', showCentralFreq=False, showYIG=True):
    """
    Prints the values of LO1, LO2 and the TFB LO offset (if applicable).  If no
    spw is specified, then it prints the values for all spws in the ASDM.
    For further help and examples, see
    https://safe.nrao.edu/wiki/bin/view/ALMA/PrintLOsFromASDM
    Todd Hunter
    """
    if (os.path.exists(sdmfile)==False):
        print "Could not find this ASDM file = %s." % (sdmfile)
        return
    if (spw != ''):
      if (type(spw) == list):
        spw = spw
      elif (type(spw) == str):
        a = spw.split(',')
        spw = [int(x) for x in a]
      else:
        spw = [int(spw)]
    scandict = getLOsFromASDM(sdmfile)
    scandictspw = getSpwsFromASDM(sdmfile)
    if (showCentralFreq):
        line = "spw BB# Chan RxId CenFrq(GHz) LO1(GHz)  LO2(GHz) Sampler"
    else:
        line = "spw BB# Chan RxId Ch1Frq(GHz) LO1(GHz)  LO2(GHz) Sampler"
    if (showYIG):
        line += '  YIG(GHz)'
    line += ' TFBoffset(MHz)'
    
    print line

    # find gap in spectral window numbering in Receiver.xml
    gap = 0
    for i in range(len(scandict)):
        if (scandict[i]['spectralWindowId'] > 0):
            gap = scandict[i]['spectralWindowId']-1
            break
    for j in range(len(scandictspw)):
      # find spw
      myspw = -1
      for i in range(len(scandict)):
          if (scandictspw[j]['spectralWindowId'] == scandict[i]['spectralWindowId']):
              myspw = i
              break
      if (myspw < 0):
            continue
      if (spw == '' or j in spw):
        if (j >= gap+1):  
            myline =  " %2d %2d " % (scandict[myspw]['spectralWindowId']-gap,
                                     scandictspw[j]['basebandNumber'])
        else:
            myline =  " %2d %2d " % (scandict[myspw]['spectralWindowId'],
                                     scandictspw[j]['basebandNumber'])
        if (scandict[myspw]['frequencyBand'].split('_')[-1].isdigit()):
            rxband = scandict[myspw]['frequencyBand'].split('_')[-1]
        else:
            rxband = 'WVR'
        myline += '%4d  %3s ' % (scandictspw[j]['numChan'],
#                                  scandict[myspw]['receiverId'])
                                  rxband)
        if (showCentralFreq):
            myline += '%10.6f  ' % (1e-9*scandictspw[j]['centerFreq'])
        else:
            myline += '%10.6f  ' % (1e-9*scandictspw[j]['chanFreqStart'])
        if (scandictspw[j]['basebandNumber'] == 0):
            # don't show (irrelevant) LO for WVR
            print myline
            continue
        for i in range(scandict[myspw]['numLO']):
            if (i<2):
                myline += '%10.6f' % (scandict[myspw]['freqLO'][i]*1e-9)
            else:
                myline += '%5.2f' % (scandict[myspw]['freqLO'][i]*1e-9)
        if (showYIG):
            yigHarm = yigHarmonic(scandict[myspw]['frequencyBand'])
            yig = 1e-9 * scandict[myspw]['freqLO'][0] / (yigHarm*1.0)
            myline += '%10.6f' % yig
        if (scandictspw[j]['numChan'] > 256):
            # work out what LO4 must have been
            LO1 = scandict[myspw]['freqLO'][0]
            LO2 = scandict[myspw]['freqLO'][1]
            LO3 = scandict[myspw]['freqLO'][2]
            if (scandictspw[j]['sideband'] > 0):
                IFlocation = LO3 - (LO2 - (scandictspw[j]['centerFreq'] - LO1))
            else:
                IFlocation = LO3 - (LO2 - (LO1 - scandictspw[j]['centerFreq']))
            LO4 = 2e9 + IFlocation
            TFBLOoffset = LO4-3e9
            myline += '%9.3f %+8.3f' % (LO4 * 1e-6,  TFBLOoffset * 1e-6)
        print myline
    
def getLOsFromASDM(sdmfile):
    """
    Returns a dictionary of the LO values for every spw in the specified ASDM.
    Dictionary contents: numLO, freqLO, spectralWindowId.  freqLO is itself a
    list of floating point values.
    Todd Hunter
    """
    if (os.path.exists(sdmfile) == False):
        print "getLOsFromASDM(): Could not find file = ", sdmfile
        return
    xmlscans = minidom.parse(sdmfile+'/Receiver.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    for rownode in rowlist:
        scandict[fid] = {}
        rownumLO = rownode.getElementsByTagName("numLO")
        numLO = int(rownumLO[0].childNodes[0].nodeValue)
        rowfreqLO = rownode.getElementsByTagName("freqLO")
        rowreceiverId = rownode.getElementsByTagName("receiverId")
        receiverId = int(rowreceiverId[0].childNodes[0].nodeValue)
        rowfrequencyBand = rownode.getElementsByTagName("frequencyBand")
        frequencyBand = str(rowfrequencyBand[0].childNodes[0].nodeValue)
        freqLO = []
        r = filter(None,(rowfreqLO[0].childNodes[0].nodeValue).split(' '))
        for i in range(2,len(r)):
            freqLO.append(float(r[i]))
        
        rowspwid = rownode.getElementsByTagName("spectralWindowId")
        spwid = int(str(rowspwid[0].childNodes[0].nodeValue).split('_')[1])
        scandict[fid]['spectralWindowId'] = spwid
        scandict[fid]['freqLO'] = freqLO
        scandict[fid]['numLO'] = numLO
        scandict[fid]['receiverId'] = receiverId
        scandict[fid]['frequencyBand'] = frequencyBand
        fid +=1
    return(scandict)

def getNumChanFromASDM(sdmfile):
    """
    Gets the number of channels of each spw from an ASDM.
    -Todd Hunter
    """
    spws = getSpwsFromASDM(sdmfile)
    for spw in spws:
        print "%2d: %4d" % (spw, spws[spw]['numChan'])

def getMeanFreqFromASDM(sdmfile, minnumchan=64):
    """
    Gets the mean frequency of the spectral windows for each sideband, assuming
    that the bandwidth of each spw is the same.  Useful for holography data.
    Returns:
    dictionary of the form: {'lsb': {'meanfreq': meanfreq, 'spws': nspws},
                             'usb': {'meanfreq': meanfreq, 'spws': nspws},
                             'mean': {'meanfreq': meanfreq, 'spws': nspws}}
    -Todd Hunter
    """
    mydict = getSpwsFromASDM(sdmfile, minnumchan)
    lsb = []
    usb = []
    for spw in mydict:
        if (mydict[spw]['sideband'] == -1):
            lsb.append(mydict[spw]['centerFreq'])
        elif (mydict[spw]['sideband'] == 1):
            usb.append(mydict[spw]['centerFreq'])
    mydict = {'lsb': {'meanfreq': np.mean(lsb), 'spws': len(lsb)},
              'usb': {'meanfreq': np.mean(usb), 'spws':len(usb)},
              'mean': {'meanfreq': np.mean([np.mean(usb),np.mean(lsb)]),
                       'spws':len(usb)+len(lsb)}
              }
    return(mydict)

def getSpwsFromASDM(sdmfile, minnumchan=0):
    """
    Returns a dictionary of the spw information for every spw in the specified
    ASDM.  Dictionary contents: spectralWindowId, numChan, refFreq, sideband,
    centerFreq.
    minnumchan: only return information on those spws with at least this many channels
    Todd Hunter
    """
    if (os.path.exists(sdmfile) == False):
        print "getSpwsFromASDM(): Could not find file = ", sdmfile
        return
    xmlscans = minidom.parse(sdmfile+'/SpectralWindow.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    for rownode in rowlist:
        rowspwid = rownode.getElementsByTagName("spectralWindowId")
        spwid = int(str(rowspwid[0].childNodes[0].nodeValue).split('_')[1])
        rownumLO = rownode.getElementsByTagName("numChan")
        numChan = int(rownumLO[0].childNodes[0].nodeValue)
        if (numChan < minnumchan): continue
        scandict[fid] = {}
        rownumLO = rownode.getElementsByTagName("refFreq")
        refFreq = float(rownumLO[0].childNodes[0].nodeValue)
        rownumNOBB = rownode.getElementsByTagName("basebandName")
        noBB = rownumNOBB[0].childNodes[0].nodeValue
        scandict[fid]['spectralWindowId'] = spwid
        scandict[fid]['numChan'] = numChan
        scandict[fid]['refFreq'] = refFreq
        if (noBB == 'NOBB'):
            scandict[fid]['basebandNumber'] = 0
        else:
            scandict[fid]['basebandNumber'] = int(noBB.split('_')[-1])
        try:
            rownumLO = rownode.getElementsByTagName("chanFreqStart")
            chanFreqStart = float(rownumLO[0].childNodes[0].nodeValue)
            rownumLO = rownode.getElementsByTagName("chanFreqStep")
            chanFreqStep = float(rownumLO[0].childNodes[0].nodeValue)
            if ((numChan % 2) == 1):
                centerFreq = chanFreqStart + (numChan/2)*chanFreqStep
            else:
                centerFreq = chanFreqStart + (numChan-1)*0.5*chanFreqStep
        except:
            try:
                rownumLO = rownode.getElementsByTagName("chanFreqArray")
                r = filter(None,(rownumLO[0].childNodes[0].nodeValue).split(' '))
                freqLO = []
                for i in range(2,len(r)):
                    freqLO.append(float(r[i]))
                centerFreq = np.mean(freqLO)
                chanFreqStart = freqLO[0]
            except:
                print "Did not find chanFreqStart nor chanFreqArray on row=%d, spw=%d" % (fid,spwid)
                scandict[fid]['centerFreq'] = 0
                continue
        scandict[fid]['centerFreq'] = centerFreq
        scandict[fid]['chanFreqStart'] = chanFreqStart
        if (refFreq > centerFreq):
            scandict[fid]['sideband'] = -1
        else:
            scandict[fid]['sideband'] = +1
        fid +=1
    return(scandict)

def getLOs(inputMs, verbose=True):
    """
    Reads the LO information from an ms's ASDM_RECEIVER table.  It returns
    a list of four lists: [freqLO,band,spws,names]
    The logic for converting this raw list into sensible association with
    spw numbers is in printLOs().

    Todd Hunter
    """
    if (os.path.exists(inputMs)):
        if (os.path.exists("%s/ASDM_RECEIVER" % inputMs)):
            try:
                tb.open("%s/ASDM_RECEIVER" % inputMs)
            except:
                print "Could not open the existing ASDM_RECEIVER table"
                return([])
        else:
            if (os.path.exists(inputMs+'/ASDMBinary')):
                print "This is an ASDM, not an ms!"
            else:
                if (verbose):
                    print "The ASDM_RECEIVER table for this ms does not exist."
            return([])
    else:
        print "This ms does not exist = %s." % (inputMs)
        return([])
        
    numLO = tb.getcol('numLO')
    freqLO = []
    band = []
    spws = []
    names = []
    sidebands = []
    receiverIds = []
    for i in range(len(numLO)):
        freqLO.append(tb.getcell('freqLO',i))
        band.append(tb.getcell('frequencyBand',i))
        spws.append(int((tb.getcell('spectralWindowId',i).split('_')[1])))
        names.append(tb.getcell('name',i))
        sidebands.append(tb.getcell('sidebandLO',i))
        receiverIds.append(int(tb.getcell('receiverId',i)))
    tb.close()
    tb.open("%s/SPECTRAL_WINDOW" % inputMs)
    spwNames = tb.getcol("NAME")
    tb.close()
    return([freqLO,band,spws,names,sidebands,receiverIds,spwNames])
    
def mjdVectorToUTHours(mjd):
    return(24*(np.modf(mjd)[0]))

def mjdSecondsVectorToMJD(mjdsec):
    return(mjdsec / 86400.0)

def call_qa_time(arg, form='', prec=0, showform=False):
    """
    This is a wrapper for qa.time(), which in casa 4.0.0 returns a list 
    of strings instead of just a scalar string.  
    - Todd Hunter
    """
    if (type(arg) == dict):
        if (type(arg['value']) == list or 
            type(arg['value']) == np.ndarray):
            if (len(arg['value']) > 1):
                print "WARNING: call_qa_time() received a dictionary containing a list of length=%d rather than a scalar. Using first value." % (len(arg['value']))
            arg['value'] = arg['value'][0]
    result = qa.time(arg, form=form, prec=prec, showform=showform)
    if (type(result) == list or type(result) == np.ndarray):
        return(result[0])
    else:
        return(result)

def call_qa_angle(arg, form='', prec=0, showform=False):
    """
    This is a wrapper for qa.angle(), which in casa 4.0.0 returns a list 
    of strings instead of just a scalar string.  
    - Todd Hunter
    """
    if (type(arg) == dict):
        if (type(arg['value']) == list or 
            type(arg['value']) == np.ndarray):
            if (len(arg['value']) > 1):
                print "WARNING: call_qa_angle() received a dictionary containing a list of length=%d rather than a scalar. Using first value." % (len(arg['value']))
            arg['value'] = arg['value'][0]
    result = qa.angle(arg, form=form, prec=prec, showform=showform)
    if (type(result) == list or type(result) == np.ndarray):
        return(result[0])
    else:
        return(result)

def getMJD():
    """
    Returns the current MJD.  See also getCurrentMJDSec().
    -Todd
    """
    myme = createCasaTool(metool)
    mjd = me.epoch('utc','today')['m0']['value']
    myme.done()
    return(mjd)
    
def mjdListToDateTime(mjdList):
    """
    Takes a list of mjd values and converts it to a list of datetime 
    structures.
    - Todd Hunter
    """
    return(mjdSecondsListToDateTime(np.array(mjdList)*86400.0))
    
def mjdSecondsListToDateTime(mjdsecList):
    """
    Takes a list of mjd seconds and converts it to a list of datetime 
    structures.
    - Todd Hunter
    """
    me = createCasaTool(metool)
    dt = []
    typelist = type(mjdsecList)
    if not (typelist == list or typelist == np.ndarray):
        mjdsecList = [mjdsecList]
    for mjdsec in mjdsecList:
        today = me.epoch('utc','today')
        mjd = mjdsec / 86400.
        today['m0']['value'] =  mjd
        hhmmss = call_qa_time(today['m0'])
        date = qa.splitdate(today['m0'])  # date is now a dict
        timeString = '%d-%d-%d %d:%d:%d.%06d'%(date['monthday'],date['month'],date['year'],date['hour'],date['min'],date['sec'],date['usec'])
        mydate = datetime.datetime.strptime(timeString,'%d-%m-%Y %H:%M:%S.%f')
        # previous implementation truncated to nearest second!
#        mydate = datetime.datetime.strptime('%d-%d-%d %d:%d:%f'%(date['monthday'],date['month'],date['year'],date['hour'],date['min'],date['s']),'%d-%m-%Y %H:%M:%S')
        dt.append(mydate)
    return(dt)

def mjdToPredictcomp(MJD):
    """
    Converts an MJD into a string suitable for the epoch parameter of
    predictcomp:
    i.e., 2011-12-31-5:34:12
    -- Todd Hunter
    """
    mystring = mjdsecToUT(MJD*86400)
    tokens = mystring.split()
    return(tokens[0]+'-'+tokens[1])
    
def mjdToJD(MJD):
    """
    Converts an MJD value to JD
    """
    JD = MJD + 2400000.5
    return(JD)

def ymdhmsToMJD(year,month,day,hour=0,minute=0,second=0.0):
    """
    converts 2010,12,31 to MJD on Dec 31, 2010 at UT=0
    converts 2010,12,31,9.50 to MJD on Dec 31, 2010 at UT=09:30
    converts 2010,12,31,9,0,5 to MJD on Dec 31, 2010 at UT=09:05
    required arguments: year, month, day
    optional arguments: hour, minute, second
    """
    if (month < 3):
        month += 12
        year -= 1
    a =  floor(year / 100.)
    b = 2 - a + floor(a/4.)
    UT = hour+minute/60.+second/3600.
    day += UT/24.
    jd  = floor(365.25*(year+4716)) + floor(30.6001*(month+1)) + day + b - 1524.5;
    mjd = jdToMJD(jd)
    return(mjd)

def jdToMJD(JD):
    """
    Converts a JD value to MJD
    """
    MJD = JD - 2400000.5
    return(MJD)

def mjdsecToUT(mjdsec, prec=6):
    """
    Converts an MJD seconds value to a UT date and time string
    such as '2012-03-14 00:00:00 UT'
    """
    utstring = mjdSecondsToMJDandUT(mjdsec, prec=prec)[1]
    return(utstring)
        
def mjdsecToUTHMS(mjdsec, prec=6):
    """
    Converts MJD seconds to HH:MM:SS
    prec: 6 means HH:MM:SS,  7 means HH:MM:SS.S
    """
    hms = mjdsecToUT(mjdsec, prec=prec).split()[1]
    return(hms)
    
def mjdsecToUTHM(mjdsec):
    """
    Converts MJD seconds to HH:MM
    """
    hms = mjdsecToUTHMS(mjdsec)
    hm = hms.split(':')[0] + ':' + hms.split(':')[1]
    return(hm)

def mjdToUT(mjd, use_metool=True, prec=6):
    """
    Converts an MJD value to a UT date and time string
    such as '2012-03-14 00:00:00 UT'
    use_metool: whether or not to use the CASA measures tool if running from CASA.
         This parameter is simply for testing the non-casa calculation.
    """
    utstring = mjdSecondsToMJDandUT(mjd*86400, use_metool, prec=prec)[1]
    return(utstring)
        
def mjdNanosecondsToMJDandUT(mjdnanosec, prec=6):
    return(mjdSecondsToMJDandUT(mjdnanosec*1e-9, prec=prec))

def unixTimeToDateString(unixtime):
    """
    Converts a time in unix time (seconds since 1970) to a string
    of the format 'YYYY-MM-DD HH:MM:SS UT'
    """
    # could try this someday:
    #      return(datetime.datetime.fromtimestamp(unixtime).astimezone(pytz.utc).strftime('%Y-%m-%d %H:%M:%S UT'))
    jd = ComputeJulianDayFromUnixTime(unixtime)
    mjd = jdToMJD(jd)
    utstring = mjdsecToUT(mjd*86400)
    return(utstring)
    
def ComputeJulianDayFromUnixTime(seconds):
    """
    Converts a time expressed in unix time (seconds since Jan 1, 1970)
    into Julian day number as a floating point value.
    - Todd Hunter
    """
    [tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec, tm_wday, tm_yday, tm_isdst] = timeUtilities.gmtime(seconds)
    if (tm_mon < 3):
        tm_mon += 12
        tm_year -= 1
    UT = tm_hour + tm_min/60. + tm_sec/3600.
    a =  floor(tm_year / 100.)
    b = 2 - a + floor(a/4.)
    day = tm_mday + UT/24.
    jd  = floor(365.25*((tm_year)+4716)) + floor(30.6001*((tm_mon)+1))  + day + b - 1524.5
    return(jd) 

def mjdSecondsToMJDandUT(mjdsec, use_metool=True, debug=False, prec=6):
    """
    Converts a value of MJD seconds into MJD, and into a UT date/time string.
    prec: 6 means HH:MM:SS,  7 means HH:MM:SS.S
    example: (56000.0, '2012-03-14 00:00:00 UT')
    Caveat: only works for a scalar input value
    Todd Hunter
    """
    if (os.getenv('CASAPATH') == None or use_metool==False):
        mjd = mjdsec / 86400.
        jd = mjdToJD(mjd)
        trialUnixTime = 1200000000
        diff  = ComputeJulianDayFromUnixTime(trialUnixTime) - jd
        if (debug): print "first difference = %f days" % (diff)
        trialUnixTime -= diff*86400
        diff  = ComputeJulianDayFromUnixTime(trialUnixTime) - jd
        if (debug): print "second difference = %f seconds" % (diff*86400)
        trialUnixTime -= diff*86400
        diff  = ComputeJulianDayFromUnixTime(trialUnixTime) - jd
        if (debug): print "third difference = %f seconds" % (diff*86400)
        # Convert unixtime to date string 
        utstring = timeUtilities.strftime('%Y-%m-%d %H:%M:%S UT', 
                       timeUtilities.gmtime(trialUnixTime))
    else:
        me = createCasaTool(metool)
        today = me.epoch('utc','today')
        mjd = np.array(mjdsec) / 86400.
        today['m0']['value'] =  mjd
        hhmmss = call_qa_time(today['m0'], prec=prec)
        date = qa.splitdate(today['m0'])
        utstring = "%s-%02d-%02d %s UT" % (date['year'],date['month'],date['monthday'],hhmmss)
    return(mjd, utstring)

def mjdsecToTimerange(mjdsec1, mjdsec2=None, decimalDigits=2, includeDate=True, 
                      use_metool=True, debug=False):
    """
    Converts two value of MJD seconds into a UT date/time string suitable for 
    the timerange argument in plotms.  They can be entered as two separated values,
    or a single tuple.
    Example output: '2012/03/14/00:00:00.00~2012/03/14/00:10:00.00'
    input options:
       decimalDigits: how many digits to display after the decimal point
       use_metool: True=use casa tool to convert to UT, False: use formula in aU
    -Todd Hunter
    """
    if (type(mjdsec1) == list or type(mjdsec1)==np.ndarray):
        mjdsec2 = mjdsec1[1]
        mjdsec1 = mjdsec1[0]
    return(mjdsecToTimerangeComponent(mjdsec1, decimalDigits, includeDate, use_metool, debug) + '~' \
           + mjdsecToTimerangeComponent(mjdsec2, decimalDigits, includeDate, use_metool, debug))
        
def mjdsecToTimerangeComponent(mjdsec, decimalDigits=2, includeDate=True, use_metool=True, debug=False):
    """
    Converts a value of MJD seconds into a UT date/time string suitable for one
    member of the timerange argument in plotms.
    example: '2012/03/14/00:00:00.00'
    input options:
       decimalDigits: how many digits to display after the decimal point
       use_metool: True=use casa tool to convert to UT, False: use formula in aU
    Todd Hunter
    """
    if (os.getenv('CASAPATH') == None or use_metool==False):
        mjd = mjdsec / 86400.
        jd = mjdToJD(mjd)
        trialUnixTime = 1200000000
        diff  = ComputeJulianDayFromUnixTime(trialUnixTime) - jd
        if (debug): print "first difference = %f days" % (diff)
        trialUnixTime -= diff*86400
        diff  = ComputeJulianDayFromUnixTime(trialUnixTime) - jd
        if (debug): print "second difference = %f seconds" % (diff*86400)
        trialUnixTime -= diff*86400
        diff  = ComputeJulianDayFromUnixTime(trialUnixTime) - jd
        if (debug): print "third difference = %f seconds" % (diff*86400)
        # Convert unixtime to date string
        if (includeDate):
            utstring = timeUtilities.strftime('%Y/%m/%d/%H:%M:%S', 
                                              timeUtilities.gmtime(trialUnixTime))
        else:
            utstring = timeUtilities.strftime('%H:%M:%S', 
                                              timeUtilities.gmtime(trialUnixTime))
        utstring += '.%0*d'  % (decimalDigits, np.round(10**decimalDigits*(trialUnixTime % 1)))
    else:
        me = createCasaTool(metool)
        today = me.epoch('utc','today')
        mjd = np.array(mjdsec) / 86400.
        today['m0']['value'] =  mjd
        hhmmss = call_qa_time(today['m0'],prec=6+decimalDigits)
        date = qa.splitdate(today['m0'])
        if (includeDate):
            utstring = "%s/%02d/%02d/%s" % (date['year'],date['month'],date['monthday'],hhmmss)
        else:
            utstring = hhmmss
    return(utstring)

def dateStringToMJD(datestring, datestring2='', verbose=True, use_metool=True):
    """
    Convert a date/time string to floating point MJD
    Input date format: 2011/10/15 05:00:00  or   2011/10/15-05:00:00
                    or 2011-10-15 05:00:00  or   2011-10-15-05:00:00
                    or 2011-10-15T05:00:00  
    The time portion is optional.
    If a second string is given, both values will be converted and printed,
    but only the first is returned.
    use_metool: this parameter is simply for testing the non-casa calculation
    -- Todd Hunter
    """
    if (datestring.find('/') < 0):
        if (datestring.count('-') == 3 or datestring.find('T')>0):
            # This is needed to accept 2010-01-01-12:00:00 (accepted by predictcomp)'
            #                     or   2010-01-01T12:00:00 (output by ALMA TMC DB)'
            # by making it look like 2010-01-01 12:00:00'
            datestring = datestring[0:10] + ' ' + datestring[11:]
        if (datestring.count('-') != 2):
            print "Date format: 2011/10/15 05:00:00  or   2011/10/15-05:00:00"
            print"           or 2011-10-15 05:00:00  or   2011-10-15T05:00:00"
            print "The time portion is optional."
            return(None)
        else:
            d = datestring.split('-')
            datestring = d[0] + '/' + d[1] + '/' + d[2].split('T')[0]
    if (datestring2 != ''):
      if (datestring2.find('/') < 0):
        if (datestring2.count('-') == 3 or datestring2.find('T')>0):
            # This is needed to accept 2010-01-01-12:00:00 (accepted by predictcomp)'
            #                     or   2010-01-01T12:00:00 (output by ALMA TMC DB)'
            # by making it look like 2010-01-01 12:00:00'
            datestring2 = datestring2[0:10] + ' ' + datestring2[11:]
        if (datestring2.count('-') != 2):
            print "Date format: 2011/10/15 05:00:00  or   2011/10/15-05:00:00"
            print"           or 2011-10-15 05:00:00  or   2011-10-15T05:00:00"
            print "The time portion is optional."
            return(None)
        else:
            d = datestring2.split('-')
            datestring2 = d[0] + '/' + d[1] + '/' + d[2]
    mjd1 = dateStringToMJDSec(datestring, verbose=verbose,
                              use_metool=use_metool) / 86400.
    if (datestring2 != ''):
        mjd2 = dateStringToMJDSec(datestring2, verbose=verbose,
                                  use_metool=use_metool) / 86400.
    return(mjd1)

def dateStringToMJDSec(datestring='2011/10/15 05:00:00', datestring2='',
                       verbose=True, use_metool=True):
    """
    Converts a date string into MJD seconds.  This is useful for passing
    time ranges to plotms, because they must be specified in mjd seconds.
    Either of these formats is valid: 2011/10/15 05:00:00
                                      2011/10/15-05:00:00
                                      2011-10-15 05:00:00
                                      2011-10-15T05:00:00
    The time portion is optional.
    If a second string is given, both values will be converted and a
    string will be created that can be used as a plotrange in plotms.
    use_metool: this parameter is simply for testing the non-casa calculation
    
    For further help and examples, see:
    https://safe.nrao.edu/wiki/bin/view/ALMA/DateStringToMJDSec
    Todd Hunter
    """
    if (datestring.find('T') > 0):
        datestring = datestring.replace('T',' ')
    if (datestring[-1] == '-'):
        datestring = datestring[:-1]
    mydate = datestring.split()
    
    if (len(mydate) < 2):
        mydate = datestring.split('-')
        if (len(mydate) > 2):
            # e.g. we entered '2012-10-01 hh:mm:ss'
            mydate = [datestring.replace('-','/')]
            
    # At this point, the date is in the format 2011/10/15
    hours = 0
    if (len(mydate) > 1):
        mytime = (mydate[1]).split(':')
        for i in range(len(mytime)):
            hours += float(mytime[i])/(60.0**i)
    if (os.getenv('CASAPATH') == None or use_metool==False):
        year, month, day = mydate[0].split('/')
        mjd = ymdhmsToMJD(int(year),int(month),int(day),hours)
    else:
        me = createCasaTool(metool)
        me_epoch = me.epoch('utc',mydate[0])
        if (me_epoch != {}):
            mjd = me_epoch['m0']['value'] + hours/24.
        else:
            print "Bad date = ", mydate[0]
            return(0)
    mjdsec = 86400*mjd
    if (verbose):
        print "MJD= %.5f, MJDseconds= %.1f, JD= %.5f" % (mjd, mjdsec, mjdToJD(mjd))
    if (len(datestring2) > 0):
        mydate2 = datestring2.split()
        if (len(mydate2) < 1):
            return(mjdsec)
        if (len(mydate2) < 2):
            mydate2 = datestring2.split('-')
        hours = 0
        if (len(mydate2) > 1):
            mytime2 = (mydate2[1]).split(':')
            if (len(mytime2) > 1):
              for i in range(len(mytime2)):
                hours += float(mytime2[i])/(60.0**i)
#            print "hours = %f" % (hours)
        mjd = me.epoch('utc',mydate2[0])['m0']['value'] + hours/24.
        mjdsec2 = mjd*86400
        print "plotrange = [%.1f, %.1f, 0, 0]" % (mjdsec, mjdsec2)
        print "plotrange = '%.0f~%.0f'" % (mjdsec, mjdsec2)
        return([mjdsec,mjdsec2])
    else:
        return(mjdsec)
        

def plotPointingResults(vis='', figfile=False, source='',buildpdf=False,
                        gs='gs', convert='convert',
                        verbose=False, labels=False, pdftk='pdftk',debug=False,
                        interactive=True, nsigma=2, thresholdArcsec=10.0,
                        fractionOfScansBad=0.60, doplot=True):
    """
    This function will plot the pointing results for an ms, assuming that the
    ASDM_CALPOINTING table was filled, e.g. by importasdm(asis='*').  See also
    plotPointingResultsFromASDM(). The default behavior is to plot all sources
    that were pointed on.  In order to plot just one, then give the source
    name.  Setting labels=True will draw tiny antenna names at the points.
    If buildpdf does not work because gs or convert are not in the standard
    location, then you can specify the full paths with gs='' and convert=''.
    For further help and examples, see
    https://safe.nrao.edu/wiki/bin/view/ALMA/PlotPointingResults
    Todd Hunter
    """
    if (buildpdf and figfile==False):
        figfile=True
    fname = '%s/ASDM_CALPOINTING' % vis
    if (os.path.exists(fname)):
#        print "Trying to open table = %s" % fname
        mytb = createCasaTool(tbtool)
        mytb.open(fname)
    else:
        fname = './ASDM_CALPOINTING'
        if (os.path.exists(fname)):
            print "Looking for table in current directory"
            mytb.open(fname)
        else:
            print "No ASDM_CALPOINTING table found."
            return
    colOffsetRelative = ARCSEC_PER_RAD*mytb.getcol('collOffsetRelative')
    calDataId = mytb.getcol('calDataId')
    antennaName = mytb.getcol('antennaName')
    colError = ARCSEC_PER_RAD*mytb.getcol('collError')
    pols = mytb.getcol('polarizationTypes')
    startValidTime = mytb.getcol('startValidTime')
    uniqueAntennaNames = np.unique(antennaName)
    if (len(startValidTime) == 0):
        print "ASDM_CALPOINTING table is empty."
        return
    (mjd, utstring) = mjdSecondsToMJDandUT(startValidTime[0])
    print 'time = %f = %f = %s' % (startValidTime[0], mjd, utstring)
    mytb.close()
    #
    fname = '%s/ASDM_CALDATA'%vis
    if (os.path.exists(fname)):
        mytb.open(fname)
    else:
        fname = './ASDM_CALDATA'
        if (os.path.exists(fname)):
            mytb.open('./ASDM_CALDATA')
        else:
            print "Could not open ASDM_CALDATA table."
            return
    calDataList = mytb.getcol('calDataId')
    calType = mytb.getcol('calType')
    startTimeObserved = mytb.getcol('startTimeObserved')
    endTimeObserved = mytb.getcol('endTimeObserved')
    #        matches = np.where(calDataList == calDataId[0])
    matches = np.where(calType == 'CAL_POINTING')[0]
    print "Found %d pointing calibrations, in ASDM_CALDATA rows: " % (len(matches)), matches
    nscans = len(matches)
    mytb.close()
    if (doplot):
        plotfiles = []
        pointingPlots = []
    filelist = ''
    if (type(figfile)==str):
        if (figfile.find('/')):
            directories = figfile.split('/')
            directory = ''
            for d in range(len(directories)):
                directory += directories[d] + '/'
            if (os.path.exists(directory)==False):
                print "Making directory = ", directory
                os.system("mkdir -p %s" % directory)

    vm = ValueMapping(vis)
    previousSeconds = 0
    antenna = 0
    uniquePointingScans = []
    outlier = {}
    radialErrors = {}
    for i in range(nscans):
        index = matches[i]
        if (debug):
            print "startTimeObserved[%d]=%f" % (index, startTimeObserved[index])
            print "  endTimeObserved[%d]=%f" % (index, endTimeObserved[index])
        # determine sourcename
        mytime = 0.5*(startTimeObserved[index]+endTimeObserved[index])
        if (debug):
            print "Time = ", mytime
#        scan = vm.getScansForTime(mytime)  # this fails, apparently too strict
        scan = getScansForTime(vm.scansForTimes, mytime)
        uniquePointingScans.append(scan)
        radialErrors[uniquePointingScans[i]] = {}
        outlier[uniquePointingScans[i]] = {}
        if (debug):
            print "Scan = ", scan
        [avgazim,avgelev] = listazel(vis,scan,antenna,vm)
        pointingSource = vm.getFieldsForScan(scan)[0].split(';')[0]
        if (source != ''):
            if (source != pointingSource):
                print "Source does not match the request, skipping"
                continue
        if (doplot):
            pb.clf()
            adesc = pb.subplot(111)
            c = ['blue','red']
        seconds = []
        for p in range(len(pols)):
            seconds.append(np.max(np.max(np.abs(colOffsetRelative[p][0])+colError[p][0])))
            seconds.append(np.max(np.max(np.abs(colOffsetRelative[p][1])+colError[p][1])))
        seconds = np.max(seconds)*1.25
        if (seconds <= previousSeconds):
            seconds = previousSeconds
        previousSeconds = seconds
        if (doplot):
            pb.xlim([-seconds,seconds])
            pb.ylim([-seconds,seconds])
            pb.hold(True)
        thisscan0 = np.where(startTimeObserved[index] < startValidTime)[0]
        thisscan1 = np.where(endTimeObserved[index] > startValidTime)[0]
        thisscan = np.intersect1d(thisscan0,thisscan1)
        mystd = []
        for p in range(len(pols)):
            mystd.append([np.std(colOffsetRelative[p][0]), np.std(colOffsetRelative[p][1])])
        for a in thisscan:
            antenna = np.where(uniqueAntennaNames==antennaName[a])[0][0]
            for p in range(len(pols)):
                if (verbose):
                    print "%s: %.2f, %.2f = %.2e, %.2e" % (uniqueAntennaNames[a],
                       colOffsetRelative[p][0][a], colOffsetRelative[p][1][a], 
                       colOffsetRelative[p][0][a]/ARCSEC_PER_RAD, colOffsetRelative[p][1][a]/ARCSEC_PER_RAD)
                if (doplot):
#                    pb.plot(colOffsetRelative[p][0][a], colOffsetRelative[p][1][a], 'o',
#                        markerfacecolor=overlayColors[antenna], markersize=6, color=overlayColors[antenna],
#                        markeredgecolor=overlayColors[antenna])
                    pb.errorbar(colOffsetRelative[p][0][a], colOffsetRelative[p][1][a], fmt='o',
                            yerr=colError[p][1][a], xerr=colError[p][0][a],
                            color=overlayColors[antenna], markersize=5,
                            markerfacecolor=overlayColors[antenna], markeredgecolor=overlayColors[antenna])
                    if (labels or abs(colOffsetRelative[p][0][a])>nsigma*mystd[p][0] or
                        abs(colOffsetRelative[p][1][a])>nsigma*mystd[p][1]):
                        pb.text(colOffsetRelative[p][0][a], colOffsetRelative[p][1][a],
                                antennaName[a], color='k', size=8)
                totalOffset = (colOffsetRelative[p][0][a]**2 + colOffsetRelative[p][1][a]**2)**0.5
                if (totalOffset > thresholdArcsec):
                    outlier[uniquePointingScans[i]][antennaName[a]] = [True, totalOffset]
                else:
                    outlier[uniquePointingScans[i]][antennaName[a]] = [False]
                radialErrors[uniquePointingScans[i]][antennaName[a]] = totalOffset
                
        if (doplot):
            # Draw spec
            cir = pb.Circle((0, 0), radius=2, facecolor='none', edgecolor='k', linestyle='dotted')
            pb.gca().add_patch(cir)
            pb.hold(False)
            pb.title('Relative collimation offsets at %s - %s scan %d' % (utstring,pointingSource,scan),fontsize=12)
            pb.axvline(0,color='k',linestyle='--')
            pb.axhline(0,color='k',linestyle='--')
            yFormatter = ScalarFormatter(useOffset=False)
            adesc.yaxis.set_major_formatter(yFormatter)
            adesc.xaxis.set_major_formatter(yFormatter)
            if (False):
                minorTickSpacing = 1.0
                xminorLocator = MultipleLocator(minorTickSpacing)
                yminorLocator = MultipleLocator(minorTickSpacing)
                adesc.xaxis.set_minor_locator(xminorLocator)
                adesc.yaxis.set_minor_locator(yminorLocator)
                majorTickSpacing = 5.0
                majorLocator = MultipleLocator(majorTickSpacing)
                adesc.xaxis.set_major_locator(majorLocator)
                adesc.yaxis.set_major_locator(majorLocator)
            adesc.xaxis.grid(True,which='major')
            adesc.yaxis.grid(True,which='major')
            pb.xlabel('Cross-elevation offset (arcsec)')
            pb.ylabel('Elevation offset (arcsec)')
            # now draw the legend for plotPointingResults
            myxlim = pb.xlim()
            myylim = pb.ylim()
            myxrange = myxlim[1]-myxlim[0]
            myyrange = myylim[1]-myylim[0]
            x0 = myxlim[0] + 0.05*myxrange
            y0 = myylim[1]-np.abs(myyrange*0.05)
            mystep = 0.025-0.0001*(len(uniqueAntennaNames)) # 0.020 for 50 antennas, 0.0225 for 25 antennas, etc.
            for a in range(len(antennaName[thisscan])):
                pb.text(myxlim[1]+0.02*myxrange,
                        myylim[1]-(a+1)*myyrange*mystep,
                        antennaName[thisscan][a],
                        color=overlayColors[list(uniqueAntennaNames).index(antennaName[thisscan][a])],
                        fontsize=10)
            pb.text(x0,y0,'azim=%+.0f, elev=%.0f'%(avgazim,avgelev),color='k', fontsize=14)
            pb.text(myxlim[0]+0.02*myxrange, myylim[1]+0.05*myyrange,vis,fontsize=12,color='k')
            pb.axis('scaled')
            pb.axis([-seconds,seconds,-seconds,seconds])
            if (figfile==True):
                myfigfile = vis+'.pointing.scan%02d.png' % (scan)
                pointingPlots.append(myfigfile)
                pb.savefig(myfigfile,density=144)
                plotfiles.append(myfigfile)
                print "Figure left in %s" % myfigfile
            elif (figfile != False):
                myfigfile=figfile
                pb.savefig(figfile,density=144)
                plotfiles.append(myfigfile)
                print "Figure left in %s" % myfigfile
            else:
                print "To make a hardcopy, re-run with figfile=True or figfile='my.png'"
            pb.draw()
            if (buildpdf == True):
                cmd = '%s -density 144 %s %s.pdf'%(convert,myfigfile,myfigfile)
                print "Running command = ", cmd
                mystatus = os.system(cmd)
                if (mystatus == 0):
                    print "plotfiles[i] = ", plotfiles[i]
                    filelist += plotfiles[i] + '.pdf '
                else:
                    print "ImageMagick's convert command is missing, no PDF created."
                    buildpdf = False
        if (i < nscans-1 and interactive):
            mystring = raw_input("Press return for next scan (or 'q' to quit): ")
            if (mystring.lower().find('q') >= 0):
                return
    # end 'for' loop over scans
    badAntennas = {}
    for antenna in uniqueAntennaNames:
        goodscans = 0.0
        radialErrorsThisAntenna = {}
        for scan in uniquePointingScans:
            # datasets with only 2 antennas have 1 antenna solution per scan
            if (antenna in radialErrors[scan]):
                radialErrorsThisAntenna[scan] = radialErrors[scan][antenna]
                if (outlier[scan][antenna][0]==False):
                    goodscans += 1.0
                
        badscans = len(uniquePointingScans)-goodscans
        if (badscans/len(uniquePointingScans) >= fractionOfScansBad):
            print "Antenna %s was an outlier (>%.1f arcsec) for %d/%d scans" % (antenna, thresholdArcsec, badscans, len(uniquePointingScans))
            badAntennas[antenna] = radialErrorsThisAntenna
                
    if (buildpdf and doplot):
        pdfname = vis+'.pointing.pdf'
        if (nscans > 1):
            mystatus = concatenatePDFs(filelist, pdfname, pdftk=pdftk, gs=gs)
        else:
            cmd = 'cp %s %s' % (filelist,pdfname)
            print "Running command = %s" % (cmd)
            mystatus = os.system(cmd)
        if (mystatus == 0):
            print "PDF left in %s" % (pdfname)
            os.system("rm -f %s" % filelist)
        else:
            print "Both pdftk and ghostscript are missing, no PDF created"
    return(pointingPlots, badAntennas)  
# end of plotPointingResults
    
def getScanNumbersFromASDM(asdm, intent='CALIBRATE_ATMOSPHERE'):
    """
    Returns a list of scan numbers in an ASDM that have the
    specified intent, and a list of the number of subscans in each of these scans.
    -Todd Hunter
    """
    mydict = readscans(asdm)[0]
    scans = []
    subscans = []
    for scan in mydict.keys():
        if (intent == '' or mydict[scan]['intent'].find(intent)>=0):
            scans.append(scan)
            subscans.append(mydict[scan]['nsubs'])
    return(scans, subscans)

def readscans(asdm):
    """
    This function was ported from a version originally written by Steve Myers
    for EVLA.  It works for both ALMA and EVLA data.  It returns a dictionary
    containing: startTime, endTime, timerange, sourcename, intent, nsubs, 
    duration.
    Todd Hunter
    """
    # This function lives in a separate .py file.
    return(rs.readscans(asdm))

def listscans(asdm):
    """
    This function was ported from a version originally written by Steve Myers
    for EVLA.  It works for both ALMA and EVLA data.  It prints the summary
    of each scan in the ASDM and the total time on each source. For further
    help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/Listscans
    Todd Hunter
    """
    # This function resides in an external .py file.
    return(rs.listscans(rs.readscans(asdm)))

def plotPointingResultsFromASDMForDatasets(asdmlist, doplot=False, figfile=False, interactive=False, buildpdf=False):
    """
    Runs plotPointingResultsFromASDM on a list of ASDMs.
    Writes a text file with the list of suspect antennas.
    asdmlist: can be a string containing a wildcard character, which will use all matching files in pwd
         or it can be the name of a file which contains a list of files to use
          or it can be a list of asdms, i.e. ['uid1','uid2']
    doplot: create plots for each scan
    buildpdf: create plots for each scan and assemble them into a PDF
    figfile: specify the file name of the plots
         True:   the filenames will be asdm.pointing.scan%02d.png
         String: the filenames will be String.scan%02d, String.scan%02d, ...
    -Todd Hunter
    """
    if (buildpdf):
        doplot = True
    if (type(asdmlist) == str):
        if (asdmlist.find('*') >= 0):
            outfile = 'plotPointingResultsForDatasets.txt'
            asdmlist = glob.glob(asdmlist)
        else:
            outfile = asdmlist+'.plotPointingResultsForDatasets.txt'
            asdmlist = getListOfFilesFromFile(asdmlist, appendms=False)
    else:
        outfile = 'plotPointingResultsForDatasets.txt'
    f = open(outfile,'w')
    pngs = []
    for asdm in asdmlist:
        print "Working on %s" % (asdm)
        figfile = True
        pointingPlots, badAntennas = plotPointingResultsFromASDM(asdm,figfile=figfile,doplot=doplot,
                                                                 interactive=interactive,buildpdf=buildpdf)
        f.write('%s   %s\nsuspect antennas = %s\n\n' % (asdm,getObservationStartDateFromASDM(asdm),str(badAntennas)))
        pngs += pointingPlots
    f.close()
    if (len(pngs) > 0):
        buildPdfFromPngs(pngs, pdfname=outfile+'.pdf', gs='/usr/bin/gs')
    print "Results left in %s" % (outfile)

def plotPointingResultsFromASDM(asdm='', figfile=False, buildpdf=False,
                                gs='gs', convert='convert', labels=False,
                                xrange=[0,0],yrange=[0,0], pdftk='pdftk',
                                interactive=True, thresholdArcsec=10.0,
                                figfiledir='', nsigma=2,
                                fractionOfScansBad=0.60, doplot=True):
    """
    This function will plot the pointing results for an ASDM. To use an ms
    instead, see plotPointingResults(). The default behavior is to plot all
    sources that were pointed on.  In order to plot just one, then give the
    source name.
    Setting labels=True will draw tiny antenna names at the points.
    If buildpdf does not work because gs or convert are not in the standard
    location, then you can specify the full paths with gs='' and convert=''.
    figfile: can be False, True, or a string.
         False:  no plot produced
         True:   the filenames will be asdm.pointing.scan%02d.png
         String: the filenames will be String.scan%02d, String.scan%02d, ...
    figfiledir:  useful for figfile=True option, specifies the directory to
                 (create and) write 
    Returns: a list of figure file names produced, followed by a list of
        suspect antenna names (those that have errors larger than the
        threshold on all scans).
    For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/PlotPointingResultsFromASDM
    Todd Hunter
    """
    if (buildpdf and figfile==False):
        figfile=True
    asdm = asdm.rstrip('/')
    asdmNoPath = os.path.basename(asdm)
    source = ''
    result = readCalPointing(asdm)
    if (result == None):
        return
    [colOffsetRelative,antennaName,startValidTime,pols,calDataID,azim,elev,colError] = result
    # Need to match calDataId to scan numbers
        
    scandict = rs.readscans(asdm)[0]
    caldict = readCalDataFromASDM(asdm)  # this contains translation from calDataId to scan number
    if (caldict == None):
        return
    uniqueScans = 1+np.array(range(len(scandict)))  # in this list, scans appear only once
    scans = []  # in this list, each scan will appear N times, where N=number of antennas
    for i in calDataID:
      for c in range(len(caldict)):
        if (int(caldict[c]['calDataId'].split('_')[1]) == i):
            scans.append(caldict[c]['scan'])

    pointingScans = []
    for i in range(len(caldict)):
        if (int(caldict[i]['calDataId'].split('_')[1]) in calDataID):
            pointingScans.append(caldict[i]['scan'])
    uniquePointingScans = np.unique(pointingScans)
    
    print "pointing scans = ", pointingScans
    pointingSources = ''
    for i in uniquePointingScans:
        pointingSources += scandict[i]['source'].split(';')[0]
        if (i != uniquePointingScans[-1]):
            pointingSources += ', '
    print "pointing sources = ",pointingSources
    nPointingScans = len(uniquePointingScans)
    if (len(startValidTime) == 0):
        print "CalPointing.xml table is empty."
        return
    
    plotfiles = []
    filelist = ''
    if (figfiledir != ''):
        if (os.path.exists(figfiledir) == False):
            print "Making directory: %s" % (figfiledir)
            os.makedirs(figfiledir)
        if (figfiledir[-1] != '/'): figfiledir += '/'
    if (type(figfile)==str):
        if (figfile.find('/')):
            directories = figfile.split('/')
            directory = ''
            for d in range(len(directories)):
                directory += directories[d] + '/'
            if (os.path.exists(directory)==False):
                print "Making directory = ", directory
                os.system("mkdir -p %s" % directory)

    previousSeconds = 0
    antenna = 0
    uniqueAntennaNames = np.unique(antennaName)
    pointingPlots = []
    outlier = {}
    radialErrors = {}
    for i in range(nPointingScans):
        outlier[uniquePointingScans[i]] = {}
        radialErrors[uniquePointingScans[i]] = {}
        if (doplot):
            pb.clf()
            adesc = pb.subplot(111)
        c = ['blue','red']
        seconds = []
        for p in range(len(pols)):
            seconds.append(np.max(np.max(np.abs(colOffsetRelative[p][0]))) + np.median(colError[0]))
            seconds.append(np.max(np.max(np.abs(colOffsetRelative[p][1]))) + np.median(colError[1]))
        seconds = np.max(seconds)*1.25
        if (seconds <= previousSeconds):
            # don't allow subsequent plots to cover a smaller range of sky
            seconds = previousSeconds
        previousSeconds = seconds
        if (doplot):
            pb.xlim([-seconds,seconds])
            pb.ylim([-seconds,seconds])
            pb.hold(True)
        thisscan = np.where(scans == uniquePointingScans[i])[0]
        mystd = []
        colOffsetRelativeTrans = np.transpose(colOffsetRelative[thisscan])
#        print "np.shape(colOffsetRelativeTrans) = ", np.shape(colOffsetRelativeTrans)
        for p in range(len(pols[thisscan[0]])):
            mystd.append([np.std(colOffsetRelativeTrans[0][p]), np.std(colOffsetRelativeTrans[1][p])])
        for a in thisscan:
            antenna = np.where(uniqueAntennaNames==antennaName[a])[0][0]
            for p in range(len(pols[a])):
#                pb.plot(colOffsetRelative[a][p][0], colOffsetRelative[a][p][1], 'o',
#                        markerfacecolor=overlayColors[antenna], markersize=6,
#                         color=overlayColors[antenna])
                if (doplot):
                    pb.errorbar(colOffsetRelative[a][p][0], colOffsetRelative[a][p][1], fmt='o',
                            yerr=colError[a][p][1], xerr=colError[a][p][0],
                            color=overlayColors[antenna], markersize=5,
                            markerfacecolor=overlayColors[antenna], markeredgecolor=overlayColors[antenna])
                totalOffset = (colOffsetRelative[a][p][0]**2 + colOffsetRelative[a][p][1]**2)**0.5
                if (totalOffset > thresholdArcsec):
                    outlier[uniquePointingScans[i]][antennaName[a]] = [True, totalOffset]
                else:
                    outlier[uniquePointingScans[i]][antennaName[a]] = [False]
                radialErrors[uniquePointingScans[i]][antennaName[a]] = totalOffset
                if (doplot and (labels or abs(colOffsetRelative[a][p][0])>nsigma*mystd[p][0] or
                                abs(colOffsetRelative[a][p][1])>nsigma*mystd[p][1])):
                    pb.text(colOffsetRelative[a][p][0], colOffsetRelative[a][p][1], 
                            antennaName[a], color='k', size=8)
        # Draw spec
        if (doplot):
            cir = pb.Circle((0, 0), radius=2, facecolor='none', edgecolor='k', linestyle='dotted')
            pb.gca().add_patch(cir)
#        print "scandict = ", scandict
#        print "len(scandict) = ", len(scandict)
#        print "\n scandict[%d].keys() = " % (uniquePointingScans[i]), scandict[uniquePointingScans[i]].keys()
        pointingSource = scandict[uniquePointingScans[i]]['source'].split(';')[0]
        (mjd, utstring) = mjdSecondsToMJDandUT(startValidTime[thisscan[0]])
        if (doplot):
            pb.title('Relative collimation offsets at %s - %s scan %d' % (utstring,pointingSource,uniquePointingScans[i]),fontsize=12)
            pb.axvline(0,color='k',linestyle='--')
            pb.axhline(0,color='k',linestyle='--')
            pb.xlabel('Cross-elevation offset (arcsec)')
            pb.ylabel('Elevation offset (arcsec)')
            pb.axis('scaled')
            if (xrange[0] != 0 or xrange[1] != 0):
                if (yrange[0] != 0 or yrange[1] != 0):
                    pb.axis([xrange[0],xrange[1],yrange[0],yrange[1]])
                else:
                    pb.axis([xrange[0],xrange[1],-seconds,seconds])
            elif (yrange[0] != 0 or yrange[1] != 0):
                pb.axis([-seconds,seconds, yrange[0], yrange[1]])
            else:
                pb.axis([-seconds,seconds,-seconds,seconds])

            # now draw the legend for plotPointingResultsFromASDM
            myxlim = pb.xlim()
            myylim = pb.ylim()
            myxrange = myxlim[1]-myxlim[0]
            myyrange = myylim[1]-myylim[0]
            x0 = myxlim[0] + 0.05*myxrange
            y0 = myylim[1]-np.abs(myyrange*0.05)
            pb.text(x0,y0,'azim=%+.0f, elev=%.0f'%(azim[thisscan[0]],elev[thisscan[0]]),color='k', fontsize=14)
            asdmNoPath = asdm.split('/')[-1]
            pb.text(myxlim[0]+0.02*myxrange, myylim[1]+0.05*myyrange, asdmNoPath, fontsize=12,color='k')
            mystep = 0.025-0.0001*(len(uniqueAntennaNames)) # 0.020 for 50 antennas, 0.0225 for 25 antennas, etc.
            for a in range(len(uniqueAntennaNames)):
                pb.text(myxlim[1]+0.02*myxrange, myylim[1]-(a+1)*myyrange*mystep, uniqueAntennaNames[a], color=overlayColors[a],fontsize=10)
            pb.axvline(0,color='k',linestyle='--')
            pb.axhline(0,color='k',linestyle='--')
            yFormatter = ScalarFormatter(useOffset=False)
            adesc.yaxis.set_major_formatter(yFormatter)
            adesc.xaxis.set_major_formatter(yFormatter)
            adesc.xaxis.grid(True,which='major')
            adesc.yaxis.grid(True,which='major')
            if (figfile==True):
                myfigfile = figfiledir + asdmNoPath + '.pointing.scan%02d.png' % (uniquePointingScans[i])
                pointingPlots.append(myfigfile)
                pb.savefig(myfigfile,density=144)
                plotfiles.append(myfigfile)
                print "Figure left in %s" % myfigfile
            elif (figfile != False):
                myfigfile = figfiledir + figfile.replace('.png','') + '.scan%02d.png' % (uniquePointingScans[i])
                pb.savefig(myfigfile, density=144)
                plotfiles.append(myfigfile)
                print "Figure left in %s" % myfigfile
            else:
                print "To make a hardcopy, re-run with figfile=True or figfile='my.png'"
            if (buildpdf == True):
                cmd = '%s -density 144 %s %s.pdf'%(convert,myfigfile,myfigfile)
                print "Running command = ", cmd
                mystatus = os.system(cmd)
                if (mystatus == 0):
                    print "plotfiles[i] = ", plotfiles[i]
                    filelist += plotfiles[i] + '.pdf '
                else:
                    print "ImageMagick's convert command is missing, no PDF created."
                    buildpdf = False
            pb.draw()
            if (i < nPointingScans-1 and interactive):
                mystring = raw_input("Press return for next scan (or 'q' to quit): ")
                if (mystring.lower().find('q') >= 0):
                    return(pointingPlots)
    # end 'for' loop over scans
    badAntennas = {}
    for antenna in uniqueAntennaNames:
        goodscans = 0.0
        radialErrorsThisAntenna = {}
        for scan in uniquePointingScans:
            # datasets with only 2 antennas have 1 antenna solution per scan
            if (antenna in radialErrors[scan]):
                radialErrorsThisAntenna[scan] = radialErrors[scan][antenna]
                if (outlier[scan][antenna][0]==False):
                    goodscans += 1.0
                
        badscans = len(uniquePointingScans)-goodscans
        if (badscans/len(uniquePointingScans) >= fractionOfScansBad):
            print "Antenna %s was an outlier (>%.1f arcsec) for %d/%d scans" % (antenna, thresholdArcsec, badscans, len(uniquePointingScans))
            badAntennas[antenna] = radialErrorsThisAntenna
                
    if (buildpdf and doplot):
      pdfname = asdm+'.asdmpointing.pdf'
      if (nPointingScans > 1):
          mystatus = concatenatePDFs(filelist, pdfname, pdftk=pdftk, gs=gs)
      else:
          cmd = 'cp %s %s' % (filelist,pdfname)
          print "Running command = %s" % (cmd)
          mystatus = os.system(cmd)
      if (mystatus == 0):
          print "PDF left in %s" % (pdfname)
          os.system("rm -f %s" % filelist)
      else:
          print "Both pdftk and ghostscript are missing, no PDF created"
    return(pointingPlots, badAntennas)  
# end of plotPointingResultsFromASDM
            
def offlineTcAtmosphere(asdm,scanlist,mode='AH',origin='specauto') :
    for scan in scanlist :
        print scan
        tc_atmosphere(asdm=asdm,dataorigin=origin,trecmode=mode,scans=str(scan),
                      antennas='',calresult=asdm,showplot=False,verbose=False)

def importasdm2(asdm, intent=''):

    f = open(asdm+'/Scan.xml')
    fc = f.read()
    f.close()

    scanBlockList = re.findall('<row>.+?</row>', fc, re.DOTALL|re.MULTILINE)

    scanNumList = []

    for i in range(len(scanBlockList)):
        scanBlocksIntents = re.findall('<scanIntent>.+?</scanIntent>', scanBlockList[i])[0]
        if re.search(intent, scanBlocksIntents) != None:
            scanNum1 = re.findall('<scanNumber>[0-9]+</scanNumber>', scanBlockList[i])
            if len(scanNum1) != 1: continue
            scanNum1 = re.findall('[0-9]+', scanNum1[0])
            if len(scanNum1) != 1: continue
            scanNumList.append(scanNum1[0])

    scanNumList = ','.join(scanNumList)

    importasdm(asdm, scans=scanNumList)

def readwvr(sdmfile):
    """
    This function reads the CalWVR.xml table from the ASDM and returns a
    dictionary containing: 'start', 'end', 'startmjd', 'endmjd',
    'startmjdsec', 'endmjdsec',
    'timerange', 'antenna', 'water', 'duration'.
    'water' is the zenith PWV in meters.
    This function is called by readpwv(). -- Todd Hunter
    """
    if (os.path.exists(sdmfile) == False):
        print "readwvr(): Could not find file = ", sdmfile
        return
    xmlscans = minidom.parse(sdmfile+'/CalWVR.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    for rownode in rowlist:
        rowpwv = rownode.getElementsByTagName("water")
        pwv = float(rowpwv[0].childNodes[0].nodeValue)
        water = pwv
        scandict[fid] = {}

        # start and end times in mjd ns
        rowstart = rownode.getElementsByTagName("startValidTime")
        start = int(rowstart[0].childNodes[0].nodeValue)
        startmjd = float(start)*1.0E-9/86400.0
        t = qa.quantity(startmjd,'d')
        starttime = call_qa_time(t,form="ymd",prec=8)
        rowend = rownode.getElementsByTagName("endValidTime")
        end = int(rowend[0].childNodes[0].nodeValue)
        endmjd = float(end)*1.0E-9/86400.0
        t = qa.quantity(endmjd,'d')
        endtime = call_qa_time(t,form="ymd",prec=8)
        # antenna
        rowantenna = rownode.getElementsByTagName("antennaName")
        antenna = str(rowantenna[0].childNodes[0].nodeValue)

        scandict[fid]['start'] = starttime
        scandict[fid]['end'] = endtime
        scandict[fid]['startmjd'] = startmjd
        scandict[fid]['endmjd'] = endmjd
        scandict[fid]['startmjdsec'] = startmjd*86400
        scandict[fid]['endmjdsec'] = endmjd*86400
        timestr = starttime+'~'+endtime
        scandict[fid]['timerange'] = timestr
        scandict[fid]['antenna'] = antenna
        scandict[fid]['water'] = water
        scandict[fid]['duration'] = (endmjd-startmjd)*86400
        fid += 1

    print '  Found ',rowlist.length,' rows in CalWVR.xml'

    # return the dictionary for later use
    return scandict
# Done

def readpwv(asdm):
  """
  This function assembles the dictionary returned by readwvr() into arrays
  containing the PWV measurements written by TelCal into the ASDM.
  -- Todd Hunter
  """
#  print "Entered readpwv"
  dict = readwvr(asdm)
#  print "Finished readwvr"
  bigantlist = []
  for entry in dict:
      bigantlist.append(dict[entry]['antenna'])
  antlist = np.unique(bigantlist)
  watertime = []
  water = []
  antenna = []
  for entry in dict:
      measurements = 1
      for i in range(measurements):
          watertime.append(dict[entry]['startmjdsec']+(i*1.0/measurements)*dict[entry]['duration'])
          water.append(dict[entry]['water'])
          antenna.append(dict[entry]['antenna'])
  return([watertime,water,antenna])   

def readSysCal(asdm):
    """
    This function reads the SysCal.xml table from the ASDM and checks
    how many Tsys entries there are for each combination of Antenna,
    time and spw (which should be 1). Reports the number of duplicates
    and returns a dictionary keyed by [antenna][spw] = list of timestamps
    -- Todd Hunter
    """
    if (os.path.exists(asdm) == False):
        print "readsyscal(): Could not find file = ", asdm
        return
    xmlscans = minidom.parse(asdm+'/SysCal.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    duplicates = 0
    scandict = {}
    for rownode in rowlist:
        antennaID = rownode.getElementsByTagName("antennaId")
        antenna = int(str(antennaID[0].childNodes[0].nodeValue).split('_')[1])
        if (antenna not in scandict.keys()):
            scandict[antenna] = {}
        spwID = rownode.getElementsByTagName("spectralWindowId")
        spw = int(str(spwID[0].childNodes[0].nodeValue).split('_')[1])
        if (spw not in scandict[antenna].keys()):
            scandict[antenna][spw] = []
        timeData = rownode.getElementsByTagName("timeInterval")
        timeStamp = int(str(timeData[0].childNodes[0].nodeValue).split()[0])
        timeInterval = int(str(timeData[0].childNodes[0].nodeValue).split()[1])
        if (timeStamp-timeInterval/2 in scandict[antenna][spw]):
            print "Duplicate seen!"
            duplicates += 1
        else:
            scandict[antenna][spw].append(timeStamp-timeInterval/2)

        # start and end times in mjd ns
#        rowstart = rownode.getElementsByTagName("startValidTime")
#        start = int(rowstart[0].childNodes[0].nodeValue)
#        startmjd = float(start)*1.0E-9/86400.0
#        scandict[fid]['start'] = starttime
        fid += 1

    print '  Found ',rowlist.length,' Tsys rows in SysCal.xml'
    print "%d duplicates found" % (duplicates)
    return (scandict)

def replaceTsysFromSQLD(caltable, sqld, asdm, spws, verbose=False):
    """
    This is a utility to replace the Tsys spectrum for one combination
    of antenna+spw+pol+scan with the median value from the square law 
    detector Tsys located in the SysCal.xml table.
    Typically, the SysCal.xml table was produced manually by running 
    casapy-telcal offline.

    caltable: the name of the gencal-produced Tsys cal table to correct
    sqld: the path to the SysCal.xml file to get the SQLD Tsys values from
    asdm: the path to the original ASDM (with SpectralWindow.xml and Scan.xml) 
    spws: a list of spws to replace (in order of baseband number).  The number of
          spws specified must match the number of SQLDs in the SysCal.xml file.
    - Todd Hunter
    """
    tsys = getTsysFromSysCal(sqld, asdm)
    values = 0
    if (type(spws) == str):
        spws = spws.split(',')
    changeFactor = []
    for antenna in tsys.keys():
        for spw in tsys[antenna].keys():
            baseband = tsys[antenna][spw]['baseband']-1 # 1..4  converted here to 0..3
            for scan in tsys[antenna][spw]['scans'].keys():
                for pol in tsys[antenna][spw]['scans'][scan].keys():
                    if (pol == 0): polarization = 'X'
                    if (pol == 1): polarization = 'Y'
                    if (verbose):
                        print "Calling replaceTsysScan('%s', antenna=%d, spw=%d, pol='%s', fromscan=%d, toscan=%d, newvalue=%f)" % (caltable, antenna, int(spws[baseband]), polarization, scan, scan, np.median(tsys[antenna][spw]['scans'][scan][pol]))
                    replaced, change = replaceTsysScan(caltable, antenna, int(spws[baseband]), polarization, scan, scan, tsys[antenna][spw]['scans'][scan][pol],verbose=verbose)
                    values += replaced
                    if (replaced > 0):
                        changeFactor.append(change)
    print "Replaced %d values with a median change of a factor of %f" % (values,np.median(changeFactor))
    
def getTsysFromSysCal(sqld, asdm):
    """
    This function reads the Tsys values from a SysCal.xml table 
    associated with an ASDM into a dictionary keyed by antenna ID, 
    spw, scan, and pol (0 or 1).  
    sqld: the path to the SysCal.xml table (or its parent directory)
    asdm: the path to the original ASDM (containing Scan.xml and SpectralWindow.xml)
      The reason you need to specify both is because the primary usage is
      to read values from a SysCal.xml file produced by offline casapy-telcal.
    -- Todd Hunter
    """
    if (os.path.exists(sqld) == False):
        print "getTsysFromSysCal(): Could not find file = ", sqld
        return
    if (sqld.split('/')[-1] != 'SysCal.xml'):
        sqld += '/SysCal.xml'
    if (os.path.exists(asdm) == False):
        print "getTsysFromSysCal(): Could not find ASDM = ", asdm
        return
    scanlist = readscans(asdm)[0]
    wvrSpws = []
    xmlscans = minidom.parse(asdm+'/SpectralWindow.xml')
    rowlist = xmlscans.getElementsByTagName("row")
    baseband = {}
    for rownode in rowlist:
        name = rownode.getElementsByTagName("name")
        name = str(name[0].childNodes[0].nodeValue)
        spwID = rownode.getElementsByTagName("spectralWindowId")
        spw = int(str(spwID[0].childNodes[0].nodeValue).split('_')[1])
        basebandName = rownode.getElementsByTagName("basebandName")
        basebandName = str(basebandName[0].childNodes[0].nodeValue).split('_')  # e.g. "BB_1"
        if (len(basebandName) < 2):
            baseband[spw] = -1  # NOBB
        else:
            baseband[spw] = int(basebandName[1])
        if (name.find('WVR') >= 0):
            wvrSpws.append(spw)
    xmlscans = minidom.parse(sqld)
    rowlist = xmlscans.getElementsByTagName("row")
    scandict = {}
    fid = 0
    duplicates = 0
    scandict = {}
    for rownode in rowlist:
        antennaID = rownode.getElementsByTagName("antennaId")
        antenna = int(str(antennaID[0].childNodes[0].nodeValue).split('_')[1])
        if (antenna not in scandict.keys()):
            scandict[antenna] = {}
        spwID = rownode.getElementsByTagName("spectralWindowId")
        asdmspw = int(str(spwID[0].childNodes[0].nodeValue).split('_')[1])
        subtract = len(np.where(asdmspw > np.array(wvrSpws))[0])-1 
        spw = asdmspw-subtract # translate this to actual spw number, as only 1 WVR spw is real
        if (spw not in scandict[antenna].keys()):
            scandict[antenna][spw] = {}
            scandict[antenna][spw]['baseband'] = baseband[asdmspw]
            scandict[antenna][spw]['scans'] = {}
        timeData = rownode.getElementsByTagName("timeInterval")
        timeStamp = int(str(timeData[0].childNodes[0].nodeValue).split()[0])
        timeInterval = int(str(timeData[0].childNodes[0].nodeValue).split()[1])
        timeCenter = timeStamp-timeInterval/2
        timeCenterMJD = timeCenter*1e-9/86400.
        scan = -1
        for s in scanlist.keys():
            if (scanlist[s]['endmjd'] >= timeCenterMJD and scanlist[s]['startmjd'] <= timeCenterMJD):
                scan = s
        if (scan not in scandict[antenna][spw]['scans'].keys()):
            scandict[antenna][spw]['scans'][scan] = {}
        tsysSpectrum = rownode.getElementsByTagName("tsysSpectrum")
        values = tsysSpectrum[0].childNodes[0].nodeValue.split()
        npol = int(values[1])  # or is it [0] ?
        nchan = int(values[2])
        for pol in range(npol):
            tsys = []
            for i in range(pol*nchan, nchan*(pol+1)):
                tsys.append(float(values[3+i]))
            scandict[antenna][spw]['scans'][scan][pol] = tsys
        # start and end times in mjd ns
#        rowstart = rownode.getElementsByTagName("startValidTime")
#        start = int(rowstart[0].childNodes[0].nodeValue)
#        startmjd = float(start)*1.0E-9/86400.0
#        scandict[fid]['start'] = starttime
        fid += 1
    print '  Found ',rowlist.length,' Tsys rows in SysCal.xml'
    return (scandict)

def getNonWvrSpws(mymsmd):
    """
    Uses the msmd tool instance to find a list of the non-WVR spws, in a backward-compatible way.
    -Todd Hunter
    """
    try:
        spws = list(set(range(mymsmd.nspw())).difference(set(mymsmd.almaspws(wvr=True))))
    except:
        spws = list(set(range(mymsmd.nspw())).difference(set(mymsmd.wvrspws())))
    return(spws)

def getNonChanAvgSpws(mymsmd):
    """
    Uses the msmd tool instance to find a list of the non-WVR spws, in a backward-compatible way.
    -Todd Hunter
    """
    try:
        spws = list(set(range(mymsmd.nspw())).difference(set(mymsmd.almaspws(chavg=True))))
    except:
        spws = list(set(range(mymsmd.nspw())).difference(set(mymsmd.chanavgspws())))
    return(spws)

def getScienceFrequencies(vis):
    # Return a list of the mean frequencies of each spw with more than 4 channels
    # i.e. not the WVR data nor the channel-averaged data.  -- Todd Hunter
    #
    freqs = []
    if (casadef.casa_version >= '4.1.0'):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        nonwvrspws = getNonWvrSpws(mymsmd)
        for spw in nonwvrspws:
            freqs.append(mymsmd.meanfreq(spw))
        mymsmd.close()
    else:
        mytb = createCasaTool(tbtool)
        try:
            mytb.open("%s/SPECTRAL_WINDOW" % vis)
        except:
            print "Could not open ms table = %s" % (vis)
            return(freqs)
        numChan = mytb.getcol("NUM_CHAN")
        for i in range(len(numChan)):
            if (numChan[i] > 4):
                chanFreq = mytb.getcell("CHAN_FREQ",i)
                freqs.append(np.mean(chanFreq))
        mytb.close()
    return freqs
    
def listConditionsFromASDM(asdm, station=16, verbose=True):
    """
    This function extracts the weather conditions for the specified ASDM,
    and computes and returns a dictionary containing the median values.
    The default weather station to use is 16.
    For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/ListConditionsFromASDM
    Todd Hunter
    """
    [conditions, medianConditions, stationName] = getWeatherFromASDM(asdm,station=station)
    if (verbose):
        print "Median weather values for %s to %s" % (plotbp3.utstring(conditions[0][0]),plotbp3.utstring(conditions[0][-1]))
        print "  Pressure = %.2f mb" % (medianConditions['pressure'])
        print "  Temperature = %.2f C" % (medianConditions['temperature'])
#        print "  Dew point = %.2f C" % (medianConditions['dewpoint'])
        print "  Relative Humidity = %.2f %%" % (medianConditions['humidity'])
        print "  Wind speed = %.2f m/s" % (medianConditions['windSpeed'])
        print "  Wind max = %.2f m/s" % (np.max(conditions[6]))
        print "  Wind direction = %.2f deg" % (medianConditions['windDirection'])
    return(medianConditions)

def listConditions(vis='', scan='', antenna='0',verbose=True,asdm='',reffreq=0,
                   byscan=False, vm=0, mymsmd=''):
  """
  This is simply a wrapper for listconditions which might go away in the future.
  See help(au.listconditions).
  --- Todd Hunter
  """
  return(listconditions(vis,scan,antenna,verbose,asdm,reffreq,byscan,vm,mymsmd))

def listconditions(vis='', scan='', antenna='0',verbose=True,asdm='',reffreq=0,
                   byscan=False, vm=0, mymsmd=''):
    """
    Compiles the mean weather, pwv and opacity values for the given scan
    number or scan list for the specified ms.  If a scan number
    is not provided it returns the average over the whole ms.
    Setting byscan=True will return a dictionary with conditions per scan.
    Scan can be a single list: [1,2,3] or '1,2,3' or a single range: '1~4'.
    For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/Listconditions
    Todd Hunter
    """
    if (os.path.exists(vis)==False):
        print "Could not find the ms = %s." % (vis)
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (reffreq==0):
        freqs = 1e-9*np.array(getScienceFrequencies(vis))
    else:
        freqs = [reffreq]
    if (type(scan) == str):
        if (scan.find(',')>0):
            scan = [int(k) for k in scan.split(',')]
        elif (scan.find('~')>0):
            scan = range(int(scan.split('~')[0]),int(scan.split('~')[1])+1)
    if (casadef.casa_version >= '4.1.0' and mymsmd==''):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
    if (byscan and (type(scan) == list or scan=='')):
        conditions = {}
        if (scan == ''):
            if (casadef.casa_version >= '4.1.0'):
                scan = mymsmd.scannumbers()
            else:
                if (vm == 0):
                    vm = ValueMapping(vis)
                scan = np.unique(vm.scans)
            print "Scans = ", scan
        pwvstd = 1 # get into the loop the first time, but do not repeat if no WVR file present
        for i in scan:
#            print "Calling getWeather('%s',%d,'%s',%s)" % (vis,i,antenna,verbose)
            [cond,myTimes,vm] = getWeather(vis,i,antenna,verbose,vm,mymsmd)
            if (len(myTimes) > 0 and pwvstd>0):
                [pwv,pwvstd] = getMedianPWV(vis,myTimes,asdm,verbose=False)
                if (pwvstd > 0):
                    if (pwv > 0):
                        tau = []
                        zenithtau = []
                        for myfreq in range(len(freqs)):
                            reffreq = freqs[myfreq]
                            [z,t] = estimateOpacity(pwv, reffreq, cond,verbose)
                            zenithtau.append(z)
                            tau.append(t)
                        d2 = {}
                        d2['tauzenith'] = np.mean(zenithtau)
                        d2['tau'] = np.mean(tau)
                        d2['transmissionzenith'] = np.exp(-np.mean(zenithtau))
                        d2['transmission'] = np.exp(-np.mean(tau))
                        d2['pwv'] = pwv
                        d2['pwvstd'] = pwvstd
                        cond = dict(cond.items() + d2.items())
            conditions[i] = cond
    else:
#        print "Calling getWeather('%s',%d,'%s',%s), len(freqs)=%d" % (vis,scan,antenna,verbose,len(freqs))
        [conditions,myTimes,vm] = getWeather(vis,scan,antenna,verbose,vm,mymsmd)
#        print "len(myTimes) = %d" % (len(myTimes))
        if (len(myTimes) < 1):
            return(conditions)
        [pwv,pwvstd] = getMedianPWV(vis,myTimes,asdm,verbose=False)
#        print "pwv = %f" % (pwv)
        if (pwvstd < 0):
            return(conditions)
        if (pwv > 0):
            tau = []
            zenithtau = []
            for i in range(len(freqs)):
                reffreq = freqs[i]
                [z,t] = estimateOpacity(pwv, reffreq, conditions,verbose)
                zenithtau.append(z)
                tau.append(t)
            d2 = {}
            d2['tauzenith'] = np.mean(zenithtau)
            d2['tau'] = np.mean(tau)
            d2['transmissionzenith'] = np.exp(-np.mean(zenithtau))
            d2['transmission'] = np.exp(-np.mean(tau))
            d2['pwv'] = pwv
            d2['pwvstd'] = pwvstd
            conditions = dict(conditions.items()+d2.items())
    if (mymsmd != ''):
        mymsmd.close()
    return(conditions)

def buildCalDataIdDictionary(vis, tol=10, debug=False, sbr=True, atm=True):
    """
    Provides the mapping from cal data ID to scan number via the times, as an alternative
    to using readCalData which requires the ASDM_CALDATA table.
    vis: string name of ms
    tol: tolerance in seconds (should not have to change this)
    sbr: include SIDEBAND_RATIO scans
    atm: include CALIBRATE_ATMOSPHERE scans
    """
    mytable = vis+'/ASDM_CALATMOSPHERE'
    mytb = createCasaTool(tbtool)
    mytb.open(mytable)
    startValidTime = mytb.getcol('startValidTime')
    calDataId = np.array([int(c.split('_')[-1]) for c in mytb.getcol('calDataId')])
    mytb.close()
    # these range from 2-40 seconds after the first integration of the scan
    # so do a rough correction for this
    startValidTime -= 10  
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    scans = mymsmd.scannumbers()
    times = mymsmd.timesforscans(scans)
    if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' in mymsmd.intents()):
        calscans = mymsmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
    else:
        calscans = []
    if ('CALIBRATE_SIDEBAND_RATIO#ON_SOURCE' in mymsmd.intents()):
        sbrscans = mymsmd.scansforintent('CALIBRATE_SIDEBAND_RATIO#ON_SOURCE')
    else:
        sbrscans = []
    if (debug):
        print "%d calscans=%s,  %d sbrscans=%s" % (len(calscans),str(calscans), len(sbrscans), str(sbrscans))
    if (sbr and atm):
        cal_sbr_scans = np.unique(np.union1d(calscans, sbrscans))
    elif (sbr):
        cal_sbr_scans = sbrscans
    else:
        cal_sbr_scans = calscans
        
    calscantimesdict = {}
    for i in range(len(calDataId)):
        cal = calDataId[i]
        if (cal not in calscantimesdict.keys()):
            calscantimesdict[cal] = []
        calscantimesdict[cal].append(startValidTime[i])
    for key in calscantimesdict.keys():
        mylen = len(np.unique(calscantimesdict[key]))
        if (mylen > 1):
            print "Cal data ID %d has multiple startValidTimes (%d). Taking the minimum." % (key, mylen)
        calscantimesdict[key] = np.min(calscantimesdict[key])
        if (debug):
            print "%2d = %s" % (key, mjdsecToUTHMS(calscantimesdict[key]))
        
    calscandict = {}
    scansAssigned = []
    stopTol = 6.01*tol
    for tolerance in np.arange(tol, stopTol, tol):
        if (debug):
            print "tolerance = %.0f sec, calscandict=%s" % (tolerance,str(calscandict))
        for i in range(len(calDataId)):
            cal = calDataId[i]
            if (debug):
                print "Working on row %d, calDataId=%d" % (i,cal)
            if (cal not in calscandict.keys()):
                calscandict[cal] = []
            if (tolerance == tol or len(calscandict[cal]) == 0):
                trialscans = mymsmd.scansfortimes(calscantimesdict[cal]+tolerance, tol=tolerance)
                for scan in sorted(list(trialscans)):
                    if (scan not in calscandict[cal] and
                        scan not in scansAssigned):
                        if (scan in cal_sbr_scans):
                            calscandict[cal].append(scan)
                            scansAssigned.append(scan)
                            if (debug):
                                print "tol=%.0f: calscandict[%d].append(%d) of %s (%s-%s)" % (tolerance,cal,scan,str(trialscans), mjdsecToUTHMS(calscantimesdict[cal]), mjdsecToUTHMS(calscantimesdict[cal]+tolerance*2))
        # loosen the tolerance until all are filled with a value
        if (len(scansAssigned) == len(cal_sbr_scans)):
            allFilled = True
            for key in calscandict.keys():
                if (len(calscandict[key]) == 0):
                    allFilled = False
            if (allFilled): break
        unassigned = np.setdiff1d(cal_sbr_scans, scansAssigned) 
        if (tolerance+tol < stopTol):
            scansAssigned = []
            calscandict = {}
        if ((debug or tolerance+tol > stopTol) and sbr and atm):
            print "not all scans assigned (%d vs. %d), unassigned = %s" % (len(scansAssigned), len(calscans)+len(sbrscans), str(unassigned))
    csd = {}
    for key in calscandict.keys():
        if (len(calscandict[key]) > 0):
            csd[key] = np.array(calscandict[key],int32)
    mymsmd.close()
    if (debug):
        print "returning from buildCalDataIdDictionary, %d/%d scans assigned" % (len(scansAssigned),len(cal_sbr_scans))
    return(csd)
    
def readCalData(vis, calType='CAL_ATMOSPHERE'):
    """
    Provides the mapping from cal data ID to scan number
    Returns:
       a translation dictionary from calDataId to scan numbers
    Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    if (os.path.exists(vis+'/ASDM_CALDATA') == False):
        print "No ASDM_CALDATA file.  Either importasdm(asis='CalData') or try readCalDataFromASDM instead."
        return 
    mytb.open(vis+'/ASDM_CALDATA')
    calDataId = np.array([int(c.split('_')[-1]) for c in mytb.getcol('calDataId')])
    calibType = mytb.getcol('calType')
    if (calType not in calibType):
        print "%s is not a calibration type in this dataset.\nAvailable types = %s" % (calType,str(np.unique(calibType)))
        return
    scanSet = []
    for row in range(len(calibType)):
        scanSet.append(mytb.getcell('scanSet',row))
    mytb.close()
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    if (calType == 'CAL_ATMOSPHERE'):
        calatmscans = mymsmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
    else:
        calatmscans = mymsmd.scansforintent(calType)
    mymsmd.close()
    mydict = {}
    for row in range(len(calibType)):
        cDI = calDataId[row]
        mydict[cDI] = scanSet[row]
    return(mydict)
    
def readCalDataFromASDM(sdmfile):
    """
    Builds a dictionary relating the calDataId to the scan number of an ASDM.
    Todd Hunter
    """
    if (os.path.exists(sdmfile) == False):
        print "readCalDataFromASDM(): Could not find file = ", sdmfile
        return
    xmlscans = minidom.parse(sdmfile+'/CalData.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    for rownode in rowlist:
        scandict[fid] = {}
        rowscan = rownode.getElementsByTagName("scanSet")
        tokens = rowscan[0].childNodes[0].nodeValue.split()
        scan = int(tokens[2])

        rowcaldataid = rownode.getElementsByTagName("calDataId")
        caldataid = str(rowcaldataid[0].childNodes[0].nodeValue)
        scandict[fid]['calDataId'] = caldataid
        scandict[fid]['scan'] = scan
        fid +=1 
    return(scandict)

def readCalPointingTable(sdmfile):
    """
    Reads the CalPointing.xml table for the specified ASDM
    and returns a dictionary of values.
    Todd Hunter
    """
    if (os.path.exists(sdmfile) == False):
        print "readCalPointingTable(): Could not find ASDM = ", sdmfile
        return(None)
    if (os.path.exists(sdmfile+'/CalPointing.xml') == False):
        print "readCalPointingTable(): Could not find CalPointing.xml.", sdmfile
        return(None)
    xmlscans = minidom.parse(sdmfile+'/CalPointing.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    for rownode in rowlist:
        scandict[fid] = {}
        rowAntennaName = rownode.getElementsByTagName("antennaName")
        antenna = str(rowAntennaName[0].childNodes[0].nodeValue)

        rowDirection = rownode.getElementsByTagName("direction")
#        for r in range(len(rowDirection)):
#            for c in range(len(rowDirection[r].childNodes)):
#                print "%d %d = " % (r,c), rowDirection[r].childNodes[c].nodeValue
        tokens = rowDirection[0].childNodes[0].nodeValue.split()
        azimuth = float(tokens[2])
        elevation = float(tokens[3])

        rowFrequency = rownode.getElementsByTagName("frequencyRange")
        tokens = rowFrequency[0].childNodes[0].nodeValue.split()
        frequency1 = float(tokens[2])
        frequency2 = float(tokens[3])
        frequency = 0.5*(frequency1+frequency2)

        rowRelative = rownode.getElementsByTagName("collOffsetRelative")
        tokens = rowRelative[0].childNodes[0].nodeValue.split()
        azOffset = float(tokens[3])
        elOffset = float(tokens[4])
        azOffset2 = float(tokens[5])
        elOffset2 = float(tokens[6])
        
        rowRelative = rownode.getElementsByTagName("collError")
        tokens = rowRelative[0].childNodes[0].nodeValue.split()
        azError = float(tokens[3])
        elError = float(tokens[4])
        azError2 = float(tokens[5])
        elError2 = float(tokens[6])
        
        rowCalDataId = rownode.getElementsByTagName("calDataId")
        calDataId = str(rowCalDataId[0].childNodes[0].nodeValue)
        scan = int(calDataId.split('_')[1])

        rowpol = rownode.getElementsByTagName("polarizationTypes")
        tokens = rowpol[0].childNodes[0].nodeValue.split()
        poltypes = []
        poltypes.append(str(tokens[2]))
        poltypes.append(str(tokens[3]))

        # start and end times in mjd ns
        rowstart = rownode.getElementsByTagName("startValidTime")
        start = int(rowstart[0].childNodes[0].nodeValue)/1000000000
        startmjd = start/86400.0
        t = qa.quantity(startmjd,'d')
        starttime = call_qa_time(t,form="ymd",prec=8)
        rowend = rownode.getElementsByTagName("endValidTime")
        end = int(rowend[0].childNodes[0].nodeValue)
        endmjd = float(end)*1.0E-9/86400.0
        t = qa.quantity(endmjd,'d')
        endtime = call_qa_time(t,form="ymd",prec=8)

        scandict[fid]['startValidTime'] = start
        scandict[fid]['endValidTime'] = end
        scandict[fid]['start'] = starttime
        scandict[fid]['end'] = endtime
        scandict[fid]['startmjd'] = startmjd
        scandict[fid]['endmjd'] = endmjd
        scandict[fid]['startmjdsec'] = startmjd*86400
        scandict[fid]['endmjdsec'] = endmjd*86400
        timestr = starttime+'~'+endtime
        scandict[fid]['azimuth'] = azimuth
        scandict[fid]['elevation'] = elevation
        scandict[fid]['antenna'] = antenna
        scandict[fid]['frequency'] = frequency
        scandict[fid]['azOffset'] = azOffset
        scandict[fid]['elOffset'] = elOffset
        scandict[fid]['azOffset2'] = azOffset2
        scandict[fid]['elOffset2'] = elOffset2
        scandict[fid]['azError'] = azError
        scandict[fid]['elError'] = elError
        scandict[fid]['azError2'] = azError2
        scandict[fid]['elError2'] = elError2
        scandict[fid]['scan'] = scan
        scandict[fid]['duration'] = (endmjd-startmjd)*86400
        scandict[fid]['polarizationTypes'] = poltypes
        fid += 1

    print '  Found ',rowlist.length,' rows in CalPointing.xml'

    # return the dictionary for later use
    return scandict
# end of readCalPointingTable(sdmfile):

def readCalPointing(asdm):
    """
    Calls readCalPointingTable() and converts the returned dictionary to a list
    of lists that is subsequently used by plotPointingResultsFromASDM().
    Todd Hunter
    """
    dict = readCalPointingTable(asdm)
    if (dict == None):
        return
    colOffsetRelative = []
    colError = []
    antennaName = []
    pols = []
    scans = []
    startValidTime = []
    azim = []
    elev = []
    for entry in dict:
        colOffsetRelative.append([[dict[entry]['azOffset'],dict[entry]['elOffset']],[dict[entry]['azOffset2'],dict[entry]['elOffset2']]])
        antennaName.append(dict[entry]['antenna'])
        startValidTime.append(dict[entry]['startValidTime'])
        pols.append(dict[entry]['polarizationTypes'])
        scans.append(dict[entry]['scan'])
        azim.append(dict[entry]['azimuth'])
        elev.append(dict[entry]['elevation'])
        colError.append([[dict[entry]['azError'], dict[entry]['elError']], [dict[entry]['azError2'], dict[entry]['elError2']]])
    return([ARCSEC_PER_RAD*np.array(colOffsetRelative), antennaName, startValidTime, pols, scans,
            np.array(azim)*180/math.pi,np.array(elev)*180/math.pi, ARCSEC_PER_RAD*np.array(colError)])   


def getMedianPWV(vis='.', myTimes=[0,999999999999], asdm='', verbose=False):
    """
    Extracts the PWV measurements from the WVR on all antennas for the
    specified time range.  The time range is input as a two-element list of
    MJD seconds (default = all times).  First, it tries to find the ASDM_CALWVR
    table in the ms.  If that fails, it then tries to find the 
    ASDM_CALATMOSPHERE table in the ms.  If that fails, it then tried to find 
    the CalWVR.xml in the specified ASDM, or failing that, an ASDM of the 
    same name (-.ms).  If neither of these exist, then it tries to find 
    CalWVR.xml in the present working directory. If it still fails, it looks 
    for CalWVR.xml in the .ms directory.  Thus, you only need to copy this 
    xml file from the ASDM into your ms, rather than the entire ASDM. Returns 
    the median and standard deviation in millimeters.
    Returns:
    The median PWV, and the median absolute deviation (scaled to match rms)
    For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/GetMedianPWV
    -- Todd Hunter
    """
    pwvmean = 0
    success = False
    if (verbose):
        print "in getMedianPWV with myTimes = ", myTimes
    try:
      if (os.path.exists("%s/ASDM_CALWVR"%vis)):
          tb.open("%s/ASDM_CALWVR" % vis)
          pwvtime = tb.getcol('startValidTime')  # mjdsec
          antenna = tb.getcol('antennaName')
          pwv = tb.getcol('water')
          tb.close()
          success = True
          if (len(pwv) < 1):
              if (os.path.exists("%s/ASDM_CALATMOSPHERE" % vis)):
                  pwvtime, antenna, pwv = readPWVFromASDM_CALATMOSPHERE(vis)
                  success = True
                  if (len(pwv) < 1):
                      print "Found no data in ASDM_CALWVR nor ASDM_CALATMOSPHERE table"
                      return(0,-1)
              else:
                  if (verbose):
                      print "Did not find ASDM_CALATMOSPHERE in the ms"
                  return(0,-1)
          if (verbose):
              print "Opened ASDM_CALWVR table, len(pwvtime)=", len(pwvtime)
      else:
          if (verbose):
              print "Did not find ASDM_CALWVR table in the ms. Will look for ASDM_CALATMOSPHERE next."
          if (os.path.exists("%s/ASDM_CALATMOSPHERE" % vis)):
              pwvtime, antenna, pwv = readPWVFromASDM_CALATMOSPHERE(vis)
              success = True
              if (len(pwv) < 1):
                  print "Found no data in ASDM_CALATMOSPHERE table"
                  return(0,-1)
          else:
              if (verbose):
                  print "Did not find ASDM_CALATMOSPHERE in the ms"
    except:
        if (verbose):
            print "Could not open ASDM_CALWVR table in the ms"
    finally:
    # try to find the ASDM table
     if (success == False):
       if (len(asdm) > 0):
           if (os.path.exists(asdm) == False):
               print "Could not open ASDM = ", asdm
               return(0,-1)
           try:
               [pwvtime,pwv,antenna] = readpwv(asdm)
           except:
               if (verbose):
                   print "Could not open ASDM = %s" % (asdm)
               return(pwvmean,-1)
       else:
           try:
               tryasdm = vis.split('.ms')[0]
               if (verbose):
                   print "No ASDM name provided, so I will try this name = %s" % (tryasdm)
               [pwvtime,pwv,antenna] = readpwv(tryasdm)
           except:
               try:
                   if (verbose):
                       print "Still did not find it.  Will look for CalWVR.xml in current directory."
                   [pwvtime, pwv, antenna] = readpwv('.')
               except:
                   try:
                       if (verbose):
                           print "Still did not find it.  Will look for CalWVR.xml in the .ms directory."
                       [pwvtime, pwv, antenna] = readpwv('%s/'%vis)
                   except:
                       if (verbose):
                           print "No CalWVR.xml file found, so no PWV retrieved. Copy it to this directory and try again."
                       return(pwvmean,-1)
    try:
        matches = np.where(np.array(pwvtime)>myTimes[0])[0]
    except:
        print "Found no times > %d" % (myTimes[0])
        return(0,-1)
    if (len(pwv) < 1):
        print "Found no PWV data"
        return(0,-1)
    if (verbose):
        print "%d matches = " % (len(matches)), matches
        print "%d pwv = " % (len(pwv)), pwv
    ptime = np.array(pwvtime)[matches]
    matchedpwv = np.array(pwv)[matches]
    matches2 = np.where(ptime<=myTimes[-1])[0]
    if (verbose):
        print "matchedpwv = %s" % (matchedpwv)
        print "pwv = %s" % (pwv)
    if (len(matches2) < 1):
        # look for the value with the closest start time
        mindiff = 1e12
        for i in range(len(pwvtime)):
            if (abs(myTimes[0]-pwvtime[i]) < mindiff):
                mindiff = abs(myTimes[0]-pwvtime[i])
#                pwvmean = pwv[i]*1000
        matchedpwv = []
        for i in range(len(pwvtime)):
            if (abs(abs(myTimes[0]-pwvtime[i]) - mindiff) < 1.0):
                matchedpwv.append(pwv[i])
        pwvmean = 1000*np.median(matchedpwv)
        if (verbose):
            print "Taking the median of %d pwv measurements from all antennas = %.3f mm" % (len(matchedpwv),pwvmean)
        pwvstd = 1000*MAD(matchedpwv)
    else:
        pwvmean = 1000*np.median(matchedpwv[matches2])
        pwvstd = 1000*MAD(matchedpwv[matches2])
        if (verbose):
            print "Taking the median of %d pwv measurements from all antennas = %.3f mm" % (len(matches2),pwvmean)
    return(pwvmean,pwvstd)
# end of getMedianPWV

def ReadWeatherStation(scandict, station):
    timeInterval = []
    pressure = []
    relHumidity = []
    temperature = []
    windDirection = []
    windSpeed = []
    windMax = []
    for entry in range(len(scandict)):
        if (scandict[entry]['stationId'] == station):
            timeInterval.append(scandict[entry]['timeInterval'])
            pressure.append(scandict[entry]['pressure'])
            relHumidity.append(scandict[entry]['relHumidity'])
            temperature.append(scandict[entry]['temperature'])
            windDirection.append(scandict[entry]['windDirection'])
            windSpeed.append(scandict[entry]['windSpeed'])
            windMax.append(scandict[entry]['windMax'])
#        else:
#            print "scandict=%d != %d" % (scandict[entry]['stationId'],station)
    d1 = [timeInterval, pressure, relHumidity, temperature, windDirection,
          windSpeed, windMax, station]
    return(d1)

def convertASDMTimeIntervalToMJDSeconds(s):
    """
    converts a string of format: 'start=2013-11-10T07:44:17.552000000, duration=369.180000'
    to MJD seconds.
    -Todd Hunter
    """
    ymdhms = s.split('=')[1].split(',')[0]
    return(dateStringToMJDSec(ymdhms,verbose=False))

def asdmspwmap(asdm):
    """
    Generate a list that maps the spw number that will be found in the
    measurement set to the corresponding value in the ASDM xml files.
    In general, the order will be [0,n+1,n+2,....] where n=number of antennas
    with WVR data.  For example: [0,5,6,7...] if n=4 antennas, meaning
    that spw 1 in the ms = spw 5 in the ASDM xml files.
    -Todd Hunter
    """
    if (asdmLibraryAvailable == False):
        print "The ASDM bindings library is not available on this machine."
        return
    a = ASDM()
    a.setFromFile(asdm,True)
    spwTable = a.spectralWindowTable().get()
    spwmap = []
    for row in range(len(spwTable)):
        if (spwTable[row].name().find('WVR#Antenna') < 0):
            spwmap.append(row)
    return(spwmap)

def readTcal(asdm, antenna, spw, meantime=None, spectrum='tcal', verbose=False):
    """
    Read the Tcal, Trx, Tsky, or Tsys spectrum for a specific antenna, spw and time. 
    If the time is not specified, it will return a dictionary of spectra keyed
    by the time (in MJD seconds).  The spw should be an spw number
    in the measurement set that is associated with a CALIBRATE_ATMOSPHERE scan.
    A conversion will be made to the spw number
    in the ASDM. If the spw is FDM, it is up to the user to find
    the associated TDM spw (e.g. via tsysspwmap) and pass it in.
    antenna: the antenna ID (string or integer, not the name)
    spw: the spw ID (string or integer)
    spectrum: 'tsys', 'trx' or 'tcal'

    Returns:
    A dictionary keyed by the MJD in seconds, with values equal to a list of
    arrays (one per polarization) each with N channels.
    
    Todd Hunter
    """
    spectrum = spectrum.lower()
    antenna = str(antenna)
    spw = int(spw)
    if (asdmLibraryAvailable == False):
        print "The ASDM bindings library is not available on this machine."
        return
    a = ASDM()
    a.setFromFile(asdm,True)
    sysCalTable = a.sysCalTable().get()
    # find offset (usually it is the number of antennas with WVR data)
    spwmap = asdmspwmap(asdm)
    if (verbose):
        print "Spwmap = ", spwmap
    spectra = {}
    timeDelta = 1e20
    for row in sysCalTable:
        antennaId = str(row.antennaId()).split('_')[1]
        if (antennaId == antenna):
            spectralWindowId = str(row.spectralWindowId()).split('_')[1]
            myspw = int(spectralWindowId)
            if (verbose):
                print "spw %d in the MS is spw %d in the ASDM, comparing to ASDM spw %d" % (spw, spwmap[spw], myspw)
            if (spwmap[spw] == myspw):
                mjdsec = convertASDMTimeIntervalToMJDSeconds(str(row.timeInterval()))
                if (spectrum == 'tcal'):
                    values = row.tcalSpectrum()
                elif (spectrum == 'trx'):
                    values = row.trxSpectrum()
                elif (spectrum == 'tsys'):
                    values = row.tsysSpectrum()
                elif (spectrum == 'tsky'):
                    values = row.tsysSpectrum()
                else:
                    print "Unrecognized spectrum type (%s)" % (spectrum)
                    return
                spectra[mjdsec] = []
                for v in values: # there will be one per polarization
                    spectra[mjdsec].append(np.array([v[f].get() for f in range(row.numChan())]))
                if (meantime != None):
                    if (abs(mjdsec-meantime) < timeDelta):
                        timeDelta = abs(mjdsec-meantime)
                        closestTime = mjdsec
    if (verbose):
        print "Found %d spectra" % (len(spectra))
    if (meantime == None):
        return(spectra)
    else:
        return(spectra[closestTime], closestTime)
    
def readStationFromASDM(sdmfile, station=None):
    """
    This function uses the ASDM bindings from casapy-telcal and reads the Station position from the
    Station.xml file ( in the ASDM) and returns a dictionary of station positions if no station is
    specified.  The dictionary format is:  {0: {'name':'J503',position:[x,y,z]}, 1:  etc.}.  If a
    station is specified, then it returns the name and location as a simple list: ['J503',[x,y,z]].  
    - dbarkats
    """
    if (asdmLibraryAvailable == False):
        print "The ASDM bindings library is not available on this machine. Using minidom code instead."
        mydict = au_noASDMLibrary.readStationFromASDM_minidom(sdmfile)
        if (station==None):
            return(mydict)
        else:
            return(mydict[station]['name'],mydict[station]['position'])
    a = ASDM()
    a.setFromFile(sdmfile,True)
    stationTable = a.stationTable().get()  

    staPos = {}
    for row in stationTable:
        stationName = row.name()
        position = [row.position()[0].get(),row.position()[1].get(),row.position()[2].get()]
        id = row.stationId().get()
        if (id not in staPos):  staPos[id] = {}
        staPos[id] = {'position':position, 'name':stationName}
    if (station != None):
        return(staPos[station]['name'], staPos[station]['position'])
    return staPos

def readAntennaPositionFromASDM(sdmfile, station=None):
    """
    this function uses the ASDM bindings from casapy-telcal  and reads the Antenna position from the
    Antenna.xml file (in the ASDM)  and returns a dictionary of Antenna positions

    - dbarkats
    """
    if (asdmLibraryAvailable == False):
        print "The ASDM bindings library is not available on this machine."
        return
    a = ASDM()
    a.setFromFile(sdmfile,True)
    antennaTable = a.antennaTable().get()  

    antPos = {}
    for row in antennaTable:
        antName = row.name()
        id = row.stationId().get()
        position = [row.position()[0].get(),row.position()[1].get(),row.position()[2].get()]
        if (antName not in antPos):  antPos[antName] = {}
        antPos[antName] = {'position':position, 'id':id}
        
    return antPos

def getBaselineLengthsFromASDM(asdm, refAnt):
    bl = {}
    antList = readAntennasFromASDM(asdm)
    antPos = readAntennaPositionFromASDM(asdm)
    padPos = readStationFromASDM(asdm)
    refAntPos = padPos[antPos[refAnt]['id']]['position']
    for ant in antList:
        bl[ant]= computeBaselineLength(padPos[antPos[ant]['id']]['position'], refAntPos)
        #print ant, int(bl[ant]*100)/100.
    return bl
    
def printSwVersionFromASDM(asdm):
    """
    Reads and prints the contents of the ASDM's Annotation.xml table.
    -Denis Barkats and Todd Hunter
    """
    if (asdmLibraryAvailable == False):
        print "The ASDM bindings library is not available on this machine. Using the minidom code instead."
        return(au_noASDMLibrary.readSoftwareVersionFromASDM_minidom(asdm))
    a = ASDM()
    a.setFromFile(asdm,True)
    at = a.annotationTable().get()
    print '\n### Software version for ASDM: %s ###' %asdm
    for row in at:
        print "%s: %s" %(row.issue(),row.details())

    print "#### \n"
    return

def printFluxesFromASDM(sdmfile, sourcename='', field=-1, useCalFlux=False, spw=-1):
    """
    Calls readFluxesFromASDM, organizes the output and prints it to
    the screen.
    -Todd Hunter
    """
    result = readFluxesFromASDM(sdmfile, sourcename, field, useCalFlux)
    if (result == None):
        print "readFluxesFromASDM returns None"
        return
    if (type(spw) == list):
        spwlist = spw
    elif (type(spw) == str):
        spwlist = [int(n) for n in spw.split(',')]
    else:
        spwlist = [spw]
#    print "spwlist = ", spwlist
    mylist, mydict = result
    srcName = mydict.keys()[0]
    stokes = ''
    stokesParameters = mydict[srcName][0]['stokesParameters']
    for sp in stokesParameters:
        stokes += sp + ' '
    intents = getIntentsFromASDM(sdmfile,stripPrefix=True)
    for source in mydict.keys():
        if (source in intents.keys()):
            print "%s intents = %s" % (source, intents[source])
    if ('frequency' in mydict[srcName][0].keys()):
        print "Sourcename  spw   Freq(GHz)  Flux densities (%s)" % (stokes)
    else:
        print "Sourcename  Freq(GHz)  Flux densities (%s)" % (stokes)
    for source in mydict.keys():
        for entry in mydict[source]:
          if (entry['spw'] in spwlist or spwlist == [-1]):
            if ('frequency' in entry.keys()):
                for f in range(len(entry['frequency'])):
                    line = "%s  %2d  " % (source, entry['spw'])
                    freq = entry['frequency'][f]
                    line +=  '%.3f  ' % (freq)
                    for stokes in range(len(entry['stokesParameters'])):
                        line +=  '%.3f  ' % (entry['fluxDensity'][f][stokes])
                    print line
            else:  # These results are from the CalFlux.xml file
                for f in range(len(entry['frequencyRange'])):
                    line = "%s  " % (source)
                    freq = entry['frequencyRange'][f]
                    line +=  '%.3f-%.3f  ' % (freq[0],freq[1])
                    for stokes in range(len(entry['stokesParameters'])):
                        print "entry['fluxDensity'][f] = ", entry['fluxDensity'][f]
                        print "stokes = ", stokes
                        line +=  '%.3f  ' % (entry['fluxDensity'][f][stokes])
                    print line
                
def readFluxesFromASDM(sdmfile, sourcename='', field=-1, useCalFlux=False, spw=-1):
    """
    Read the flux densities from an ASDM.  If useCalFlux=False,
    look for fluxes in the Source.xml table, otherwise, look in CalFlux.xml.
    Returns a raw list of dictionaries (one per row) and a dictionary of
    the information keyed by the field name. Specify a sourcename or
    field ID to limit the results to a specific source. Inserting the
    wildcard character (*) into sourcename will return partial matches.
            {'sourceName': sourceName, 'stokes': stokesParameters,
            'frequencyRange': frequency, 'fluxDensity': fluxDensity,
            'fluxDensityError': fluxDensityError}
    - Todd Hunter
    """
    if (type(spw) != list):
        if (type(spw) == string):
            spw = [int(a) for a in spw.split(',')]
        else:
            spw = [spw]
    if (os.path.exists(sdmfile) == False):
        print "readFluxesFromASDM(): Could not find file = ", sdmfile
        return(None)
    if (useCalFlux):
        calflux = sdmfile + '/CalFlux.xml'
        if (os.path.exists(calflux) == False):
            print "readFluxesFromASDM(): Could not find file = ", calflux
            print "Looking for Source.xml instead"
            sourcefile = sdmfile + '/Source.xml'
            if (os.path.exists(sourcefile) == False):
                print "readFluxesFromASDM(): Could not find file = ", sourcefile
                return(None)
            useCalFlux = False
    else:
        sourcefile = sdmfile + '/Source.xml'
        if (os.path.exists(sourcefile) == False):
            print "readFluxesFromASDM(): Could not find file = ", sourcefile
            return(None)
    scandict = {}
    fid = 0
    sources = []
    myspw = ''
    sourceid=''
    if (useCalFlux == False):   # Source.xml
        noFrequencyKeywords = True
        xmlscans = minidom.parse(sourcefile)
        rowlist = xmlscans.getElementsByTagName("row")
        for rownode in rowlist:
            scandict[fid] = {}
            row = rownode.getElementsByTagName("sourceId")
            sourceId = int(str(row[0].childNodes[0].nodeValue))
            if (sourceid != '' and sourceid != sourceId): continue
            row = rownode.getElementsByTagName("sourceName")
            sourceName = str(row[0].childNodes[0].nodeValue).strip(' ')
            if (sourcename != ''):
                if (sourcename.find('*') >= 0):
                    if (sourceName.find(sourcename.replace('*','')) < 0): continue
                else:
                    if (sourceName != sourcename):
                        continue
            elif (field != -1):
                if (sourceId != field):
                    continue
                
            row = rownode.getElementsByTagName("spectralWindowId")
            spectralWindowId = int(str(row[0].childNodes[0].nodeValue).split('_')[-1])
            if (myspw != '' and myspw != spectralWindowId): continue
            row = rownode.getElementsByTagName("frequency")
            if (row == []):
                continue
            noFrequencyKeywords = False
            r = filter(None, (row[0].childNodes[0].nodeValue).split(' '))
            frequency = []
            for freq in r[2:]:
                frequency.append(float(freq))
            row = rownode.getElementsByTagName("stokesParameter")
            r = filter(None,str(row[0].childNodes[0].nodeValue).split(' '))
            stokesParameters = []
            for stokes in r[2:]:
                stokesParameters.append(stokes)
            row = rownode.getElementsByTagName("flux")
            r = filter(None,(row[0].childNodes[0].nodeValue).split(' '))
            nflux = int(r[1])
            fluxDensity = []
            for flux in range(nflux):
                stokesFlux = []
                for stokes in range(len(stokesParameters)):
                    stokesFlux.append(float(r[3+stokes+flux*len(stokesParameters)]))
                fluxDensity.append(stokesFlux)
            if (spectralWindowId in spw or spw==[-1]):
                sources.append({'sourceId': sourceId, 'sourceName': sourceName,
                                'spw': spectralWindowId,
                                'stokesParameters': stokesParameters,
                                'frequency': frequency, 'fluxDensity': fluxDensity})
                fid +=1
    else:
        # still working on this
        xmlscans = minidom.parse(calflux)
        rowlist = xmlscans.getElementsByTagName("row")
        for rownode in rowlist:
            scandict[fid] = {}
            row = rownode.getElementsByTagName("sourceName")
            sourceName = str(row[0].childNodes[0].nodeValue)
            if (sourcename != ''):
                if (sourcename.find('*') >= 0):
                    if (sourceName.find(sourcename.replace('*','')) < 0): continue
                else:
                    if (sourceName != sourcename):
                        continue
            row = rownode.getElementsByTagName("frequencyRanges")
            if (row == []):
                continue
            r = filter(None, (row[0].childNodes[0].nodeValue).split(' '))
            frequency = []
            for freq in range(3,len(r)-1,2):
                frequency.append([float(r[freq])*1.0e-9, float(r[freq+1])*1.0e-9])
            row = rownode.getElementsByTagName("stokes")
            r = filter(None,str(row[0].childNodes[0].nodeValue).split(' '))
            stokesParameters = []
            for stokes in r[2:]:
                stokesParameters.append(stokes)
            row = rownode.getElementsByTagName("flux")
            r = filter(None,(row[0].childNodes[0].nodeValue).split(' '))
            rowerror = rownode.getElementsByTagName("fluxError")
            rerror = filter(None,(rowerror[0].childNodes[0].nodeValue).split(' '))
            nflux = int(r[1])
            fluxDensity = []
            fluxDensityError = []
            for flux in range(nflux):
                stokesFlux = []
                errorFlux = []
                for stokes in range(len(stokesParameters)):
                    stokesFlux.append(float(r[3+stokes+flux*len(stokesParameters)]))
                    errorFlux.append(float(rerror[3+stokes+flux*len(stokesParameters)]))
                fluxDensity.append(stokesFlux)
                fluxDensityError.append(errorFlux)
            sources.append({'sourceName': sourceName, 'stokes': stokesParameters,
                            'frequencyRange': frequency, 'fluxDensity': fluxDensity,
                            'fluxDensityError':fluxDensityError})
            fid +=1
    mydict = {}
    for src in sources:
        if (src['sourceName'] not in mydict.keys()):
            mydict[src['sourceName']] = []
        if (useCalFlux == False):
            subdict = {'fluxDensity': src['fluxDensity'], 'frequency': src['frequency'], 'spw': src['spw'],
                       'stokesParameters': src['stokesParameters']}
        else:
            subdict = {'fluxDensity': src['fluxDensity'], 'frequencyRange': src['frequencyRange'],
                       'stokesParameters': src['stokes']}
        mydict[src['sourceName']].append(subdict)
    if (useCalFlux == False and noFrequencyKeywords):
        print "No frequency keywords found in the Source.xml file. Try setting useCalFlux=True."
    return(sources, mydict)


def getWeatherFromASDM(sdmfile='',verbose=False, station=1):
    """
    Reads the weather table in the ASDM, and returns an array of values,
    and a dictionary of the median values.  Default station is 1 (for WSTB1),
    but 2 can also be given (for WSTB2).
    - T. Hunter
    """
    scandict = readWeatherFromASDM(sdmfile)
    if (scandict == None):
        return({},{},'')
    if (verbose):
        print "len(scandict) = ", len(scandict)
    stationOrder = range(69)  # max antennas + max weather stations (66+2)
    for s in stationOrder:
        d1 = ReadWeatherStation(scandict, station=s)
        if (len(d1[0]) > 0):
            print "Calling readStationFromASDM('%s',%d)" % (sdmfile,s)
            stationName,stationLocation = readStationFromASDM(sdmfile, s)
            if (stationName.find('WSTB%d'%station) >= 0):
                print "Data found from stationId %d" % (s)
                print "Name = %s, location = " % (stationName), stationLocation
                break
    d2 = {}
    if (len(d1[0]) < 1):
        print "No data found from any stations"
        return(d1,d2,'')

    timeInterval, pressure, relHumidity, temperature, windDirection, windSpeed, windMax, station = d1
    d2['pressure'] = np.median(pressure)
    d2['humidity'] = np.median(relHumidity)
    d2['temperature'] = np.median(temperature)
    sinWindDirection = np.sin(np.array(windDirection)*np.pi/180)
    cosWindDirection = np.cos(np.array(windDirection)*np.pi/180)
    d2['windDirection'] = (180./np.pi)*np.arctan2(np.mean(sinWindDirection),
                                                  np.mean(cosWindDirection))
    if (d2['windDirection'] < 0):
        d2['windDirection'] += 360
    d2['windSpeed'] = np.median(windSpeed)
    d2['windMax'] = np.median(windMax)
    return(d1,d2,stationName)

def readWeatherFromASDM(sdmfile, station=16):
    """
    Reads the weather table in the ASDM, and returns a dictionary containing:
    timeInterval, pressure, relHumidity, temperature, windDirection, windSpeed,
    windMax and stationId.
    - T. Hunter
    """
    if (os.path.exists(sdmfile) == False):
        print "readWeatherFromASDM(): Could not find file = ", sdmfile
        return(None)
    xmlscans = minidom.parse(sdmfile+'/Weather.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    for rownode in rowlist:
        scandict[fid] = {}
        row = rownode.getElementsByTagName("timeInterval")
        tokens = row[0].childNodes[0].nodeValue.split()
        scandict[fid]['timeInterval'] = float(tokens[0])*1e-9  # MJD seconds
        row = rownode.getElementsByTagName("pressure")
        scandict[fid]['pressure'] = float(row[0].childNodes[0].nodeValue)*0.01 # mbar
        row = rownode.getElementsByTagName("relHumidity")
        scandict[fid]['relHumidity'] = float(row[0].childNodes[0].nodeValue)
        row = rownode.getElementsByTagName("temperature")
        scandict[fid]['temperature'] = float(row[0].childNodes[0].nodeValue)
        row = rownode.getElementsByTagName("windDirection")
        scandict[fid]['windDirection'] = float(row[0].childNodes[0].nodeValue)*180/math.pi  # degrees
        row = rownode.getElementsByTagName("windSpeed")
        scandict[fid]['windSpeed'] = float(row[0].childNodes[0].nodeValue)
        row = rownode.getElementsByTagName("windMax")
        scandict[fid]['windMax'] = float(row[0].childNodes[0].nodeValue)
        row = rownode.getElementsByTagName("stationId")
        scandict[fid]['stationId'] = int((str(row[0].childNodes[0].nodeValue)).split('_')[1])
        fid += 1
    return scandict

# Obsolete, now replaced by getObservationStartDateFromASDM(asdm):
#def getASDMStartTime(sdmfile):
#    # get the start time of the ASDM
#    b = os.popen('grep TimeOfCreation %s/ASDM.xml' %sdmfile).read()
#    dateOfCreation = b.split('>')[1].split('<')[0]
#    return dateOfCreation[0:22]

def readStationsFromASDM(sdmfile):
    """
    Similar to readStationFromASDM, but returns different format dictionary
    {'J503': [x,y,z], 'N605': etc.}
    -Todd Hunter
    """
    if (asdmLibraryAvailable == False):
        mydict = au_noASDMLibrary.readStationsFromASDM_minidom(sdmfile)
    else:
        mydict = readStationFromASDM(sdmfile)
        newdict = {}
        for station in mydict.keys():
            name = mydict[station]['name']
            position = mydict[station]['position']
            newdict[name] = position
        mydict = newdict
    return(mydict)

def readAntennasFromASDM(sdmfile, stations=False, diameters=False, printOnly=False):
    """
    Reads the list of antenna names from the ASDM.
    stations: if True, also return the stations in a second integer list
    diameters: if True, also return the dish diameters in a second (or third) integer list
    - D Barkats
    """
    xmlscans = minidom.parse(sdmfile+'/Antenna.xml')
    antList = []
    stationList = []
    dishDiameterList = []
    rowlist = xmlscans.getElementsByTagName("row")
    for rownode in rowlist:
        row = rownode.getElementsByTagName("name")
        tokens = row[0].childNodes[0].nodeValue.split()
        antList.append(str(tokens[0]))
        if (stations):
            row = rownode.getElementsByTagName("stationId")
            tokens = row[0].childNodes[0].nodeValue.split()
            stationList.append(int(str(tokens[0]).split('_')[1]))
        if (diameters):
            row = rownode.getElementsByTagName("dishDiameter")
            tokens = row[0].childNodes[0].nodeValue.split()
            dishDiameterList.append(float(str(tokens[0])))
    print '%s'%', '.join(map(str, antList))
    if (stations and diameters):
        return antList, stationList, dishDiameterList
    elif (stations):
        return antList, stationList
    elif (diameters):
        return antList, dishDiameterList
    else:
        return antList

def getWeather(vis, scan='', antenna='0',verbose=False, vm=0, mymsmd=''):
    """
    Queries the WEATHER and ANTENNA tables of an .ms by scan number or
    list of scan numbers in order to return mean values of: angleToSun,
      pressure, temperature, humidity, dew point, wind speed, wind direction,
      azimuth, elevation, solarangle, solarelev, solarazim.
    If the sun is below the horizon, the solarangle returns is negated.
    If run in casa < 4.1.0, this function needs to run ValueMapping, unless
    a ValueMapping object is passed via the vm argument. Otherwise it will
    run msmd.open, unless an msmd tool is passed via the mymsmd argument.
    -- Todd Hunter
    """
#    if (verbose):
#        print "Entered getWeather with vis,scan,antenna = ", vis, ",", scan, ",", antenna
    if (os.path.exists(vis) == False):
        print "Measurement set not found"
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    try:
        if str(antenna).isdigit():
            antennaName = getAntennaNames(vis)[int(str(antenna))]
        else:
            antennaName = antenna
            try:
                antenna = getAntennaIndex(vis,antennaName)
            except:
                antennaName = string.upper(antenna)
                antenna = getAntennaIndex(vis,antennaName)
    except:
        print "Either the ANTENNA table does not exist or antenna %s does not exist" % (antenna)
        return([0,[],vm])
    try:
        tb.open("%s/POINTING" % vis)
    except:
        print "POINTING table does not exist"
        return([0,0,vm])
    subtable = tb.query("ANTENNA_ID == %s" % antenna)
    tb.close()
    needToClose_mymsmd = False
    if (vm == 0 or vm==''):
        if (casadef.casa_version < '4.1.0'):
            print "getWeather: Running ValueMapping... (this may take a minute)"
            vm = ValueMapping(vis)
        elif (mymsmd == ''):
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(vis)
            needToClose_mymsmd = True
    else:
        if (verbose):
            print "getWeather: Using current ValueMapping result"
    try:
        tb.open("%s/OBSERVATION" % vis)
        observatory = tb.getcell("TELESCOPE_NAME",0)
        tb.close()
    except:
        print "OBSERVATION table does not exist, assuming observatory == ALMA"
        observatory = "ALMA"
    if (scan == ''):
        if (mymsmd != '' and casadef.casa_version >= '4.1.0'):
            scan = mymsmd.scannumbers()
        else:
            scan = vm.uniqueScans
    conditions = {}
    conditions['pressure']=conditions['temperature']=conditions['humidity']=conditions['dewpoint']=conditions['windspeed']=conditions['winddirection'] = 0
    conditions['scan'] = scan
    if (type(scan) == str):
        if (scan.find('~')>0):
            tokens = scan.split('~')
            scan = [int(k) for k in range(int(tokens[0]),int(tokens[1])+1)]
        else:
            scan = [int(k) for k in scan.split(',')]
    if (type(scan) == np.ndarray):
        scan = list(scan)
    if (type(scan) == list):
        myTimes = np.array([])
        for sc in scan:
            try:
                if (mymsmd != '' and casadef.casa_version >= '4.1.0'):
#                    print "1) Calling mymsmd.timesforscan(%d)" % (sc)
                    newTimes = mymsmd.timesforscan(sc)
                else:
#                    print "1) Calling vm.getTimesForScan(%d)" % (sc)
                    newTimes = vm.getTimesForScan(sc)
            except:
                print "1) Error reading scan %d, is it in the data?" % (sc)
                if (needToClose_mymsmd): mymsmd.close()
                return([conditions,[],vm])
            myTimes = np.concatenate((myTimes,newTimes))
    elif (scan != None):
        try:
            if (mymsmd != '' and casadef.casa_version >= '4.1.0'):
#                print "2) Calling mymsmd.timesforscan(%d)" % (scan)
                myTimes = mymsmd.timesforscan(scan)
            else:
#                print "2) Calling vm.getTimesForScan(%d)" % (scan)
                myTimes = vm.getTimesForScan(scan)
        except:
            print "2) Error reading scan %d, is it in the data?" % (scan)
            if (needToClose_mymsmd): mymsmd.close()
            return([conditions,[],vm])
    else:
        print "scan = ", scan
        if (needToClose_mymsmd): mymsmd.close()
        return([conditions,[],vm])
    if (type(scan) == str):
        scan = [int(k) for k in scan.split(',')]
    if (type(scan) == list):
        listscan = ""
        listfield = []
        for sc in scan:
#            print "Processing scan ", sc
            if (mymsmd != '' and casadef.casa_version >= '4.1.0'):
                listfield.append(mymsmd.fieldsforscan(sc))
            else:
                listfield.append(vm.getFieldsForScan(sc))
            listscan += "%d" % sc
            if (sc != scan[-1]):
                listscan += ","
#        print "listfield = ", listfield
        listfields = np.unique(listfield[0])
        listfield = ""
        for field in listfields:
            listfield += "%s" % field
            if (field != listfields[-1]):
                listfield += ","
    else:
        listscan = str(scan)
        if (mymsmd != '' and casadef.casa_version >= '4.1.0'):
            listfield = mymsmd.fieldsforscan(scan)
        else:
            listfield = vm.getFieldsForScan(scan)
    [az,el] = ComputeSolarAzEl(myTimes[0], observatory)
    [az2,el2] = ComputeSolarAzEl(myTimes[-1], observatory)
    azsun = np.mean([az,az2])
    elsun = np.mean([el,el2])
    direction = subtable.getcol("DIRECTION")
    azeltime = subtable.getcol("TIME")
    subtable.close()
    telescopeName = getObservatoryName(vis)
    if (len(direction) > 0 and telescopeName.find('VLA') < 0):
        azimuth = direction[0][0]*180.0/math.pi
        elevation = direction[1][0]*180.0/math.pi
#        print "len(azimuth) = %d, len(myTimes)=%d" % (len(azimuth), len(myTimes))
        npat = np.array(azeltime)
        matches = np.where(npat>=myTimes[0])[0]
        matches2 = np.where(npat<=myTimes[-1])[0]
        matchingIndices = range(matches[0],matches2[-1]+1)
        if (len(matchingIndices) > 0):
            conditions['azimuth'] = np.mean(azimuth[matches[0]:matches2[-1]+1])
            conditions['elevation'] = np.mean(elevation[matches[0]:matches2[-1]+1])
        else:
            conditions['azimuth'] = np.mean(azimuth[matches[0]])
            conditions['elevation'] = np.mean(elevation[matches[0]])
            
#        print "%d matches after %f, %d matches before %f" % (len(matches), myTimes[0], len(matches2), myTimes[-1])
        conditions['solarangle'] = angularSeparation(azsun,elsun,conditions['azimuth'],conditions['elevation'])
        conditions['solarelev'] = elsun
        conditions['solarazim'] = azsun
        if (verbose):
            print "Using antenna = %s to retrieve mean azimuth and elevation" % (antennaName)
            print "Separation from sun = %f deg" % (abs(conditions['solarangle']))
        if (elsun<0):
            conditions['solarangle'] = -conditions['solarangle']
            if (verbose):
                print "Sun is below horizon (elev=%.1f deg)" % (elsun)
        else:
            if (verbose):
                print "Sun is above horizon (elev=%.1f deg)" % (elsun)
        if (verbose):
            print "Average azimuth = %.2f, elevation = %.2f degrees" % (conditions['azimuth'],conditions['elevation'])
    else:
      if (verbose):
          print "The POINTING table is blank."
      if (type(scan) == int or type(scan)==np.int32):
          # compute Az/El for this scan
          if (mymsmd != '' and casadef.casa_version >= '4.1.0'):
              myfieldId = mymsmd.fieldsforscan(scan)
              if (type(myfieldId) == list or type(myfieldId) == type(np.ndarray(0))):
                  myfieldId = myfieldId[0]
              fieldName = mymsmd.namesforfields(myfieldId)
              if (type(fieldName) == list):
                  fieldName = fieldName[0]
          else:
              fieldName = vm.getFieldsForScan(scan)
              if (type(fieldName) == list):
                  fieldName = fieldName[0]
              myfieldId = vm.getFieldIdsForFieldName(fieldName)
              if (type(myfieldId) == list or type(myfieldId) == type(np.ndarray(0))):
                  # If the same field name has two IDs (this happens in EVLA data)
                  myfieldId = myfieldId[0]
  #            print "type(myfieldId) = ", type(myfieldId)
          if (mymsmd != '' and casadef.casa_version >= '4.1.0'):
              myscantime = np.mean(mymsmd.timesforscan(scan))
          else:
              myscantime = np.mean(vm.getTimesForScans(scan))
          mydirection = getRADecForField(vis, myfieldId)
          if (len(telescopeName) < 1):
              telescopeName = 'ALMA'
          myazel = computeAzElFromRADecMJD(mydirection, myscantime/86400., telescopeName, verbose=False)
          conditions['elevation'] = myazel[1] * 180/math.pi
          conditions['azimuth'] = myazel[0] * 180/math.pi
          conditions['solarangle'] = angularSeparation(azsun,elsun,conditions['azimuth'],conditions['elevation'])
          conditions['solarelev'] = elsun
          conditions['solarazim'] = azsun
          if (verbose):
              print "Separation from sun = %f deg" % (abs(conditions['solarangle']))
          if (elsun<0):
              conditions['solarangle'] = -conditions['solarangle']
              if (verbose):
                  print "Sun is below horizon (elev=%.1f deg)" % (elsun)
          else:
              if (verbose):
                  print "Sun is above horizon (elev=%.1f deg)" % (elsun)
          if (verbose):
              print "Average azimuth = %.2f, elevation = %.2f degrees" % (conditions['azimuth'],conditions['elevation'])
      elif (type(scan) == list):
          myaz = []
          myel = []
          if (verbose):
              print "Scans to loop over = ", scan
          for s in scan:
              if (type(myfieldId) == list or type(myfieldId)==np.ndarray):
                  fieldName = mymsmd.fieldsforscan(s)
              else:
                  fieldName = vm.getFieldsForScan(s)
              if (type(fieldName) == list):
                  # take only the first pointing in the mosaic
                  fieldName = fieldName[0]
              if (type(myfieldId) == list or type(myfieldId)==np.ndarray):
                  myfieldId = mymsmd.fieldsforname(fieldName)
              else:
                  myfieldId = vm.getFieldIdsForFieldName(fieldName)
              if (type(myfieldId) == list or type(myfieldId)==np.ndarray):
                  # If the same field name has two IDs (this happens in EVLA data)
                  myfieldId = myfieldId[0]
              if (type(myfieldId) == list or type(myfieldId)==np.ndarray):
                  myscantime = np.mean(mymsmd.timesforscan(s))
              else:
                  myscantime = np.mean(vm.getTimesForScans(s))
              mydirection = getRADecForField(vis, myfieldId)
              telescopeName = getObservatoryName(vis)
              if (len(telescopeName) < 1):
                  telescopeName = 'ALMA'
              myazel = computeAzElFromRADecMJD(mydirection, myscantime/86400., telescopeName, verbose=False)
              myaz.append(myazel[0]*180/math.pi)
              myel.append(myazel[1]*180/math.pi)
          conditions['azimuth'] = np.mean(myaz)
          conditions['elevation'] = np.mean(myel)
          conditions['solarangle'] = angularSeparation(azsun,elsun,conditions['azimuth'],conditions['elevation'])
          conditions['solarelev'] = elsun
          conditions['solarazim'] = azsun
          if (verbose):
              print "*Using antenna = %s to retrieve mean azimuth and elevation" % (antennaName)
              print "Separation from sun = %f deg" % (abs(conditions['solarangle']))
          if (elsun<0):
              conditions['solarangle'] = -conditions['solarangle']
              if (verbose):
                  print "Sun is below horizon (elev=%.1f deg)" % (elsun)
          else:
              if (verbose):
                  print "Sun is above horizon (elev=%.1f deg)" % (elsun)
          if (verbose):
              print "Average azimuth = %.2f, elevation = %.2f degrees" % (conditions['azimuth'],conditions['elevation'])
          
              
    # now, get the weather
    try:
        tb.open("%s/WEATHER" % vis)
    except:
        print "Could not open the WEATHER table for this ms."
        if (needToClose_mymsmd): mymsmd.close()
        return([conditions,myTimes,vm])
    if (True):
        mjdsec = tb.getcol('TIME')
        indices = np.argsort(mjdsec)
        mjd = mjdsec/86400.
        pressure = tb.getcol('PRESSURE')
        relativeHumidity = tb.getcol('REL_HUMIDITY')
        temperature = tb.getcol('TEMPERATURE')
        if (np.mean(temperature) > 100):
            # must be in units of Kelvin, so convert to C
            temperature -= 273.15        
        dewPoint = tb.getcol('DEW_POINT')
        if (np.mean(dewPoint) > 100):
            # must be in units of Kelvin, so convert to C
            dewPoint -= 273.15        
        if (np.mean(dewPoint) == 0):
            # assume it is not measured and use NOAA formula to compute from humidity:
            dewPoint = ComputeDewPointCFromRHAndTempC(relativeHumidity, temperature)
        sinWindDirection = np.sin(tb.getcol('WIND_DIRECTION'))
        cosWindDirection = np.cos(tb.getcol('WIND_DIRECTION'))
        windSpeed = tb.getcol('WIND_SPEED')
        tb.close()

        # put values into time order (they mostly are, but there can be small differences)
        mjdsec = np.array(mjdsec)[indices]
        pressure = np.array(pressure)[indices]
        relativeHumidity = np.array(relativeHumidity)[indices]
        temperature = np.array(temperature)[indices]
        dewPoint = np.array(dewPoint)[indices]
        windSpeed = np.array(windSpeed)[indices]
        sinWindDirection = np.array(sinWindDirection)[indices]
        cosWindDirection = np.array(cosWindDirection)[indices]

        # find the overlap of weather measurement times and scan times
        matches = np.where(mjdsec>=np.min(myTimes))[0]
        matches2 = np.where(mjdsec<=np.max(myTimes))[0]
#        print "len(matches)=%d, len(matches2)=%d, len(myTimes)=%d, len(mjdsec)=%d" % (len(matches), len(matches2), len(myTimes), len(mjdsec))
        noWeatherData = False
        if (len(matches)>0 and len(matches2) > 0):
            # average the weather points enclosed by the scan time range
            selectedValues = range(matches[0], matches2[-1]+1)
            if (selectedValues == []):
                # there was a either gap in the weather data, or an incredibly short scan duration
                if (verbose):
                    print "----  Finding the nearest weather value --------------------------- "
                selectedValues = findClosestTime(mjdsec, myTimes[0])
        elif (len(matches)>0):
            # all points are greater than myTime, so take the first one
            selectedValues = matches[0]
        elif (len(matches2)>0):
            # all points are less than myTime, so take the last one
            selectedValues = matches2[-1]
        else:
            # table has no weather data!
            noWeatherData = True
        if (noWeatherData):
            conditions['pressure'] = 563.0
            conditions['temperature'] = 0  # Celsius is expected
            conditions['humidity'] = 20.0
            conditions['dewpoint'] = -20.0
            conditions['windspeed'] = 0
            conditions['winddirection'] = 0
            print "WARNING: No weather data found in the WEATHER table!"
        else:
            if (type(selectedValues) == np.int64 or type(selectedValues) == np.int32 or  
                type(selectedValues) == np.int):
                conditions['readings'] = 1
                if (verbose):
                    print "selectedValues=%d, myTimes[0]=%.0f, len(matches)=%d, len(matches2)=%d" % (selectedValues,
                                                 myTimes[0], len(matches), len(matches2))
                    if (len(matches) > 0):
                        print "matches[0]=%f, matches[-1]=%f" % (matches[0], matches[-1])
                    if (len(matches2) > 0):
                        print "matches2[0]=%f, matches2[-1]=%d" % (matches2[0], matches2[-1])
            else:
                conditions['readings'] = len(selectedValues)
            conditions['pressure'] = np.mean(pressure[selectedValues])
            if (conditions['pressure'] != conditions['pressure']):
                # A nan value got through, due to no selected values (should be impossible)"
                if (verbose):
                    print ">>>>>>>>>>>>>>>>>>>>>>>>  selectedValues = ", selectedValues
                    print "len(matches)=%d, len(matches2)=%d" % (len(matches), len(matches2))
                    print "matches[0]=%f, matches[-1]=%f, matches2[0]=%f, matches2[-1]=%d" % (matches[0], matches[-1], matches2[0], matches2[-1])
            conditions['temperature'] = np.mean(temperature[selectedValues])
            conditions['humidity'] = np.mean(relativeHumidity[selectedValues])
            conditions['dewpoint'] = np.mean(dewPoint[selectedValues])
            conditions['windspeed'] = np.mean(windSpeed[selectedValues])
            conditions['winddirection'] = (180./math.pi)*np.arctan2(np.mean(sinWindDirection[selectedValues]),np.mean(cosWindDirection[selectedValues]))
            if (conditions['winddirection'] < 0):
                conditions['winddirection'] += 360
            if (verbose and noWeatherData==False):
                print "Mean weather values for scan %s (field %s)" % (listscan,listfield)
                print "  Pressure = %.2f mb" % (conditions['pressure'])
                print "  Temperature = %.2f C" % (conditions['temperature'])
                print "  Dew point = %.2f C" % (conditions['dewpoint'])
                print "  Relative Humidity = %.2f %%" % (conditions['humidity'])
                print "  Wind speed = %.2f m/s" % (conditions['windspeed'])
                print "  Wind direction = %.2f deg" % (conditions['winddirection'])

    if (needToClose_mymsmd): mymsmd.close()
    return([conditions,myTimes,vm])
    # end of getWeather

def listazel(vis, scan, antenna='0', vm=0):
    """
    Extracts the mean azimuth and elevation for the specified 'scan' in the
    specified ms (whose name is passed in by the vis argument).
    The scan can be a single scan or a list, as in [1,2,3], or in '1,2,3'
    The antenna can be either the antenna number or its name.
    This function needs to run ValueMapping, unless a ValueMapping object
    is passed via the vm argument.
    -- Todd Hunter
    """
    try:
        if str(antenna).isdigit():
            antennaName = getAntennaNames(vis)[int(str(antenna))]
        else:
            try:
                antenna = getAntennaIndex(vis,antennaName)
            except:
                antennaName = string.upper(antenna)
                antenna = getAntennaIndex(vis,antennaName)
    except:
        print "Either the ANTENNA table, or antenna %s does not exist" % str(antenna)
        return([0,0])
    try:
        tb.open("%s/POINTING" % vis)
    except:
        print "POINTING table does not exist"
        return([0,0])
    subtable = tb.query("ANTENNA_ID == %s" % antenna)
    tb.close()
    if (vm==0):
        vm = ValueMapping(vis)
    if (type(scan) == str):
        scan = [int(k) for k in scan.split(',')]
    if (type(scan) == list):
        myTimes = np.array([])
        for sc in scan:
            try:
#                print "3) Calling vm.getTimesForScan(%d)" % (sc)
                newTimes = vm.getTimesForScan(sc)
            except:
                print "3) Error reading scan %d, is it in the data?" % (sc)
                return([0,0])
            myTimes = np.concatenate((myTimes,newTimes))
    elif (scan != None):
        try:
#            print "4) Calling vm.getTimesForScan(%d)" % (scan)
            myTimes = vm.getTimesForScan(scan)
        except:
            print "4) Error reading scan %d, is it in the data?" % (scan)
            return([0,0])
    else:
        print "scan = ", scan
        return([0,0])
    direction = subtable.getcol("DIRECTION")
    time = subtable.getcol("TIME")
    azimuth = direction[0][0]*180.0/math.pi
    elevation = direction[1][0]*180.0/math.pi
    npat = np.array(time)
    matches = np.where(npat>myTimes[0])[0]
    matches2 = np.where(npat<myTimes[-1])[0]
    azimuth = np.mean(azimuth[matches[0]:matches2[-1]+1])
    elevation = np.mean(elevation[matches[0]:matches2[-1]+1])
    if (type(scan) == list):
        listscan = ""
        listfield = []
        for sc in scan:
            fields = vm.getFieldsForScan(sc)
            for f in fields:
                listfield.append(f)
            listscan += "%d" % sc
            if (sc != scan[-1]):
                listscan += ","
        listfields = np.unique(listfield)
        listfield = ""
        for field in listfields:
            listfield += "%s" % field
            if (field != listfields[-1]):
                listfield += ","
    else:
        listscan = str(scan)
        listfield = vm.getFieldsForScan(listscan)
    print "Scan %s (field=%s): azim = %.2f,  elev = %.2f  (degrees)" % (listscan, listfield, azimuth, elevation)
    return([azimuth, elevation])
# end of listazel()

def plotElevation(vis, antenna='0', xrange=None, yrange=None):
    """
    Plots the elevation vs. time for a specified antenna in an ms.
    The antenna parameter can be either the number, the number string,
    or the name string of the antenna.  xrange and yrange can be
    used to set the plot range.
    Produces a plot called  <vis>.elev.png.
    -- Todd Hunter
    """
    plotPosition(vis,1,antenna,xrange,yrange)

def plotAzimuth(vis, antenna='0',xrange=None,yrange=None):
    """
    Plots the azimuth vs. time for a specified antenna in an ms.
    The antenna parameter can be either the number, the number string,
    or the name string of the antenna.  xrange and yrange can be
    used to set the plot range.  
    Produces a plot called <vis>.azim.png.
    See also plotElevation.
     -- Todd Hunter
    """
    plotPosition(vis,0,antenna,xrange,yrange)

def plotPosition(vis, azel, antenna='0', xrange=None, yrange=None):
    """
    Plots the azimuth or elevation vs. time for a specified antenna in an ms
    from the POINTING table.  azel=0 means azimuth,  1 means elevation
    This function is useful for showing the az/el of planetary bodies which
    might appear with RA,dec = 0,0 in plotms (in older ALMA data).
    Produces a plot called  <vis>.elev.png or <vis>.azim.png.
    -- Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not find the ms = %s" % (vis)
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    try:
      if str(antenna).isdigit():
          antennaName = getAntennaNames(vis)[int(str(antenna))]
      else:
          antennaName = antenna
          try:
              antenna = getAntennaIndex(vis,antennaName)
          except:
              antennaName = string.upper(antenna)
              antenna = getAntennaIndex(vis,antennaName)
    except:
        print "Either the ANTENNA file or antenna %s does not exist" % (antennaName)
        return
    mytb = createCasaTool(tbtool)
    mytb.open("%s/POINTING" % vis)
    ref = mytb.getcolkeywords('DIRECTION')['MEASINFO']['Ref']
    if (ref.upper().find('AZEL') < 0):
        print "Sorry, the POINTING table is in %s format, not AZELGEO" % (ref)
        return
    subtable = mytb.query("ANTENNA_ID == %s" % antenna)
    mytb.close()        
    direction = subtable.getcol("DIRECTION")
    if (len(direction) == 0):
        print "The POINTING table appears to be empty."
        return
    elevation = direction[azel][0]*180.0/math.pi
    mjdsec = (subtable.getcol("TIME"))
    mjd  = mjdsec/86400.
    elevTime = (mjd-math.floor(mjd[0]))*24.
    pb.clf()
    plot(elevTime,elevation,'r.')
    if (azel == 1):
        ylabel('Elevation (deg)')
        ylim([0,90])
    else:
        ylabel('Azimuth (deg)')
    if (yrange != None):
        ylim(yrange)
    if (xrange != None):
        xlim(xrange)
    (mjd, datestring) = mjdSecondsToMJDandUT(mjdsec[0])
    xlabel('UT hour on %s'%(datestring[0:10]))
    title('%s  %s'%(vis,antennaName))
    if (azel==1):
        savefig('%s.elev.png'%(vis))
    else:
        savefig('%s.azim.png'%(vis))

def getMJDSec():
    """
    Returns the current MJD in seconds.
    Todd Hunter
    """
    return(getCurrentMJDSec())

def getCurrentUnixTime():
    """
    Returns the current unix time (seconds since 1970)
    """
    return(timeUtilities.time())

def getCurrentMJDSec():
    """
    Returns the current MJD in seconds.
    Todd Hunter
    """
    mjdsec = getMJD() * 86400
    return(mjdsec)

def ComputeLSTDay(mjdsec=-1, date='', longitude=ALMA_LONGITUDE, verbose=True):
    """
    Computes the LST day (useful for running NRAO dopset)
    and LST (in hours) for a specified time/date and longitude.
    Default longitude is for ALMA.
    The input longitude is in degrees, where east of Greenwich is positive.
    If mjdsec is a string, it will be assumed to be a date string.
    For date, either of these formats is valid: 2011/10/15
                                                2011/10/15 05:00:00
                                                2011/10/15-05:00:00
    -- Todd Hunter
    """
    if (date == ''):
        if (type(mjdsec) == str):
            mjdsec = dateStringToMJDSec(mjdsec,verbose=verbose)
        else:
            if (mjdsec<0):
                mjdsec = getCurrentMJDSec()
                print "Using current date/time"
    else:
        mjdsec = dateStringToMJDSec(date,verbose=verbose)
    LST = ComputeLST(mjdsec, longitude)
    MJD = mjdsec/86400.
    JD = mjdToJD(MJD)

# See http://gge.unb.ca/Pubs/TR171.pdf
    siderealDay = int(np.floor(JD*(0.002737909350795) + MJD) )
    if (verbose):
        print "LST day = %d,  LST = %.4f hours (at longitude=%f)" % (siderealDay,
                                                                     LST,longitude)
        print "Julian day = %f, MJD = %f, MJD seconds = %f" % (JD,MJD,mjdsec)
    return(siderealDay)
      
def ComputeLST(mjdsec, longitude):
    """
    Computes the LST (in hours) for a specified time and longitude. 
    The input longitude is in degrees, where east of Greenwich is > 0.
    -- Todd Hunter
    """
    JD = mjdToJD(mjdsec/86400.)
    T = (JD - 2451545.0) / 36525.0
    sidereal = 280.46061837 + 360.98564736629*(JD - 2451545.0) + 0.000387933*T*T - T*T*T/38710000.
    # now we have LST in Greenwich, need to scale back to site
    sidereal += longitude
    sidereal /= 360.
    sidereal -= np.floor(sidereal)
    sidereal *= 24.0
    if (sidereal < 0):
        sidereal += 24
    if (sidereal >= 24):
        sidereal -= 24
    return(sidereal)

def computeMeanSeparation(P, skyCoordinates=False):
    """
    Compute the mean separation of a set of points.
    -Todd Hunter
    """
    separation = []
    for i,x in enumerate(P[:-1]):
        for j,y in enumerate(P[i+1:]):
            if (skyCoordinates):
                separation.append(angularSeparationRadiansTuples(x,y))
            else:
                separation.append(ssd.pdist([x,y]))
    return(np.mean(separation))

def computeRcluster(P, skyCoordinates=False):
    """
    Compute the radius and mean position of a set of points.
    -Todd Hunter
    """
    meanPosition = np.mean(P,axis=0)
    radii = []
    for i,x in enumerate(P):
        if skyCoordinates:
          radii.append(angularSeparationRadiansTuples(meanPosition,x))
        else:
          radii.append(ssd.pdist([meanPosition,x]))
    return(np.max(radii),meanPosition)

def minimum_spanning_tree(X, copy_X=True):
    """
    Compute the minimum spanning tree of a graph.
    peekaboo-vision.blogspot.com/2012/02/simplistic-minimum-spanning-tree-in.html
    Inputs:
    X are edge weights of fully connected graph
    -Todd Hunter
    """
    if copy_X:
        X = X.copy()
    if X.shape[0] != X.shape[1]:
        raise ValueError("X needs to be square matrix of edge weights")
    n_vertices = X.shape[0]
    spanning_edges = []
    # initialize with node 0:
    visited_vertices = [0]
    num_visited = 1
    # exclude self connections:
    diag_indices = np.arange(n_vertices)
    X[diag_indices, diag_indices] = np.inf
    while num_visited != n_vertices:
        new_edge = np.argmin(X[visited_vertices], axis=None)
        # 2d encoding of new_edge from flat, get correct indices
        new_edge = divmod(new_edge, n_vertices)
        new_edge = [visited_vertices[new_edge[0]], new_edge[1]]
        # add edge to tree
        spanning_edges.append(new_edge)
        visited_vertices.append(new_edge[1])
        # remove all edges inside current tree
        X[visited_vertices, new_edge[1]] = np.inf
        X[new_edge[1], visited_vertices] = np.inf
        num_visited += 1
    return np.vstack(spanning_edges)

def clusterCentroid(filename, xcol=0, ycol=1, zcol=None, delimiter=None, maxLines=None):
    """
    Reads a list of RA/Dec positions and intensity from a file and computes
    the centroid, or intensity-weighted centroid.
    xcol: column containing RA in the format HH:MM:SS.S
    ycol: column containing Dec in the format DD:MM:SS.S
    zcol: optional column containing intensity (i.e. weight)
    --Todd Hunter
    """
    x,y = getxyFromFile(filename,xcol,ycol,delimiter,maxLines)
    points = np.transpose([x,y])
    if (zcol != None):
        weights,ignore = getxyFromFile(filename,zcol,zcol,delimiter,maxLines)
    else:
        weights = np.ones(len(points))
    ra = np.average(points[:,0], weights=weights)
    dec = np.average(points[:,1], weights=weights)
    return(rad2radec(ra,dec))
    
def clusterStatistics(filename, xcol, ycol, delimiter=None,
                      skyCoordinates=False, maxLines=None,
                      showplot=False, plotcenter=None,
                      showtitle=False, showcenter=False,
                      showseparations=False, plotfile=None,
                      plotwidths=None, filledpoints=None,
                      horizontalGrid=None):
    """
    Reads the x and y coordinates of points from specified columns
    in an ASCII file, and computes useful statistics.
    * filename: ASCII table that contains X and Y points in separate columns
      Note: if a colon is in the data string for the X column, then treat the
      colon-delimited X and Y strings as sexagesimal RA/Dec and convert to radians
    * xcol: the column to use for x (column numbers start at zero)
    * ycol: the column to use for y (column numbers start at zero)
    * skyCoordinates: if True, then use spherical great circle distance,
         otherwise treat as rectilinear coordinates and use Pythagorean.
    * showplot:  if True, show a plot of the minimum spanning tree
    * plotcenter: sexagesimal string in RA/Dec, or None for mean position
    * showtitle: include cluster radius and mean separation in title
    * showcenter: mark the center of the cluster
    * showseparations: mark the length of each edge
    * plotfile: the name of the plotfile to generate (.png and .eps)
    * plotwidths: [width,height] in degrees (as per aplpy's recenter command)
          if not specified, then automatic limits are used, with axis('scaled')
    * filledpoints: if showplot==True, mark these positions with filled points
          and the rest with unfilled points
    * horizontalGrid: draw dotted lines every X arcsec
    
    Returns:
    * mean separation (in arcsec if skyCoordinates == True)
    * cluster radius (in arcsec if skyCoordinates == True)
    * mean edge length of minimum spanning tree (in arcsec if skyCoordinates == True)
    * Q-parameter (see Cartwright & Whitworth 2004, MNRAS)
    -Todd Hunter
    """
    x,y = getxyFromFile(filename,xcol,ycol,delimiter,maxLines)
    N = len(x)
    print "N = ", N
    points = np.transpose([x,y])
    meanSeparation = computeMeanSeparation(points, skyCoordinates)
    print "Mean separation = %f" % (meanSeparation)
    if (skyCoordinates):
        meanSeparation  *= ARCSEC_PER_RAD
        print "Mean separation = %f arcsec" % (meanSeparation)
    Rcluster, meanPosition = computeRcluster(points, skyCoordinates)
    print "Cluster radius = %f" % (Rcluster)
    if (skyCoordinates):
        Rcluster *= ARCSEC_PER_RAD
        print "Cluster radius = %f arcsec" % (Rcluster)
        print "Mean position = %s" % (rad2radec(meanPosition[0],meanPosition[1]))
    normalizedMeanSeparation = meanSeparation / Rcluster
    if (skyCoordinates):
        dist = []
        for i,P in enumerate(points[:-1]):
            for j,Q in enumerate(points[i+1:]):
                dist.append(angularSeparationRadiansTuples(P,Q)/Rcluster)
        dist = np.array(dist)
    else:
        dist = ssd.pdist(points)
    X = ssd.squareform(dist)
    edge_list = minimum_spanning_tree(X)
    edgeLength = []
    for edge in edge_list:
        i, j = edge
        if skyCoordinates:
            edgeLength.append(angularSeparationRadians(points[i][0], points[i][1], points[j][0], points[j][1]))
        else:
            edgeLength.append(ssd.pdist([(points[i,0], points[i,1]), (points[j,0], points[j,1])]))
    meanEdgeLength = np.mean(edgeLength)
    meanEdgeLengthNormalizationFactor = (N*np.pi*Rcluster**2)**0.5/(N-1)
    normalizedMeanEdgeLength = meanEdgeLength / meanEdgeLengthNormalizationFactor
    if (skyCoordinates):
        meanEdgeLength *= ARCSEC_PER_RAD
        normalizedMeanEdgeLength *= ARCSEC_PER_RAD
        print "mean edge length = %f arcsec / [(N*pi*R**2)**0.5 / (N-1)] " % (meanEdgeLength)
        print "mean edge length = %f / %f = %f" % (meanEdgeLength,meanEdgeLengthNormalizationFactor,
                                                   meanEdgeLength/meanEdgeLengthNormalizationFactor)
    Q = (meanEdgeLength/meanEdgeLengthNormalizationFactor) / (meanSeparation/Rcluster)
    if (showplot):
        pb.clf()
        adesc = pb.subplot(111)
        points -= meanPosition
        if (skyCoordinates):
            if (plotcenter != None):
                racen, deccen = radec2rad(plotcenter)
            else:
                racen = meanPosition[0]
                deccen = meanPosition[1]
            points *= ARCSEC_PER_RAD
            for i in range(len(points)):
                points[i][0] *= np.cos(deccen)
        if (filledpoints != None):
            pb.scatter(points[:, 0], points[:, 1], c='k', facecolor='w')
#            pb.scatter(points[filledpoints, 0], points[filledpoints, 1], c='k', facecolor='k')
            pb.plot(points[filledpoints, 0], points[filledpoints, 1], 'ko', markersize=6, markerfacecolor='k')
        else:
            pb.scatter(points[:, 0], points[:, 1], c='k', facecolor='k')
        pb.xlabel('Right ascension offset (arcsec)')
        pb.ylabel('Declination offset (arcsec)')
        pb.axis('scaled')
        if (showcenter):
            # mark the cluster center
            pb.scatter([0],[0],c='k',marker='+') 
        for c, edge in enumerate(edge_list):
            i, j = edge
            pb.plot([points[i,0], points[j,0]], [points[i,1],points[j,1]],c='k')
            if (showseparations):
                pb.text(0.5*(points[i,0]+points[j,0]),
                        0.5*(points[i,1]+points[j,1]),
                        '%.1f'%(edgeLength[c]*ARCSEC_PER_RAD), size=8)
        if (plotwidths != None):
            xoff = (racen - meanPosition[0])*ARCSEC_PER_RAD*np.cos(deccen)
            yoff = (deccen - meanPosition[1])*ARCSEC_PER_RAD
            print "xoff=%f, yoff=%f arcsec" % (xoff,yoff)
            width = plotwidths[0]*3600
            height = plotwidths[1]*3600
            pb.xlim([width*0.5+xoff, -width*0.5+xoff])
            pb.ylim([-height*0.5+yoff, height*0.5+yoff])
        if (showtitle):
            pb.title('mean separation/Rcluster=%.3f"/%.3f"=%.3f", mean edge length=%.3f"/%.3f = %.3f"'%(meanSeparation, Rcluster, normalizedMeanSeparation, meanEdgeLength, meanEdgeLengthNormalizationFactor, normalizedMeanEdgeLength), size=10)
        print "Q = (%.3f/%.3f) / (%.3f/%.3f) = (%f/%f) = %.3f" % (meanEdgeLength, meanEdgeLengthNormalizationFactor,
                                                                  meanSeparation, Rcluster,
                                                                  normalizedMeanEdgeLength, normalizedMeanSeparation, Q)
        minorLocator = MultipleLocator(1)
        adesc.xaxis.set_minor_locator(minorLocator)
        adesc.yaxis.set_minor_locator(minorLocator)
        if (plotfile == None):
            png = filename+'.mst.png'
            eps = filename+'.mst.eps'
        else:
            png = plotfile.strip('.png') + '.png'
            eps = plotfile.strip('.eps') + '.eps'
        if (horizontalGrid != None):
            for y in np.arange(0.5*horizontalGrid, pb.ylim()[1], horizontalGrid):
                pb.plot(pb.xlim(), [y,y], 'k:')
                pb.plot(pb.xlim(), [-y,-y], 'k:')
        pb.savefig(png)
        pb.savefig(eps,bbox_inches='tight')
        print "plot left in %s and %s" % (png,eps)
    return(meanSeparation,Rcluster,meanEdgeLength,Q)

def LbolFromLH2O(LH2O, trials=1000):
    """
    Computes bolometric luminosity from water maser luminosity using Urquhart et al. 2001 Eq 9
    -- Todd Hunter
    """
    Lbol = []
    for i in range(trials):
        exponent = 1/(1.47+pickRandomError()*0.76)
        L = (LH2O / (7.1e-12 + 0.3e-12*pickRandomError()))**exponent
        Lbol.append(L)
    print "Monte-Carlo: %g +- %g Lsun,  range=%g-%g Lsun" % (np.median(Lbol), MAD(Lbol), np.nanmin(Lbol), np.nanmax(Lbol))
    L = []
    for a in [-1,0,1]:
        for b in [-1,0,1]:
            exponent = 1.0/(1.47+0.76*b)
            L.append((LH2O / (7.1e-12 + a*0.3e-12))**(exponent))
    print "1-sigma: %g +- %g Lsun,  range=%g-%g Lsun" % (np.median(L), 0.5*(np.max(L)-np.min(L)), np.min(L), np.max(L))
    return(np.median(Lbol), MAD(Lbol))

def sigmaEvent(sigma):
    """
    Compute the probability of an N-sigma event.
    -Todd Hunter
    """
    odds = 1-math.erf(sigma/2**0.5)
    print "The odds of a %g sigma event is %g:1 = %g%%" % (sigma, odds, odds*100)
    print "The odds of a %g sigma positive event is %g:1 = %g%%" % (sigma, odds/2., odds*50)
    return(odds,odds/2.)
    
def angularSeparationOfFields(ms='', fields=[]):
    """
    Reads an ms and computes the angular separation of all combinations
    of fields, or if the fields parameter is given, only those field
    names or IDs specified in the fields parameter, which can be either
    a list of IDs or names, or an individual ID or name.
    It computes great circle angle using the Vincenty formula.
    -- Todd Hunter
    """
    if (os.path.exists(ms) == False):
        print "ms does not exist = ", ms
        return
    if (type(fields) != list):
        fields = [fields]
    tb.open(ms+'/FIELD')
    name = tb.getcol('NAME')
    print "Field =              Names                 Separations"
    sid = tb.getcol('SOURCE_ID')
    pos = tb.getcol('PHASE_DIR')
    pos = np.transpose(pos)
    nfields = len(pos)
    for i in range(nfields):
        for j in range(i+1,len(pos)):
            if (fields == [] or fields == [''] or (i in fields or j in fields) or
                (name[i] in fields or name[j] in fields)):
                radians = angularSeparationRadiansTuples(pos[i][0], pos[j][0])
                degrees = radians*180/np.pi
                arcsec = 3600*degrees
                print "%02d-%02d = %15s-%15s: %8g deg = %8g arcsec" % (i,j,name[i],name[j],degrees,arcsec)

def angularSeparationOfScans(vis='', scans=[], skipConsecutive=True,
                             observatory='ALMA', verbose=False, forceVM=False):
    """
    Reads an ms and computes the angular separation of each transition between
    scans.
    -- Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "ms does not exist = ", vis
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (type(scans) != list):
        print "The scans parameter must be a list."
        return
    if (len(scans) == 1):
        print "You must give at least two scans (or none, which means all)."
        return
    if (casadef.casa_version >= '4.1.0' and forceVM==False):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        if (scans == []):
            scans = mymsmd.scannumbers()
        fieldsForScans = []
        timesForScans = []
        for j in scans:
            fieldsForScans.append(mymsmd.fieldsforscan(j)[0]) # assume first field
            timesForScans.append(mymsmd.timesforscans(j))
        mymsmd.close()
    else:
        vm = ValueMapping(vis)
        if (scans == []):
            scans = vm.uniqueScans
        fieldNamesForScans = vm.getFieldsForScans(scans)
        fieldsForScans = []
        for fn in fieldNamesForScans:
            fieldsForScans.append(vm.getFieldIdsForFieldName(fn)[0]) # assume first field
        timesForScans = vm.getTimesForScans(scans)
    if (verbose):
        print "%d scans = " % (len(scans)), scans
        print "%d fieldsForScans = " % (len(fieldsForScans)), fieldsForScans
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/FIELD')
    name = mytb.getcol('NAME')
    print "                                      Angular separations"
    print "Scan slew         Field Names      on-the-sky (deg)  (arcsec)  dAz(deg) dEl(deg)"
    pos = mytb.getcol('PHASE_DIR')
    mytb.close()
    pos = np.transpose(pos)
    for i in range(len(scans)-1):
        field = []
        field.append(fieldsForScans[i])
        field.append(fieldsForScans[i+1])
        radians = angularSeparationRadiansTuples(pos[field[0]][0], pos[field[1]][0])
        degrees = radians*180/np.pi
        if (degrees == 0 and skipConsecutive): continue
        arcsec = 3600*degrees
        mjd = []
        mjd.append(np.max(timesForScans[i])/86400.)
        mjd.append(np.min(timesForScans[i+1])/86400.)
        if (verbose):
            print "Computing separation of field %d-%d at %.5f-%.5f" % (field[0], field[1], mjd[0], mjd[1])
        azel = []
        for j in range(2):
            azel.append(computeAzElFromRADecMJD(pos[field[j]][0],mjd[j],observatory=observatory,verbose=False))
        deltaaz = (azel[1][0]-azel[0][0])*180/np.pi
        deltael = (azel[1][1]-azel[0][1])*180/np.pi
        outline = "%02d-%02d = %14s to %14s %8g = %8g %+8.3f %+8.3f" % (scans[i],scans[i+1],name[fieldsForScans[i]],name[fieldsForScans[i+1]]+' '*(15-len(name[fieldsForScans[i+1]])),degrees,arcsec,deltaaz,deltael)
        if (verbose):
            outline += "  %.5f %.5f" % (mjd[0],mjd[1])
        print outline

def medianFrequencyOfIntent(vis, intent='OBSERVE_TARGET#ON_SOURCE'):
    """
    Returns the median of the mean frequency (in Hz) of the spws observed with
    the specified intent (default = OBSERVE_TARGET#ON_SOURCE).
    -Todd Hunter
    """
    if (casadef.casa_version >= '4.1.0'):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        try:
            spws = mymsmd.spwsforintent(intent)
        except:
            spws = []
        if (len(spws) < 1):
            print "No spws with intent = %s" % (intent)
            return None
#        print "spws = ", spws
        freq = []
        for spw in spws:
            freq.append(mymsmd.meanfreq(spw))
    else:
        vm = ValueMapping(vis)
        spws = vm.getSpwsForIntent(intent)
        if (len(spws) < 1):
            print "No spws with intent = %s" % (intent)
            return None
#        print "spws = ", spws
        freq = []
        for spw in spws:
            if (spw in vm.spwInfo.keys()):
#                print "spw = %d, " % (spw), vm.spwInfo[spw]
                freq.append(vm.spwInfo[spw]['meanFreq'])
    return(np.median(freq))

def radecOffsetToRadec(radec, rao, deco):
    """
    Converts an absolute J2000 position and offset into a new position.
    radec: either a string ('hh:mm:ss.s dd:mm:ss') or a tuple of radians
    rao, deco: offset in arcseconds
    Returns: a sexagesimal string
    """
    if (type(radec) == str):
        rarad, decrad = radec2rad(radec)
    elif (type(radec) == list):
        rarad, decrad = radec
    else:
        print "radec must be either a string ('hh:mm:ss.s dd:mm:ss') or a list in radians [ra,dec]"
        return
    rarad += rao*np.pi/(180*3600.)
    decrad += deco*np.pi/(180*3600.)
    return(rad2radec(rarad,decrad))
           
def angularSeparationOfPlanets(planet1='', planet2='', date='',
             observatory=JPL_HORIZONS_ID['ALMA'], useJPL=True, target=None,
             returnComponents=False, verbose=False, vis='', bodyForScan='',
             frequency=None, diameter=None):
    """
    Computes the current angular separation of two planets at 0 UT on the 
    current date, or the exact specified date string.  Default viewing 
    location is ALMA.
    If 'target' is specified as a valid RA/Dec, then the separation between 
    it and planet1 will be computed.
    If 'vis' is specified, then it will use the time of the first scan on the
    target, or the start time of the ms if neither target is not found.
    'bodyForScan' is passed to both calls to planet() to pick time of first scan
    If 'frequency' and 'diameter' are specified, these are passed to
       primaryBeamArcsec() to compute the separation in beam diameters.
    If 'vis' is specified, it will use the median dish diameter and median
       of the mean frequencies of the OBSERVE_TARGET spws.
    Required format for target:  HH[:MM:SS.S]  [+]DD[:MM:SS.S]
    date: one possible format of the date string is: '2011-10-31 11:59:59'
          or simply '2011-10-31' for 0:00 UT. A list of allowed formats for date
          is at:   http://ssd.jpl.nasa.gov/?horizons_doc#time
    Returns the separation value in radians.  If the primary beam is known, it
    also returns the value in primary beam units, and a Boolean value telling
    whether it is safe to use the object as amplitude calibrator (>2*beam+25'').
    Todd Hunter
    """
    if (planet1 == '' or planet2 == ''):
        if (vis == ''):
            print "You must either specify planet1 and planet2, or vis (or all three)"
            return
        else:
            fields = getFields(vis)
            fieldsUpperCase = [x.upper() for x in fields]
            checkObjects = ['TITAN','CALLISTO','GANYMEDE','IO','EUROPA']
            for object in checkObjects:
                if (object in fieldsUpperCase):
                    planet1 = object
                    bodyForScan = object
                    break
            if (planet1 == ''):
                print "None of these satellites were observed: ", checkObjects
                return
            if (planet1 == 'TITAN'):
                planet2 = 'SATURN'
            else:
                planet2 = 'JUPITER'
    data1 = planet(planet1, date=date, observatory=observatory, useJPL=useJPL, verbose=verbose,vis=vis, bodyForScan=bodyForScan)
    if (data1 == None): return
    if (target == None):
        data2 = planet(planet2, date=date, observatory=observatory, useJPL=useJPL, verbose=verbose,vis=vis, bodyForScan=bodyForScan)
    else:
        results = target.split()
        if (len(results) != 2):
            print "Required format for target:  HH[:MM:SS.S]  [+]DD[:MM:SS.S]"
            return
        ra,dec = results
        if (ra.find(':') > 0):
            ratokens = ra.split(':')
            ra = float(ratokens[0])
            if (ratokens > 1):
                ra += float(ratokens[1])/60.
            if (ratokens > 2):
                ra += float(ratokens[2])/3600.
        else:
            print "Required format for target:  HH[:MM:SS.S]  [+]DD[:MM:SS.S]"
            return
        
        if (dec.find(':') > 0):
            dectokens = dec.split(':')
            dec = abs(float(dectokens[0]))
            if (dectokens > 1):
                dec += float(dectokens[1])/60.
            if (dectokens > 2):
                dec += float(dectokens[2])/3600.
            if (dectokens[0].find('-') >= 0):
                dec = -dec
        else:
            print "Required format for target:  HH[:MM:SS.S]  [+]DD[:MM:SS.S]"
            return
        data2 = {'directionRadians': [float(ra)*pi/12.0, float(dec)*pi/180]}
#    print data1['directionRadians'][0], data1['directionRadians'][1], data2['directionRadians'][0], data2['directionRadians'][1]
    result = angularSeparationRadians(data1['directionRadians'][0], data1['directionRadians'][1], 
                                      data2['directionRadians'][0], data2['directionRadians'][1], returnComponents)
    if (returnComponents):
        rad, raRadians, decRadians, raRadiansCosDec = result
    else:
        rad = result
    print "Separation = %g rad = %g deg = %g arcsec" % (rad, rad*180/math.pi, rad*3600*180/math.pi)
    print "RA separation = %g hours" % (12*(data1['directionRadians'][0] - data2['directionRadians'][0])/math.pi)
    if (vis != '' or (frequency!=None and diameter!=None)):
        if (vis != ''):
            primaryBeam = primaryBeamArcsec(vis=vis)
        else:
            primaryBeam = primaryBeamArcsec(frequency=frequency, diameter=diameter)
        beams = rad*3600*180/math.pi / primaryBeam
        print "%.1f primary beams" % (beams)
        separationArcsec = rad*3600*180/math.pi
        if (separationArcsec > 2*primaryBeam + 25):  # 25 is the kludged value used by CSV for planet half-diameter
            safe = True
        else:
            safe = False
        return(result, beams, safe)
    else:
        return(result)
    
def angularSeparationOfDirections(dir1,dir2,returnComponents=False):
    """
    Accepts two direction dictionaries and returns the separation in radians.
    It computes great circle angle using the Vincenty formula.
    --Todd Hunter
    """
    print dir1, dir2
    rad = angularSeparationRadians(dir1['m0']['value'], dir1['m1']['value'], dir2['m0']['value'], dir2['m1']['value'],returnComponents)
    return(rad)

def angularSeparationOfDirectionsArcsec(dir1,dir2,returnComponents=False):
    """
    Accepts two direction dictionaries and returns the separation in arcsec.
    It computes great circle angle using the Vincenty formula.
    Todd Hunter
    """
    retval = angularSeparationOfDirections(dir1, dir2, returnComponents)
    if (returnComponents):
        retval = np.array(retval) * 180*3600 / np.pi
    else:
        retval *= 180*3600 / np.pi
    return(retval)

def angularSeparationRadiansTuples(pos0,pos1,returnComponents=False):
    """
    Computes the great circle angle between two celestial coordinates.
    using the Vincenty formula (from wikipedia) which is correct for all
    angles, as long as you use atan2() to handle a zero denominator.  
       See  http://en.wikipedia.org/wiki/Great_circle_distance
    Input and output are in radians.  The input must be in the form of
    tuples: [ra0,dec0], [ra1,dec1], such as read from the FIELD table.
    It also works for the az,el coordinate system.
    returnComponents=True will return: [separation, raSeparation, decSeparation, raSeparationCosDec]
    See also angularSeparation() and angularSeparationRadians().
    """
    return(angularSeparationRadians(pos0[0],pos0[1], pos1[0],pos1[1],returnComponents))
           
def angularSeparationRadians(ra0,dec0,ra1,dec1,returnComponents=False):
  """
  Computes the great circle angle between two celestial coordinates.
  using the Vincenty formula (from wikipedia) which is correct for all
  angles, as long as you use atan2() to handle a zero denominator.  
     See  http://en.wikipedia.org/wiki/Great_circle_distance
  Input and output are in radians.  It also works for the az,el coordinate system.
  returnComponents=True will return: [separation, raSeparation, decSeparation, raSeparationCosDec]
  See also angularSeparation()
  -- Todd Hunter
  """
  result = angularSeparation(ra0*180/math.pi, dec0*180/math.pi, ra1*180/math.pi, dec1*180/math.pi,returnComponents)
  if (returnComponents):
      return(np.array(result)*math.pi/180.)
  else:
      return(result*math.pi/180.)

def angularSeparationOfStringsFromFile(filename,verbose=True,arcsec=False):
    """
    Reads a text file and sends each line to angularSeparationOfStrings after
    stripping off the leading source name.  Required format:
        sourcename RA1 Dec1 RA2 Dec2 optional_comments
    where the sexagesimal components of RA/Dec can be either colon-delimited
    or space-delimited.
    Returns: an array of the separations in degrees, unless arcsec==True.
    - Todd Hunter
    """
    if (os.path.exists(filename) == False):
        print "File not found."
        return
    f = open(filename,'r')
    sep = []
    returnComponents = False  # True will return more than one value
    for line in f.readlines():
        tokens = line.split()
        line = ' '.join(tokens[1:]) # pull off the leading name
        line = line.replace(':',' ').replace('&',' ')
        tokens = line.split()
        sep.append(angularSeparationOfStrings(' '.join(tokens[:6]), ' '.join(tokens[6:12]),
                                              returnComponents,verbose))
    f.close()
    result = np.array(sep)
    if (arcsec):
        result *= 3600
    return(result)

def pickRandomError():
    """
    Picks a random value from a Gaussian distribution with mean 0 and standard deviation = 1.
    """
    w = 1.0
    while ( w >= 1.0 ):
      x1 = 2.0 * random.random() - 1.0
      x2 = 2.0 * random.random() - 1.0
      w = x1 * x1 + x2 * x2

    w = np.sqrt( (-2.0 * np.log( w ) ) / w )
    y1 = x1 * w
    y2 = x2 * w
    return(y1)

def angularSeparationOfStrings(radec0,radec1,returnComponents=False,verbose=True,
                               uncertainties=None,date=None,observatory='ALMA'):
    """
    Accepts input of the form: '23:29:17.70000, -47:30:19.211595'
                            or '23:29:17.70000  -47:30:19.211595'
                            or '23:29:17.70000, -47.30.19.211595'
                            or '23:29:17.70000  -47.30.19.211595'
                            or '23 29 17.70000  -47 30 19.211595'
    and computes the angular separation.  Returns it in degrees.
    Leading spaces are removed from both coordinates.
    If a date is specified, it also converts the input
         coordinates to Az/El, then computes the deltaAz and deltaEl
    date: can be specified as a string, e.g. 2014-03-15T10:24:48.417
          or a float, which is interpreted as MJD
    If returnComponents==True, then it also returns the separation in 
       longitude and latitude as well as the position angle (in degrees).
    If uncertainties is a list of 4 numbers, then run a Monte-Carlo simulation 
      using these values as ra0unc, dec0unc, ra1unc, dec1unc
    """
    radec0 = radec0.replace('&',' ')  # allow pasting from Latex tables
    radec0 = radec0.replace('?','-')  # openoffice cut&paste mangles -- into ?
    radec1 = radec1.replace('&',' ')  # allow pasting from Latex tables
    radec1 = radec1.replace('?','-')  # openoffice cut&paste mangles -- into ?
    if (radec0.find(',')>0):
        (ra,dec) = radec0.split(',')
    else:
        tokens = radec0.split()
        if (len(tokens) == 2):
            (ra,dec) = tokens
        elif (len(tokens) == 6):
            ra = tokens[0] + ':' + tokens[1] + ':' + tokens[2]
            dec = tokens[3] + ':' + tokens[4] + ':' + tokens[5]
        else:
            print "Confusing input for first position.  Need either 2 or 6 tokens"
            return
    (h,m,s) = ra.lstrip().split(':')
    hours = float(h)+float(m)/60. + float(s)/3600.
    ra0 = hours*15

    if (dec.find(':')>0):
        (d,m,s) = dec.lstrip().split(':')
    else:
        try:
            (d,m,s) = dec.lstrip().split('.')
        except:
            (d,m,s,sfraction) = dec.lstrip().split('.')
            s = s+'.'+sfraction
    dec0 = abs(float(d))+float(m)/60.+float(s)/3600.
    if (dec.lstrip().find('-') == 0):
        dec0 = -dec0

    if (radec1.find(',') > 0):
        (ra,dec) = radec1.split(',')
    else:
        tokens = radec1.split()
        if (len(tokens) == 2):
            (ra,dec) = tokens
        elif (len(tokens) == 6):
            ra = tokens[0] + ':' + tokens[1] + ':' + tokens[2]
            dec = tokens[3] + ':' + tokens[4] + ':' + tokens[5]
        else:
            print "Confusing input for second position.  Need either 2 or 6 tokens"
            return
    (h,m,s) = ra.lstrip().split(':')
    hours = float(h)+float(m)/60. + float(s)/3600.
    if (dec.find(':') > 0):
        (d,m,s) = dec.lstrip().split(':')
    else:
        try:
            (d,m,s) = dec.lstrip().split('.')
        except:
            (d,m,s,sfraction) = dec.lstrip().split('.')
            s = s + '.' + sfraction
    dec1 = abs(float(d))+float(m)/60.+float(s)/3600.
    if (dec.lstrip().find('-') == 0):
        dec1 = -dec1
    ra1 = hours*15
#    print ra0/15., dec0, ra1/15., dec1
    if (returnComponents):
        if (uncertainties != None):
            if (len(uncertainties) != 4):
                print "uncertainties must be a list of 4 values in arcsec"
                return
            trials = 1000
        else:
            trials = 1
            dra0 = 0
            dra1 = 0
            ddec0 = 0
            ddec1 = 0
        degArray = []
        raArray = []
        decArray = []
        positionAngleArray = []
        for t in range(trials):
            if (uncertainties != None):
                dra0 = uncertainties[0]*pickRandomError()/3600.
                dra1 = uncertainties[1]*pickRandomError()/3600.
                ddec0 = uncertainties[2]*pickRandomError()/3600.
                ddec1 = uncertainties[3]*pickRandomError()/3600.
            degrees, radegrees, decdegrees, radegreesCosDec = angularSeparation(ra0+dra0,dec0+ddec0,ra1+dra1,dec1+ddec1,returnComponents)
            positionAngle = 90-math.atan2(decdegrees*math.pi/180., radegreesCosDec*math.pi/180.)*180/math.pi
            if (positionAngle > 180):
                positionAngle -= 360
            if (positionAngle < -180):
                positionAngle += 360
            retval = degrees, radegrees, decdegrees, radegreesCosDec, positionAngle
            raArray.append(radegrees)
            decArray.append(decdegrees)
            degArray.append(degrees)
            positionAngleArray.append(positionAngle)
            if (verbose):
                print "RA Separation: radian = %g, degrees = %f, arcsec = %f" % (radegreesCosDec*math.pi/180., 
                                                                                 radegreesCosDec, radegreesCosDec*3600)
                print "Dec Separation: radian = %g, degrees = %f, arcsec = %f" % (decdegrees*math.pi/180., 
                                                                                  decdegrees, decdegrees*3600)
                print "Position angle: %g deg E of N" % (positionAngle)
        if (trials > 1):
            retval = np.median(degArray), np.median(raArray), np.median(decArray), np.median(positionAngleArray), np.std(degArray), np.std(positionAngleArray)
            print "separation = %f +- %f deg, position angle = %f +- %f deg" % (np.median(degArray), np.std(degArray), np.median(positionAngleArray), np.std(positionAngleArray))
            print "separation = %f +- %f arcsec, position angle = %f +- %f deg" % (3600*np.median(degArray), 3600*np.std(degArray), np.median(positionAngleArray), np.std(positionAngleArray))
            
    else:
        degrees = angularSeparation(ra0,dec0,ra1,dec1,returnComponents)
        retval = degrees
    if (verbose):
        print "Separation: radian = %g, degrees = %f, arcsec = %f" % (degrees*math.pi/180., 
                                                                      degrees, degrees*3600)
    if (date != None):
        if (type(date) == str):
            mjd = dateStringToMJD(date)
        else:
            mjd = date
        # convert ra/decs to az/el, then recompute separation
        az0,el0 = computeAzElFromRADecMJD([ra0*np.pi/180.,dec0*np.pi/180.],mjd,observatory)
        az1,el1 = computeAzElFromRADecMJD([ra1*np.pi/180.,dec1*np.pi/180.],mjd,observatory)
        total = angularSeparationRadians(az0,el0,az1,el1)
        print "Initial az/el = %f, %f deg" % (az0*180/np.pi, el0*180/np.pi)
        print "Delta azimuth = %f deg,  Delta elevation = %f deg  (total = %f deg)" % ((az1-az0)*180/np.pi, (el1-el0)*180/np.pi, total*180/np.pi) 

    return(retval)


def angularSeparation(ra0,dec0,ra1,dec1, returnComponents=False):
  """
  Usage:  au.angularSeparation(ra0,dec0,ra1,dec1)
  Computes the great circle angle between two celestial coordinates.
  using the Vincenty formula (from wikipedia) which is correct for all
  angles, as long as you use atan2() to handle a zero denominator.  
     See  http://en.wikipedia.org/wiki/Great_circle_distance
  ra,dec must be given in degrees, as is the output.
  It also works for the az,el coordinate system.
  Component separations are field_0 minus field_1.
  See also angularSeparationRadians()
  -- Todd Hunter
  """
  ra0 *= math.pi/180.
  dec0 *= math.pi/180.
  ra1 *= math.pi/180.
  dec1 *= math.pi/180.
  deltaLong = ra0-ra1
  argument1 = (((math.cos(dec1)*math.sin(deltaLong))**2) +
               ((math.cos(dec0)*math.sin(dec1)-math.sin(dec0)*math.cos(dec1)*math.cos(deltaLong))**2))**0.5
  argument2 = math.sin(dec0)*math.sin(dec1) + math.cos(dec0)*math.cos(dec1)*math.cos(deltaLong)
  angle = math.atan2(argument1, argument2) / (math.pi/180.)
  if (returnComponents):
      cosdec = math.cos((dec1+dec0)*0.5)
      radegreesCosDec = (ra0-ra1)*cosdec*180/math.pi
      radegrees = (ra0-ra1)*180/math.pi
      decdegrees = (dec0-dec1)*180/math.pi
#      positionAngle = -math.atan2(decdegrees*math.pi/180., radegreesCosDec*math.pi/180.)*180/math.pi
      retval = angle,radegrees,decdegrees, radegreesCosDec
  else:
      retval = angle
  return(retval)

def sun(observatory='' ,mjdsec='', mjd=''):
    """
    Determines the az/el of the Sun for the specified observatory and specified
    time in MJD seconds (or MJD).  Defaults are ALMA and 'now'.
    Returns az, el in degrees.
    Other observatories available:
      ARECIBO  ATCA  BIMA  CLRO  DRAO  DWL  GB  GBT  GMRT  IRAM PDB  IRAM_PDB
      JCMT  MOPRA  MOST  NRAO12M  NRAO_GBT  PKS  SAO SMA  SMA  VLA  VLBA  WSRT
      ATF  ATA  CARMA  ACA  OSF  OVRO_MMA  EVLA  ASKAP  APEX  SMT  NRO  ASTE
      LOFAR  MeerKAT  KAT-7  EVN  LWA1  PAPER_SA  PAPER_GB  e-MERLIN  MERLIN2

    For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/Sun
    -- Todd Hunter
    """
    printCurrent = False
    if (mjdsec=='' and mjd==''):
        printCurrent = True
        mjdsec = getCurrentMJDSec()
    elif (mjdsec==''):
        mjdsec = double(mjd)*86400
    else:
        mjdsec = double(mjdsec)

    mjd = mjdsec/86400.
    if (observatory==''):
        observatory = 'ALMA'
    try:
        [latitude,longitude,observatory] = getObservatoryLatLong(observatory)
        if (printCurrent):
            print "Found location for %s: %f, %f degrees" % (observatory,longitude,latitude)
            print "MJD = %f = %f seconds" % (mjd, mjdsec)
    except:
        print "Did not find this observatory=%s, using ALMA instead." % (observatory)
        
    (az,el) = ComputeSolarAzElLatLong(mjdsec,latitude,longitude)
    if (printCurrent):
        print "At %s, the Sun is currently at azim=%.3f, elev=%.3f" % (observatory,az,el)
    return(az,el)

def listAvailableObservatories():
    """
    Lists the observatories known to CASA.
    Todd Hunter
    """
    repotable=os.getenv("CASAPATH").split()[0]+"/data/geodetic/Observatories"
    try:
        tb.open(repotable)
        Name = tb.getcol('Name')
        ns = ''
        for N in Name:
            ns += N + "  "
            if (len(ns) > 70):
                print ns
                ns = ''
        tb.close()
    except:
        print "Could not open table = %s" % (repotable)

def getObservatoryLatLong(observatory='',help=False, verbose=False):
     """
     Opens the casa table of known observatories and returns the latitude and longitude
     in degrees for the specified observatory name string.
     -- Todd Hunter
     """
     if (help):
        print "Opens the casa table of known observatories and returns the latitude"
        print "and longitude in degrees for the specified observatory (default=ALMA)."
        print "Usage: getObservatoryLatLong(observatory='ALMA')"
        print "Usage: getObservatoryLatLong(observatory=-7)"
        print "Usage: getObservatoryLatLong(observatory='-7')"
        listAvailableObservatories()
        return
     repotable=os.getenv("CASAPATH").split()[0]+"/data/geodetic/Observatories"
     try:
        tb.open(repotable)
     except:
        print "Could not open table = %s, returning ALMA coordinates instead" % (repotable)
        longitude = ALMA_LONGITUDE
        latitude = ALMA_LATITUDE
        observatory = 'ALMA'
        return([latitude,longitude,observatory])
     if (type(observatory) == 'int' or str(observatory) in JPL_HORIZONS_ID.values()):
         if (str(observatory) in JPL_HORIZONS_ID.values()):
             observatory = JPL_HORIZONS_ID.keys()[JPL_HORIZONS_ID.values().index(str(observatory))]
             if (verbose):
                 print "Recognized observatory = %s" % observatory
             if (observatory == 'MAUNAKEA'): observatory = 'SMA'
             if (observatory == 'OVRO'): observatory = 'OVRO_MMA'
         else:
             print "Did not recognize observatory='%s' in %s, using ALMA instead." % (observatory,str(JPL_HORIZONS_ID.values()))
             observatory = 'ALMA'
#     else:
#         print "%s is not in %s" % (observatory, str(JPL_HORIZONS_ID.values()))
             
     Name = tb.getcol('Name')
     matches = np.where(np.array(Name)==observatory)
     if (len(matches) < 1 and str(observatory).find('500') < 0):
         print "Names = ", Name
         print "Did not find observatory='%s', using ALMA instead." % (observatory)
         for n in Name:
             if (n.find(observatory) >= 0):
                 print "Partial match: ", n
         observatory = 'ALMA'
         longitude = ALMA_LONGITUDE
         latitude = ALMA_LATITUDE
     elif (str(observatory).find('500') >= 0 or
           str(observatory).lower().find('geocentric') >= 0):
         observatory = 'Geocentric'
         longitude = 0
         latitude = 0
     else:
         longitude = tb.getcol('Long')[matches[0]]
         latitude = tb.getcol('Lat')[matches[0]]
     tb.close()
         
     return([latitude,longitude,observatory])

def ComputeSolarAzEl(mjdsec=None, observatory='ALMA'):
  """
  Return the az and el of the Sun in degrees for the specified
  time (default=now).  Default observatory is ALMA. See also ComputeSolarRADec().
  Todd Hunter
  """
  if (mjdsec==None):
      mjdsec = getCurrentMJDSec()
  [latitude,longitude,obs] = getObservatoryLatLong(observatory) 
  return(ComputeSolarAzElLatLong(mjdsec,latitude,longitude))

def ComputeSolarAzElLatLong(mjdsec,latitude,longitude):
  """
  Computes the apparent Az,El of the Sun for a specified time and location
  on Earth.  Latitude and longitude must arrive in degrees, with positive
  longitude meaning east of Greenwich.
  -- Todd Hunter
  """
  DEG_TO_RAD = math.pi/180.
  RAD_TO_DEG = 180/math.pi
  HRS_TO_RAD = math.pi/12.
  [RA,Dec] = ComputeSolarRADec(mjdsec)
  LST = ComputeLST(mjdsec, longitude)

  phi = latitude*DEG_TO_RAD
  hourAngle = HRS_TO_RAD*(LST - RA)
  azimuth = RAD_TO_DEG*math.atan2(math.sin(hourAngle), (math.cos(hourAngle)*math.sin(phi) - math.tan(Dec*DEG_TO_RAD)*math.cos(phi)))

# the following is to convert from South=0 (which the French formula uses)
# to North=0, which is what the rest of the world uses */
  azimuth += 180.0;

  if (azimuth > 360.0):
    azimuth -= 360.0
  if (azimuth < 0.0):
    azimuth += 360.0

  argument = math.sin(phi)*math.sin(Dec*DEG_TO_RAD) + math.cos(phi)*math.cos(Dec*DEG_TO_RAD) * math.cos(hourAngle);
  elevation = RAD_TO_DEG*math.asin(argument);

  return([azimuth,elevation])

def angleToSun(date=None, mjdsec=None, radec='', raRadian=None, decRadian=None,
               raDegrees=None, decDegrees=None, days=None, figfile=None,
               vis=None, field=0):
    """
    Compute the angular separation between the Sun and another object.
    Specify the date/time to use in one of the following two ways
    date: UT in string format, e.g. '2011/10/16 05:00:00'
    mjdsec: the time to use (default = now)
    
    Specify the coordinates of the object in one of the three following ways:
    radec: a sexagesimal string, e.g. 03:49:10.99 +57:17:44.806
    raRadian and decRadian: in radians
    raDegrees and decDegrees: in degrees
    vis: measurement set name: if specified, will compute angle from Sun to all fields
    field: if vis is specified, then return the angle between the Sun and this field

    days: compute the angle for the next number of days (default=None) and
          also make a plot
    - Todd Hunter
    """
    if (date != None):
        myValidCharacterList = [' ','/','-',':'] + [str(m) for m in range(10)]
        if (len(date) == sum([m in myValidCharacterList for m in date])):
            mjdsec = dateStringToMJDSec(date)
        else:
            print "Invalid date string"
            return
    if (mjdsec==None and date==None):
        if (vis == None):
            mjdsec = getCurrentMJDSec()
        else:
            mjdsec = getObservationStart(vis)
    if (days != None):
        mjdsecStop = mjdsec + days*86400
        angle = []
    else:
        mjdsecStop = mjdsec+1
    seconds = np.array(np.arange(mjdsec, mjdsecStop, 86400))
    if (raRadian!=None and decRadian!=None):
        radec = rad2radec(raRadian,decRadian)
    elif (raDegrees!=None and decDegrees!=None):
        radec = rad2radec(raDegrees*np.pi/180,decDegrees)
    elif (vis != None):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        nfields = mymsmd.nfields()
        fieldnames = mymsmd.namesforfields(range(nfields))
        mymsmd.close()
        print "Field ID, Name     Angle to sun (deg) at %s" % (mjdsecToUT(mjdsec))
        for myfieldId in range(nfields):
            radec = rad2radec(getRADecForField(vis, myfieldId, usemstool=False, forcePositiveRA=False), verbose=False)
            ra, dec = ComputeSolarRADecRadians(seconds[0])
            solarString = rad2radec(ra, dec, verbose=False)
            separation = angularSeparationOfStrings(radec, solarString, verbose=False)
            print "%2d = %12s = %6.3f" % (myfieldId, fieldnames[myfieldId],separation)
        if (field == None):
            field = 0
        if (type(field) == str):
            if (field.isdigit() == False):
                if (field not in fieldnames):
                    print "%s is not in the dataset" % (field)
                    return
                field = fieldnames.index(field)
        radec = rad2radec(getRADecForField(vis, field, usemstool=False, forcePositiveRA=False), verbose=False)
    elif (radec == ''):
        print "You must specify either: (1) radec, (2) raRadian and decRadian, (3) raDegrees, decDegrees"
        print "  where (1) is a sexagesimal string, e.g. 03:49:10.99 +57:17:44.806"
        return(-1)
    for second in seconds:
        ra, dec = ComputeSolarRADecRadians(second)
        solarString = rad2radec(ra, dec, verbose=False)
        separation = angularSeparationOfStrings(radec, solarString)
        if (days != None):
            angle.append(separation)
    if (days != None):
        pb.clf()
        pb.plot((seconds-seconds[0])/86400., angle, 'k-')
        pb.ylabel('Angle (degrees)')
        pb.xlabel('Days since %s' % (mjdSecondsToMJDandUT(seconds[0])[1]))
        pb.title('Angle between the Sun and %s' % (radec))
        pb.draw()
        if (figfile != None):
            if (figfile == True):
                figfile = 'angleToSun.png'
            pb.savefig(figfile)
            print "Plot saved to %s" % (figfile)
    return(separation)
    
def ComputeSolarRADec(mjdsec=None):
    """
    Computes the RA,Dec of the Sun (in hours and degrees) for a specified time (default=now).
    -- Todd Hunter
    """
    RAD_TO_DEG = 180/math.pi
    RAD_TO_HRS = (1.0/0.2617993877991509)
    ra,dec = ComputeSolarRADecRadians(mjdsec)
    return(ra*RAD_TO_HRS, dec*RAD_TO_DEG)

def ComputeSolarRADecRadians(mjdsec=None):
    """
    Computes the RA,Dec of the Sun (in radians) for a specified time (default=now).
    -- Todd Hunter
    """
    if (mjdsec == None):
        mjdsec = getCurrentMJDSec()
    jd = mjdToJD(mjdsec/86400.)
    RAD_TO_DEG = 180/math.pi
    RAD_TO_HRS = (1.0/0.2617993877991509)
    DEG_TO_RAD = math.pi/180.
    T = (jd - 2451545.0) / 36525.0
    Lo = 280.46646 + 36000.76983*T + 0.0003032*T*T
    M = 357.52911 + 35999.05029*T - 0.0001537*T*T
    Mrad = M * DEG_TO_RAD
    e = 0.016708634 - 0.000042037*T - 0.0000001267*T*T
    C = (1.914602 - 0.004817*T - 0.000014*T*T) * math.sin(Mrad) +  (0.019993 - 0.000101*T) * math.sin(2*Mrad) + 0.000289*math.sin(3*Mrad)
    L = Lo + C
    nu = DEG_TO_RAD*(M + C)
    R = 1.000001018 * (1-e*e) / (1 + e*math.cos(nu))
    Omega = DEG_TO_RAD*(125.04 - 1934.136*T)
    mylambda = DEG_TO_RAD*(L - 0.00569 - 0.00478 * math.sin(Omega))  
    epsilon0 = (84381.448 - 46.8150*T - 0.00059*T*T + 0.001813*T*T*T) / 3600.
    epsilon = (epsilon0 + 0.00256 * math.cos(Omega)) * DEG_TO_RAD
    rightAscension = math.atan2(math.cos(epsilon)*math.sin(mylambda), math.cos(mylambda))
    if (rightAscension < 0):
        rightAscension += np.pi*2
    argument = math.sin(epsilon) * math.sin(mylambda)
    declination = math.asin(argument)
    return([rightAscension, declination])
    
def parseMonitorPowerLevels(filename,antenna,polarization=0,plot_type='sb_power') :
    if ((plot_type <> 'sb_power') and (plot_type <> 'bb_power') and (plot_type <> 'atten')) :
        return "You must select plot_type sb_power, bb_power or atten"
    if ((polarization <> 0) and (polarization <> 1)) :
        return 'Polarization needs to be 0 or 1.'
    polarization = str(polarization)
    table = fiop.fileToTable(filename)
    [rest,rows]  = fiop.getRestrictTable(table,1,antenna)
    [rest2,rows] = fiop.getRestrictTable(rest,2,polarization)
    rest2 = fiop.getInvertTable(rest2)
    times = rest2[0]
    times_ = convertTimeStamps(times)
    for i in range(len(times_[:-2000])) : print times_[i],i
    clf()
    if plot_type == 'sb_power' :
        plot(times_,rest2[3])
        plot(times_,rest2[4])
    elif plot_type == 'bb_power' :
        plot(times_,rest2[5])
        plot(times_,rest2[6])
        plot(times_,rest2[7])
        plot(times_,rest2[8])        
    elif plot_type == 'atten' :
        plot(times_,rest2[9],'.')
        plot(times_,rest2[10],'.')
        plot(times_,rest2[11],'.')
        plot(times_,rest2[12],'.')
        plot(times_,rest2[13],'.')
        plot(times_,rest2[14],'.')
    show()
        
class FixPosition:
  def __init__(self,inputMs=''):
    """
    Instantiation of this class calls this, i.e.,
        fp = aU.FixPosition('myInputMS.ms').  
    The dataset name is the only allowed input.
    For further help, see https://safe.nrao.edu/wiki/bin/view/ALMA/FixPosition
    Todd Hunter (May 2011)
    """
    self.inputMs = inputMs

  def getDirectionFromProperMotion(self,field,years=0):
      """
      Find the first occurrence of the source name or source ID, 
      and then use its position and proper motion to compute a
      new direction, and return it.
      Letting years=0 means to start at J2000 and come forward.
      -Todd Hunter (May 2011)
      """
      from math import pi
      tb.open('%s/SOURCE'%(self.inputMs),nomodify=True)
      if (isinstance(field,str)):
          source = tb.getcol('NAME')
      else:
          source = tb.getcol('SOURCE_ID')
      direction = tb.getcol('DIRECTION')
      properMotion = tb.getcol('PROPER_MOTION')
      tb.close()
#      print "len(direction[0]) = %d" % (len(direction[0]))
      if (years == 0):
          tb.open('%s/FIELD'%(self.inputMs),nomodify=True)
          if (isinstance(field,str)):
             mySource = tb.getcol('NAME')
          else:
             mySource = tb.getcol('SOURCE_ID')
          for i in range(len(mySource)):
              if (mySource[i] == field):
                  timestamp = tb.getcell('TIME',i)
                  j2000 = 4453401600
                  years = (timestamp - j2000)/31556925.0
                  seconds = (timestamp - j2000)
                  print "Applying %f years (%.1f seconds) of proper motion since J2000." % (years,seconds)
                  break
          tb.close()
      else:
          seconds = years*31556925.
      foundSource = 0
      for i in range(len(direction[0])):
          if (source[i] == field):
              new_dec = direction[1][i] + properMotion[1][i]*seconds
              new_ra = direction[0][i] + properMotion[0][i]*seconds/math.cos(new_dec)
              new_direction = np.array([[new_ra], [new_dec]])
              hr = (new_ra*180/pi)/15.
              h = int(floor(hr))
              m = int((hr-h)*60)
              s = 3600*(hr-h-m/60.)
              if (new_dec < 0):
                  mysign = '-'
              else:
                  mysign = '+'
              dec = abs(new_dec*180/pi)
              d = int(floor(dec))
              dm = int(60*(dec-d))
              ds = 3600*(dec-d-dm/60.)
              print "New direction = %.12f, %.12f = %02d:%02d:%07.4f, %c%02d:%02d:%07.4f" % (new_ra, new_dec, h,m,s,mysign,d,dm,ds)
              foundSource = 1
              break
      if (foundSource == 0):
          print "Did not find source = ", field
          return(0)
      else:
          return(new_direction)
      
  def setDirectionFromRADec(self,field,raString,decString):
      """
      Sets the direction of a field from a specified ra and dec
      string. The strings
      should be in the form:  hh:mm:ss.sssss   +dd:mm:ss.ssss
      Todd Hunter
      """
      from math import pi
      (hour,minute,second) = raString.split(':')
      (deg,dmin,dsec) = decString.split(':')
      rahour = (float(hour)+float(minute)/60.+float(second)/3600.) 
      ra = 15*rahour*pi/180.
      if (deg.find('-')>=0):
          sign = -1
      else:
          sign = +1
      deg = abs(float(deg))
      dec = sign*(deg+float(dmin)/60.+float(dsec)/3600.)*pi/180
      new_direction = np.array([[ra],[dec]])
      # now double check it by showing it to the user
      hr = (ra*180/pi)/15.
      h = int(floor(hr))
      m = int(floor((hr-h)*60))
      s = 3600*(hr-h-m/60.)
      if (dec < 0):
          mysign = -1
          mychar = '-'
      else:
          mysign = +1
          mychar = '+'
      decdeg = abs(dec*180/pi)
      d = int(floor(decdeg))
      dm = int(floor(60*(decdeg-d)))
      ds = 3600*(decdeg-d-dm/60.)
      print "New direction: %.11f,%.11fdeg = %02d:%02d:%06.3f,%c%02d:%02d:%07.4f" % (hr, mysign*decdeg, h,m,s,mychar,d,dm,ds)
      print "             = %.13f,%.13f radian" % (ra,dec)
      self.setDirectionFromValue(field,new_direction)
      return
      
  def setDirectionFromProperMotion(self,field,years=0):
      """
      Will set the PHASE, DELAY and REFERENCE directions of the field to the modified
      position as computed from the proper motion in the SOURCE table.
      Todd Hunter
      """
      new_direction = self.getDirectionFromProperMotion(field,years)
      if (isinstance(new_direction,int)):
          print "Did not find source"
          return
      self.setDirectionFromValue(field,new_direction)
      return
      
  def setDirectionFromValue(self,field,new_direction):
      tb.open('%s/FIELD'%(self.inputMs),nomodify=False)
      sourceName = tb.getcol('NAME')
      if (isinstance(field,str)):
          source = tb.getcol('NAME')
      else:
          source = tb.getcol('SOURCE_ID')
      changed = 0
      for j in range(len(source)):
          if (source[j] == field):
              direction = tb.getcell('PHASE_DIR',j)   
#              print "len(direction), direction = ", len(direction), direction
#              print "len(new_direction), new_direction = ", len(new_direction), new_direction
              tb.putcell('PHASE_DIR',j,new_direction)   
              tb.putcell('DELAY_DIR',j,new_direction)   
              tb.putcell('REFERENCE_DIR',j,new_direction)   
              changed += 1
      tb.close()
      print "Changed %d positions in FIELD table." % (changed)
      return

  def getRADecJ2000FromAntennas(self,field,timestamp=0):
#      loop over antennas,  this needs improvement
    ant = range(0,9)
    self.doRADecJ2000FromAntenna(field,0,ant,timestamp=timestamp)

  def doRADecJ2000FromAntenna(self, field, observatory=JPL_HORIZONS_ID['ALMA'], set=0, ant=0, timestamp=0):
    """
    Computes the mean RA/Dec in J2000 coordinates for the specified 
    field string by using the azim/elev pointing of the specified 
    antenna and stuffs this into the FIELD tables. This is the 
    equivalent of something Dirk wrote independently and should be 
    superceded by the method: getRADecJ2000FromJPL().

    ant = antenna number index (0..n)
    timestamp = 0 means compute the mean position
      (otherwise, find the antenna position at the nearest time to this)
    Todd Hunter
    """ 
    me = createCasaTool(metool)
    vm = ValueMapping(self.inputMs)
    try:
        times = vm.getTimesForField(field)
    except:
        print "did not find %s in the ms" %(field)
        return
    tb.open('%s/POINTING'%(self.inputMs))
    tim=tb.getcol('TIME')
    dir=tb.getcol('DIRECTION')
    antenna=tb.getcol('ANTENNA_ID')
    tb.close()
    tb.open('%s/ANTENNA'%(self.inputMs))
    antpos=tb.getcol('POSITION')
    tb.close()

    if (isinstance(ant,int)):
        ants = [ant]
    else:
        ants = ant
    antCounter = -1
    for ant in ants:
      iant = ant
      me.doframe(me.position('ITRF','%.8fm'%(antpos[0][iant]), '%.8fm'%(antpos[1][iant]), '%.8fm'%(antpos[2][iant])))
      raRadian = []
      decRadian = []
      for k in range(len(tim)):
        if ((tim[k] > times[0]) and (tim[k] < times[-1])):
          if (antenna[k] == ant):
            me.doframe(me.epoch('UTC', qa.quantity(tim[k],'s')))
            dirJ2000=me.measure(me.direction('AZELGEO',
                                             qa.quantity(dir[0,0,k], 'rad'), 
                                             qa.quantity(dir[1,0,k],'rad')),
                               'J2000')
            raRadian.append(dirJ2000['m0']['value'])
            decRadian.append(dirJ2000['m1']['value'])
      if (timestamp == 0):
        meanRA = mean(raRadian)
        meanDEC = mean(decRadian)
      else:
        index = self.find_index_of_nearest(times, timestamp)
        if (ant == ants[0]):
          print "The nearest time to %.3f is %.3f, a difference of %.3f seconds" % (timestamp,times[index],timestamp-times[index])
        meanRA = raRadian[index]
        meanDEC = decRadian[index]
      if (meanRA < 0):
        meanRA = meanRA+2*math.pi
      hours = meanRA*12/math.pi
      deg = meanDEC*180/math.pi
      absdeg = abs(deg)
      if (len(ants) < 2):
        antstring = ''
        if (timestamp == 0):
          print 'mean RA, Dec:'
        else:
          print 'RA, Dec at closest time:'
      else:
        antstring = '%d'%(ant)

      xyz = "antpos = %.4fm, %.4fm, %.4fm" % (antpos[0][ant],antpos[1][ant],antpos[2][ant])
      print 'Antenna %s  %s  %02d:%02d:%07.4f, %c%02d:%02d:%06.3f  %s' % (antstring,
        vm.getAntennaNamesForAntennaId(ant),
        int(hours), 
        int(60*(hours-int(hours))), 3600*(hours-int(hours)-int(60*(hours-int(hours)))/60.),
        ('%+f'%(deg))[0], int(absdeg), int(60*(absdeg-int(absdeg))), 3600*(absdeg-int(absdeg)-int(60*(absdeg-int(absdeg)))/60.), 
        xyz)
    tb.open('%s/FIELD'%(self.inputMs),nomodify=False)
    name = tb.getcol('NAME')
    j = 0
    for i in range(len(name)):
        if (name[i] == field):
            reference_dir = tb.getcell('REFERENCE_DIR',j)   
            reference_dir = np.array([[meanRA],[meanDEC]])
            if (set):
                tb.putcell('REFERENCE_DIR',j,reference_dir)   
                tb.putcell('PHASE_DIR',j,reference_dir)   
                tb.putcell('DELAY_DIR',j,reference_dir)   
                print "Values updated"
#            else:
#                print "Values NOT updated"
        j = j+1
    tb.close()

  def setRADecJ2000FromAntenna(self,field,ant=0,timestamp=0):
      self.doRADecJ2000FromAntenna(field,set=1,ant=ant,timestamp=timestamp)

  def getRADecJ2000FromAntenna(self,field,ant=0,timestamp=0):
      self.doRADecJ2000FromAntenna(field,set=0,ant=ant,timestamp=timestamp)

  def find_nearest(self,array,value):
    idx = (np.abs(array-value)).argmin()
    return array[idx]

  def find_index_of_nearest(self,array,value):
    idx = (np.abs(array-value)).argmin()
    return idx

  def doRADecJ2000FromJPL(self, field, observatory=JPL_HORIZONS_ID['ALMA'], set=0, verbose=0):
    """
    Contacts JPL Horizons via the telnet interface, gets the position and derivative
    for the mean time of observation, and stuffs them into the FIELD table of the ms.
    At present, this function can only accept a single field, but could be modified to
    do more than one at once.  The apparent coordinates are for ALMA.
    It returns the polynomial for use in subsequent .ms.
    Todd Hunter
    """
    nPolyTerms = 2
    vm = ValueMapping(self.inputMs)
    try:
        times = vm.getTimesForField(field)
    except:
        print "did not find %s in the ms" %(field)
        return
    meanTime = mean(times)
    print "Will query JPL Horizons for position & derivative at mean time = %.1f " % (meanTime)
    s = mjdSecondsToMJDandUT(meanTime)
    print " = %.5f = %s" % (s[0],s[1])
    tb.open('%s/FIELD'%(self.inputMs),nomodify=False)
    sourceName = tb.getcol('NAME')
    if (isinstance(field,str)):
        source = tb.getcol('NAME')
    else:
        source = tb.getcol('SOURCE_ID')
    j = 0
    for i in range(len(source)):
        if (source[i] == field):
            [directionRadians,rateRadiansPerSecond,angularDiameter] = self.contactJPLHorizons(sourceName[i], meanTime, observatory, verbose)
            reference_dir = tb.getcell('REFERENCE_DIR',j)   
            print "original PHASE_DIR = ", reference_dir
# definitely works:
            reference_dir = np.array([[directionRadians[0], rateRadiansPerSecond[0]],
                                      [directionRadians[1], rateRadiansPerSecond[1]]])
# this does not
#            reference_dir = np.array([directionRadians[0], directionRadians[1], 
#                                      rateRadiansPerSecond[0], rateRadiansPerSecond[1]])

            print "new PHASE_DIR = ", reference_dir
            if (set):
                tb.putcell('REFERENCE_DIR',j,reference_dir)   
                tb.putcell('PHASE_DIR',j,reference_dir)   
                tb.putcell('DELAY_DIR',j,reference_dir)   
                tb.putcell('TIME',j,meanTime)
                tb.putcell('NUM_POLY',j,nPolyTerms)   
                print "Values updated"
            else:
                print "Values NOT updated"
        j = j+1
    if (set):
        tb.putcolkeyword('PHASE_DIR','MEASINFO', {'Ref':'J2000', 'type':'direction'})
        tb.putcolkeyword('DELAY_DIR','MEASINFO', {'Ref':'J2000', 'type':'direction'})
        tb.putcolkeyword('REFERENCE_DIR','MEASINFO', {'Ref':'J2000', 'type':'direction'})
    tb.close()
    return([reference_dir,meanTime])

  def setRADecJ2000FromPolynomial(self,field,polynomial,timestamp,set=True):
    """
    Sets the RA and Dec for the specified field using the specified
    polynomial and timestamp.
    Todd Hunter
    """
    nPolyTerms = len(polynomial) - 1 # Bryan Butler told me to add the "- 1" on March, 12 2012. - TRH
    tb.open('%s/FIELD'%(self.inputMs),nomodify=False)
    sourceName = tb.getcol('NAME')
    if (isinstance(field,str)):
        source = tb.getcol('NAME')
    else:
        source = tb.getcol('SOURCE_ID')
    j = 0
    for i in range(len(source)):
        if (source[i] == field):
            reference_dir = polynomial
            print "new PHASE_DIR = ", reference_dir
            if (set):
                tb.putcell('REFERENCE_DIR',j,reference_dir)   
                tb.putcell('PHASE_DIR',j,reference_dir)   
                tb.putcell('DELAY_DIR',j,reference_dir)   
                tb.putcell('TIME',j,timestamp)
                tb.putcell('NUM_POLY',j,nPolyTerms)   
                print "Values updated"
            else:
                print "Values NOT updated"
        j = j+1
    if (set):
        tb.putcolkeyword('PHASE_DIR','MEASINFO', {'Ref':'J2000', 'type':'direction'})
        tb.putcolkeyword('DELAY_DIR','MEASINFO', {'Ref':'J2000', 'type':'direction'})
        tb.putcolkeyword('REFERENCE_DIR','MEASINFO', {'Ref':'J2000', 'type':'direction'})
    tb.close()
    return

  def setRADecJ2000FromJPL(self,field,observatory=JPL_HORIZONS_ID['ALMA']):
    """
    Contacts JPL Horizons via the telnet interface, gets the position
    of a planetary body along with its derivative for the mean time of
    observation, and stuffs them into the FIELD table of the ms.
    Todd Hunter
    """
    polynomialData = self.doRADecJ2000FromJPL(field, observatory, set=1)
    return(polynomialData)

  def getRADecJ2000FromJPL(self,field, observatory=JPL_HORIZONS_ID['ALMA'], verbose=0):
    """
    Contacts JPL Horizons via the telnet interface, gets the position
    of a planetary body along with its derivative for the mean time of
    observation and returns it.
    Todd
    """
    polynomialData = self.doRADecJ2000FromJPL(field, observatory, set=0, verbose=verbose)
    return(polynomialData)

  def getRaDecSize(self, body, datestring, observatory=JPL_HORIZONS_ID['ALMA'], 
                   verbose=False, apparent=False):
    if (len(datestring.split()) < 2):
        # append a UT time if not given
        datestring += ' 00:00'
        print "Assuming 0 hours UT"
    mjdsec = dateStringToMJDSec(datestring)
    (directionRadians, rateRadiansPerSecond,angularDiameter,rangeRate,rangeAU) = self.contactJPLHorizons(body, mjdsec, observatory, verbose, apparent)
    data = {}
    data['directionRadians'] = directionRadians
    data['rateRadiansPerSecond'] = rateRadiansPerSecond
    data['angularDiameter'] = angularDiameter
    data['rangeRateKms'] = rangeRate
    data['rangeAU'] = rangeAU
    return(data)      
  
  def contactJPLHorizons(self, body, mjdsec, observatory=JPL_HORIZONS_ID['ALMA'], 
                         verbose=False, apparent=False):
    """
    observatory needs to be an integer ID acceptable to JPL horizons
    example interactive session:
    telnet://horizons.jpl.nasa.gov:6775
    606 # = Titan
    e  # for ephemeris
    o  # for observables
    -7 # for ALMA
    y  # confirm
    2011-Apr-23 00:00  #  UT
    2011-Apr-23 01:00  #  UT
    1h #  interval
    y  # default output
    1,3,13,20 # RA/DEC and rates (Rarcsec/hour), angular diameter, and range+rate
    space  # to get to next prompt
    q   # quit
    """

    OBSERVATORY_ID = observatory
    tstart = mjdSecondsToMJDandUT(mjdsec)[1][0:-3]
    if (verbose):
        print "tstart = ", tstart
    tstop = mjdSecondsToMJDandUT(mjdsec+3600)[1][0:-3]
    timeout = 4  #seconds
    t = None
    while (t==None):
        try:
            t = telnetlib.Telnet('horizons.jpl.nasa.gov',6775)  # this can bomb with err=110, connection timed out
        except:
            print "Telnet connection to JPL time out. Trying again."
    t.set_option_negotiation_callback(self.optcallback)
    data = t.read_until('Horizons> ')
    if (verbose):
        print "data = ", data
        print "hex string = %s\n\n" % binascii.hexlify(data)
    while (data.find('Horizons>') < 0):
        t.write('\n')
        data = t.read_until('Horizons> ')
        if (verbose):
            print "data = ", data
    t.write(body+'\n')
    data = t.read_until('Select ... [E]phemeris, [F]tp, [M]ail, [R]edisplay, ?, <cr>: ',timeout)
    if (verbose):
        print "data = ", data
    if (data.find('phemeris') < 0):
      if (data.find('EXACT')>=0):
        t.write('\n')
        data = t.read_until('Select ... [E]phemeris, [F]tp, [M]ail, [R]edisplay, ?, <cr>: ', timeout)
        if (verbose):
            print data
        useID = ''
      else:
        # then we have a conflict in the name. 
        # e.g. Titan vs. Titania, or Mars vs. Mars Barycenter
        # Try to resolve by forcing an exact match.
        lines = data.split('\n')
        if (verbose):
            print "Multiple entries found, using exact match"
            print "nlines = %d" % (len(lines))
        firstline = -1
        lastvalidline = -1
        l = 0
        useID = -1
        for line in lines:
            if (verbose):
                print line
            if (line.find('-----') >= 0):
                if (firstline == -1):
                    firstline = l+1
            else:
              tokens = line.split()
              if (firstline>=0 and lastvalidline == -1):
                  if (len(tokens) < 2):
                      lastvalidline = l-1
                  elif (tokens[1] == body):
                      if (len(tokens) == 2 or (len(tokens)>2 and useID==-1)):
                          useID = int(tokens[0])
                          useBody = tokens[1]
                          if (verbose):
                              print "Use instead the id = %s = %d" % (tokens[0],useID)
            l = l+1
        if (useID == -1):
          # Try again with only the first letter capitalized
          body = string.upper(body[0]) + string.lower(body[1:])
          if (verbose):
              print "Try the exact match search again with body = ", body
          firstline = -1
          lastvalidline = -1
          l = 0
          for line in lines:
            if (verbose):
                print line
            if (line.find('-----') >= 0):
                if (firstline == -1):
                    firstline = l+1
            elif (firstline > 0):
              line = line.lstrip(' ')
              if (verbose):
                  print "Splitting this line = %s" % (line)
              tokens = line.split()
              if (verbose):
                  message = "length=%d,  %d tokens found: " % (len(line),len(tokens))
                  for tok in tokens:
                      message +=  "%s " % (tok)
                  print message
              if (firstline>=0 and lastvalidline == -1):
                  if (len(tokens) < 2):
                      # this is the final (i.e. blank) line in the list
                      lastvalidline = l-1
                  elif (tokens[1] == body):
                      if (len(tokens) == 2 or (len(tokens)>2 and useID==-1)):
                          useID = int(tokens[0])
                          useBody = tokens[1]
                          if (verbose):
                              print "Use instead the id = %s = %d" % (tokens[0],useID)
            l = l+1
        if (verbose):
            print "line with first possible source = ", firstline
            print "line with last possible source = ", lastvalidline
            print "first possible source = ", (lines[firstline].split())[1]
            print "last possible source = ", (lines[lastvalidline].split())[1]
            print "Writing ", useID
        if (useID == -1):
            return
        t.write(str(useID)+'\n')
        data = t.read_until('Select ... [E]phemeris, [F]tp, [M]ail, [R]edisplay, ?, <cr>: ', timeout)
        if (verbose):
            print data
    else:
        useID = ''
    t.write('e\n')
    data = t.read_until('Observe, Elements, Vectors  [o,e,v,?] : ', timeout)
    if (verbose):
        print data
    t.write('o\n')
    data = t.read_until('Coordinate center [ <id>,coord,geo  ] : ', timeout)
    if (verbose):
        print data
    t.write('%s\n' % OBSERVATORY_ID)
    data = t.read_until('[ y/n ] --> ', timeout)
    pointer = data.find('----------------')
    ending = data[pointer:]
    lines = ending.split('\n')
    try:
        if (verbose):
            print "Parsing line = %s" % (lines)
        tokens = lines[1].split()
    except:
        print "Telescope code unrecognized by JPL."
        return([],[],[])
        
    if (verbose):
        print data
    obsname = ''
    for i in range(4,len(tokens)):
        obsname += tokens[i]
        if (i < len(tokens)+1): obsname += ' '
    # display LST date/time and Julian date/time
    [latitude,longitude,obs] = getObservatoryLatLong(OBSERVATORY_ID)
    if (verbose):
        print "latitude = %s, longitude = %s" % (str(latitude), str(longitude))
    ComputeLSTDay(mjdsec, longitude=longitude, verbose=False)
    if (verbose):
        print "Confirmed Observatory name = %s (= %s in CASA)" % (obsname, obs)
        if (useID != ''):
            print "Confirmed Target ID = %d = %s" % (useID, useBody)
    t.write('y\n')
    data = t.read_until('] : ',3)
    if (verbose):
        print data
    t.write(tstart+'\n')
    data = t.read_until('] : ',3)
    if (verbose):
        print data
    t.write(tstop+'\n')
    data = t.read_until(' ? ] : ',timeout)
    if (verbose):
        print data
    t.write('1h\n')
    data = t.read_until(', ?] : ',timeout)
    if (verbose):
        print data
    if (True):
        t.write('n\n') # accept default output?
        data = t.read_until('Select table quantities [ <#,#..>, ?] :',timeout)
        if (verbose):
            print data
        # Set the first '1' to '2' for apparent coordinates
        if (apparent):
            if (verbose):
                print "Querying for apparent coordinates......"
            t.write('2,3,13,20\nJ2000\n\n\n\nDEG\nYES\n\n\n\n\n\n\n\n\n\n\n')
        else:
            if (verbose):
                print "Querying for J2000 coordinates......"
            t.write('1,3,13,20\nJ2000\n\n\n\nDEG\nYES\n\n\n\n\n\n\n\n\n\n\n')
    else:
        t.write('y\n') # accept default output?
        data = t.read_until(', ?] : ') #,timeout)
        if (verbose):
            print data
        t.write('1,3\n')
    t.read_until('$$SOE',timeout)  # This marks the line prior to the data we want
    data = t.read_until('$$EOE',timeout)  # This marks the line after the data we want
    if (verbose):
        print "data = ", data
    t.close()
    lines = data.split('\n')
    if (verbose):
        print "lines = ", lines
    if (len(lines[1].split()) == 9):
        (date, time, raDegrees, decDegrees, raRate, decRate, angularDiameter, rangeAU, rangeRate) = lines[1].split()
    else:
        (date, time, flag, raDegrees, decDegrees, raRate, decRate, angularDiameter, rangeAU, rangeRate) = lines[1].split()
    raRadian = float(raDegrees)*math.pi/180.0
    decRadian = float(decDegrees)*math.pi/180.0
    directionRadians = [raRadian,decRadian]
    directionDegrees = [float(raDegrees), float(decDegrees)]
    rate = [float(raRate), float(decRate)]
    rateRadiansPerSecond = [float(raRate)*math.pi/(180*3600.*3600.),float(decRate)*math.pi/(180*3600.*3600.)]
    rangeAU = float(rangeAU)
    rangeRate = float(rangeRate)
    if (verbose):
        print "Range rate = %+f km/sec" % (rangeRate)
        print "degrees: position = ", directionDegrees, "  rates (arcsec/hr) = ",rate
    if (apparent):
        coords = 'Apparent'
    else:
        coords = 'J2000'
    observatoryName = JPL_HORIZONS_ID.keys()[JPL_HORIZONS_ID.values().index(str(observatory))]
    azim, elev = computeAzElFromRADecMJD(directionRadians, mjdsec/86400., observatory=observatoryName)
    azim *= 180/np.pi
    elev *= 180/np.pi
    print '%s %s Position: %s, %s   Azim, Elev: %.3f, %.3f' % (body, coords,qa.formxxx('%.12fdeg'%directionDegrees[0],format='hms',prec=5),
                                   qa.formxxx('%.12fdeg'%directionDegrees[1],format='dms',prec=4).replace('.',':',2),azim,elev)
    pa = np.arctan2(rate[0],rate[1]) * 180/np.pi
    if (verbose):
        print "%s %s Rate: %+.4f, %+.4f arcsec/hour (position angle = %+.1fdeg)" % (body,coords, rate[0], rate[1], pa)    
        print '%s %s Rate: %+.6f, %+.6f arcsec/second  (position angle = %+.1fdeg)' % (body,coords, rate[0]/3600., rate[1]/3600., pa)
    if (angularDiameter.find('n.a.') >=0):
        return(directionRadians, rateRadiansPerSecond, [], rangeRate, rangeAU)
    else:
        return(directionRadians, rateRadiansPerSecond, float(angularDiameter), rangeRate, rangeAU)

  # Reject all telnet requests.  Vanilla all the way.
  def optcallback(self, socket, command, option):
        cnum = ord(command)
        onum = ord(option)
        if cnum == telnetlib.WILL: # and onum == ECHO:
                socket.write(telnetlib.IAC + telnetlib.DONT + onum)
        if cnum == telnetlib.DO and onum == telnetlib.TTYPE:
                socket.write(telnetlib.IAC + telnetlib.WONT + telnetlib.TTYPE)

def computeBaselineLength(pos1,pos2):
    """
    Simple function to compute the length of a baseline, given the X,Y,Z coordinates
    of two stations, in some arbitrary linear coordinate system.  See also
    au.getBaselineLength to compute it for specific antennas in an ms.
    - Todd Hunter
    """
    length = ((pos1[0]-pos2[0])**2+(pos1[1]-pos2[1])**2+(pos1[2]-pos2[2])**2)**0.5
    return(length)

def getBaselineExtrema(msFile):
    """
    Will compute the shortest and longest baseline for the specified ms.
    Projection toward the sources in the ms is not accounted for.
    Todd Hunter
    """
    tb.open(msFile+'/ANTENNA')
    names = tb.getcol('NAME')
    positions = np.transpose(tb.getcol('POSITION'))
    maxlength = 0
    minlength = 1e20
    for i in range(len(positions)):
        for j in range(i+1,len(positions)):
            length = computeBaselineLength(positions[i],positions[j])
            if (length > maxlength):
                maxlength = length
                maxbaseline = '%s-%s' % (names[i],names[j])
            if (length < minlength):
                minlength = length
                minbaseline = '%s-%s' % (names[i],names[j])
    tb.close()
    print "Longest baseline = %.3f m = %s" % (maxlength,maxbaseline)
    print "Shortest baseline = %.3f m = %s" % (minlength,minbaseline)
    return([maxlength,minlength,maxbaseline,minbaseline])
#    return

def getBaselineStats(msFile='', length=None, percentile=None, field='',
                     azimuth=None, elevation=None, config=None,
                     angularSize=None, frequency=None, verbose=True):
    """
    Compute statistics on the baseline lengths of the specified ms.
    Returns: number, min, max, median, mean, st.dev, 20%ile, 25%ile, 30%ile,
             75%ile, 90%ile
    msFile: the measurement set to examine (if config is not None)
    field: if not blank, then find the first integration on the specified
           field ID or name, get its az&el and compute the projected baseline
           lengths rather than the unprojected baseline lengths
    azimuth,elevation: if field=='', and these are both set (in degrees),
           then compute the projected baseline length toward this direction
           rather than the unprojected baseline lengths
    config: a configuration file to read, instead of a visibility file
    length: If not None, then it also finds the percentile for that length.
    percentile: If not None, then it finds the length for that percentile and
           returns it as an additional (first) argument.
    angularSize: If not None, then it find the percentage of baselines shorter
           than this angular scale (in arcseconds) and returns it as an
           additional (first) argument
    frequency: in GHz, used with the angularSize option.
    
    Todd Hunter
    """
    if (percentile != None and angularSize != None):
        print "percentile and angularSize are cannot both be specified."
        return
    if (angularSize != None and frequency == None):
        print "A frequency must be specified if angular size is specified."
        return
    if (msFile == '' and config==None):
        print "Either an msFile or a config file must be specified."
        return
    bl1 = getBaselineLengths(msFile=msFile,field=field,azimuth=azimuth,
                            elevation=elevation,config=config)
    if (bl1==None): return

    bl = []
    for i in range(len(bl1)):
        if len(bl1[i]) != 2: sys.exit('ERROR')
        bl.append(tuple([bl1[i][0], bl1[i][1]]))

    bl = np.array(bl)
    lengths = bl[:,1].astype(np.float)
    number = len(lengths)
    twenty = scoreatpercentile(lengths, 20)    
    twentyfive = scoreatpercentile(lengths, 25)    
    thirty = scoreatpercentile(lengths, 30)    
    seventyfive = scoreatpercentile(lengths, 75)
    ninety = scoreatpercentile(lengths, 90)
    if (verbose):
        print "number=%d, min=%.2fm, max=%.2fm, median=%.2fm, mean=%.2fm, std=%.2fm" % (number, np.min(lengths), np.max(lengths), np.median(lengths), np.mean(lengths), np.std(lengths))
        print "20%%ile=%.1fm 25%%ile=%.1fm, 30%%ile=%.1fm, 75%%ile=%.1fm, 90%%ile=%.1fm" % (twenty, twentyfive, thirty, seventyfive, ninety)
    if (length != None):
        mypercentile = percentileofscore(lengths,length)
        if (verbose):
            print "%g m corresponds to %g percentile" % (length,mypercentile)
    if (percentile != None):
        mylength = scoreatpercentile(lengths,percentile)
        if (verbose):
            print "%g m corresponds to %g percentile" % (mylength,percentile)
        return(mylength, number, np.min(lengths), np.max(lengths), np.median(lengths),
               np.mean(lengths), np.std(lengths), twenty, twentyfive, thirty,
               seventyfive, ninety)
    elif (angularSize != None):
        mypercentage = percentileofscore(lengths, angularScaleBaseline(angularSize,frequency))
        if (verbose):
            print "Percentage of baselines shorter than %.3f arcsec: %.3f" % (angularSize,mypercentage)
        return(mypercentage, number,np.min(lengths),np.max(lengths),
               np.median(lengths),
               np.mean(lengths), np.std(lengths),twenty,twentyfive,thirty,
               seventyfive,ninety)
    else:
        return(number,np.min(lengths),np.max(lengths),np.median(lengths),
               np.mean(lengths), np.std(lengths),twenty,twentyfive,thirty,
               seventyfive,ninety)

def angularScaleBaseline(angularScale, frequency):
    """
    Return the baseline length (in meters) corresponding to the specified
    angular scale at the specified frequency.  See also findNull().
    angularScale: arcsec
    frequency: GHz
    -- Todd Hunter
    """
    wavelengthMeters = c_mks*1e-9/float(frequency)
    lengthLambda = ARCSEC_PER_RAD/angularScale
    lengthMeters = lengthLambda*wavelengthMeters
    return(lengthMeters)

def printBaselineAngularScale(length, frequency=[]):
    """
    Converts a baseline length into angular scale on the sky either at the
    specified frequency(s), or at the four major ALMA bands (default), using
    the formula: ARCSEC_PER_RAD*(wavelength/baseline).
    frequency can be a single integer/float or a list thereof.
    Returns the value in arc seconds of the last one in the list.
    --Todd Hunter
    """
    if (frequency == []):
        frequency = [100, 230, 345, 690]
    elif (type(frequency) == int or type(frequency) == float):
        frequency = [frequency]
    for freq in frequency:
        wavelengthMeters = 0.2998/np.float(freq)
        lengthLambda = length/wavelengthMeters
        arcsec = ARCSEC_PER_RAD/lengthLambda
        print "%g m corresponds to %g kilolambda and %g arcsec at %d GHz" % (length,lengthLambda*0.001,arcsec,freq)
    return(arcsec)

def readPadConfigurationFile(config, verbose=False):
    """
    Reads a pad configuration file and returns 3 arrays and an integer:
        stations: ['1']
        positions:  [[X,Y,Z]]
        names:  ['padXXX']
        nAntennas: len(stations)
    -Todd Hunter
    """
    if (os.path.exists(config) == False):
        repotable=os.getenv("CASAPATH").split()[0]+"/data/alma/simmos/"
        config = repotable + config
    if (os.path.exists(config) == False):
        if (os.path.exists(config+'.cfg') == False):
            print "Could not find configuration file: %s" % (config)
            return
        config = config + '.cfg'
    cfile = open(config, 'r')
    lines = cfile.readlines()
    stations = []
    positions = []
    for line in lines:
        if (line[0] == '#'):
            if (line.find('coordsys') >= 0):
                coordsys = line.split('coordsys=')[1]
        else:
            if (verbose):
                print "splitting line = ", line
            tokens = line.split()
            if (len(tokens) < 4): continue
            elif (len(tokens) < 5):
                a,b,c,d = tokens
                pad = '???'
            else:
                a,b,c,d,pad = tokens
            x = float(a)
            y = float(b)
            z = float(c)
            stations.append(pad)
            positions.append([x,y,z])
    nAntennas= len(stations)
    names = ['pad%03s'%(x) for x in stations]
    cfile.close()
    return stations, positions, names, nAntennas

def getPadLOC(pad):
    """
    Returns the local tangent plane coordinates of the specified ALMA pad from
    the file AOS_Pads_XYZ_ENU.txt distributed with analysisUtils. 
    This function is only used if (casadef.subversion_revision < '25324'), as
    later versions can use the COFA in the ms with simutil.itrf2loc
    -Todd Hunter
    """
    almafile = os.path.dirname(__file__) + '/AOS_Pads_XYZ_ENU.txt'
    if (os.path.exists(almafile) == False):
        print "Could not find file: ", almafile
        return
    f = open(almafile,'r')
    lines = f.readlines()
    for line in lines:
        if (line.find(pad)>0 and line.find('#')<0):
            tokens = line.split()
            x = float(tokens[0])
            y = float(tokens[1])
            z = float(tokens[2])
            return(x,y,z)
    print "%: No such pad!" % (pad)
    return(0,0,0)

def getBaselineLengths(msFile='', sort=True, length=None, rigorous=False,
                       subarraySize=0, percentile=None, field='', azimuth=None,
                       elevation=None, uvrange='', config=None, debug=False):
    """
    Determines the baseline lengths for the specified ms and returns a
    list of tuples with the first value being the baseline string and the
    second value being the baseline length in meters. If the length parameter
    is given, it instead returns the maximum number of antennas in a
    subarray configuration where all baselines are less than this value,
    and the corresponding list of antenna names. If the percentile parameter
    is given, then it computes the baseline length corresponding to that
    percentile and proceeds to use it as the length parameter.

    length:  find the subarray with the most antennas for which the longest
             baseline is less than this value (in meters)
    percentile: compute and use the length corresponding to this percentile of
             the baseline lengths for the configuration.
    sort=True sorts by baseline length, sort=False sorts by antenna name
    rigorous=Performs a full analysis of all possible combinations of
           N-1 antennas, then N-2, etc. until it find one that meets the
           length criterion.  Fast for ACA, but slow for >=32 antennas!
    subarraySize: in the option rigorous, this number of antennas tells it
           where to start its checks (going downward), which greatly speeds
           the calculation; default=0 ==> start with all N antennas in dataset
    field: if not blank, then find the first integration on the specified
           field ID, get its az&el and compute the projected baseline length
    azimuth,elevation: if field=='', and these are both set (in degrees),
           then compute the projected baseline length toward this direction
    uvrange: a string range in meters: '5~40'.  If present, then compute the
             number of baselines within the specified range
    config: a configuration file to read, instead of a visibility file
    
    For further help and examples, see
       http://casaguides.nrao.edu/index.php?title=GetBaselineLengths
    Todd Hunter
    """
    if (config == None):
        if (os.path.exists(msFile+'/ANTENNA') == False):
            print "Could not find table = ", msFile+'/ANTENNA'
            return
        if (percentile != None):
            tokens = getBaselineStats(msFile, percentile=percentile,field=field)
            length = tokens[0]
        mytb = createCasaTool(tbtool)
        try:
            mytb.open(msFile+'/ANTENNA')
        except:
            print "Could not open table = ", msFile+'/ANTENNA'
            return
        names = list(mytb.getcol('NAME'))
        nAntennas = len(names)
        if (nAntennas < 17 and rigorous==False and length != None):
            print "getBaselineLengths(): Switching to rigorous mode for better accuracy"
            rigorous = True
        positions = np.transpose(mytb.getcol('POSITION'))
        stations = mytb.getcol('STATION')
        mytb.close()
    else:
        returnValue = readPadConfigurationFile(config)
        if (returnValue == None): return
        stations, positions, names, nAntennas = returnValue
        
    # Now figure out where it ranks in the array
    l = {}
    mostNeighbors = 0
    neighborlist = []
    maxlength = 0
    minlength = 1e9
    mylengths = [[0.0 for i in range(nAntennas)] for j in range(nAntennas)]
    if (uvrange != ''):
        tokens = uvrange.split('~')
        if (len(tokens) != 2):
            print "uvrange must be specified in the format: '5~40'"
            return
        uvrangeBaselines = 0
        uvmin = float(tokens[0])
        uvmax = float(tokens[1])
    if (field != ''):
        if (type(field) == str):
            # may need to convert to int
            if (field.isdigit()):
                field = int(field)
            elif field in getFields(msFile):
                field = list(getFields(msFile)).index(field)
            else:
                print "Field %s not in the ms. It has: %s" % (field,str(getFields(msFile)))
                return
        # field will now be an int
        nfields = len(getFields(msFile))
        if (field not in range(nfields)):
            print "Field %d not in the ms, only %s" % (field,str(range(nfields)))
            return
        # get the az,el of the observation, which amounts to getting the
        # UT time of the first integration and the observatory location.
        # open the ms, and look for first scan on field
        mydirection = getRADecForField(msFile, field)
        if (casadef.casa_version >= '4.1.0'):
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(msFile)
            scan = np.min(mymsmd.scansforfield(field))
            myscantime = np.mean(mymsmd.timesforscan(scan))
            telescopeName = mymsmd.observatorynames()[0]
            mymsmd.close()
        else:
            vm = ValueMapping(msFile)
            scan = np.min(vm.getScansForField(field))
            myscantime = np.mean(vm.getTimesForScans(scan))
            telescopeName = getObservatoryName(msfile)
        print "Using scan = ", scan
        myazel = computeAzElFromRADecMJD(mydirection, myscantime/86400., telescopeName)
        source_el = myazel[1]*180/pi
        source_az = myazel[0]*180/pi
        projected = True
    elif (elevation != None and azimuth != None):
        source_el = elevation
        source_az = azimuth
        projected = True
        telescopeName = getObservatoryName(msFile)
    else:
        projected = False
    if (projected):
        if (telescopeName.find('ALMA') < 0 and telescopeName.find('ACA') < 0 and
            casadef.subversion_revision<'25324'):
            print "In casa revisions < 25324, computation of the projected baselines is only\n supported for ALMA, not %s." % (telescopeName)
            return
        u = simutil.simutil()
    for i in range(nAntennas):
        neighborlist.append([names[i]])
        # For the ith antenna, we now measure each baseline, and if it is less
        # than half the specified criterion, we add it to the neighborlist for
        # the ith antenna.  This will yield a group of antennas within a circle
        # of diameter of length centered near the ith antenna.
        for j in range(i+1,nAntennas):
            x = positions[i][0]-positions[j][0]
            y = positions[i][1]-positions[j][1]
            z = positions[i][2]-positions[j][2]
            mylengths[i][j] = (x**2 + y**2 + z**2)**0.5
            if (projected):
                # convert length to projected. the formula for azimuth and elevation
                # assumes that x,y,z are in local coordinates, not UTM, so until
                # itrf2loc returns all 3 coords, we have to read the pad coordinates
                # from AOS_Pads_XYZ_ENU.txt.
                if (casadef.subversion_revision < '25324'):
                    # The only telescope that will reach this point is ALMA or ACA.
                    x0,y0,z0 = getPadLOC(stations[i])
                    x1,y1,z1 = getPadLOC(stations[j])
                else:
                    cx,cy,cz,Long,Lat = getCOFA(msFile)
                    if (debug):
                        print "Calling u.itrf2loc(%f,%f,%f,%f,%f,%f)" % (positions[i][0],positions[i][1],positions[i][2],cx,cy,cz)
                    x0,y0,z0 = u.itrf2loc(positions[i][0],positions[i][1],positions[i][2],cx,cy,cz)
                    x1,y1,z1 = u.itrf2loc(positions[j][0],positions[j][1],positions[j][2],cx,cy,cz)
                x = x0-x1
                y = y0-y1
                z = z0-z1
                elevation = np.arcsin(z / mylengths[i][j]) * 45/np.arctan(1.0) 
                azimuth = 90 - (45/np.arctan(1.0))*np.arctan2(y,x)
                # formula from http://saj.matf.bg.ac.yu/177/pdf/115-124.pdf 
                cosTheta = np.cos(elevation*pi/180.)*np.cos(source_el*pi/180.)*np.cos((azimuth-source_az)*pi/180.) + \
                           np.sin(elevation*pi/180.)*np.sin(source_el*pi/180.)
                mylengths[i][j] *= np.sin(np.arccos(cosTheta))
                if (type(mylengths[i][j]) == np.ndarray):
                    # u.itrf2loc (above) returns arrays of length 1
                    mylengths[i][j] = mylengths[i][j][0]
            if (mylengths[i][j] > maxlength):
                maxlength = mylengths[i][j]
            if (mylengths[i][j] < minlength):
                minlength = mylengths[i][j]
            if (uvrange != ''):
                if (mylengths[i][j] > uvmin and mylengths[i][j] < uvmax):
                    uvrangeBaselines += 1
            l['%s-%s'%(names[i],names[j])] = mylengths[i][j]
            if (length != None):
                if (mylengths[i][j] < length*0.5):
                    neighborlist[i].append(names[j])
        if (length != None):
            if (len(neighborlist[i]) > mostNeighbors):
                mostNeighbors = len(neighborlist[i])
                bestAntenna = i
    if (length == None):
        print "Found %d baselines" % (len(l))
        rmslength = np.sqrt(np.mean(np.array(mylengths).flatten()**2))
        if (projected):
            print "Projected lengths toward the source:  min=%f, max=%f, rms=%f" % (minlength, maxlength, rmslength)
        else:
            print "Unprojected lengths:  min=%f, max=%f, rms=%f" % (minlength, maxlength, rmslength)
        if (uvrange != ''):
            print "%d baselines are within the uvrange %sm" % (uvrangeBaselines,uvrange)
        if (sort):
            sortedBaselines = sorted(l.items(), key=operator.itemgetter(1))
            return(sortedBaselines)
        else:
            return(l)
    elif (rigorous == False):
        return(mostNeighbors,neighborlist[bestAntenna])

    # Now do the rigorous calculation
    maxlengthFullArray = maxlength
    foundSubarray = []
    if (subarraySize == 0):
        dropAntsStart = 1
    else:
        dropAntsStart = nAntennas-subarraySize
    for dropAnts in range(dropAntsStart, nAntennas-2):
        myiterator = itertools.combinations(names, nAntennas-dropAnts)
        ctr = 0
        for subarray in myiterator:
            ctr += 1
        trials = ctr
        notify = trials/100
        print "Testing %d configurations with %d antennas" % (ctr, nAntennas-dropAnts)
        myiterator = itertools.combinations(names, nAntennas-dropAnts)
        minimumMaxlength = maxlengthFullArray
        ctr = 0
        for subarray in myiterator:
            ctr += 1
            nAntennasInSubarray = len(subarray)
            maxlength = 0
            for i in range(nAntennasInSubarray):
                for j in range(i+1,nAntennasInSubarray):
                    ipos = names.index(subarray[i])
                    jpos = names.index(subarray[j])
                    mylength = ((positions[ipos][0]-positions[jpos][0])**2 +
                                (positions[ipos][1]-positions[jpos][1])**2 +
                                (positions[ipos][2]-positions[jpos][2])**2)**0.5
                    if (mylength > maxlength):
                        maxlength = mylength
            if (trials > 10000):
                if (ctr%notify == 0):
                    print "Done %d%%" % (ctr*100/trials)
            if (maxlength < length):
                foundSubarray = subarray
                print "Found a subarray that met the criterion on the %dth try (%.1f%%)" % (ctr,ctr*100.0/trials)
                break
            if (maxlength < minimumMaxlength):
                minimumMaxlength = maxlength
        if (maxlength > length):
            print "   smallest maximum baseline length = %.2fm" % (minimumMaxlength)
        if (foundSubarray != []):
            break
    mostNeighbors = len(foundSubarray)
    return(mostNeighbors,foundSubarray)

def getBaselineLength(msFile='', ant1='', ant2='', help=False, verbose=True) :
    """
    Computes the specified baseline's length in meters.  The antennas
    can be specified by name string or ID number.
    Also compute its percentile length for the configuration.
    For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/GetBaselineLength
    Todd Hunter (June 2011)
    """
    if (help):
        print "Usage example: getBaselineLength(ms, 'DV01', 'DV02')"
        return
    try:
        tb.open(msFile+'/ANTENNA')
    except:
        print "Could not open table = ", msFile+'/ANTENNA'
        return
    if (type(ant1) == str):
        if (len(ant1) < 1):
            print "You must specify two separate antenna names or IDs"
            return
    if (type(ant2) == str):
        if (len(ant2) < 1):
            print "You must specify two separate antenna names or IDs"
            return
    names = tb.getcol('NAME')
    positions = np.transpose(tb.getcol('POSITION'))
    tb.close()
    position = []
    j = 0
    for i in range(len(names)):
        if (isinstance(ant1,str)):
            if (names[i] == ant1):
                position.append(positions[i])
                ant1 = i
                j += 1
        else:
            if (i == ant1):
                position.append(positions[i])
                j += 1
        if (isinstance(ant2,str)):
            if (names[i] == ant2):
                position.append(positions[i])
                ant2 = i
                j += 1
        else:
            if (i == ant2):
                position.append(positions[i])
                j += 1
        if (j==2):
            break
    if (j<2):
        print "Did not find both antennas: %s, %s" % (ant1,ant2)
        print "Found: ", names
        length = 0
        return length
    else:
        length = ((position[0][0]-position[1][0])**2+
                  (position[0][1]-position[1][1])**2+
                  (position[0][2]-position[1][2])**2
                  )**0.5
        if (verbose):
            print "Length of %s-%s (%d-%d) is %.3f m." % (names[ant1],names[ant2],ant1,ant2,length)
    # Now figure out where it ranks in the array
    l = []
    for i in range(len(names)):
      for j in range(i,len(names)):
          if (i != j):
             l.append(((positions[i][0]-positions[j][0])**2 +  (positions[i][1]-positions[j][1])**2 +
                  (positions[i][2]-positions[j][2])**2)**0.5)
    sortedBaselines = np.sort(l)
    nBaselines = len(sortedBaselines)
    for i in range(nBaselines):
#        print sortedBaselines[i]
        if (length <= sortedBaselines[i]):
            if (verbose):
                print "Of %d baselines, this baseline length is percentile %.0f, where 100=longest." % (nBaselines,i*100.0/(nBaselines-1))
            break
    return length,names[ant1],names[ant2]

def freqif(vis, freq) :
    """
    A Castro Carrizo (August 2011)
    Computes the frequency values corresponding to the different freq planes, which is particularly
    useful for the investigation of spurious signals generated in the system
    Sky (GHz)
    IF1 (4-8) or (5-10) depending on band (GHz)
    IF2 (2-4) (GHz)
    IF3 (0-2) (GHz) + channel numbering 
    entries: vis = ms file - if empty, it would read some defaults from script;
                           possible improvement could be that flo1 and flo2 would be given as inputs
             freq = input freq, which could be in sky, if1 or if2 units (always GHz). If empty, it 
                    will give all the details about LOs and spectral configuration.
    If LO4s are introduced in future ASDM datasets to define the position of the spectral unit within
    the IF3 window, this is to be read and included in the script to properly calculate the channel
    numbering
    """
    viss="no"+vis+"ne" 
    freqq="no"+freq+"ne"
    out_of_range=True
    if freqq == 'none' and viss != 'none':  
        tb.open("%s/SPECTRAL_WINDOW" % vis)
        bb = tb.getcol("BBC_NO")           # num unidad
        freq = tb.getcol("REF_FREQUENCY")  # freq cada unidad
        numchan = tb.getcol("NUM_CHAN")    # num channels
        tbw = tb.getcol("TOTAL_BANDWIDTH") # total bandwidth
        tb.close()
        try:
            tb.open("%s/ASDM_RECEIVER" % vis)
        except:
            print "Could not open ASDM_RECEIVER table:"
            print " ' asdm2MS --asis='*' ' may be needed "
            return([])
        numLO = tb.getcol('numLO')  # num of used spectral units
        freqLO = []
        band = []
        spws = []
        names = []
        for i in range(len(numLO)):
            freqLO.append(tb.getcell('freqLO',i))
            band.append(tb.getcell('frequencyBand',i))
            spws.append(int((tb.getcell('spectralWindowId',i).split('_')[1])))
            names.append(tb.getcell('name',i))
        tb.close() 
        print "SPECTRAL_WINDOW ...."
        print "basebands", bb
        print "Sky freqs (ghz)? ", freq/1e9
        print "num chan", numchan
        print "total bw (mhz)", tbw/1e6
        print ""
        print "ASDM_RECEIVER ...."
        print "numLO ", numLO
        for i in range(len(numLO)):
            print "freqLO (ghz)", freqLO[i]/1e9
        print "band", band
        print "spws", spws
        print "names", names
        return([])
 
    paras=float(freq)

    if paras > 12.:
        skyfreq=True
    else:
        skyfreq=False
    
      
    if viss != 'none':              # read spect config from ms file
        tb.open("%s/SPECTRAL_WINDOW" % vis)
        bb = tb.getcol("BBC_NO")           # num unidad
        freq = tb.getcol("REF_FREQUENCY")  # freq cada unidad
        numchan = tb.getcol("NUM_CHAN")    # num channels
        tbw = tb.getcol("TOTAL_BANDWIDTH") # total bandwidth
        tb.close()

        try:
            tb.open("%s/ASDM_RECEIVER" % vis)
        except:
            print " "
            print "Could not open ASDM_RECEIVER table:"
            print " ' asdm2MS --asis='*' ' may be needed "
            return([])
        numLO = tb.getcol('numLO')  # num of used spectral units
        freqLO = []
        band = []
        spws = []
        names = []
        for i in range(len(numLO)):
            freqLO.append(tb.getcell('freqLO',i))
            band.append(tb.getcell('frequencyBand',i))
            spws.append(int((tb.getcell('spectralWindowId',i).split('_')[1])))
            names.append(tb.getcell('name',i))
        tb.close() 
        numbb=(len(numLO)-1)/2
        flo1=freqLO[0]/1e9
        flo2=pb.zeros(numbb)
        flo3=pb.zeros(numbb)
        nchan=pb.zeros(numbb,int)
        c=0
        for i in range(1,len(numLO),2):  #BB_1,3,5,7...
            flo2[c]=freqLO[i][1]/1e9
            flo3[c]=freqLO[i][2]/1e9
            nchan[c]=numchan[i]
            c=c+1

        if1min = 4000.0/1e3          
        kk=band[1]   # a unique band is observed -- TO BE ADAPTED 
        if kk[9]=='6':
            if1min = 5000.0/1e3
        if1max = 8000.0/1e3 
        if kk[9]=='1' or kk[9]=='2' or kk[9]=='9' or kk[9]=='10':
            if1max = 12000.0/1e3
        elif kk[9]=='6':
            if1max = 10000.0/1e3
    else:                          # no ms file to read spect config 
        numbb = 4  # for general use it's worth to adapt this part to be read as input parameters(freq,lo1,lo2s)
        # 
        freq = [1.8342e11, 8.71848362499E10, 8.71848362499E10, 8.73020237499E10, 8.73020237499E10, 9.71848362501E10, 9.71848362501E10, 9.73020237501E10,  9.73020237501E10]
        flo1 = 92.21228               #
        flo1 = 104.26885              #
        flo2 = [9.0274437501,8.9102562501,8.9725562501,9.0897437501] #
        flo2 = [9.02744375,9.052256250,8.97255625,8.94774375]        #
        flo3 = [4.0,4.0,4.0,4.0]      #          
        nchan= [3840,3840,3840,3840]  #
        if1min = 4000.0/1e3           #
        if1max = 8000.0/1e3           #
        tbw = [1.875*1e9,1.875*1e9,1.875*1e9,1.875*1e9,1.875*1e9,1.875*1e9,1.875*1e9,1.875*1e9,1.875*1e9,1.875*1e9]  #
        tbw = [1.171875E8,1.171875E8,1.171875E8,1.171875E8,1.171875E8,1.171875E8,1.171875E8,1.171875E8,1.171875E8]   #

        
    if2min = (2000.+2000.*1/16/2)/1e3     # fix: start 2ghz band
    if2max = (4000.-2000.*1/16/2)/1e3     # fix: end 2ghz band
    if2cen = 3000./1e3
    bandif2 = 2.*15/16

    if3min = (2000.*1/16/2)/1e3           # fix: start 2ghz band  !DG output
    if3max = (2000.-2000.*1/16/2)/1e3     # fix: end 2ghz band    !
    if3cen = 1000./1e3                    #                       !
    
    if2par=pb.zeros(numbb)                #  if2 units (2-4)
    if3par=pb.zeros(numbb)                #  if3 units (0-2)
    # if3par_sbb=pb.zeros(numbb)          #  subbaseband filter number in if3 (?)
    chanpar = pb.zeros(numbb)             #  channel number

    
    for i in range(0,numbb):
        chanpar[i] = -1

    if skyfreq:
        parif1 = [False,False]              # lsb,usb 
        parif2 = [False,False,False,False,False,False,False,False] # should be limited to nunbb
        parif3 = [False,False,False,False,False,False,False,False] # should be limited to nunbb
        if1par=pb.zeros(2)                  # lsb,usb 
        if1par[0] = flo1 - paras            # if parasite in lsb
        if1par[1] = paras - flo1            # if parasite in usb
        # print if1par[0],if1par[1]

        for i in range(0,2):                # lsb,usb  
            if if1par[i] < if1max and if1par[i] > if1min:
                parif1[i] = True 
            # print " if1 = ",if1par[i],parif1[i]
                
        for i in range(0,numbb):
            if freq[(i+1)*2]/1e9 < flo1:    
                if2par[i] = flo2[i] - if1par[0]     # lsb
                #print i,' lsb',(freq[(i+1)*2]/1e9),if2par[i]
            if freq[(i+1)*2]/1e9 > flo1: 
                if2par[i] = flo2[i] - if1par[1]     # usb
                #print i,' usb',(freq[(i+1)*2]/1e9),if2par[i]
            if if2par[i] < if2max and if2par[i] > if2min:
                parif2[i] = True
                
            if3par[i] = flo3[i] - if2par[i]
            if if3par[i] < if3max and if3par[i] > if3min:
                parif3[i] = True
                # if3par_sbb[i] = ((if3par[i]-if3cen)*32./1.875)+(16.)  
                chanpar[i] = ((if3par[i]-if3cen)*nchan[i]/(tbw[(i+1)*2]/1e9)+(nchan[i]+1.)/2)  # valid if units are centered,
                                                                   # here LO4 is to be read once they're not centered anymore 
                # chanpar[i] = ((if3par[i]-if3cen)*nchan[i]/(tbw[(i+1)*2]/1e9)+(nchan[i])/2)   # valid if units are centered
                # print i,if3par[i],if3cen,(if3par[i]-if3cen),nchan[i],tbw[(i+1)*2]/1e9
            # print " if2 = ",i,if2par[i],flo2[i]
            # print " if3 = ",i,if3par[i],flo3[i]
            
    else:
        parif1 = False   
        parif2 = False  
        parif3 = False

        if (paras < 4.0) and (paras > 2.0):
            parif2 = True
        elif (paras > 4.0):
            parif1 = True

        if1par=pb.zeros(numbb)
        fsky_par=pb.zeros(numbb)
    
        if parif2:              # parasite in 2-4ghz bandwidth
            for i in range(0,numbb):
                if2par[i] = paras
                if1par[i] = flo2[i] - if2par[i]
                if3par[i] = flo3[i] - if2par[i]
                # print " parif2",if1par[i],if2par[i],if3par[i]

        if parif1:              # parasite in 4-12ghz bandwidth
            for i in range(0,numbb):
                if1par[i] = paras
                if2par[i] = flo2[i] - if1par[i]
                if3par[i] = flo3[i] - if2par[i]
                # print " parif1",if1par[i],if2par[i],if3par[i]
        
        for i in range(0,numbb):     # channel with parasite
            if if3par[i] > if3min and if3par[i] < if3max:
                # if3par_sbb[i] = ((if3par[i]-if3cen)*32./1.875)+(16.)  
                chanpar[i] = ((if3par[i]-if3cen)*nchan[i]/(tbw[(i+1)*2]/1e9)+(nchan[i]+1.)/2)  # valid if units are centered
                                                                   # here LO4 is to be read once they're not centered anymore 
                # chanpar[i] = ((if3par[i]-if3cen)*nchan[i]/(tbw[(i+1)*2]/1e9)+(nchan[i])/2)   # valid if units are centered
                # print if3par[i],if3cen,(if3par[i]-if3cen),nchan[i],tbw[(i+1)*2]/1e9
                
        for i in range(0,numbb):
            if freq[(i+1)*2]/1e9 < flo1: 
                fsky_par[i] = flo1 - 1*if1par[i]  #lsb
            if freq[(i+1)*2]/1e9 > flo1: 
                fsky_par[i] = flo1 + 1*if1par[i]  #usb
            
            
    # Present results
    # print " "
    # print " Input must be in GHz, either for Sky, LO1 or LO2 frequencies "
    print " "
    print " INPUT frequency at ...", paras, "GHz !!"
    print " "
    print " FLo1 (GHz)   =  %7.3f " %flo1
    print "        LSB=(","%5.3f" %(flo1-if1max),"-","%5.3f" %(flo1-if1min),")GHz  and  USB=(","%5.3f" %(flo1+if1min),"-","%5.3f" %(flo1+if1max),")GHz "
    print " IFLo1    LSB=(","%5.3f" %(if1max),"-","%5.3f" %(if1min),")GHz  and  USB=(","%5.3f" %(if1min),"-","%5.3f" %(if1max),")GHz "
    print " "
    # print "                   BB_1(L)    BB_2(L)    BB_3(U)    BB_4(U)" 
    print " FLo2 (GHz)   =  ", ["%7.3f" %flo2[i] for i in range(0,numbb)]
    print " IFLo2 BB_LSB=(","%5.3f" %(if2min),"-","%5.3f" %(if2max),")GHz  and BB_USB=(","%5.3f" %(if2max),"-","%5.3f" %(if2min),")GHz "
    print " "
    print " FLo3 (GHz)   =  ", ["%7.3f" %flo3[i] for i in range(0,numbb)]
    print " IFLo3 BB_LSB=(","%5.3f" %(if3max),"-","%5.3f" %(if3min),")GHz  and BB_USB=(","%5.3f" %(if3min),"-","%5.3f" %(if3max),")GHz "
    print " "
    print " N_channels   =  ", ["%i" %nchan[i] for i in range(0,numbb)]
    print "   channel width (KHz) = ", ["%7.5f" %((tbw[(i+1)*2]/1e3)/nchan[i]) for i in range(0,numbb)]
    print "     total width (MHz) = ", ["%7.3f" %((tbw[(i+1)*2]/1e6)) for i in range(0,numbb)]
    print " " 
    print " RESULTS:"

    if skyfreq:

        sb=["LSB","USB"]
        for i in range(0,2):
            if parif1[i]:
                print " Equivalent IF1 freq: %10.4f " %(if1par[i]*1000), "MHz in the IF_LO1",sb[i],",   of range (","%5.3f" %if1min,"-","%5.3f" %if1max,") GHz "
            #else:
                #print "         (deduced IF1 freq =%7.3f"  %if1par[i], sb[i],")"
                #  print parif1[i]
                out_of_range=False

        for i in range(0,numbb):
            if parif2[i]:
                print ""
                print " Equivalent IF2 freq: %10.4f " %(if2par[i]*1000), "MHz in the IF_LO2, BB_",(i+1)," of range (","%5.3f" %if2min,"-","%5.3f" %if2max,") GHz "
                out_of_range=False
                if parif3[i]:
                    print "         which is %10.6f " %(if3par[i]*1000), "MHz in the IF_LO3, BB_",(i+1)," of range (","%5.3f" %if3min,"-","%5.3f" %if3max,") GHz "
                    # print " IF_LO3 channel    = ", ["%i" %chanpar[i] for i in range(0,numbb)]
                    print " IF_LO3 channel    = ", ["%7.3f" %chanpar[i] for i in range(0,numbb)]
                    if chanpar[i] > nchan[i] or chanpar[i] < 0:
                        print "     which is out of range for the selected setup... "
                    # print " IF_LO3 SBB filter = ", ["%7.3f" %if3par_sbb[i] for i in range(0,numbb)]

        if out_of_range:
            print " The proposed frequency is out of range..."
            
    else:
        print " Sky freq (GHz) = ", ["%10.6f" %fsky_par[i] for i in range(0,numbb)]," from LSB=(","%5.3f" %(flo1-if1max),"-","%5.3f" %(flo1-if1min),") and USB=(","%5.3f" %(flo1+if1min),"-","%5.3f" %(flo1+if1max),")"
        print " IF_LO1 freq (MHz) = ", ["%10.4f" %(if1par[i]*1000) for i in range(0,numbb)]," of range (","%5.3f" %if1min,"-","%5.3f" %if1max,") GHz "
        print " IF_LO2 freq (MHz) = ", ["%10.4f" %(if2par[i]*1000) for i in range(0,numbb)]," of range (","%5.3f" %if2min,"-","%5.3f" %if2max,") GHz "
        print " IF_LO3 freq (MHz) = ", ["%10.7f" %(if3par[i]*1000) for i in range(0,numbb)]," of range (","%5.3f" %if3min,"-","%5.3f" %if3max,") GHz "

        # print " IF_LO3 channel    = ", ["%i" %chanpar[i] for i in range(0,numbb)]
        print " IF_LO3 channel    = ", ["%7.3f" %chanpar[i] for i in range(0,numbb)] # no integer, have more precision
        if chanpar[i] > nchan[i] or chanpar[i] < 0:
            print "     which is out of range for the selected setup... "
        # print " IF_LO3 SBB filter = ", ["%7.3f" %if3par_sbb[i] for i in range(0,numbb)]

    return

def ComputeDewPointCFromRHAndTempC(relativeHumidity, temperature):
    """
    inputs:  relativeHumidity in percentage, temperature in C
    output: in degrees C
    Uses formula from http://en.wikipedia.org/wiki/Dew_point#Calculating_the_dew_point
    Todd Hunter
    """
    temperature = np.array(temperature)            # protect against it being a list
    relativeHumidity = np.array(relativeHumidity)  # protect against it being a list
    es = 6.112*np.exp(17.67*temperature/(temperature+243.5))
    e = relativeHumidity*0.01*es
    dewPoint = 243.5*np.log(e/6.112)/(17.67-np.log(e/6.112))
    return(dewPoint)

def computeWVP(d):
    """
    This simply converts the specified temperature (in Celsius) to water vapor
    pressure, which can be used to estimate the relative humidity from the
    measured dew point. -- Todd Hunter
    """
    # d is in Celsius
    t = d+273.15
    w = np.exp(-6096.9385/t +21.2409642-(2.711193e-2)*t +(1.673952e-5)*t**2 +2.433502*log(t))
    return(w)


def resizeFonts(adesc,fontsize):
    """
    Todd Hunter
    """
    yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.yaxis.set_major_formatter(yFormat)
    adesc.xaxis.set_major_formatter(yFormat)
    pb.setp(adesc.get_xticklabels(), fontsize=fontsize)
    pb.setp(adesc.get_yticklabels(), fontsize=fontsize)

def estimateALMAOpacity(pwv,reffreq,airmass=1.0,h0=2.0,verbose=True):
   """
   Estimate the zenith opacity at ALMA using J. Pardo's model in casa.
   This function is useful if the weather conditions for your specific
   observation are not available and the average weather conditions must
   be used. -- Todd Hunter
   For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/EstimateOpacity
   """
   P = 563.0
   H = 20.0
   T = 273.0
   altitude = 5059
   midLatitudeWinter = 3
   chansep=1
   numchan=1
   nb = 1
   myqa = createCasaTool(qatool)
   at.initAtmProfile(humidity=H,
                     temperature = create_casa_quantity(myqa, T, "K"),
                     altitude=create_casa_quantity(myqa, altitude,"m"),
                     pressure=create_casa_quantity(myqa, P,'mbar'),
                     atmType = midLatitudeWinter,
                     h0 = create_casa_quantity(myqa, h0,"km")
                     )
   fC = create_casa_quantity(myqa, reffreq,'GHz')
   fR = create_casa_quantity(myqa, chansep,'GHz')
   fW = create_casa_quantity(myqa, numchan*chansep,'GHz')
   at.initSpectralWindow(nb,fC,fW,fR)
   at.setUserWH2O(create_casa_quantity(myqa, pwv,'mm'))
   dry, wet, TebbSkyZenith, rf, cs = getAtmDetails(at)
   if (verbose):
       print "%5.1f GHz tau at zenith = %.3f (dry=%.3f, wet=%.3f)" % (reffreq,dry+wet, dry, wet)
   TebbSky = TebbSkyZenith*(1-np.exp(-airmass*(wet+dry)))/(1-np.exp(-wet-dry))
   hvkT = h*reffreq*1e9/(k*TebbSky)
   J = hvkT / (np.expm1(hvkT))
   TebbSky_Planck = TebbSky*J
   return(airmass*(dry+wet), TebbSky_Planck, TebbSky)
    
def estimateOpacity(pwvmean=1.0,reffreq=230,conditions=None,verbose=True,
                    elevation=90, altitude=5059, P=563, H=20, T=273, Trx=0,
                    etaTelescope=0.75, telescope=None, airmass=0):
   """
   Estimate the opacity at a specified frequency and weather condition at an
   observatory using J. Pardo's ATM in casa.
   Return values:
     If Trx is not specified, then it returns:  [tauZenith, tau]
     If Trx is specified, then it returns:
       [[tauZenith, tau], [transZenith, trans], [TskyZenith, Tsky], [TsysZenith, Tsys]]
   Equation for Tsys:
     (Trx + etaTelescope*T*(1-etaSky) + T*(1-etaTelescope))/(etaTelescope*etaSky)
     where etaSky = atmospheric transmission (as a fraction)
       and etaTelescope = telescope efficiency (as a fraction)
   units: pwv(mm), reffreq(GHz), elevation(deg), altitude(m), pressure(mb), temp(K)
   The default values are nominal conditions at ALMA.  To change them, you may
   either specify the weather and location variables, or use the shortcuts:
    telescope: 'ALMA', 'SMA', 'EVLA'
    conditions: a dictionary containing:
                pressure,solarangle,temperature,humidity,elevation
   For further help, see
   https://safe.nrao.edu/wiki/bin/view/ALMA/EstimateOpacity
   -- Todd Hunter
   """
   # default P,H,T are set to ALMA typical, but should get this from observatory
   if (airmass >= 1.0):
       elevation = math.asin(1./airmass)*180/math.pi
   if (conditions != None):
     if (conditions['pressure'] > 1e-10):
       angle = conditions['solarangle']
       P = conditions['pressure']
       T = conditions['temperature'] + 273.15
       H = conditions['humidity']
       elevation = conditions['elevation']
   elif (telescope != None):
       if (telescope == 'SMA'):
           P = 629.5
           altitude = 4072
           print "Using pressure=%.1fmb, temperature=%.1fK and humidity=%.0f%% at SMA." % (P,T,H)
       elif (telescope.find('VLA')>=0):
           P = 785
           altitude = 2124
           print "Using pressure=%.1fmb, temperature=%.1fK and humidity=%.0f%% at %s." % (P,T,H,telescope)
       elif (telescope != 'ALMA'):
           print "Unrecognized telescope.  Available choices: SMA, ALMA, (E)VLA"
           return
   else:
       if (verbose):
           print "Using pressure=%.1fmb, temperature=%.1fK, humidity=%.0f%%, etaTelescope=%.2f at ALMA." % (P,T,H,etaTelescope)
   midLatitudeWinter = 3
   chansep=1
   numchan=1
   nb = 1
   reffreq = double(reffreq)
   chansep = double(chansep)
   numchan = int(numchan)
   chansep = double(chansep)
   spwid = 0
   myqa = createCasaTool(qatool)
   at.initAtmProfile(humidity=H,
                     temperature=create_casa_quantity(myqa, T,"K"),
                     altitude=create_casa_quantity(myqa, altitude,"m"),
                     pressure=create_casa_quantity(myqa, P,'mbar'),
                     atmType = midLatitudeWinter)
   fC = create_casa_quantity(myqa, reffreq,'GHz')
   fR = create_casa_quantity(myqa, chansep,'GHz')
   fW = create_casa_quantity(myqa, numchan*chansep,'GHz')
   at.initSpectralWindow(nb,fC,fW,fR)
   at.setUserWH2O(create_casa_quantity(myqa, pwvmean,'mm'))
   dry, wet, TebbSkyZenith, rf, cs = getAtmDetails(at)
   transZenith = math.exp(-dry-wet)*100
   if (verbose):
       print "%5.1f GHz tau at zenith= %.3f (dry=%.3f,wet=%.3f), trans=%.1f%%, Tsky=%.2f" % (reffreq,dry+wet, dry, wet,math.exp(-dry-wet)*100, TebbSkyZenith)
   airmass = 1/math.sin(elevation*math.pi/180.)
   TebbSky = TebbSkyZenith * (1-np.exp(-airmass*(wet+dry)))/(1-np.exp(-wet-dry))
   trans = math.exp((-dry-wet)*airmass)*100
   if (verbose and elevation<90):
       print "%5.1f GHz tau toward source (elev=%.1f,airm=%.2f)=%.3f, trans=%.1f%%, Tsky=%.2f" % (reffreq,elevation,airmass,(dry+wet)*airmass,math.exp((-dry-wet)*airmass)*100, TebbSky)
   if (Trx > 0):
       # compute expected Tsys
       etaSkyZenith = math.exp(-(dry+wet))
       TsysZenith = (T*(1/etaSkyZenith-1) + Trx/etaSkyZenith) / etaTelescope
       etaSky = math.exp(-airmass*(dry+wet))
       Tsys = (T*(1/etaSky-1) + Trx/etaSky) / etaTelescope
       if (verbose):
           print "Expected Tsys at zenith = %.1fK,   toward source = %.1fK" % (TsysZenith,Tsys)
       return([[dry+wet, (dry+wet)*airmass], [transZenith,trans], [TebbSkyZenith,TebbSky],
               [TsysZenith,Tsys]])
   else:
       return([dry+wet, (dry+wet)*airmass])

def computeTskyForSPW(vis='', spw=0, pwv=1.0):
   """
   Returns arrays of frequency and Tsky computed for the observation
   - Todd Hunter
   """
   spw = int(spw)
   try:
       tb.open(vis+'/SPECTRAL_WINDOW')
   except:
       print "Could not open ms = %s." % (vis)
       return
   midLatitudeWinter = 3
   T = 270
   altitude = 5056
   P = 563
   H = 20
   numchan = tb.getcell("NUM_CHAN",spw)    # num channels
   chanfreq = tb.getcell("CHAN_FREQ",spw)    # num channels
   if (numchan == 1):
       chansep = 1
   else:
       chansep = (chanfreq[-1] - chanfreq[0]) / (numchan-1)
   numberWindows = 1
   reffreq = chanfreq[0]
   chansep = double(chansep)
   spwid = 0
   myqa = createCasaTool(qatool)
   at.initAtmProfile(humidity=H, temperature=create_casa_quantity(myqa,T,"K"),
                     altitude=create_casa_quantity(myqa,altitude,"m"),
                     pressure=create_casa_quantity(myqa,P,'mbar'),
                     atmType=midLatitudeWinter)
   fC = create_casa_quantity(myqa,reffreq,'Hz')
   fR = create_casa_quantity(myqa,chansep,'Hz')
   fW = create_casa_quantity(myqa,numchan*chansep,'Hz')
   at.initSpectralWindow(numberWindows, fC, fW, fR)
   at.setUserWH2O(create_casa_quantity(myqa,pwv, 'mm'))
   dry, wet, TebbSky, rf, cs = getAtmDetails(at)
   chanfreqGHz = 1e-9 * chanfreq
   return(chanfreqGHz, TebbSky)
    

def readPWVFromMS(vis):
    """
    Reads all the PWV values from a measurement set, returning a list
    of lists:   [[mjdsec], [pwv], [antennaName]]
    - Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    if (os.path.exists("%s/ASDM_CALWVR" % vis)):
        mytb.open("%s/ASDM_CALWVR" % vis)
        time = mytb.getcol('startValidTime')  # mjdsec
        antenna = mytb.getcol('antennaName')
        pwv = mytb.getcol('water')
        mytb.close()
        if (len(pwv) < 1):
            print "The ASDM_CALWVR table is empty, switching to ASDM_CALATMOSPHERE"
            time, antenna, pwv = readPWVFromASDM_CALATMOSPHERE(vis)
    elif (os.path.exists("%s/ASDM_CALATMOSPHERE" % vis)):
        time, antenna, pwv = readPWVFromASDM_CALATMOSPHERE(vis)
    else:
        print "Did not find ASDM_CALWVR nor ASDM_CALATMOSPHERE."
        return[[0],[1],[0]]
    return[time,pwv,antenna]

def readPWVFromASDM_CALATMOSPHERE(vis):
    """
    Reads the PWV via the water column of the ASDM_CALATMOSPHERE table.
    - Todd Hunter
    """
    if (not os.path.exists(vis+'/ASDM_CALATMOSPHERE')):
        if (vis.find('.ms') < 0):
            vis += '.ms'
            if (not os.path.exists(vis)):
                print "Could not find measurement set"
                return
            elif (not os.path.exists(vis+'/ASDM_CALATMOSPHERE')):
                print "Could not find ASDM_CALATMOSPHERE in the measurement set"
                return
        else:
            print "Could not find measurement set"
            return
    mytb = createCasaTool(tbtool)
    mytb.open("%s/ASDM_CALATMOSPHERE" % vis)
    pwvtime = mytb.getcol('startValidTime')  # mjdsec
    antenna = mytb.getcol('antennaName')
    pwv = mytb.getcol('water')[0]  # There seem to be 2 identical entries per row, so take first one.
    mytb.close()
    return(pwvtime, antenna, pwv)
    
def MAD(a, c=0.6745, axis=0):
    """
    Median Absolute Deviation along given axis of an array:

    median(abs(a - median(a))) / c

    c = 0.6745 is the constant to convert from MAD to std; it is used by
    default

    """
    a = np.array(a)
    good = (a==a)
    a = np.asarray(a, np.float64)
    if a.ndim == 1:
        d = np.median(a[good])
        m = np.median(np.fabs(a[good] - d) / c)
#        print  "mad = %f" % (m)
    else:
        d = np.median(a[good], axis=axis)
        # I don't want the array to change so I have to copy it?
        if axis > 0:
            aswp = swapaxes(a[good],0,axis)
        else:
            aswp = a[good]
        m = np.median(np.fabs(aswp - d) / c, axis=0)

    return m

def plotPWV(ms, figfile='', plotrange=[0,0,0,0], clip=True,verbose=False):
  """
  Read and plot the PWV values from the ms via the ASDM_CALWVR table.
  If that table is not found, it reads the ASDM_CALATMOSPHERE table.
  Different antennas are shown in different colored points.
  Arguments:
  ms:  the measurement set
  plotrange: the ranges for the X and Y axes (default=[0,0,0,0] which is autorange)
  clip:  default=True,  True=do not plot outliers beyond 5*MAD from the median.
  figfile: True, False, or a string
           If figfile is not a string, the file created will be <ms>.pwv.png.
  For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/PlotPWV
  -- Todd Hunter
  """
  if (os.path.exists(ms) == False):
      print "Could not find the ms = %s" % (ms)
      return
  if (os.path.exists(ms+'/ASDM_CALWVR') == False and os.path.exists(ms+'/ASDM_CALATMOSPHERE') == False):
      # Confirm that it is ALMA data
      observatory = getObservatoryName(ms)
      if (observatory.find('ALMA') < 0 and observatory.find('ACA')<0):
          print "Either this is not a measurement set, or this is not ALMA data and "
          print "this telescope (%s) does not appear to have WVR data." % (observatory)
      else:
          print "Could not find %s/ASDM_CALWVR nor ASDM_CALATMOSPHERE.  Did you importasdm(asis='*')?" % (ms)
          print "You could also try: plotPWVFromASDM(your_asdm)"
      return
  try:
      [watertime,water,antennaName] = readPWVFromMS(ms)
#      print "Found %d measurements" % (len(water))
  except:
      print "Could not open %s/ASDM_CALWVR nor ASDM_CALATMOSPHERE.  Did you importasdm(asis='*')?" % (ms)
      print "You could also try: plotPWVFromASDM(your_asdm)"
      return
  pb.clf()
  adesc = subplot(111)
  ms = ms.split('/')[-1]
#  watertime = np.array(watertime)/86400.   
#  offset = int(floor(watertime[0]))
#  watertime -= offset
  water = np.array(water)*1000
  if (clip):
      mad = MAD(water)
      median = np.median(water)
      if (verbose):
          print "MAD = %e, median = %e" % (mad, median)
      if (mad <= 0):
          matches = range(len(water))
      else:
          matches = np.where(abs(water - median) < 5*mad)[0]
          nonmatches = np.where(abs(water - median) >= 5*mad)[0]
          print "Dropped %d/%d points (with median=%fmm) because they appear to be 5sigma outliers" % (len(water)-len(matches), len(water), np.median(water[nonmatches]))
      water = water[matches]
      watertime = watertime[matches]
      antennaName = antennaName[matches]
  uniqueAntennas = np.unique(antennaName)
  pb.hold(True)
  list_of_date_times = mjdSecondsListToDateTime(watertime)
  timeplot = pb.date2num(list_of_date_times)
  for a in range(len(uniqueAntennas)):
      matches = np.where(uniqueAntennas[a] == np.array(antennaName))[0]
      pb.plot_date(timeplot[matches], water[matches], '.', color=overlayColors[a])
#      pb.plot(watertime[matches], water[matches], '.', color=overlayColors[a])
  if (verbose):
      print "len(matches) = %d" % (len(matches))
  # now sort to average duplicate timestamps to one value, then fit spline
  indices = np.argsort(watertime)
  watertime = watertime[indices]
  water = water[indices]
  newwater = []
  newtime = []
  for w in range(len(water)):
      if (watertime[w] not in newtime):
          matches = np.where(watertime[w] == watertime)[0]
          newwater.append(np.median(water[matches]))
          newtime.append(watertime[w])
  watertime = newtime
  water = newwater
  regularTime = np.linspace(watertime[0], watertime[-1], len(watertime))
  ius = splrep(watertime, water,s=len(watertime)-sqrt(2*len(watertime)))
  water = splev(regularTime, ius, der=0)
  list_of_date_times = mjdSecondsListToDateTime(regularTime)
  timeplot = pb.date2num(list_of_date_times)
#  pb.plot(regularTime,water,'k-')
  pb.plot_date(timeplot,water,'k-')
  print "Median value at zenith = %.3f mm" % (np.median(water))
  if (plotrange[0] != 0 or plotrange[1] != 0):
      pb.xlim([plotrange[0],plotrange[1]])
  if (plotrange[2] != 0 or plotrange[3] != 0):
      pb.ylim([plotrange[2],plotrange[3]])
  xlim = pb.xlim()
  ylim = pb.ylim()
  xrange = xlim[1]-xlim[0]
  yrange = ylim[1]-ylim[0]
  for a in range(len(uniqueAntennas)):
      pb.text(xlim[1]+0.01*xrange, ylim[1]-0.024*yrange*(a-2), 
              uniqueAntennas[a], color=overlayColors[a], size=8)
  pb.xlabel('Universal Time (%s)' % (plotbp3.utdatestring(watertime[0])))
  pb.ylabel('PWV (mm)')
  adesc.xaxis.grid(True,which='major')
  adesc.yaxis.grid(True,which='major')
  pb.title(ms)
  adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
  adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
  adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
  adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
  RescaleXAxisTimeTicks(pb.xlim(), adesc)
  autoFigureName = "%s.pwv.png" % (ms)
  pb.draw()
  if (figfile==True):
      pb.savefig(autoFigureName)
      print "Wrote file = %s" % (autoFigureName)
  elif (len(figfile)>0):
      pb.savefig(figfile)
      print "Wrote file = %s" % (figfile)
  else:
      print "To create a png file, rerun with either:"
      print "  plotPWV(%s,figfile=True) to produce the automatic name=%s" % (ms,autoFigureName)
      print "  plotPWV('%s',figfile='myname.png')" % (ms)

def getSB(vis):
    """
    Gets the UID of the schedule block for a measurement set
    """
    mytb = createCasaTool(tbtool)
    if (os.path.exists(vis+'/OBSERVATION') == False):
        print "Could not open OBSERVATION able for this ms"
        return
    sched = 'unknown'
    sbname = 'unknown'
    mytb.open(vis+'/OBSERVATION')
    if ('SCHEDULE' in mytb.colnames()):
        if (tb.iscelldefined('SCHEDULE',0)):
            sched = mytb.getcol('SCHEDULE')
            sbname = '%s' % (sched[0][0].split()[1])  # This is the SB UID.
    mytb.close()
    return(sbname)
    
def getSBGainFromASDM(asdm=''):
    """
    This function reads the CalAtmosphere.xml table from the ASDM and returns a
    dictionary.
    -Todd Hunter
    """
    if (os.path.exists(asdm) == False):
        print "getSBGainFromASDM(): Could not find file = ", asdm
        return
    sdmfile = asdm
    xmlscans = minidom.parse(sdmfile+'/CalAtmosphere.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    for rownode in rowlist:
        myrow = rownode.getElementsByTagName("syscalType")
        mytype = myrow[0].childNodes[0].nodeValue
        if (mytype == 'SIDEBAND_RATIO'):
            rowSBGain = rownode.getElementsByTagName("sbGain")
            sbGain = []
            tokens = rowSBGain[0].childNodes[0].nodeValue.split()
            gains = []
            for i in range(int(tokens[1])):
                gains.append(float(tokens[i+2]))
            sbGain = gains
            scandict[fid] = {}

            # start and end times in mjd ns
            rowstart = rownode.getElementsByTagName("startValidTime")
            start = int(rowstart[0].childNodes[0].nodeValue)
            startmjd = float(start)*1.0E-9/86400.0
            t = qa.quantity(startmjd,'d')
            starttime = call_qa_time(t,form="ymd",prec=8)
            rowend = rownode.getElementsByTagName("endValidTime")
            end = int(rowend[0].childNodes[0].nodeValue)
            endmjd = float(end)*1.0E-9/86400.0
            t = qa.quantity(endmjd,'d')
            endtime = call_qa_time(t,form="ymd",prec=8)
            # antenna
            rowantenna = rownode.getElementsByTagName("antennaName")
            antenna = str(rowantenna[0].childNodes[0].nodeValue)
            # baseband
            rowbaseband = rownode.getElementsByTagName("basebandName")
            baseband = int(rowbaseband[0].childNodes[0].nodeValue.split('_')[1])
            # scan
            rowCalDataId = rownode.getElementsByTagName("calDataId")
            calDataId = str(rowCalDataId[0].childNodes[0].nodeValue)
            scan = int(calDataId.split('_')[1])
            rowCalDataId = rownode.getElementsByTagName("receiverBand")
            receiverBand = int(rowCalDataId[0].childNodes[0].nodeValue.split('_')[2])

            scandict[fid]['start'] = starttime
            scandict[fid]['end'] = endtime
            scandict[fid]['startmjd'] = startmjd
            scandict[fid]['endmjd'] = endmjd
            scandict[fid]['startmjdsec'] = startmjd*86400
            scandict[fid]['endmjdsec'] = endmjd*86400
            timestr = starttime+'~'+endtime
            scandict[fid]['timerange'] = timestr
            scandict[fid]['antenna'] = antenna
            scandict[fid]['baseband'] = baseband
            scandict[fid]['scan'] = scan
            scandict[fid]['sbGain'] = sbGain
            scandict[fid]['receiverBand'] = receiverBand
            scandict[fid]['duration'] = (endmjd-startmjd)*86400
            fid += 1

    print 'getSBGainFromASDM(): Found ',rowlist.length,' rows in CalAtmosphere.xml'
    if (rowlist.length == 0):
        print "This table is now in binary format. You need to importasdm(asis='CalAtmosphere') and run au.plotSBGain()"

    # return the dictionary for later use
    return scandict
    
    
def plotSBGainFromASDM(asdm='', pol='', figfile='', verbose=False,antenna='',
                       baseband='', doplot=True, threshold=None, 
                       SBR_THRESHOLD_2SB=0.80, SBR_THRESHOLD_DSB=0.25):
    """
    Plots the sideband gain ratio values from the SIDEBAND_RATIO entries in
    the CalAtmosphere.xml table for the specified ASDM.
    pol: 'X', 'Y', or ''=both,  only plot this polarization
    figfile: name of png file to save, default = asdm + '.sbgain.png'
    verbose: print all values of sbGain
       antenna: restrict the verbose printing to one specified antenna name
       baseband: restrict the verbose printing to one specified baseband number (1..4)
    -Todd Hunter
    """
    if (os.path.exists(asdm) == False):
        print "Could not find ASDM = ", asdm
        return
    scandict = getSBGainFromASDM(asdm)
    if (verbose):
        print "len(scandict) = %d" % (len(scandict))
    suspect = ''
    if (len(scandict) < 1):
        return('', suspect)
    sbGains = []
    sbGainsX = []
    sbGainsY = []
    scans = []
    antennas = []
    receiverBands = []
    basebands = []
    mjdsec = []
    for sd in scandict:
        s = scandict[sd]
        sbGainsX.append(s['sbGain'][0])
        if (len(s['sbGain']) > 1):
            sbGainsY.append(s['sbGain'][1])
        scans.append(s['scan'])
        antennas.append(s['antenna'])
        receiverBands.append(s['receiverBand'])
        basebands.append(s['baseband'])
#        mjdsec.append((s['startmjdsec']+s['endmjdsec'])*0.5)
#   The end time is often set to be way in the future (30 days).
        mjdsec.append(s['startmjdsec'])
        if (verbose):
            if (antenna == '' or antenna == s['antenna']):
                if (baseband == '' or baseband == s['baseband']):
                    print "ant=%s, scan=%d, rx=%d, baseband=%d, s['sbGain'] = " % (s['antenna'],
                           s['scan'], s['receiverBand'], s['baseband']), s['sbGain']
    sbGains = [sbGainsX]
    if (len(sbGainsY) > 0):               
        sbGains.append(sbGainsY)
    sbrscans=scans
    figfile, suspect, valuesAreDefault = plotSBGainFromData(asdm, sbGains, antennas, receiverBands, basebands, 
                                          mjdsec, scans, pol, figfile, verbose, antenna,
                                          baseband, doplot, threshold, sbrscans, SBR_THRESHOLD_2SB,
                                          SBR_THRESHOLD_DSB)    
    return(figfile, suspect, valuesAreDefault)

def getCalAtmosphereInfo(vis, pol='', antenna='', baseband='', scan = '', receiverBand='',
                         debug=False, tol=10, altscan=None, calscandict=None, favorSBgain=False):
    """
    Reads the sideband gain ratio and other useful values from the ASDM_CALATMOSPHERE
    file of a measurement set.  Returns 12 arrays:
       sideband gain, antenna name, receiver band number, baseband number,
       time (in MJD seconds), scan number, pwv, groundPressure, groundTemperature,
       groundRelHumidity, myIndex, sbrscans

    Returns either all of the rows, or only those
    rows which match the input parameters:
    antenna: must be the string name (e.g. 'DA41')
    scan: a single scan number (as string or integer)
    baseband: a single baseband number (as string or integer)
    receiverBand: a single receiver band number (as string or integer)
    pol: '0', 'X', '1', 'Y' or ''=both
    tol: tolerance in seconds to pass to buildCalDataIdDictionary (should not have to change this)
    calscandict: optional dictionary (to avoid having to call buildCalDataIdDictionary)
    -- Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not find MS"
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' in mymsmd.intents()):
        calscans = mymsmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
    else:
        calscans = []
    if ('CALIBRATE_SIDEBAND_RATIO#ON_SOURCE' in mymsmd.intents()):
        sbrscans = mymsmd.scansforintent('CALIBRATE_SIDEBAND_RATIO#ON_SOURCE')
    else:
        sbrscans = []
    print "atmcal scans = %s,  sbrcal scans = %s" % (str(calscans), str(sbrscans))
    calscans = np.union1d(calscans,sbrscans)
    if (len(calscans) < 1):
        print "No atmcal or sideband ratio scans in this dataset"
        return
    mymsmd.close()
    mytable = vis+'/ASDM_CALATMOSPHERE'
    if (os.path.exists(mytable) == False):
        print "Could not find table = %s" % (mytable)
        print "Did you importasdm with asis='CalAtmosphere' ?"
        return(None)
    mytb = createCasaTool(tbtool)
    mytb.open(mytable)
    pwv = mytb.getcol('water') * 1000
    groundPressure = mytb.getcol('groundPressure') * 0.01  # convert Pascals to mbar
    groundTemperature = mytb.getcol('groundTemperature')
    groundRelHumidity = mytb.getcol('groundRelHumidity')
    antennas = mytb.getcol('antennaName')
    startValidTime = mytb.getcol('startValidTime')
    mjdsec = mytb.getcol('startValidTime')
    calDataId = np.array([int(c.split('_')[-1]) for c in mytb.getcol('calDataId')])
    basebands = np.array([int(c.split('_')[-1]) for c in mytb.getcol('basebandName')])
    receiverBands = np.array([int(c.split('_')[-1]) for c in mytb.getcol('receiverBand')])
    if (calscandict == None):
        if (debug):
            print "getCalAtmosphereInfo(): Calling buildCalDataIdDictionary"
        if (favorSBgain):
            calscandict = buildCalDataIdDictionary(vis, tol, debug=debug, atm=False)
        else:
            calscandict = buildCalDataIdDictionary(vis, tol, debug=debug)
    if (calscandict == {}):
        print "The dictionary returned by buildCalDataIdDictionary is blank!"
        return(None)
    if (antenna != '' and antenna != None):
        if (antenna not in antennas):
            print "Antenna %s is not in this dataset (available antennas = %s)" % (antenna, str(np.unique(antennas)))
            return(None)
    if (scan != '' and scan != None):
        if (int(scan) not in calscans):
            print "Scan %s is not a cal scan in this dataset (available scans = %s)" % (scan, str(np.unique(calscans)))
            return(None)
    if (baseband != '' and baseband != None):
        if (int(baseband) not in basebands):
            print "Baseband %s is not in this dataset (available basebands= %s)" % (baseband, str(np.unique(basebands)))
            return(None)
    if (receiverBand != '' and receiverBand != None):
        if (int(receiverBand) not in receiverBands):
            print "Band %s is not in this dataset (available bands= %s)" % (receiverBand, str(np.unique(receiverBands)))
            return(None)
        
    sbGains = mytb.getcol('sbGain')
    if (debug): print "getSBGain: initial shape sbGains = %s" % (str(np.shape(sbGains)))
    mytb.close()
    calDataIdIndex = range(len(calDataId))
    antennaIndex = range(len(antennas))
    basebandIndex = range(len(basebands))
    receiverBandIndex = range(len(receiverBands))
    scanIndex = []
    scans = []
    for row in range(len(calDataId)):
        cDI = calDataId[row]
        if (cDI not in calscandict.keys()):
#            print "calDataId_%d is not in the dictionary: %s" % (cDI, str(calscandict))
            scans.append(None)
            continue
        if (len(calscandict[cDI]) > 0):
            scans.append(calscandict[cDI][0])
            if (debug):
                print "scan=%s, calscandict[%d]=%s" % (str(scan), cDI, str(calscandict[cDI]))
            # Here I need to guard against more than one scan being associated with a calDataId
            # take the final one (usually ATMCal)
            if (favorSBgain):
                if ([calscandict[cDI][0]] == [scan] or scan=='' or scan==None or
                    [calscandict[cDI][0]] == [altscan]):
                    scanIndex.append(row)
            else:
                if ([calscandict[cDI][-1]] == [scan] or scan=='' or scan==None or
                    [calscandict[cDI][-1]] == [altscan]):
                    scanIndex.append(row)
        elif (debug):
            print "calscandict[%d] = %s" % (cDI, str(calscandict[cDI]))
            
    if (debug):
        print "calscandict=", calscandict
        print "scanIndex=", scanIndex
        print "len(scanIndex)=",len(scanIndex)
    scans = np.array(scans)   # has an entry for every row
    scanIndex = np.array(scanIndex)  # only has entries for each row that matches the selected scan
    if (antenna != '' and antenna != None):
        antennaIndex = np.where(antennas == antenna)[0]
    if (baseband != '' and baseband != None):
        basebandIndex = np.where(basebands == int(baseband))[0]
    if (receiverBand != '' and receiverBand != None):
        receiverBandIndex = np.where(receiverBands == int(receiverBand))[0]
    myIndex = np.intersect1d(scanIndex, antennaIndex)
    myIndex = np.intersect1d(myIndex, basebandIndex)
    myIndex = np.intersect1d(myIndex, receiverBandIndex)
    if (len(myIndex) < 1):
        print "No rows found in the ASDM_CALATMOSPHERE table for this scan/antenna. Use altscan parameter."
        return(None)
    sbGains = sbGains[:,myIndex]
    xpol = ['X','x','0',0]
    ypol = ['Y','y','1',1]
    if (pol in xpol):
        if (debug): print "getSBGain: returning only X pol"
        sbGains = sbGains[0,:]
    elif (pol in ypol):
        if (debug): print "getSBGain: returning only Y pol"
        sbGains = sbGains[1,:]
    elif (pol not in ['X,Y','Y,X','x,y','y,x','','0,1','1,0']):
        print "Unrecognized polarization option: %s" % (pol)
        return(None)
    if (debug):
        print "getSBGain: final shape(sbGains) = ", np.shape(sbGains)
        print "lengths:  myindex=%d, mjdsec=%d, scans=%d, pwv=%d, groundPressure=%d" % (len(myIndex), len(mjdsec), len(scans), len(pwv[0]), len(groundPressure))
        print "lengths: antennas=%d, receiverBands=%d, basebands=%d, groundTemperature=%d, groundRelHumidity=%d" % (len(antennas),len(receiverBands),len(basebands),len(groundTemperature),len(groundRelHumidity))
    return(sbGains, antennas[myIndex], receiverBands[myIndex], basebands[myIndex],
           mjdsec[myIndex], scans[myIndex], pwv[0,myIndex], groundPressure[myIndex],
           groundTemperature[myIndex], groundRelHumidity[myIndex], myIndex, sbrscans)
    # end getCalAtmosphereInfo()

def plotSBGainForDatasets(vislist=[], pol='', figfile='', verbose=False,antenna='',
               baseband='', doplot=True, threshold=None, 
               SBR_THRESHOLD_2SB=0.80, SBR_THRESHOLD_DSB=0.25, scan=''):
    """
    Calls plotSBGain for a list of datasets.
    -Todd Hunter
    """
    if (type(vislist) == str):
        outfile = vislist+'.plotSBGainForDatasets.txt'
        vislist = getListOfFilesFromFile(vislist, appendms=True)
    else:
        outfile = 'plotSBGainForDatasets.txt'
    figfiles = []
    f = open(outfile,'w')
    for vis in vislist:
        figfile = ''
        figfile,suspect,suspectDict,valuesAreDefault = plotSBGain(vis,pol,figfile,verbose,antenna,
                                                                  baseband,doplot,threshold,
                                                                  SBR_THRESHOLD_2SB,
                                                                  SBR_THRESHOLD_DSB, scan)
        figfiles.append(figfile)
        f.write('%s   %s\nsuspect values = %s\nvaluesAreDefault=%s\n\n' % (vis,getObservationStartDate(vis),
                                                                           str(suspectDict),str(valuesAreDefault)))
    pdfname = outfile + '.pdf'
    f.close()
    print "Left results in %s" % (outfile)
    buildPdfFromPngs(figfiles, pdfname=pdfname)
    return(pdfname)

def plotSBGain(vis, pol='', figfile='', verbose=False,antenna='',
               baseband='', doplot=True, threshold=None, 
               SBR_THRESHOLD_2SB=0.80, SBR_THRESHOLD_DSB=0.25, scan='',
               perscan=False, interactive=False, tol=10):
    """
    Plots the sideband gain ratio values from the SIDEBAND_RATIO entries in
    the ASDM_CALATMOSPHERE table for the specified measurement set
    pol: 'X', 'Y', or ''=both,  only plot this polarization
    figfile: name of png file to save, default = vis + '.sbgain.png'
    verbose: print all values of sbGain
    antenna: restrict the verbose printing to one specified antenna name
    baseband: restrict the verbose printing to one specified baseband number (1..4)
    scan: restrict the plot and verbose printing to one specified scan number
    perscan: make an individual plot for scan (under development)
    
    Returns:
    1) the name of the png file produced
    2) an html string suitable for analyzemscal's pipeline result
    3) a dictionary of suspect values keyed by antenna name, baseband number (1-4), and polarization (0,1)
    4) a Boolean indicating if the values are simply the default values
    
    -Todd Hunter
    """
    if (scan != '' and type(scan) == str):
        scan = int(scan)
    favorSBgain = True
    result = getCalAtmosphereInfo(vis, scan=scan, antenna=antenna, baseband=baseband,
                                  debug=verbose, favorSBgain=favorSBgain, tol=tol)
    if (result == None):
        favorSBgain = False
        result = getCalAtmosphereInfo(vis, scan=scan, antenna=antenna, baseband=baseband,
                                      debug=verbose, favorSBgain=favorSBgain, tol=tol)
        if (result == None):
            print "Aborting plotSBGain"
            return
    sbGains, antennas, receiverBands, basebands, mjdsec, scans, pwv, groundPressure, groundTemperature, groundRelHumidity, index, sbrscans = result
    if (perscan):
        scansToPlot = sbrscans
    else:
        scansToPlot = [scan]
    if (verbose):
        print "plotSBGain: shape(sbGains) = ", np.shape(sbGains)
    lo1 = None
    lo2 = None
    figfiles = []
    for scan in scansToPlot:
      if (scan != ''):
          mymsmd = createCasaTool(msmdtool)
          mymsmd.open(vis)
          spws = mymsmd.spwsforscan(scan)
          spwsforbaseband = {}
          for bb in range(1,5):
              if (casadef.subversion_revision >= casaRevisionWithAlmaspws):
                  tdmspws = mymsmd.almaspws(tdm=True)
              else:
                  tdmspws = mymsmd.tdmspws()
              spwsforbaseband[bb] = np.intersect1d(spws,np.intersect1d(getSpwsForBaseband(mymsmd,bb),tdmspws))
          mymsmd.close()
          lo1info, lo2info = interpretLOs(vis,alsoReturnLO2=True)
          lo1 = 0
          lo2 = {}
          for bb in spwsforbaseband.keys():
              if (len(spwsforbaseband[bb]) > 0):
                  if (spwsforbaseband[bb][0] not in lo1info.keys()):
                      print "spw %d not in lo1info.keys() = %s" % (spwsforbaseband[bb][0], str(lo1info.keys()))
                      lo2[bb] = {'frequency':0, 'spw': spwsforbaseband[bb][0]}
                  else:
                      lo1 = lo1info[spwsforbaseband[bb][0]]
                      lo2[bb] = {'frequency':lo2info[spwsforbaseband[bb][0]], 'spw': spwsforbaseband[bb][0]}
                      print "Got LO1=%.3f,LO2=%.3f for bb=%d, spw=%d" % (lo1*1e-9,lo2[bb]['frequency']*1e-9, bb, spwsforbaseband[bb][0])
      result = getCalAtmosphereInfo(vis, scan=scan, antenna=antenna, baseband=baseband,
                                    debug=verbose, favorSBgain=favorSBgain)
      sbGains, antennas, receiverBands, basebands, mjdsec, scans, pwv, groundPressure, groundTemperature, groundRelHumidity, index, sbrscans = result
      sbrscans = []
      for i in range(len(scans)):
        if (antenna == '' or antenna == antennas[i]):
            if (baseband == '' or baseband == basebands[i]):
                if (scan == '' or scan == scans[i]):
                    sbrscans.append(scans[i])
                    if (verbose):
                        print "ant=%s, scan=%d, rx=%d, baseband=%d, sbGain[pol 0] = " % (antennas[i],
                                    scans[i], receiverBands[i], basebands[i]), sbGains[0][i]
      sbrscans = np.unique(sbrscans)
      if (favorSBgain):
          print "plotting sbrscans=", sbrscans
      else:
          print "WARNING: plotting scans=%s, which may not be sideband ratio scans" % (str(sbrscans))
      myfigfile = figfile
      if (perscan):
          if (figfile == '' or figfile == True):
              myfigfile = vis + '.scan%02d.sbgain.png' % (scan)
      myfigfile, suspect, suspectDict, valuesAreDefault = plotSBGainFromData(vis, sbGains, antennas,
                                                                           receiverBands, basebands, 
                                          mjdsec, scans, pol, myfigfile, verbose, antenna,
                                          baseband, doplot, threshold, sbrscans, SBR_THRESHOLD_2SB,
                                          SBR_THRESHOLD_DSB, lo1=lo1, lo2=lo2)
      figfiles.append(myfigfile)
      if (interactive):
          myinput = raw_input("Press return for next page (q to quit): ")
          if (myinput == 'q'): break
    if (len(figfiles) > 1 and doplot):
        if (figfile == '' or figfile==True):
            pdfname = vis + '.sbgain.pdf'
        else:
            pdfname = figfile+'.pdf'
        buildPdfFromPngs(figfiles, pdfname=pdfname)
    return(figfile, suspect, suspectDict, valuesAreDefault)

def plotSBGainFromData(sourceFile, sbGains, antennas, receiverBands, basebands, mjdsec, 
                       caldataids, pol, figfile, verbose, antenna, baseband, doplot, threshold, sbrscans,
                       SBR_THRESHOLD_2SB=0.80, SBR_THRESHOLD_DSB=0.25, lo1=None, lo2=None):
    """
    Returns four things:
    1) name of the png produced
    2) an html string suitable for analyzemscal's pipeline result
    3) a dictionary of suspect values keyed by antenna name, baseband number (1-4), and polarization (0,1)
    4) a Boolean indicating if the values are all the default
    """
    suspect = ''
    sbGainsX = sbGains[0]
#    print "plotSBGainFromData: type(sbGainsX)=%s, shape=%s" % (type(sbGainsX), np.shape(sbGainsX))
    sbGainsXdB = 10*np.log10(1-sbGainsX)
    if (len(sbGains) > 1):
        sbGainsY = np.array(sbGains[1])
        sbGainsYdB = 10*np.log10(1-sbGainsY)
    uniqueAntennaNames = list(np.unique(antennas))
    uniqueAntennaNumbers = range(len(uniqueAntennaNames))
    antennaNumbers = []
    for antennaName in antennas:
        antennaNumbers.append(uniqueAntennaNames.index(antennaName))
    if (verbose):
        print "len(sbGainsX) = %d" % (len(sbGainsX))
    matches = np.where(sbGainsX > 0.01)[0]  # avoid apparently bogus scans
    if (verbose):
        print "len(matches) = %d" % (len(matches))
    signal_gain, image_gain = defaultSBGainsForBand(receiverBands[0])
    valuesAreDefault = False
    if (pol in ['','X','x','0',0]):
        if (fabs(signal_gain-np.median(sbGainsX[matches]))<0.0001
            and fabs(signal_gain-np.min(sbGainsX[matches]))<0.0001
            and fabs(signal_gain-np.max(sbGainsX[matches]))<0.0001):
            valuesAreDefault = True
        print "Median  for Pol X = %f/%f = %f dB" % (np.median(sbGainsX[matches]),
                                                     1-np.median(sbGainsX[matches]),
                                        10*np.log10(1-np.median(sbGainsX[matches])))
        print "Minimum for Pol X = %f/%f = %f dB" % (np.min(sbGainsX[matches]),
                                                     1-np.min(sbGainsX[matches]),
                                             10*np.log10(1-np.min(sbGainsX[matches])))
        print "Maximum for Pol X = %f/%f = %f dB" % (np.max(sbGainsX[matches]),
                                                     1-np.max(sbGainsX[matches]),
                                                 10*np.log10(1-np.max(sbGainsX[matches])))
    if (pol in ['','Y','y','1',1]):
        if (signal_gain == np.median(sbGainsY[matches])):
            valuesAreDefault = True
        print "Median  for Pol Y = %f/%f = %f dB" % (np.median(sbGainsY[matches]),
                                                    1-np.median(sbGainsY[matches]),
                                             10*np.log10(1-np.median(sbGainsY[matches])))
        print "Minimum for Pol Y = %f/%f = %f dB" % (np.min(sbGainsY[matches]),
                                                     1-np.min(sbGainsY[matches]),
                                             10*np.log10(1-np.min(sbGainsY[matches])))
        print "Maximum for Pol Y = %f/%f = %f dB" % (np.max(sbGainsY[matches]),
                                                     1-np.max(sbGainsY[matches]),
                                            10*np.log10(1-np.max(sbGainsY[matches])))

    if (threshold == None):
        mythreshold = SBR_THRESHOLD_2SB
    else:
        mythreshold = threshold
    matches = np.where(sbGainsX < mythreshold)[0]
    if (len(matches) > 0):
        # Check if this is a DSB receiver
        if (receiverBands[0] >= 9 and threshold==None):
            mythreshold = 0.25
            matches = np.where(sbGainsX < mythreshold)[0]
    suspectDict = {}
    for i in matches:
        next_suspect = "Suspect value=%f for pol X, ant=%s, calDataId=%d, rx=%d, baseband=%d" % (sbGainsX[i], antennas[i],
                    caldataids[i], receiverBands[i], basebands[i])
        if (antennas[i] not in suspectDict.keys()):
            suspectDict[antennas[i]] = {}
        if (basebands[i] not in suspectDict[antennas[i]].keys()):
            suspectDict[antennas[i]][basebands[i]] = {}
        if (0 not in suspectDict[antennas[i]][basebands[i]].keys()):
            suspectDict[antennas[i]][basebands[i]][0] = sbGainsX[i]
        print next_suspect
        suspect += next_suspect + "<br>"
    matches = np.where(sbGainsY < mythreshold)[0]
    for i in matches:
        next_suspect = "Suspect value=%f for pol Y, ant=%s, calDataId=%d, rx=%d, baseband=%d" % (sbGainsY[i], antennas[i],
                    caldataids[i], receiverBands[i], basebands[i]) 
        if (antennas[i] not in suspectDict.keys()):
            suspectDict[antennas[i]] = {}
        if (basebands[i] not in suspectDict[antennas[i]].keys()):
            suspectDict[antennas[i]][basebands[i]] = {}
        if (1 not in suspectDict[antennas[i]][basebands[i]].keys()):
            suspectDict[antennas[i]][basebands[i]][1] = sbGainsY[i]
        print next_suspect
        suspect += next_suspect + "<br>"
    if (figfile==True):
        doplot = True
        figfile = ''
    if (doplot==False):
        figfile = ''
    else:
        pb.clf()
        list_of_date_times = mjdSecondsListToDateTime(mjdsec)
        timeplot = pb.date2num(list_of_date_times)
        adesc = pb.subplot(211)
        pb.hold(True)
        c = ['k','r','g','c']
        xpol = ['','X','x','X,Y','Y,X','x,y','y,x','0',0]
        ypol = ['','Y','y','X,Y','Y,X','x,y','y,x','1',1]
        for a in range(len(antennaNumbers)):
            if (pol in xpol):
                pb.plot(antennaNumbers[a], sbGainsX[a], 'o', color=c[basebands[a]-1])
            if (pol in ypol):
                pb.plot(antennaNumbers[a], sbGainsY[a], '+', color=c[basebands[a]-1], linewidth=2)
        x0,x1 = pb.xlim()
        y0,y1 = pb.ylim()
        yrange = y1-y0
        pb.xlim([-0.9,x1+0.9])
        pb.ylim([y0-0.2*yrange,y1+yrange*0.05])
        y0,y1 = pb.ylim()
        yrange = y1-y0
        pb.plot(pb.xlim(),[signal_gain,signal_gain],'k--')
        for a in range(len(uniqueAntennaNames)):
            pb.text(a, y0+0.09*yrange, uniqueAntennaNames[a], size=8, rotation='vertical')
        bbs = np.unique(basebands)
        pb.ylabel("Sideband gain ratio (sbGain)")
        uniqueScans = np.unique(sbrscans)
        scanstring = 'scans=%s' % (str(sbrscans))
        pb.title('Band %d %s %s (%d=%s)' % (receiverBands[0],os.path.basename(sourceFile),scanstring,uniqueScans[0],plotbp3.utstring(mjdsec[0],3)), size=12)
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        majorLocator = MultipleLocator(1)
        adesc.xaxis.set_major_locator(majorLocator)

        adesc = pb.subplot(212)
        for a in range(len(antennaNumbers)):
            if (pol in xpol):
                pb.plot(antennaNumbers[a], sbGainsXdB[a], 'o', color=c[basebands[a]-1])
            if (pol in ypol):
                pb.plot(antennaNumbers[a], sbGainsYdB[a], '+', color=c[basebands[a]-1], linewidth=2)
        pb.xlabel('Antenna')
        x0,x1 = pb.xlim()
        y0,y1 = pb.ylim()
        yrange = y1-y0
        pb.xlim([-0.9,x1+0.9])
        pb.ylim([y0-0.2*yrange,y1+1])
        y0,y1 = pb.ylim()
        yrange = y1-y0
        pb.plot(pb.xlim(),[10*np.log10(1-signal_gain),10*np.log10(1-signal_gain)],'k--')
        majorLocator = MultipleLocator(1)
        adesc.xaxis.set_major_locator(majorLocator)
        for a in range(len(uniqueAntennaNames)):
            pb.text(a, y0+0.09*yrange, uniqueAntennaNames[a], size=8, rotation='vertical')
        for a in range(len(bbs)):
            if (lo2 != None):
                pb.text(0.0+a*0.2, 1.02, 'BB%d spw%d'%(bbs[a],lo2[bbs[a]]['spw']), color=c[bbs[a]-1], size=10, transform=adesc.transAxes)
            else:
                pb.text(0.0+a*0.2, 1.02, 'BB%d'%bbs[a], color=c[bbs[a]-1], size=10, transform=adesc.transAxes)
        pb.text(0.0+0.2*(len(bbs)), 1.02, 'XX=dots,YY=crosses', size=10, transform=adesc.transAxes)
        if (lo1 != None):
            pb.text(0.0+0.2*(len(bbs)), 1.08, 'LO1=%.3f'%(lo1*1e-9), size=10, transform=adesc.transAxes)
        if (lo2 != None):
            for a in range(len(bbs)):
                pb.text(0.0+0.2*a, 1.08, 'LO2=%.3f'%(lo2[bbs[a]]['frequency']*1e-9), size=10, transform=adesc.transAxes)
        pb.ylabel("10*log10(1-sbGain) (dB)")
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        if (figfile == ''):
            figfile = sourceFile + '.sbgain.png'
        if (os.path.exists(figfile)):
            if (os.access(figfile,os.W_OK) == False):
                figfile = '/tmp/' + figfile
        else:
            if (figfile.find('/') < 0):
                figfile = './'+figfile
            if (os.access(os.path.dirname(figfile),os.W_OK) == False):
                figfile = '/tmp/' + os.path.basename(figfile)
        pb.savefig(figfile)
        print "Wrote plot to %s" % (figfile)
    return(figfile, suspect, suspectDict, valuesAreDefault)

def RescaleXAxisTimeTicks(xlim, adesc):
    if (xlim[1] - xlim[0] < 10/1440.):
        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,1)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,30)))
    elif (xlim[1] - xlim[0] < 0.5/24.):
        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,5)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,1)))
    elif (xlim[1] - xlim[0] < 1/24.):
        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,2)))
                
def setXaxisTimeTicks(adesc, t0, t1, verbose=False):
    """
    Sets sensible major and minor tick intervals for a plot_date plot
    based on the start and end times.
    Inputs: t0 (startTime in seconds)
        and t1 (endTime in seconds)
        Only the difference matters.
   -Todd Hunter
    """
    timeRange = t1-t0
    if (verbose):
        print "timeRange = %f sec" % (timeRange)
    if (timeRange > 20000):
        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H'))
        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,int(60*np.floor((t1-t0)/3600)),60)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,15)))
        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H')
    elif (timeRange > 2000):
        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,15)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,5)))
        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    elif (timeRange > 600):
        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,5)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,30)))
        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    elif (timeRange > 200):
        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,3)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,10)))
        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    elif (timeRange > 40):
        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M:%S'))
        adesc.xaxis.set_major_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,20)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,5)))
        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M:%S')
    else:
        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M:%S'))
        adesc.xaxis.set_major_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,10)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,1)))
        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M:%S')

def plotPWVFromASDM(asdm='',figfile=False,showMedianOnly=True,avgtime=30.0,
                    meanelev=-1, freq=-1, station=1, linetype='.-', markersize=7):
  """
  Read and plot the PWV values from the ASDM via the CalWVR.xml table.
  avgtime is the time in secs over which to compute the median value from all
  antennas.  If meanelev is specified, it will compute the PWV toward that
  elevation. If freq is further specified (GHz), it will compute the
  transmission toward that elevation using the measured weather conditions.
  For further help and examples, see
  https://safe.nrao.edu/wiki/bin/view/ALMA/PlotPWVfromASDM
   -- Todd Hunter
  """
  if (os.path.exists(asdm)):
    try:
      [watertime,water,antenna] = readpwv(asdm)
    except:
      print "Could not open %s/CalWVR.xml" % (asdm)
      return
  else:
      print "Could not find file %s/CalWVR.xml" % (asdm)
      return
  pb.clf()
  adesc = subplot(111)
  asdm = asdm.split('/')[-1]
  print "Found WVR data from %d antennas" % (len(np.unique(antenna)))
  roundedData = avgtime*(np.round(np.array(watertime)/avgtime))
  uniqueTimes = np.unique(roundedData)
  watertime = np.array(watertime)
  mjdsec = watertime
#  watertimeHours = np.array(watertime)/3600.
#  watertimeDays = np.array(watertime)/86400.
#  offset = int(floor(watertimeDays[0]))
#  watertimeDays -= offset
  water = np.array(water)*1000
  print "Found %d times" % (len(uniqueTimes))
  timeMedian = []
  pwvMedian = []
  if (showMedianOnly==False):
      list_of_date_times = mjdSecondsListToDateTime(watertime)
      timeplot = pb.date2num(list_of_date_times)
      pb.plot(timeplot, water, 'b.',markersize=markersize)
      pb.hold(True)
      for t in uniqueTimes:
          matches = np.where(roundedData == t)[0]
          timeMedian.append(np.median(watertime[matches]))
          pwvMedian.append(np.median(water[matches]))
#      pb.plot(timeMedian, pwvMedian, 'r%s'%(linetype),markersize=markersize+2)
      list_of_date_times = mjdSecondsListToDateTime(timeMedian)
      timeplot = pb.date2num(list_of_date_times)
      pb.plot_date(timeplot, pwvMedian, 'r%s'%(linetype),markersize=markersize+2)
  else:
      pb.hold(True)
      for t in uniqueTimes:
          matches = np.where(roundedData == t)[0]
          timeMedian.append(np.median(watertime[matches]))
          pwvMedian.append(np.median(water[matches]))
#      pb.plot(timeMedian, pwvMedian, 'b%s'%(linetype), markersize=markersize+2)
      list_of_date_times = mjdSecondsListToDateTime(timeMedian)
      timeplot = pb.date2num(list_of_date_times)
      pb.plot_date(timeplot, pwvMedian, 'r%s'%(linetype),markersize=markersize+2)
  pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(watertime[0]))
  pwvRange = np.max(pwvMedian) - np.min(pwvMedian)
  pb.ylim([np.min(pwvMedian)-0.03*pwvRange, np.max(pwvMedian)+0.03*pwvRange])
  if (showMedianOnly):
      pb.ylabel('PWV (mm) (median of all antennas)')
  else:
      pb.ylabel('PWV (mm) (red = median of all antennas)')
      
  adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
  adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
  adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
  adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
  RescaleXAxisTimeTicks(pb.xlim(), adesc)
  adesc.xaxis.grid(True,which='major')
  adesc.yaxis.grid(True,which='major')
  (mjd, utstring) = mjdSecondsToMJDandUT(mjdsec[0])
  if (asdm == "." or asdm == "./"):
      pb.title(os.getenv('PWD').split('/')[-1]+'   start time='+utstring)
  else:
      pb.title(asdm+'   start time='+utstring)
  deltaTime = (np.max(watertime) - np.min(watertime))/3600.
  print " median PWV at zenith = %.3f mm over %.3f hours" % (np.median(water),deltaTime)
  if (meanelev > 0):
      airmass = 1.0/math.cos((90-meanelev)*math.pi/180.)
      print " median PWV at elev=%.0f = %.3f mm over %.3f hours" % (meanelev,airmass*np.median(water),deltaTime)
      if (freq > 0):
          [conditions,medianConditions,stationName] = getWeatherFromASDM(asdm,station=station)
          P = medianConditions['pressure']
          H = medianConditions['humidity']
          T = medianConditions['temperature']
          print "Median conditions: P,H,T = ", P, H, T
          midLatitudeWinter = 3
          fResolution = fWidth
          altitude = 5059
          myqa = createCasaTool(qatool)
          at.initAtmProfile(humidity=H,
                            temperature=create_casa_quantity(myqa,T,"K"),
                            altitude=create_casa_quantity(myqa,altitude,"m"),
                            pressure=create_casa_quantity(myqa,P,'mbar'),
                            atmType=midLatitudeWinter)
          fCenter = create_casa_quantity(myqa,freq,'GHz')
          fWidth = create_casa_quantity(myqa,1.0,'GHz')
          at.initSpectralWindow(1, fCenter, fWidth, fResolution)
          at.setUserWH2O(create_casa_quantity(myqa,airmass*np.median(water), 'mm'))
          dry, wet, TebbSkyZenith, rf, cs = getAtmDetails(at)
          transmission = np.exp((-wet-dry)*airmass)* 100
          print " transmission at median PWV at %.1f GHz = %.1f percent" % (freq, transmission)
  pb.draw()
  if (figfile==True):
      myfig = asdm + '.pwv.png'
      pb.savefig(myfig, density=144)
      print "Figure saved to %s" % (myfig)
  elif (figfile != False):
      myfig = figfile
      pb.savefig(myfig, density=144)
      print "Figure saved to %s" % (myfig)
  else:
      print "To write a png file, re-run with figfile=T"

def plotSunDuringTrack(ms='', asdm='', plotfile='', figfiledir='', elvstime=False):
    """
    Plots the solar az/el during a dataset, with one point per scan.  You
    can specify either the ms or the asdm.  It reads the observatory name
    from the ExecBlock.xml (ASDM) or the OBSERVATION table (ms).
    Returns the name of the plotfile.
    plotfile can be: True, False, or a string name
    elvstime: False=plot el vs. az;  True=plot el vs. time
          I have implemented lists to hold the times, but not plotted yet.
    -- Todd Hunter
    """
    if (ms == '' and asdm == ''):
        print "Need to specify either an ms or an asdm"
        return
    azimuth = []
    elevation = []
    pointingScans = []
    startmjd = []
    endmjd = []
    mjd = []
    if (asdm != ''):
        if (os.path.exists(asdm) == False):
            print "ASDM does not exist: %s" % (asdm)
            return
        track = os.path.basename(asdm)
        if (track == ''):
            track = os.path.basename(asdm[:-1])  # in case name ends in '/'
        observatory = getObservatoryNameFromASDM(asdm)
        scandict, sourcedict = readscans(asdm)
        for scan in scandict:
#            print "processing scan ", scan
            az,el = sun(observatory=observatory, mjd=dateStringToMJD(scandict[scan]['start'], verbose=False))
            azimuth.append(az)
            elevation.append(el)
            startmjd.append(scandict[scan]['startmjd']*86400)
            mjd.append(scandict[scan]['startmjd']*86400)
            az,el = sun(observatory=observatory, mjd=dateStringToMJD(scandict[scan]['end'], verbose=False))
            azimuth.append(az)
            elevation.append(el)
            endmjd.append(scandict[scan]['endmjd']*86400)
            mjd.append(scandict[scan]['endmjd']*86400)
            if (scandict[scan]['intent'].find('CALIBRATE_POINTING') >= 0):
                pointingScans.append(scan)
        firstScan = np.min(scandict.keys())
        lastScan = np.max(scandict.keys())
    else:
        track = os.path.basename(ms)
        if (casadef.casa_version >= '4.1.0'):
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(ms)
            scannumbers = mymsmd.scannumbers()
            t = []
            for snumber in scannumbers:
                mytimes = mymsmd.timesforscan(snumber)
                t.append([np.min(mytimes), np.max(mytimes)])
            firstScan = np.min(scannumbers)
            lastScan = np.max(scannumbers)
            if ('CALIBRATE_POINTING#ON_SOURCE' in mymsmd.intents()):
                pointingScans = mymsmd.scansforintent('CALIBRATE_POINTING#ON_SOURCE')
            else:
                pointingScans = []
        else:
            print "Running ValueMapping because this is a pre-4.1 version of casa"
            vm = ValueMapping(ms)
            t = vm.getTimesForScans(vm.uniqueScans)
            firstScan = np.min(vm.uniqueScans)
            lastScan = np.max(vm.uniqueScans)
            pointingScans = getScansForIntentFast(vm,vm.uniqueScans,'CALIBRATE_POINTING#ON_SOURCE')
        observatory = getObservatoryName(ms)
        for scantime in t:
            az,el = sun(observatory=observatory, mjdsec=np.min(scantime))
            azimuth.append(az)
            elevation.append(el)
            mjd.append(np.min(scantime))
            startmjd.append(np.min(scantime))
            az,el = sun(observatory=observatory, mjdsec=np.max(scantime))
            azimuth.append(az)
            elevation.append(el)
            endmjd.append(np.max(scantime))
            mjd.append(np.max(scantime))
    pb.clf()
    adesc = pb.subplot(111)
    twilight = False
    if (elevation[0]*elevation[-1] < 0):
        twilight = True
    if (twilight):
        color = 'r'
    elif (elevation[0] < 0): # nighttime
        color = 'k'
    else:  # daytime
        color = 'b'
    azimuthStart = np.array(azimuth)[range(0,len(azimuth),2)]
    elevationStart = np.array(elevation)[range(0,len(elevation),2)]
    azimuthEnd = np.array(azimuth)[range(1,len(azimuth),2)]
    elevationEnd = np.array(elevation)[range(1,len(elevation),2)]
    if (elvstime):
        list_of_date_times = mjdSecondsListToDateTime(mjd)
        timeplot = pb.date2num(list_of_date_times)
        pb.plot_date(timeplot, elevation, '%s-'%color)
        timeplot = pb.date2num(mjdSecondsListToDateTime(startmjd))
        pb.plot_date(timeplot, elevationStart, '%so'%color)
        timeplot = pb.date2num(mjdSecondsListToDateTime(endmjd))
        pb.plot_date(timeplot, elevationEnd, 'wo', markeredgecolor=color)
        timeplot = pb.date2num(list_of_date_times)
        pb.plot_date(timeplot, elevation, '%s.-'%color)
        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
        adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
        xlims = pb.xlim()
        xrange = xlims[1]-xlims[0]
        pb.xlim([xlims[0]-0.06*xrange, xlims[1]+0.06*xrange])
        RescaleXAxisTimeTicks(pb.xlim(), adesc)
        adesc.xaxis.grid(True,which='major')
    else:
        pb.plot(azimuth, elevation, '%s-'%color)
        pb.plot(azimuthStart, elevationStart, '%so'%color)
        pb.plot(azimuthEnd, elevationEnd, 'wo', markeredgecolor=color)
        pb.plot(azimuth, elevation, '%s.-'%color)
        
    xlims = pb.xlim()
    pb.ylim([-92,92])
    ylims = pb.ylim()
    azoff = (xlims[1]-xlims[0])*0.05
    for p in pointingScans:
        if (elvstime==False):
            pb.text(azimuth[p-1]-azoff*0.5, elevation[p-1]-8, 'Point')
        else:
            pb.text(timeplot[p-1]-azoff*0.5, elevation[p-1]-8, 'Point')
    if (elvstime==False):
        pb.text(azimuth[0]-azoff, elevation[0]+3, 'Scan %d' % (firstScan))
        pb.text(azimuth[-1]-azoff, elevation[-1]+3, 'Scan %d' % (lastScan))
    else:
        pb.text(timeplot[0]-azoff, elevation[0]+3, 'Scan %d' % (firstScan))
        pb.text(timeplot[-1]-azoff, elevation[-1]+3, 'Scan %d' % (lastScan))
    pb.axhline(0, ls='--', color='k')
    pb.ylabel('Elevation (deg)')
    if (elvstime):
        pb.xlabel('Time (UT on %s)' % (mjdsecToUT(mjd[0]).split()[0]))
    else:
        pb.xlabel('Azimuth (deg)')
    pb.yticks(range(-90,92,15))
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')
    pb.title('Solar position from %s during %s' % (observatory,track))
    if (plotfile != ''):
        if (plotfile == True):
            if (elvstime):
                plotfile = track + '.sun.elvstime.png'
            else:
                plotfile = track + '.sun.png'
        if (figfiledir != ''):
            if (os.path.exists(figfiledir) == False):
                os.makedirs(figfiledir)
            if (figfiledir[-1] != '/'):
                figfiledir += '/'
            plotfile = figfiledir + plotfile
        pb.savefig(plotfile)
        print "Wrote plot = ", plotfile
    pb.draw()
    print "Mean elevation = %f deg" % (np.mean(elevation))
    if (plotfile == ''):
        return(np.mean(elevation))
    else:
        return(plotfile)
    
def plotweather(vis='', figfile='', station=[], asdm=''):
    """
    Compiles and plots the major weather parameters for the specified ms. 
    Station can be a single integer or integer string, or a list of two integers,
    and refers to the row number in the Station.xml file of the ASDM.
    The default empty list means to plot all data from up to 2 of the stations
    which are typically present in the data.  The default plot file name will
    be 'vis'.weather.png. If you also specify the ASDM, it can look up the
    conversion from station number to WSTB number. For further help and examples,
    see http://casaguides.nrao.edu/index.php?title=Plotweather
    -- Todd Hunter
    """
    return(plotWeather(vis,figfile,station,asdm))

def setTickLabelSize(desc, size):
    pb.setp(desc.get_xticklabels(), fontsize=size)
    pb.setp(desc.get_yticklabels(), fontsize=size)
    
def plotWeather(vis='', figfile='', station=[], asdm=''):
    """
    Compiles and plots the major weather parameters for the specified ms. 
    Station can be a single integer or integer string, or a list of two integers,
    and refers to the row number in the Station.xml file of the ASDM.
    The default empty list means to plot all data from up to 2 of the stations
    which are typically present in the data.  The default plot file name will
    be 'vis'.weather.png. If you also specify the ASDM, it can look up the
    conversion from station number to WSTB number. For further help and examples,
    see http://casaguides.nrao.edu/index.php?title=Plotweather
    -- Todd Hunter
    """
    myfontsize = 8
    if (os.path.exists(vis) == False):
        if (os.path.exists(asdm)):
            return(plotWeatherFromASDM(asdm))
        else:
            print "Could not find measurement set = ", vis
            return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    try:
        tb.open("%s/WEATHER" % vis)
    except:
        if (os.path.exists(asdm)):
            return(plotWeatherFromASDM(asdm))
        else:
            print "Could not open WEATHER table.  Did you importasdm with asis='*'?"
            return
    mjdsec = tb.getcol('TIME')
    mjdsec1 = mjdsec
    vis = vis.split('/')[-1]
    pressure = tb.getcol('PRESSURE')
    relativeHumidity = tb.getcol('REL_HUMIDITY')
    temperature = tb.getcol('TEMPERATURE')
    dewPoint = tb.getcol('DEW_POINT')
    stations = tb.getcol('NS_WX_STATION_ID')
    windDirection = (180/math.pi)*tb.getcol('WIND_DIRECTION')
    windSpeed = tb.getcol('WIND_SPEED')
    uniqueStations = np.unique(stations)
    if (station != []):
        if (type(station) == int):
            if (station not in uniqueStations):
                print "Station %d is not in the data.  Present are: "%station, uniqueStations
                return
            uniqueStations = [station]
        elif (type(station) == list):
            if (len(station) > 2):
                print "Only 2 stations can be overlaid."
                return
            if (station[0] not in uniqueStations):
                print "Station %d is not in the data.  Present are: "%station[0], uniqueStations
                return
            if (station[1] not in uniqueStations):
                print "Station %d is not in the data.  Present are: "%station[1], uniqueStations
                return
            uniqueStations = station
        elif (type(station) == str):
            if (station.isdigit()):
                if (int(station) not in uniqueStations):
                    print "Station %s is not in the data.  Present are: "%station, uniqueStations
                    return
                uniqueStations = [int(station)]
            else:
                print "Invalid station ID, it must be an integer, or list of integers."
                return
            
    if (len(uniqueStations) > 1):
        firstStationRows = np.where(stations == uniqueStations[0])[0]
        secondStationRows = np.where(stations == uniqueStations[1])[0]
        pressure = pressure[firstStationRows]
        relativeHumidity = relativeHumidity[firstStationRows]
        temperature = temperature[firstStationRows]
        dewPoint = dewPoint[firstStationRows]
        windDirection = windDirection[firstStationRows]
        windSpeed = windSpeed[firstStationRows]
        mjdsec1 = mjdsec[firstStationRows]

        pressure2 = tb.getcol('PRESSURE')[secondStationRows]
        relativeHumidity2 = tb.getcol('REL_HUMIDITY')[secondStationRows]
        temperature2 = tb.getcol('TEMPERATURE')[secondStationRows]
        dewPoint2 = tb.getcol('DEW_POINT')[secondStationRows]
        windDirection2 = (180/math.pi)*tb.getcol('WIND_DIRECTION')[secondStationRows]
        windSpeed2 = tb.getcol('WIND_SPEED')[secondStationRows]
        mjdsec2 = mjdsec[secondStationRows]
        if (np.mean(temperature2) > 100):
            # convert to Celsius
            temperature2 -= 273.15        
        if (np.mean(dewPoint2) > 100):
            dewPoint2 -= 273.15        
        
    if (np.mean(temperature) > 100):
        # convert to Celsius
        temperature -= 273.15        
    if (np.mean(dewPoint) > 100):
        dewPoint -= 273.15        
    if (np.mean(dewPoint) == 0):
        # assume it is not measured and use NOAA formula to compute from humidity:
        dewPoint = ComputeDewPointCFromRHAndTempC(relativeHumidity, temperature)
    if (np.mean(dewPoint2) == 0):
        # assume it is not measured and use NOAA formula to compute from humidity:
        dewPoint2 = ComputeDewPointCFromRHAndTempC(relativeHumidity2, temperature2)
    if (np.mean(relativeHumidity) < 0.001):
        print "Replacing zeros in relative humidity with value computed from dew point and temperature."
#        dewPointWVP = np.exp(17.271*dewPoint/(237.7+dewPoint))
#        ambientWVP = np.exp(17.271*temperature/(237.7+temperature))
        dewPointWVP = computeWVP(dewPoint)
        ambientWVP = computeWVP(temperature)
        print "dWVP=%f, aWVP=%f" % (dewPointWVP[0],ambientWVP[0])
        relativeHumidity = 100*(dewPointWVP/ambientWVP)

    tb.close()
    mysize = myfontsize
    pb.clf()
    adesc = pb.subplot(321)
    myhspace = 0.25
    mywspace = 0.25
    markersize = 3
    pb.subplots_adjust(hspace=myhspace, wspace=mywspace)
    pb.title(vis)
    list_of_date_times = mjdSecondsListToDateTime(mjdsec1)
    timeplot = pb.date2num(list_of_date_times)
    pb.plot_date(timeplot, pressure, markersize=markersize)
    if (len(uniqueStations) > 1):
        pb.hold(True)
        list_of_date_times = mjdSecondsListToDateTime(mjdsec2)
        timeplot2 = pb.date2num(list_of_date_times)
        pb.plot_date(timeplot2, pressure2, markersize=markersize, color='r')
        
    resizeFonts(adesc,myfontsize)
#    pb.xlabel('MJD - %d'%mjdOffset,size=mysize)
#    pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(mjdsec[0]),size=mysize)
    pb.ylabel('Pressure (mb)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')

    adesc = pb.subplot(322)
    pb.plot_date(timeplot,temperature, markersize=markersize)
    if (len(uniqueStations) > 1):
        pb.hold(True)
        list_of_date_times = mjdSecondsListToDateTime(mjdsec2)
        timeplot2 = pb.date2num(list_of_date_times)
        pb.plot_date(timeplot2, temperature2, markersize=markersize, color='r')
    resizeFonts(adesc,myfontsize)
#    pb.xlabel('MJD - %d'%mjdOffset,size=mysize)
#    pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(mjdsec[0]),size=mysize)
    pb.ylabel('Temperature (C)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')
    stationNames = []
    if (asdm != None and asdm != ''):
        if (os.path.exists(asdm)):
            stationName, stationPosition = readStationFromASDM(asdm, uniqueStations[0])
            stationNames.append(stationName)
            if (len(uniqueStations) > 1):
                stationName, stationPosition = readStationFromASDM(asdm, uniqueStations[1])
                stationNames.append(stationName)
        else:
            print "Could not find asdm = ", asdm

    if (len(uniqueStations) > 1):
        if (len(stationNames) == 0):
            pb.title('blue=station %d,  red=station %d'%(uniqueStations[0],uniqueStations[1]))
        else:
            pb.title('blue=%s,  red=%s'%(stationNames[0],stationNames[1]))
    else:
        if (len(stationNames) == 0):
            pb.title('blue=station %d'%(uniqueStations[0]))
        else:
            pb.title('blue=%s'%(stationNames[0]))

    adesc = pb.subplot(323)
    pb.plot_date(timeplot,relativeHumidity, markersize=markersize)
    if (len(uniqueStations) > 1):
        pb.hold(True)
        list_of_date_times = mjdSecondsListToDateTime(mjdsec2)
        timeplot2 = pb.date2num(list_of_date_times)
        pb.plot_date(timeplot2, relativeHumidity2, markersize=markersize, color='r')
    resizeFonts(adesc,myfontsize)
#    pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(mjdsec[0]),size=mysize)
#    pb.xlabel('MJD - %d'%mjdOffset,size=mysize)
    pb.ylabel('Relative Humidity (%)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')

    adesc = pb.subplot(324)
    pb.plot_date(timeplot,dewPoint, markersize=markersize)
    if (len(uniqueStations) > 1):
        pb.hold(True)
        list_of_date_times = mjdSecondsListToDateTime(mjdsec2)
        timeplot2 = pb.date2num(list_of_date_times)
        pb.plot_date(timeplot2, dewPoint2, markersize=markersize, color='r')
    resizeFonts(adesc,myfontsize)
#    pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(mjdsec[0]),size=mysize)
    pb.ylabel('Dew point (C)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')

    adesc = pb.subplot(325)
    pb.plot_date(timeplot, windSpeed, markersize=markersize)
    if (len(uniqueStations) > 1):
        pb.hold(True)
        list_of_date_times = mjdSecondsListToDateTime(mjdsec2)
        timeplot2 = pb.date2num(list_of_date_times)
        pb.plot_date(timeplot2, windSpeed2, markersize=markersize, color='r')
    resizeFonts(adesc,myfontsize)
#    pb.xlabel('MJD - %d'%mjdOffset,size=mysize)
    pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(mjdsec[0]),size=mysize)
    pb.ylabel('Wind speed (m/s)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')

    adesc= pb.subplot(326)
#    pb.xlabel('MJD - %d'%mjdOffset,size=mysize)
    pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(mjdsec[0]),size=mysize)
    pb.ylabel('Wind direction (deg)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
#    pb.plot(mjdFraction,windDirection)
    pb.plot_date(timeplot,windDirection, markersize=markersize)
    if (len(uniqueStations) > 1):
        pb.hold(True)
        list_of_date_times = mjdSecondsListToDateTime(mjdsec2)
        timeplot2 = pb.date2num(list_of_date_times)
        pb.plot_date(timeplot2, windDirection2, markersize=markersize, color='r')
    resizeFonts(adesc,myfontsize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')
    if (len(figfile) < 1):
        weatherFile = vis+'.weather.png'
    else:
        weatherFile = figfile
    pb.savefig(weatherFile)
    pb.draw()
    print "Wrote file = %s" % (weatherFile)

def plotWeatherFromASDM(asdm,station=1,plotfile='',titlefontsize=10):
    """
    Calls getWeatherFromASDM() for the specified ASDM, then plots the results.
    For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/PlotWeatherFromASDM
    -- Todd Hunter
    """
    myfontsize = 8
    markersize = 3
    if (os.path.exists(asdm) == False):
        print "Could not find asdm = ", asdm
        return
    [conditions, medianConditions,stationName] = getWeatherFromASDM(asdm,station=station,verbose=False)
    if (stationName == ''):
        print "Try a different station number (e.g. 1 or 2 for 'WSTB1' or 'WSTB2')"
        return
    mjdsec = np.array(conditions[0])
    pressure = conditions[1]
    temperature = np.array(conditions[3]) - 273.15
    station = conditions[-1]
    pb.clf()
    adesc = pb.subplot(321)
    pb.title(asdm+' (station %d=%s)'%(station,stationName),size=titlefontsize)
    list_of_date_times = mjdSecondsListToDateTime(mjdsec)
    timeplot = pb.date2num(list_of_date_times)
    pb.plot_date(timeplot,pressure, markersize=markersize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    setTickLabelSize(adesc, myfontsize)
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')
    yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.yaxis.set_major_formatter(yFormat)
    mysize = myfontsize
    pb.ylabel('Pressure (mb)',size=mysize)

    adesc = pb.subplot(322)
    pb.plot_date(timeplot,temperature, markersize=markersize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.yaxis.set_major_formatter(yFormat)
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    pb.ylabel('Temperature (C)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')

    relativeHumidity = conditions[2]
    adesc = pb.subplot(323)
    pb.plot_date(timeplot,relativeHumidity, markersize=markersize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.yaxis.set_major_formatter(yFormat)
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    pb.ylabel('Relative Humidity (%)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')

    dewPoint = ComputeDewPointCFromRHAndTempC(relativeHumidity, temperature)
    adesc = pb.subplot(324)
    pb.plot_date(timeplot,dewPoint, markersize=markersize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.yaxis.set_major_formatter(yFormat)
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    pb.ylabel('Dew point (C)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')

    windSpeed = conditions[5]
    adesc = pb.subplot(325)
    pb.plot_date(timeplot,windSpeed, markersize=markersize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.yaxis.set_major_formatter(yFormat)
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(mjdsec[0]),size=mysize)
    pb.ylabel('Wind speed (m/s)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')

    windDirection = conditions[4]
    adesc= pb.subplot(326)
    pb.xlabel('Universal Time (%s)'%plotbp3.utdatestring(mjdsec[0]),size=mysize)
    pb.ylabel('Wind direction (deg)',size=mysize)
    setTickLabelSize(adesc, myfontsize)
    pb.plot_date(timeplot,windDirection, markersize=markersize)
    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
    yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.yaxis.set_major_formatter(yFormat)
    RescaleXAxisTimeTicks(pb.xlim(), adesc)
    adesc.xaxis.grid(True,which='major')
    adesc.yaxis.grid(True,which='major')
    if (plotfile == ''):
        weatherFile = asdm+'.weather.png'
    else:
        weatherFile = plotfile
    pb.subplots_adjust(hspace=0.25, wspace=0.30)
    pb.savefig(weatherFile)
    pb.draw()
    print "Wrote file = %s" % (weatherFile)

def find_key(dic, val):
    """return the key of dictionary dic given the value"""
    return [k for k, v in dic.iteritems() if v == val][0]

def degfile2radec(filename):
    """
    Converts a list of RA and Dec from a file into sexagesimal
    """
    f = open(filename,'r')
    lines = f.readlines()
    outname = filename+'.radec'
    outfile = open(filename+'.radec','w')
    for line in lines:
        ra,dec = line.split()
        radec = deg2radec(float(ra),float(dec))
        radec = radec.replace(',',' ')+'\n'
        radec = radec.replace('+0','+')
        radec = radec.replace('-0','-')
        outfile.write(radec)
    f.close()
    outfile.close()
    print "Output file = ", outname
    
def deg2radec(ra=0,dec=0, prec=5, verbose=True, hmsdms=False):
    """
    Convert a position in RA/Dec from degrees to sexagesimal string.
    default format is HH:MM:SS.SSS, +DD:MM:SS.SSS
    hmsdms: if True, then format is HHhMMmSS.SSSs, +DDdMMmSS.SSSs
    -Todd Hunter
    """
    return(rad2radec(ra*pi/180., dec*pi/180., None, prec, verbose, hmsdms=hmsdms))

def radec2deg(radecstring):
    """
    Convert a position from a single RA/Dec sexagesimal string to RA and
    Dec in degrees. The string can be either comma or space delimited.
    The dec portion of the string can be either : or . delimited.
    See also deg2radec and radec2rad.
    -Todd Hunter
    """
    myrad = radec2rad(radecstring)
    return(list(np.array(myrad)*180/np.pi))

def radec2rad(radecstring):
    """
    Convert a position from a single RA/Dec sexagesimal string to RA and
    Dec in radians.
    The RA and Dec portions can be separted by a comma or a space.
    The RA portion of the string must be colon-delimited.
    The Dec portion of the string can be either : or . delimited.
    See also rad2radec.
    -Todd Hunter
    """
    radec1 = radecstring
    if (radec1.find(',') > 0):
        (ra,dec) = radec1.split(',')
    else:
        (ra,dec) = radec1.split()
    (h,m,s) = ra.lstrip().split(':')
    hours = float(h)+float(m)/60. + float(s)/3600.
    if (dec.find(':') > 0):
        (d,m,s) = dec.lstrip().split(':')
    else:
        try:
            (d,m,s) = dec.lstrip().split('.')
        except:
            (d,m,s,sfraction) = dec.lstrip().split('.')
            s = s + '.' + sfraction
    dec1 = abs(float(d))+float(m)/60.+float(s)/3600.
    if (dec.lstrip().find('-') == 0):
        dec1 = -dec1
    decrad = dec1*np.pi/180.
    ra1 = hours*15
    rarad = ra1*np.pi/180.
    return(rarad,decrad)

def boxToRadians(string):
    # Take a string of following format and return the ra/dec in radians
    # '[[17:20:55.24514, -035.45.04.6612], [17:20:55.13641, -035.45.02.7920]]'
    # - Todd Hunter
    mylist = string.replace('[','').replace(']','')
    tokens = mylist.split(',')
    coord0 = radec2rad(tokens[0]+','+tokens[1])
    coord1 = radec2rad(tokens[2]+','+tokens[3])
    return(coord0,coord1)

def imstatBackground(img, region, prec=7, verbose=False):
    # Run imstat on the specified box region, then on the 4 adjacent boxes to 
    # determine the lowest rms in all 5 boxes.  This is necessary until CASA
    # supports the annulus shape in order to measure rms around a point source.
    # - Todd Hunter

    if (region.find('box') < 0):
        print "Only works for box regions in absolute coords"
        return
    myregion = region[region.find('box')+3:].split('coord')[0].strip()
    blc, trc = boxToRadians(myregion)
    width = abs(blc[0]-trc[0])
    height = abs(trc[1]-blc[1])
    if (verbose):
        print "width,height = %.3f, %.3f arcsec" % (width*180*3600/np.pi,height*180*3600/np.pi)
    # left, right, up, down
    blc_left = blc[0]+width, blc[1]
    trc_left = trc[0]+width, trc[1]
    blc_right = blc[0]-width, blc[1]
    trc_right = trc[0]-width, trc[1]
    blc_up = blc[0], blc[1]+height
    trc_up = trc[0], trc[1]+height
    blc_down = blc[0], blc[1]-height
    trc_down = trc[0], trc[1]-height
    regionRight = buildBoxRegion(blc_right, trc_right)
    regionLeft = buildBoxRegion(blc_left, trc_left)
    regionUp = buildBoxRegion(blc_up, trc_up)
    regionDown = buildBoxRegion(blc_down, trc_down)
    rmss = []
    rmsfield = 3
    results = imstat(img,region=region)
    rms = imstatparse(results,prec=prec).split()[rmsfield]
    if (rms > 0): rmss.append(rms)
    if (verbose):
        print "regionRight = ", regionRight
        print "regionLeft = ", regionLeft
    resultsAdjacent = imstatparse(imstat(img,region=regionRight),prec=prec).split()
    if (resultsAdjacent[rmsfield]>0): rmss.append(resultsAdjacent[rmsfield])
    resultsAdjacent = imstatparse(imstat(img,region=regionLeft),prec=prec).split()
    if (resultsAdjacent[rmsfield]>0): rmss.append(resultsAdjacent[rmsfield])
    resultsAdjacent = imstatparse(imstat(img,region=regionUp),prec=prec).split()
    if (resultsAdjacent[rmsfield]>0): rmss.append(resultsAdjacent[rmsfield])
    resultsAdjacent = imstatparse(imstat(img,region=regionDown),prec=prec).split()
    if (resultsAdjacent[rmsfield]>0): rmss.append(resultsAdjacent[rmsfield])
    rmss = [float(x) for x in rmss]
    print "non-zero rms values = ", rmss
    minrms = np.min(rmss)
    print "min rms = %f (replacing %f, %s)" % (minrms,results['rms'],type(results['rms']))
    results['rms'] = np.array([minrms])
    return results

def buildBoxRegion(blc, trc, coordsys='J2000'):
    """
    Builds a casa box region out of the blc and trc coordinates.
    - Todd Hunter
    """
    blc = rad2radec(blc[0],blc[1],replaceDecDotsWithColons=False,verbose=False)
    trc = rad2radec(trc[0],trc[1],replaceDecDotsWithColons=False,verbose=False)
    myregion = 'box [[%s, %s], [%s, %s]] coord=%s' % (blc.split(',')[0], blc.split(',')[1], trc.split(',')[0], trc.split(',')[1], coordsys)
    return(myregion)

def imstatparse(imstatdict, prec=4, stokes=0, refpos='', separationprec=2, 
                fluxunit='Jy'):
    """
    A dictionary result from imstat is passed via the 'imstatdict' argument,
    and a string is returned containing the ra, dec, [separation], peak, rms, 
    flux.
    The prec parameters set the precision (number of points to the right of the
    decimal) in the various fields.
    refpos: a sexagesimal string  (e.g.  HH:MM:SS.SSS +DD:MM:SS.SSSS)
      * If specified, also compute the separation from this position, and 
        insert it after the rms field.
      * The RA and Dec part of the string can be either comma or space 
        separated.
      * The dec portion of the string can be either : or . delimited.
    -- Todd Hunter
    """
    ra = imstatdict['maxposf'].split(',')[0]
    dec = imstatdict['maxposf'].split(',')[1].replace('.',':',2)
    peak = imstatdict['max'][stokes]
    flux = imstatdict['flux'][stokes]
    rms = imstatdict['rms'][stokes]
    if (fluxunit == 'mJy'):
        peak *= 1e3
        flux *= 1e3
        rms *= 1e3

    if (refpos != ''):
        refposra,refposdec = radec2rad(ra+' '+dec)
        rarad,decrad = radec2rad(refpos)
        separationArcsec = angularSeparationRadians(rarad,decrad, refposra, refposdec)*180*3600/np.pi
        result = '%s %s %*.*f % .*f %.*f %.*f' % (ra,dec, separationprec+6, separationprec, separationArcsec, prec, peak, prec, rms, prec, flux)
    else:
        result = '%s %s % .*f %.*f %.*f' % (ra,dec, prec, peak, prec, rms, prec, flux)
    return(result)

def fluxscaleParseLog(logfile, field=None):
    """
    Extract the spectral index fit parameters from the ASCII log file
    produced by the casa task fluxscale.
    Optional parameters:
    field: can be given as a name string (e.g. '3c279')
    Returns a list of 3 items for the first (or specified) field found: 
         flux density list: [I,0,0,0]
         reference frequency as a string (e.g. '44.5507GHz')
         spectral index as a float
    - T. Hunter
    """
    f = open(logfile,'r')
    lines = f.readlines()
    lastline = None
    for line in lines:
        if ((line.find('Fitted spectrum') > 0) and (field==None or line.find(field)>0)):
            lastline = line
            break
    f.close()
    if (lastline == None):
        if (field == None):
            print "Did not find fitted spectrum line"
        else:
            print "Did not find fitted spectrum line for %s" % (field)
        return
    fluxDensity = float(lastline.split('Flux density = ')[1].split()[0])
    refFreqString = lastline.split('freq=')[1].split(')')[0].replace(' ','')
    spidx = float(lastline.split('spidx=')[1].split(' ')[0])
    return([fluxDensity,0,0,0], refFreqString, spidx)

def imviewField(img, radius, minIntensity=None, maxIntensityFraction=None,
                xcenter=None, ycenter=None, colorwedge=True, plotfile=None,
                frequency=None, trim=True):
    """
    Plots a square portion of a CASA image using imview.
    radius: radius of the square, in arcseconds
    minIntensity: the minimum intensity to display
    maxIntensityFraction: the fraction of the image maximum to display
    xcenter, ycenter: central pixel
    colorwedge: Boolean to control the display of a colorwedge
    plotfile: the name of the png file to produce
    frequency: scale the requested radius by the ratio of this frequency
               (given in Hz or GHz) to the frequency in the image header
    trim: if True, run ImageMagick's "convert -trim" to remove blank borders
    Returns:
    the name of the png file produced
    -Todd Hunter
    """
    if (os.path.exists(img) == False):
        print "Could not find image = ", img
        return
    if (frequency != None):
        if (frequency < 2000):
            frequencyGHz = frequency
        else:
            frequencyGHz = frequency*1e-9
    myimstat = imstat(img)
    if (minIntensity == None):
        imin = float(myimstat['min'][0])
    else:
        imin = minIntensity
    imax = float(myimstat['max'][0])
    if (maxIntensityFraction != None):
        imax *= maxIntensityFraction
    myrange = [imin, imax]
    mydict = getFitsBeam(img)
    arcsecPerPixel = abs(mydict[3])
    print "arcsec per pixel = ", arcsecPerPixel
    if (frequency != None):
        imgFrequencyGHz = mydict[7]
        scaleFactor = frequencyGHz / imgFrequencyGHz
        print "Scaling radius down by %f" % (scaleFactor)
        radius *= scaleFactor
    naxis1 = mydict[5]
    naxis2 = mydict[6]
    if (xcenter == None):
        xcenter = (naxis1-1)/2.0
    if (ycenter == None):
        ycenter = (naxis2-1)/2.0
    blcx = xcenter - radius/arcsecPerPixel
    blc = [float(xcenter - radius/arcsecPerPixel), float(ycenter - radius/arcsecPerPixel)]
    trc = [float(xcenter + radius/arcsecPerPixel), float(ycenter + radius/arcsecPerPixel)]
    if (plotfile == None):
        plotfile = img + '.imview.png'
    imview(raster=[{'file':img,'colorwedge':colorwedge, 'range':myrange}],
           zoom={'coord':'pixel','blc':blc,'trc':trc},
           out=plotfile)
    if (trim):
        os.system('convert -trim %s %s' % (plotfile,plotfile))
    return(plotfile)
 
def setBeam(img, major, minor, pa='0.0deg'):
    """
    Sets the restoring beam in a CASA image using the ia tool.
    major: string with units, e.g. '4.5arcsec'
    minor: string with units, e.g. '4.5arcsec'
    pa:    string with units, e.g. '32.1deg'
    -Todd Hunter
    """
    if (not os.path.exists(img)):
        print "Could not find image = ", img
        return
    myia = createCasaTool(iatool)
    myia.open(img)
    myia.setrestoringbeam(major=major, minor=minor, pa=pa)
    myia.close()

def imfitplot(img, region='', residual=None, model=None,logfile=None,
              colorwedge=True, pngname=None, rms=None, startSigma=3.0,
              subimage=None, includepix=[], excludepix=[], box='',
              verbose=False, estimates=''):
    """
    Calls the casa task imfit, then plots the model and residual 
    images side-by-side on the same color scale.
    residual: The name to call the residual image.
    model: The name to call the model image.
    logfile: The name to call the log file.
    colorwedge: whether to include a color wedge in the plot
    pngname: The name to call the two-panel png
    rms: The rms value to use in contouring the residual image (default=10% of peak)
    startSigma: where to start the +- contour levels on the residual
    subimage: The name to call the data subimage.
    includpix, excludepix, box, estimates: passed to imfit
    -Todd Hunter
    """
    if (residual == None):
        residual = img + '.residual'
    if (model == None):
        model = img + '.model'
    if (subimage == None):
        subimage = img + '.subimage'
    if (logfile == None):
        logfile = img + '.imfit.log'
    if (os.path.exists(residual)):
        os.system('rm -rf '+residual)
    if (os.path.exists(model)):
        os.system('rm -rf '+model)
    if (os.path.exists(logfile)):
        os.system('rm -rf '+logfile)
    if (os.path.exists(subimage) == False):
        if (useImsubimage == False):
            print "This version of CASA is too old to have imsubimage."
            return
        if (verbose):
            print "Running imsubimage('%s',region='%s',outfile='%s',box='%s')" % (img,region,subimage,box)
        imsubimage(img, region=region, outfile=subimage, box=box)
    if (verbose):
        print "Running imfit('%s')" % (img)
    mydict = imfit(img, region=region, residual=residual, logfile=logfile, 
                   model=model, excludepix=excludepix, includepix=includepix, 
                   box=box, estimates=estimates)
    if (verbose):
        print "Running imstat(%s)" % img
    myimstat = imstat(img, region=region)
    myrange = [float(myimstat['min'][0]), float(myimstat['max'][0])]
    if (myrange[0] > 0):
        myrange[0] = 0
    if (verbose):
        print "running imview(raster={'file':'%s', 'colorwedge':%s}, zoom=1,out='%s.png')" % (model,colorwedge,model)
    imview(raster = {'file':model, 'range':myrange, 'colorwedge':colorwedge},
           zoom=1, out=model+'.png')
    if (verbose):
        print "Running imstat('%s')" % (residual)
    stats = imstat(residual)
    if (verbose):
        print stats
    mymax = float(stats['max'][0])
    mymin = float(stats['min'][0])
    if (rms == None):
        rms = 0.10*mymax
    levels = np.arange(startSigma*rms, mymax, rms, dtype=float)
    nlevels = np.arange(-startSigma*rms, mymin, -rms, dtype=float)
    if (verbose):
        print "levels=%s, nlevels=%s" % (str(levels), str(nlevels))
    levels = list(levels) + list(nlevels)
    levels = [float(a) for a in levels]
    if (verbose):
        print "running imview(raster={'file':'%s', 'range':%s, 'colorwedge':%s}, zoom=1,out='%s.png', contour={'levels':%s})" % (model,myrange,colorwedge,model,str(levels))
    imview(raster = {'file':residual, 'range':myrange, 'colorwedge':colorwedge},
           zoom = 1, out = residual + '.png', contour={'file':residual, 'levels': levels})
    imview(raster = {'file':subimage, 'range':myrange, 'colorwedge':colorwedge},
           zoom = 1, out = subimage + '.png')
    if (verbose):
        print "Running montagePngs"
    if (pngname == None):
        pngname = img+'.imfit.png'
    montagePngs(png2=model+'.png', png3=residual+'.png', outname=pngname, 
                sidebyside=True, png1=subimage+'.png')
    print "Wrote montaged image = ", pngname
    return(mydict)

def imfitparse(imfitdict, raprec=3, decprec=1, fluxprec=4, sizeprec=4,
               paprec=2, stokes=0, refpos='', separationprec=2, snrprec=0, 
               component=0, fluxunit='Jy', logfile=None, showpixels=False,
               meanpixel=None):
    """
    A dictionary result from imfit is passed in via the 'imfitdict' argument, and
    a string is returned containing the position of component 0 in RA/Dec
    sexagesimal, followed by its flux, fitted size, and uncertainties.
       ra, dec, flux, fluxerr, snr=(flux/fluxerr), majorarcsec, majorarcsecerr,
       minorarcsec, minorarcsecerr, posangle, posangleerr
    The various "prec" parameters set the precision (number of points to the
    right of the decimal) to show for the various corresponding quantities.
    refpos: a sexagesimal string  (e.g.  HH:MM:SS.SSS +DD:MM:SS.SSSS)
      * If specified, also compute the separation from this position, and
        insert it after the fluxerr field.
      * The RA & Dec part of the string can be either comma or space delimited.
      * The Dec portion of the string can be either : or . delimited.
    * logfile: if provided, then the size will be the size deconvolved from
       the beam, rather than the (larger) fitted size.
    * showpixels: if True, then put the pixel values as 2 final columns. If not
              Boolean, then also normalize the pixel value by this number
    * meanpixel: if specified as [x,y], then remove x,y from fitted pixel value
              before normalizing by showpixels
    -- Todd Hunter
    """
    if (showpixels != False and logfile ==None):
        print "The showpixels option requires logfile to be set."
        return
    if (imfitdict == None):
        return "no result"
    comp = 'component%d' % (component)
    if (comp not in imfitdict['results'].keys()):
        return(None)
    ra  = imfitdict['results'][comp]['shape']['direction']['m0']['value']
    dec = imfitdict['results'][comp]['shape']['direction']['m1']['value']
    flux = imfitdict['results'][comp]['flux']['value'][stokes]
    fluxerr = imfitdict['results'][comp]['flux']['error'][stokes]
    myfluxunit = imfitdict['results'][comp]['flux']['unit']
    if (fluxunit != myfluxunit):
        if (fluxunit == 'mJy' and myfluxunit=='Jy'):
            flux *= 1000
            fluxerr *= 1000
    # This major/minor is the fitted size, not deconvolved from the beam.
    majorarcsec = imfitdict['results'][comp]['shape']['majoraxis']['value']
    myunit      = imfitdict['results'][comp]['shape']['majoraxis']['unit']
    if ('arcsec' != myunit): print "imfit returned %s instead of arcsec" % (myunit)

    minorarcsec = imfitdict['results'][comp]['shape']['minoraxis']['value']
    myunit      = imfitdict['results'][comp]['shape']['minoraxis']['unit']
    if ('arcsec' != myunit): print "imfit returned %s instead of arcsec" % (myunit)

    majorarcsecerr = imfitdict['results'][comp]['shape']['majoraxiserror']['value']
    myunit         = imfitdict['results'][comp]['shape']['majoraxiserror']['unit']
    if ('arcsec' != myunit): print "imfit returned %s instead of arcsec" % (myunit)

    minorarcsecerr = imfitdict['results'][comp]['shape']['minoraxiserror']['value']
    myunit        = imfitdict['results'][comp]['shape']['minoraxiserror']['unit']
    if ('arcsec' != myunit): print "imfit returned %s instead of arcsec" % (myunit)

    posangle = imfitdict['results'][comp]['shape']['positionangle']['value']
    myunit   = imfitdict['results'][comp]['shape']['positionangle']['unit']
    if ('deg' != myunit): print "imfit returned %s instead of deg" % (myunit)

    posangleerr = imfitdict['results'][comp]['shape']['positionangleerror']['value']
    myunit      = imfitdict['results'][comp]['shape']['positionangleerror']['unit']
    if ('deg' != myunit): print "imfit returned %s instead of deg" % (myunit)

    if (refpos != ''):
        rarad,decrad = radec2rad(refpos)
        separationArcsec = angularSeparationRadians(rarad,decrad, ra, dec) * 180*3600/np.pi
        
    ra = qa.formxxx('%.12frad'%(ra),format='hms',prec=raprec)
    dec = qa.formxxx('%.12frad'%(dec),format='dms',prec=decprec).replace('.',':',2).replace('-0',' -',1)
    snr = flux/fluxerr
    if (logfile != None):
        if (os.path.exists(logfile) == False):
            print "Logfile not found"
            return
        lf = open(logfile,'r')
        lines = lf.readlines()
        lf.close()
        for i,line in enumerate(lines):
            if (line.find("Position ---")>=0 and showpixels != False):
                if (lines[i+3].find('ra') >= 0 and lines[i+3].find('pixels') >= 0 ):
                    xpixel = float(lines[i+3].split()[2])
                    if (meanpixel != None):
                        xpixel -= meanpixel[0]
                    if (showpixels != False and showpixels != True):
                        xpixel /= showpixels
                else:
                    print "Failed to parse the log file for pixel positions"
                    return
                if (lines[i+4].find('dec') >= 0 and lines[i+4].find('pixels') >= 0 ):
                    ypixel = float(lines[i+4].split()[2])
                    if (meanpixel != None):
                        ypixel -= meanpixel[1]
                    if (showpixels != False and showpixels != True):
                        ypixel /= showpixels
                else:
                    print "Failed to parse the log file for pixel positions"
                    return
            if (line.find("Image component size (deconvolved from beam)")>=0):
                if (lines[i+1].find('major axis FWHM:') >= 0):
                    fitresult = lines[i+1].split('FWHM:')[1].strip() # 2.041 +/- 0.078 arcsec
                    majorarcsec = float(fitresult.split()[0])
                    majorarcsecerr = float(fitresult.split()[2])
                    myunit = fitresult.split()[3]
                    if (myunit == 'marcsec'):
                        majorarcsec *= 0.001
                        majorarcsecerr *= 0.001
                    elif ('arcsec' != myunit):
                        print "major axis: imfit returned %s instead of arcsec" % (myunit)
                if (lines[i+2].find('minor axis FWHM:') >= 0):
                    fitresult = lines[i+2].split('FWHM:')[1].strip()
                    minorarcsec = float(fitresult.split()[0])
                    minorarcsecerr = float(fitresult.split()[2])
                    myunit = fitresult.split()[3]
                    if (myunit == 'marcsec'):
                        minorarcsec *= 0.001
                        minorarcsecerr *= 0.001
                    elif ('arcsec' != myunit):
                        print "minor axis: imfit returned %s instead of arcsec" % (myunit)
                if (lines[i+3].find('position angle:') >= 0):
                    fitresult = lines[i+3].split('angle:')[1].strip()
                    posangle = float(fitresult.split()[0])
                    posangleerr = float(fitresult.split()[2])
                    myunit = fitresult.split()[3]
                    if ('deg' != myunit):
                        print "position angle: imfit returned %s instead of deg" % (myunit)
                
#        print "logfile parsing not yet implemented"        
    if (refpos != ''):
        result = '%s %s %*.*f % .*f %.*f %*.*f  %.*f %.*f % .*f %.*f %+*.*f %*.*f' % (ra,dec,
             separationprec+6, separationprec, separationArcsec, fluxprec,flux,
             fluxprec, fluxerr, snrprec+4, snrprec, snr, sizeprec, majorarcsec, sizeprec,
             majorarcsecerr,
             sizeprec, minorarcsec, sizeprec, minorarcsecerr, 5+paprec, paprec,
             posangle, 3+paprec, paprec, posangleerr)
    else:
        result = '%s %s % .*f %.*f %*.*f  %.*f %.*f % .*f %.*f %+*.*f %*.*f' % (ra,dec,fluxprec,flux,
             fluxprec, fluxerr, snrprec+4, snrprec, snr, sizeprec, majorarcsec, sizeprec, majorarcsecerr,
             sizeprec, minorarcsec, sizeprec, minorarcsecerr, 5+paprec, paprec,
             posangle, 3+paprec, paprec, posangleerr)
    if (showpixels != False):
        result += ' %8.3f %8.3f' % (xpixel, ypixel)
    return(result)

def brightness(fluxDensity, frequency, beamsize, beamsize2=None, 
               distance=None, tdust=None, R=100, fluxDensityUncertainty=0,
               beamsizeUncertainty=0, beamsize2Uncertainty=0, trials=2000,
               kappa=None, tdustUncertainty=0, calibrationUncertainty=0,
               columnDensity=None):
    """
    Convert flux density to brightness temperature, both RJ and Planck.
    If distance is given, compute the luminosity.  If temperature is given, compute
    the dust mass, then gas mass.
    Required parameters:
    * fluxDensity: Jy
    * frequency: string with units, or floating point GHz
    * beamsize: arcsec
    Optional parameters:
    * beamsize2: second dimension of beamsize
    * distance: in kpc
    * tdust: dust temperature (K)
    * R: gas to dust mass ratio (default=100)
    * fluxDensityUncertainty: Jy
    * beamsizeUncertainty: arcsec
    * beamsize2Uncertainty: arcsec 
    * trials: the number of Monte Carlo simulations to run to determine Tb uncertainty
    * kappa: dust mass opacity coefficient to use (in cm^2 / g)
        None--> automatic, which is 1.84 at 342GHz extrpolated with beta=2
    * tdustUncertainty: in K
    * calibrationUncertainty: to be used for the mass calculation only, add in quadrature
          to the fluxDensityUncertainty
    * columnDensity: if provided, compute the abundance relative to H2 (based on R)
    Returns: dictionary containing keys: 'temperature', 'temperaturePlanck',
             'temperatureRJUncertainty'
    * If distance is given, it also returns 'luminosity'.
    * If tdust is given, it also returns 'mass', 'tau', and 'columnDensity'.
    -Todd Hunter
    """
    frequency = parseFrequencyArgument(frequency)
    if (beamsize2 == None):
        beamsize2 = beamsize
    tempRJ = (1.224e+6)*fluxDensity/(pow(frequency,2)*beamsize*beamsize2)
    tempPlanck = (0.048)*frequency/np.log(1+(3.92e-8)*pow(frequency,3)*beamsize*beamsize2/fluxDensity)
    if (fluxDensityUncertainty != 0 or beamsizeUncertainty != 0):
        tempsRJ = []
        for i in range(trials):
            while True:
                tempRJ = (1.224e+6)*(fluxDensity+fluxDensityUncertainty*pickRandomError())/(pow(frequency,2)*(beamsize+beamsizeUncertainty*pickRandomError())*(beamsize2+beamsize2Uncertainty*pickRandomError()))
                if (tempRJ > 0): break
            tempsRJ.append(tempRJ)
        tempRJUncertainty = MAD(tempsRJ)
        tempRJ = np.median(tempsRJ)
    else:
        tempRJUncertainty = 0
    retval = {'temperature': tempRJ, 'temperaturePlanck' :tempPlanck, 'temperatureRJUncertainty': tempRJUncertainty}
            
    if (distance != None):
        stefan = 5.67051e-5
        Reffective = ((beamsize*beamsize2*np.pi/4.0/np.log(2)) / np.pi)**0.5
        # 4 pi R^2 sigma T^4  R_effective=distance*R_beam
        luminosity = 4*stefan*np.pi*pow(Reffective*distance*1000*ARCSEC_PER_RAD*1.49597e13,2)*pow(tempRJ,4) / 3.83e33
        if (fluxDensityUncertainty != 0 or beamsizeUncertainty != 0):
            luminosities = []
            for i in range(trials):
                while True:
                    bU = beamsizeUncertainty*pickRandomError()
                    bU2 = beamsize2Uncertainty*pickRandomError()
                    fU = fluxDensityUncertainty*pickRandomError()
                    Reffective = (((beamsize+bU)*(beamsize2+bU2)*np.pi/4.0/np.log(2)) / np.pi)**0.5
                    mytempRJ = (1.224e+6)*(fluxDensity+fU)/(pow(frequency,2)*(beamsize+bU)*(beamsize2+bU2))
                    luminosity = 4*stefan*np.pi*pow(Reffective*distance*1000*ARCSEC_PER_RAD*1.49597e13,2)*pow(mytempRJ,4) / 3.83e33
                    if (luminosity > 0): break
                luminosities.append(luminosity)
            luminosityUncertainty = MAD(luminosities)
            luminosity = np.median(luminosities)
        else:
            luminosityUncertainty = 0
        retval['luminosity'] = luminosity
        retval['luminosityUncertainty'] = luminosityUncertainty
    if (tdust == None): return(retval)
    if (tdust < tempRJ):
        print "Dust temperature is too low for the brightness temperature."
    else:
#        tau =  -np.log(1-tempPlanck/tdust)
        tau =  -np.log(1-tempRJ/tdust)
        print "Planck optical depth = %f" % (tau)
        print "Planck Mass correction factor [tau/(1-e(-tau))] = %f" % (tau/(1-exp(-tau)))
    if (tdust < tempRJ):
        print "Dust temperature is too low for RJ temperature. Skipping tau and mass calculation."
    else:
        tau = -np.log(1-tempRJ/tdust)
        retval['tau'] = tau
        print "RJ optical depth = %f" % (tau)
        masscorr = tau/(1-exp(-tau))
        print "RJ Mass correction factor [tau/(1-e(-tau))] = %f" % (masscorr)
        if (kappa == None):
            kappa = 1.84 # cm2 g-1 
            beta = 2
            print "Using kappa = %3f cm^2 g^-1 @ 342 GHz and Beta=%.2f" % (kappa,beta)
            kappa *= pow(frequency/342,beta);
        h = 6.626e-27
        c = 2.998e10
        print "yielding kappa = %3f cm^2 g^-1" % (kappa)
        B = 2*h*pow((frequency*1e9),3)/(pow(c,2)*np.expm1(h*frequency*1e9/(k*tdust)))
        print "Using gas-to-dust mass ratio R = %f" % (R)
        mass = fluxDensity*(1e-23)*pow(distance*3.08e21,2)*masscorr*R/(B*kappa)
        massMsun = mass/2e33
        hydrogenMoleculeMass = 2.3*1.67e-24
        print "RJ mass = %f Msun" % (massMsun)
        retval['mass'] = massMsun
        if (fluxDensityUncertainty != 0 or beamsizeUncertainty != 0 or tdustUncertainty != 0):
            Msuns = []
            mycolumn = []
            for i in range(trials):
                while True:
                    bU = beamsizeUncertainty*pickRandomError()
                    bU2 = beamsize2Uncertainty*pickRandomError()
                    fU = (fluxDensityUncertainty**2 + (calibrationUncertainty*fluxDensity)**2)**0.5 * pickRandomError()
                    tU = tdustUncertainty*pickRandomError()
                    mytempRJ = (1.224e+6)*(fluxDensity+fU)/(pow(frequency,2)*(beamsize+bU)*(beamsize2+bU2))
                    mytau = -np.log(1-mytempRJ/(tdust+tU))
                    mymasscorr = mytau/(1-exp(-mytau))
                    myB = 2*h*pow((frequency*1e9),3)/(pow(c,2)*np.expm1(h*frequency*1e9/(k*(tdust+tU))))
                    Msun = (fluxDensity+fU)*(1e-23)*pow(distance*3.08e21,2)*mymasscorr*R/(myB*kappa) / 2e33
                    if (Msun > 0): break
                Msuns.append(Msun)
                beamAreaCM = (beamsize+bU)*(beamsize2+bU2)*np.pi*0.25*pow(distance*3.08e21,2)/(np.log(2)*pow(ARCSEC_PER_RAD,2))
                mycolumn.append((fluxDensity+fU)*(1e-23)*pow(distance*3.08e21,2)*masscorr*R/(B*kappa)/hydrogenMoleculeMass/(beamAreaCM))
            MsunUncertainty = MAD(Msuns)
            retval['mass'] = np.median(Msuns)
        else:
            MsunUncertainty = 0
        retval['massUncertainty'] = MsunUncertainty
        print "RJ mass = %f to %f Msun" % (massMsun-MsunUncertainty, massMsun+MsunUncertainty)
        
        beamAreaCM = beamsize*beamsize2*np.pi*0.25*pow(distance*3.08e21,2)/(np.log(2)*pow(ARCSEC_PER_RAD,2))
        column = mass/hydrogenMoleculeMass/beamAreaCM
        print "Ncolumn = %g cm-2" % (column)
        power = int(np.log10(np.median(mycolumn)))
        print "Ncolumn with uncertainty = %.2f +- %.2f E%d  = %.2f to %.2f" % (np.median(mycolumn)/10**power,
                                                               MAD(mycolumn)/10**power,power,
                                                 np.median(mycolumn)/10**power-MAD(mycolumn)/10**power,
                                                 np.median(mycolumn)/10**power+MAD(mycolumn)/10**power)
        if (columnDensity != None):
            print "Abundance of molecule relative to H2: %e" % (columnDensity/column)
        retval['columnDensity'] = column
        retval['columnDensityUncertainty'] = MAD(mycolumn) # column * retval['massUncertainty'] / retval['mass']
    return(retval)

def backgroundSources(fluxdensity, fieldDiameter=None, fieldXsize=None,
                      fieldYsize=None, frequency=5):
    """
    Computes the expected number of background radio point sources above a specified
    flux density in a specified field size, based on the formula of Anglada et al. 1998.
    -Todd Hunter
    fluxdensity: minimum detectable flux density at field center (mJy)
    fieldDiameter: in arcseconds
    or
    fieldXsize and fieldYsize: in arcseconds
    frequency: in GHz
    """
    if (fieldDiameter == None):
        if (fieldXsize == None or fieldYsize==None):
            print "You must specify either fieldDiameter or (fieldXsize and fieldYsize)."
            return
        area = fieldXsize * fieldYsize
        fieldDiameter = (area*4/np.pi)**0.5
    N = 1.4*(1-np.exp(-0.0066*(fieldDiameter/60.)**2 * (frequency/5.0)**2)) * (fluxdensity)**-0.75 * (frequency/5.0)**-2.52
    return(N)
    
def rad2radec(ra=0,dec=0,imfitdict=None, prec=5, verbose=True, component=0,
              replaceDecDotsWithColons=True, hmsdms=False):
    """
    Convert a position in RA/Dec from radians to sexagesimal string which
    is comma-delimited, e.g. '20:10:49.01, +057:17:44.806'.
    The position can either be entered as scalars via the 'ra' and 'dec' 
    parameters, as a tuple via the 'ra' parameter, as an array of shape (2,1)
    via the 'ra' parameter, or
    as an imfit dictionary can be passed via the 'imfitdict' argument, and the
    position of component 0 will be displayed in RA/Dec sexagesimal.
    replaceDotsWithColons: replace dots with colons as the Declination d/m/s delimiter
    hmsdms: produce output of format: '20h10m49.01s, +057d17m44.806s'
    Todd Hunter
    """
    if (type(imfitdict) == dict):
        comp = 'component%d' % (component)
        ra  = imfitdict['results'][comp]['shape']['direction']['m0']['value']
        dec = imfitdict['results'][comp]['shape']['direction']['m1']['value']
    if (type(ra) == tuple):
        dec = ra[1]
        ra = ra[0]
    if (np.shape(ra) == (2,1)):
        dec = ra[1][0]
        ra = ra[0][0]
    if (os.getenv('CASAPATH') == None):
        if (ra<0): ra += 2*pi
        rahr = ra*12/np.pi
        decdeg = dec*180/np.pi
        hr = int(rahr)
        min = int((rahr-hr)*60)
        sec = (rahr-hr-min/60.)*3600
        if (decdeg < 0):
            mysign = '-'
        else:
            mysign = '+'
        decdeg = abs(decdeg)
        d = int(decdeg)
        dm = int((decdeg-d)*60)
        ds = (decdeg-d-dm/60.)*3600
        mystring = '%02d:%02d:%08.5f, %c%02d:%02d:%08.5f' % (hr,min,sec,mysign,d,dm,ds)
    else:
        myqa = createCasaTool(qatool)
        myra = myqa.formxxx('%.12frad'%ra,format='hms',prec=prec)
        mydec = myqa.formxxx('%.12frad'%dec,format='dms',prec=prec)
        if replaceDecDotsWithColons:
            mydec = mydec.replace('.',':',2)
        mystring = '%s, %s' % (myra, mydec)
        myqa.done()
    if (hmsdms):
        mystring = convertColonDelimitersToHMSDMS(mystring)
    if (verbose):
        print mystring
    return(mystring)

def convertColonDelimitersToHMSDMS(mystring):
    """
    Converts HH:MM:SS.SSS, +DD:MM:SS.SSS  to HHhMMmSS.SSSs,+DDdMMmSS.SSSs
    -Todd Hunter
    """
    return(mystring.strip(' ').replace(':','h',1).replace(':','m',1).replace(',','s,',1).replace(':','d',1).replace(':','m',1) + 's')
    
def radec2direction(radecstring):
    """
    Convert a sexagesimal string into a direction dictionary suitable
    to substitute for the result of a call to me.direction().
    The string can be either comma or space delimited.
    The dec portion of the string can be either : or . delimited.
    Todd Hunter
    """
    rarad, decrad = radec2rad(radecstring)
    direction = {'m0':{'unit':'rad', 'value': rarad}, 
                 'm1':{'unit':'rad', 'value': decrad}, 
                 'refer':'J2000', 
                 'type': 'direction'}
    return(direction)

def direction2radec(direction=None, prec=5, hmsdms=False):
    """
    Convert a direction dictionary to a sexagesimal string of format:
    HH:MM:SS.SSSSS, +DDD:MM:SS.SSSSSS
    hmsdms: if True, then output format is HHhMMmSS.SSSs, +DDDdMMmSS.SSSs
    Todd Hunter
    """
    ra  = direction['m0']['value']
    dec = direction['m1']['value']
    mystring = '%s, %s' % (qa.formxxx('%.12frad'%ra,format='hms',prec=prec),
                           qa.formxxx('%.12frad'%dec,format='dms',prec=prec).replace('.',':',2))
    if (hmsdms):
        mystring = convertColonDelimitersToHMSDMS(mystring)
    return(mystring)
    
def direction2radecForSimobserve(direction=None, prec=5):
    """
    Convert a direction dictionary to a sexagesimal string that simobserve expects.
    Todd Hunter
    """
    ra  = direction['m0']['value']
    dec = direction['m1']['value']
    epoch = direction['refer']
    rastring = qa.formxxx('%.12frad'%ra,format='hms',prec=prec)
    rastring = '%sh%sm%ss' % (rastring[0:2], rastring[3:5], rastring[6:])
    decstring = qa.formxxx('%.12frad'%dec,format='dms',prec=prec).replace('.',':',2)
    decstring = '%sd%sm%ss' % (decstring[0:4], decstring[5:7], decstring[8:])
    mystring = '%s %s %s' % (epoch, rastring, decstring)
    return(mystring)

def parseSSSerror(s, body):
    if (s == 0):
        return('success')
    elif (s==1):
        return ('Error: unsupported body (%s)'%body)
    elif (s==2):
        return ('Error: unsupported frequency or time for body (%s)'%(body))
    elif (s==3):
        return ('Error: Tb model file not found (%s)'%(body))
    elif (s==4):
        return ('Error: ephemeris table not found (%s), or time out of range (note - the case where the MJD times span two ephemeris files is not supported' % (body))
    else:
        return('Error: unknown error code')
    

def call_solar_system_fd(body, MJDs, frequencies, observatory='ALMA', verbose=False):
    """
    This is a wrapper to call Bryan Butler's function, which requires a
    different number of parameters depending on whether you are using
    casa version <4.0 or  4.0 or 4.1.
    -Todd Hunter
    """
    if (casadef.casa_version >= '4.1.0'):
        sss2 = sss.solar_system_setjy()
        if (verbose):
            print "Calling sss.solar_system_setjy.solar_system_fd(sss2, '%s', %s, %s, '%s', casalog)" % (body, MJDs, frequencies, observatory)
        if (len(frequencies) == 3):
            freqs = []
            freqGHz = []
            fluxdensity = []
            for f in np.arange(frequencies[0], frequencies[1], frequencies[2]):
                freqs.append([f,f+frequencies[2]])
                freqGHz.append(np.mean(freqs[-1])*1e-9)
            print "Calling sss.solar_system_setjy.solar_system_fd with %d frequency bins of width=%gMHz" % (len(freqs),frequencies[2]*1e-6)
            print "This will take about %d seconds on a decent machine. Use bandwidth parameter to adjust." % (len(freqs)/100)
            result = sss.solar_system_setjy.solar_system_fd(sss2, body, MJDs, freqs,
                                                            observatory, casalog)
            (status,flux,uncertainty,size,direction) = result
            for fl in flux[0]:
                fluxdensity.append(fl)
            return(freqGHz, fluxdensity)
        else:
            result = sss.solar_system_setjy.solar_system_fd(sss2, body, MJDs, frequencies,
                                                            observatory, casalog)
        if (verbose):
            print "Done"
    elif (casadef.casa_version >= '4.0.0'):
        if (verbose):
            print "Calling sss.solar_system_fd('%s', %s, %s, '%s', casalog)" % (body, MJDs, frequencies, observatory)
        result = sss.solar_system_fd(body, MJDs, frequencies,
                                     observatory, casalog)
        if (verbose):
            print "Done"
    else:
        if (verbose):
            print "Calling sss.solar_system_fd('%s', %s, %s)" % (body, MJDs, frequencies)
        result = sss.solar_system_fd(body, MJDs, frequencies)
        if (verbose):
            print "Done"
    (status,flux,uncertainty,size,direction) = result        
    return(status,flux,uncertainty,size,direction)

def diskCoupling(diskArea, beamArea):
    """
    Equation C.20 of NRAO 12m user manual
    """
    return(1-np.exp(-(diskArea/beamArea)*np.log(2.0)))

def getModelPlanetFromVis(vis):
    """
    Finds the first planet with a CASA model in a measurement set.
    """
    fields = getFields(vis)
    fieldsUpperCase = [x.upper() for x in fields]
    checkObjects = ['CALLISTO','CERES','EUROPA','GANYMEDE','IO',
                    'JUNO','JUPITER','MARS','NEPTUNE','PALLAS','TITAN',
                    'URANUS','VENUS','VESTA']
    body = None
    for object in checkObjects:
        if (object in fieldsUpperCase):
            body = object
            break
    return(body)

def planetTemperature(body='', frequency=None, angularDiameter=None, vis=None,
                      date='', intent='OBSERVE_TARGET#ON_SOURCE',
                      efficiency=None, spw=None, beamFwhm=None,
                      beamFwhmFactor=1.13, telescopeDiameter=12,
                      useJPL=True, surfaceRms=25):
    """
    Estimates the expected antenna temperature of a planet based on its model
    radiative temperature in CASA, the observed frequency and angular diameter
    at a specific date of observation.
    planet: one of /usr/lib64/casapy/data/alma/SolarSystemModels/*_Tb.dat
    frequency: observed frequency (Hz, GHz, or a string with units)
    angularDiameter: of body in arcsec (if not specified, get it from JPL)
    vis: measurement set to consult for planet name and date
    date: date of observation
    intent: the observing intent to use to search for spws to use if vis is specified but spw is not
    efficiency: antenna efficiency (on a scale from 0 to 1.0),
                 if None: then use au.antennaEfficiency() with surfaceRms
    spw: the spw to use if vis is specified
    beamFwhm: the beamsize to use instead of 1.13 lambda/D
    beamFwhmFactor: the coefficient (C) to use in C*lambda/D
    telescopeDiameter: telescope diameter (meters)
    surfaceRms: in microns, only used if efficiency==None
    """
    if (vis == None):
        if (frequency==None):
            print "Must give either vis or frequency"
            return
        if (body==''):
            print "Must give either vis or frequency"
            return
    elif (os.path.exists(vis) == False):
        print "Cannot find measurement set = ", vis
        return
    if (frequency==None):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        if (spw == None):
            spws = np.intersect1d(mymsmd.spwsforintent(intent), getNonWvrSpws(mymsmd))
            if (len(spws) < 1):
                print "No spws with %s intent" % (intent)
                return
            spw = spws[0]
        frequency = mymsmd.meanfreq(int(spw))
        mymsmd.close()
    if (body==''):
        body = getModelPlanetFromVis(vis)
        if (body==''):
            print "No valid bodies with models found in measurement set."
            return
    if (type(frequency)==str):
        frequency = parseFrequencyArgument(frequency)
    elif (frequency < 10000):
        frequency *= 1e9
    frequencyGHz = frequency * 1e-9
    planetDir = os.getenv("CASAPATH").split()[0]+"/data/alma/SolarSystemModels"
    filelist = glob.glob(planetDir+"/*_Tb.dat")
    myfile = None
    for f in filelist:
        if (f.upper().find(body.upper()) >= 0):
            myfile = f
    if (myfile == None):
        print "There is no model for this object in CASA."
        return
    f = open(myfile,'r')
    ghz = []
    kelvin = []
    for line in f.readlines():
        a,b = line.strip().split()
        ghz.append(float(a))
        kelvin.append(float(b))
    f.close()
    # simply find the closest entry (for now)
    fdiff = list(abs(np.array(ghz) - frequencyGHz) )
    index = fdiff.index(min(fdiff))
    Tplanet = kelvin[index]
    if (angularDiameter == None):
        if (vis != None):
            data1 = planet(vis=vis, useJPL=useJPL)
            angularDiameter = data1['angularDiameter']
        elif (date != ''):
            data1 = planet(body,date=date, useJPL=useJPL)
            angularDiameter = data1['angularDiameter']
        else:
            print "No angularDiameter defined for the body."
            return
        print "Angular diameter of %s = %.3f arcsec" % (body,angularDiameter)
    planetArea = np.pi*(angularDiameter*0.5)**2
    if (beamFwhm==None):
        beam = primaryBeamArcsec(frequency=frequencyGHz,
                                 diameter=telescopeDiameter,
                                 fwhmfactor=beamFwhmFactor)
        if (beam == None): return
    else:
        beam = beamFwhm
    print "telescope Gaussian beam FWHM at %.1f GHz = %.3f arcsec" % (frequencyGHz, beam)
    beamArea = np.pi*(beam*0.5)**2 
    coupling = diskCoupling(planetArea,beamArea)
    print "coupling factor between %.3f arcsec disk and Gaussian beam = %f" % (angularDiameter, coupling)
    if (efficiency == None):
        efficiency = antennaEfficiency(frequency, surfaceRms)
    print "antenna efficiency assumed = %f" % (efficiency)
    Tb = Tplanet * coupling * efficiency
    print "%s model temperature = %.3f K" % (body,Tplanet)
    print "expected brightness temperature = %.3f K" % (Tb)
    fluxDensity = planetFlux(body,date=date,frequency=frequency,vis=vis,
                             spw=spw)['fluxDensity']
    print "total planet flux = %f Jy" % (fluxDensity)
    print "total flux / expected Tb = %f Jy/K (assuming no image regridding)" % (fluxDensity/Tb)
    return(Tb)
    
def planetFlux(body='', date=None, mjd=None, frequency=345e9, bandwidth=1e6, 
               dayIncrement=1.0, plotfile=None, verbose=False, observatory='ALMA',
               timeUnits='MJD', rotation=60, fontsize=8, hspace=0.4, bottom=0.2,
               vis=None, spw=None, separation=False, secondFrequency=None):
    """
    A wrapper for testing Bryan Butler's solar_system_fd() function.
    Makes a plot of flux density vs. time,  or vs. frequency if a range of dates
    or frequencies is requested.

    Parameters:
    body: To see the list of supported planets, type help(au.sss.solar_system_fd)
    mjd: default=now; otherwise, a single value or a list of 1 or 2 MJDs (2 = a range)
    date: string of format: 2011/10/15, 2011/10/15 05:00:00, or 2011/10/15-05:00:00
    frequency: a single value or string with units, or a list of 1 or 2 frequencies in Hz
              (a list of 2 is interpreted as a range)
    bandwidth: define the bandwidth at a single frequency or the increment for
               the range (in Hz): floating point, or string with units
    dayIncrement: define the MJD increment for the plot
    plotfile: specify the output png name, None=use default name
    timeUnits: when x-axis is time, set the units: 'MJD' (default) or 'YMD'
    rotation: the angle of the x-axis tick labels (for timeUnits='YMD')
    fontsize: the font size of the x-axis tick labels (for timeUnits='YMD')
    hspace: the hspace value for pylab.subplots_adjust (for timeUnits='YMD')
    wspace: the wspace value for pylab.subplots_adjust (for timeUnits='YMD')
    vis: the name of an ms from which to grab the start time and body name
    spw: the spw for which to use the mean frequency instead of the frequency parameter
    separation: if True, then for Jovian moons or Titan, compute separations
    secondFrequency: if specified, then a plot of flux vs. time will be a flux1/flux2 ratio

    Return value:
        if a plot is computed: nothing
        if single value computed:  a dictionary containing the following keys and units:
          {'fluxDensity': Jy, 'direction', 'majorAxis': arcsec, 'minorAxis': arcsec,
          'positionAngle': deg, 'frequency': [Hz,Hz], 'bandwidth': Hz, 'body': name,
          'meanFrequency': Hz}

    Example: plot Neptune's flux density in ALMA Band 7:
      au.planetFlux('Neptune',mjd=55600, frequency=[275e9,373e9], bandwidth=1e9)

    - Todd Hunter
    """
    if (body[-3:] == '.ms'):
        print "If you want to specify an ms, use the vis parameter."
        return
    timeUnitsAllowed = ['MJD','YMD']
    data1 = None
    if (mjd==None and date==None):
        if (vis==None):
            # use current MJD
            mjd = getMJD()
            date = mjdToUT(float(mjd))
            print "No MJD or date specified, assuming right now=%s." % (date)
        else:
            date = getObservationStartDate(vis).split(' UT')[0]
    if (useSolarSystemSetjy == False):
        print "This version of CASA does not contain the solar_system_setjy module."
        return
    bandwidth = parseFrequencyArgumentToHz(bandwidth)
    if (type(frequency) != list):
        if (type(frequency) == str):
            frequency = [[parseFrequencyArgumentToHz(frequency)-0.5*bandwidth,
                          parseFrequencyArgumentToHz(frequency)+0.5*bandwidth]]
        else: # it's an int or float
            frequency = [[parseFrequencyArgumentToHz(frequency)-0.5*parseFrequencyArgumentToHz(bandwidth),
                          parseFrequencyArgumentToHz(frequency)+0.5*parseFrequencyArgumentToHz(bandwidth)]]
    elif (type(frequency[0]) != list):
        if (len(frequency) == 1):
            frequency = [[frequency[0]-0.5*bandwidth, frequency[0]+0.5*bandwidth]]
        else:
            frequency = [frequency]
    elif (len(frequency[0]) == 1):
        frequency = [[frequency[0][0]-0.5*bandwidth,frequency[0][0]+0.5*bandwidth]]
    if (secondFrequency != None):
        if (type(secondFrequency) != list):
            if (type(secondFrequency) == str):
                secondFrequency = [[parseFrequencyArgumentToHz(secondFrequency)-0.5*bandwidth,
                              parseFrequencyArgumentToHz(secondFrequency)+0.5*bandwidth]]
            else: # it's an int or float
                secondFrequency = [[parseFrequencyArgumentToHz(secondFrequency)-0.5*parseFrequencyArgumentToHz(bandwidth),
                              parseFrequencyArgumentToHz(secondFrequency)+0.5*parseFrequencyArgumentToHz(bandwidth)]]
        elif (type(secondFrequency[0]) != list):
            if (len(secondFrequency) == 1):
                secondFrequency = [[secondFrequency[0]-0.5*bandwidth, secondFrequency[0]+0.5*bandwidth]]
            else:
                secondFrequency = [secondFrequency]
        elif (len(secondFrequency[0]) == 1):
            secondFrequency = [[secondFrequency[0][0]-0.5*bandwidth,secondFrequency[0][0]+0.5*bandwidth]]


    if (vis != None and spw != None):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        if (spw >= mymsmd.nspw()):
            print "spw not in ms.  Available = ", range(mymsmd.nspw())
            return
        try:
            bandwidth = mymsmd.bandwidths(int(spw))  # This is a fairly new function
        except:
            bandwidth = mymsmd.chanwidths(int(spw))[0] * mymsmd.nchan(int(spw))
        frequency = [[mymsmd.meanfreq(int(spw))-0.5*bandwidth, mymsmd.meanfreq(int(spw))+0.5*bandwidth]]
        mymsmd.close()
    if (verbose):
        print "frequency = ", frequency
    if (date != None):
        if (type(date) == list):
            mjd1 = dateStringToMJD(date[0],verbose=False)
            if (mjd1 == None):
                return
            if (len(date) > 1):
                mjd2 = dateStringToMJD(date[1],verbose=False)
                if (mjd2 == None):
                    return
                mjd = [mjd1,mjd2]
            else:
                mjd = [mjd1]
        else:
            if (len(date.split('-')) > 3):
                # This is needed to accept 2010-01-01-12:00:00'
                # by making it look like 2010-01-01 12:00:00'
                date = date[0:10] + ' ' + date[11:]
            mjd = dateStringToMJD(date,verbose=False)
            if (mjd == None):
                return
    if (body==''):
        if (vis == None):
            print "Must specify either a body or a vis"
            return
        if (os.path.exists(vis) == False):
            print "Could not find measurement set"
            return
        body = getModelPlanetFromVis(vis)
        if (body==None):
            print "No valid bodies with models found in measurement set."
            return
    if (type(mjd) != list):
        mjd = [float(mjd)]
    if ((frequency[0][1]-frequency[0][0]) <= bandwidth):
        if (len(mjd) == 1):
            if (verbose):
                print "Calling call_solar_system_fd(%s, MJDs=%s, frequencies=%s, observatory='%s')" % (body,str(mjd),str(frequency),observatory)
            (status,flux,uncertainty,size,direction) = call_solar_system_fd(body, MJDs=mjd, frequencies = frequency, observatory=observatory)
            if (verbose):
                print "Done"
            if (status[0][0] == 0):
                # Just print the flux density
                if (verbose):
                    print "Flux density at %.3f GHz averaged over a %.3f GHz bandwidth is %f Jy." % (np.mean(frequency[0])*1e-9, (frequency[0][1]-frequency[0][0])*1e-9, flux[0][0])
                    print "J2000 Position = %s" % (direction2radec(direction[0]))
                    print "size = ", size
                mydict = {'fluxDensity': flux[0][0], 'direction': direction[0], 'majorAxis': size[0][0],
                          'minorAxis': size[0][1], 'positionAngle': size[0][2], 'frequency': frequency[0],
                          'bandwidth': bandwidth, 'body': body, 'meanFrequency': np.mean(frequency[0])}
            else:
                print parseSSSerror(status[0][0],body)
                return
        else:
            # Make a plot of flux and major axis vs. time
            if (timeUnits not in timeUnitsAllowed):
                print "timeUnits must be one of: %s" % (str(timeUnitsAllowed))
                return
            if (mjd[0] >= mjd[1]):
                print "The start MJD must be earlier than the end MJD."
                return
            mjd = np.arange(mjd[0], mjd[1], dayIncrement)
            if (body.lower()=='mars'):
                timeEstimate = len(mjd)*3/2
                if (secondFrequency != None): timeEstimate = len(mjd)*3
                print "On a decent machine, this will take about %d seconds" % (timeEstimate)
            (status,flux,uncertainty,size,direction) = call_solar_system_fd(body, MJDs=mjd, frequencies = frequency, observatory=observatory)
            if (secondFrequency != None):
                (status,fluxdensitySecond,uncertaintySecond,size,direction) = \
                    call_solar_system_fd(body, MJDs=mjd, frequencies=secondFrequency, observatory=observatory)
                flux = np.array(flux)/np.array(fluxdensitySecond)
            if (status[0][0] != 0):
                print parseSSSerror(status[0][0],body)
                return
            pb.clf()
            adesc = pb.subplot(211)
            flux = [item for sublist in flux for item in sublist]
            # should have option to use pb.plot_date
            if (timeUnits == 'MJD'):
                pb.plot(mjd, flux, 'b-')
                pb.xlabel('Date (MJD)')
                adesc.xaxis.set_major_formatter(ScalarFormatter(useOffset=False))
            else:
                pb.subplots_adjust(hspace=hspace, bottom=bottom)
                pb.plot_date(pb.date2num(mjdListToDateTime(mjd)),flux,'b-')
                pb.xlabel('Date')
                pb.setp(pb.xticks()[1], rotation=rotation, fontsize=fontsize)
            adesc.yaxis.set_major_formatter(ScalarFormatter(useOffset=False))
            if (secondFrequency != None):
                pb.ylabel('Flux density ratio')
                pb.title(body+' at %.3f/%.3f GHz (BW=%.3fGHz)'%(np.mean(frequency[0])*1e-9, 
                                                                np.mean(secondFrequency[0])*1e-9, 
                                                                bandwidth*1e-9))
            else:
                pb.ylabel('Flux density (Jy)')
                pb.title(body+' at %.3f GHz (BW=%.3fGHz)'%(np.mean(frequency[0])*1e-9, bandwidth*1e-9))
            adesc.xaxis.grid(True,which='major')
            adesc.yaxis.grid(True,which='major')

            adesc = pb.subplot(212)
            majoraxis = np.transpose(size)[0]
            if (timeUnits == 'MJD'):
                pb.plot(mjd, majoraxis, 'b-')
                pb.xlabel('Date (MJD)')
                adesc.xaxis.set_major_formatter(ScalarFormatter(useOffset=False))
            else:
                pb.plot_date(pb.date2num(mjdListToDateTime(mjd)),majoraxis,'b-')
                pb.xlabel('Date')
                pb.setp(pb.xticks()[1], rotation=rotation, fontsize=fontsize)
            pb.ylabel('Major axis (arcsec)')
            adesc.xaxis.grid(True,which='major')
            adesc.yaxis.grid(True,which='major')
            if (plotfile == None):
                if (secondFrequency == None):
                    plotfile = body+'.fluxvstime.%gGHz.%d-%d.png'%(np.mean(frequency[0])*1e-9,mjd[0],mjd[-1])
                else:
                    plotfile = body+'.fluxratiovstime.%gGHz.%gGHz.%d-%d.png'%(np.mean(frequency[0])*1e-9,np.mean(secondFrequency[0])*1e-9,mjd[0],mjd[-1])
            pb.savefig(plotfile)
            print "Plot left in ", plotfile
            pb.draw()
            return
    elif (len(mjd) < 7):
        # Make a plot of flux vs. frequency
        mjdstring = ''
        colors = ['k','b','r','g','c','m']
        pb.clf()
        adesc = pb.subplot(111)
        for i in range(len(mjd)):
            mymjd = mjd[i]
            if (mjdstring != ''): mjdstring += ', '
            if ((frequency[0][1]-frequency[0][0])/bandwidth > 10000):
                print "You are asking for over 10000 channels of width %f Hz.  Aborting" % (bandwidth)
                return
            (freqGHz, fluxdensity) = call_solar_system_fd(body, MJDs=[mymjd], 
                                                          frequencies=[frequency[0][0], frequency[0][1], bandwidth], 
                                                          observatory=observatory)
            pb.plot(freqGHz, fluxdensity, '%s-'%(colors[i]))
            mjdstring += '%.1f' % (mymjd)
            if (len(mjd) > 1):
                pb.text(0.04,0.94-0.04*i, '%.1f = %s'%(mymjd,mjdToUT(mymjd).split()[0]),color=colors[i],transform=adesc.transAxes,size=10)
            pb.hold(True)
        pb.xlabel('Frequency (GHz) (channel width = %g MHz)'%(bandwidth*1e-6))
        pb.ylabel('Flux density (Jy)')
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        pb.title(body+' at MJD=%s'%(mjdstring))
        if (plotfile == None):
            plotfile = body+'.fluxvsfreq.%d-%dGHz.png'%(int(freqGHz[0]),int(freqGHz[-1]))
        pb.savefig(plotfile)
        print "Plot left in ", plotfile
        pb.draw()
        return
    else:
        print "More than 6 MJDs and multiple frequencies are not supported."
        return
    if (separation):
        jovianMoons = ['ganymede','callisto','io','europa']
        if (body.lower() == 'titan'):
            if (data1 == None):
                data1 = planet(body, date=date, observatory=observatory, useJPL=True, 
                               verbose=verbose, vis=vis, mjd=mjd)
            data2 = planet('Saturn', date=date, observatory=observatory, useJPL=True, 
                           verbose=verbose,vis=vis,mjd=mjd)
            rad = angularSeparationRadians(data1['directionRadians'][0], 
                                           data1['directionRadians'][1], 
                                           data2['directionRadians'][0], 
                                           data2['directionRadians'][1])
            print "Separation with Saturn = %g rad = %g deg = %g arcsec" % (rad, rad*180/math.pi, rad*3600*180/math.pi)
        elif (body.lower() in jovianMoons):
            if (data1 == None):
                data1 = planet(body, date=date, observatory=observatory, useJPL=True, 
                               verbose=verbose, vis=vis, mjd=mjd)
            jovianMoons.remove(body.lower())
            for otherBody in ['Jupiter']+jovianMoons:
                data2 = planet(otherBody, date=date,observatory=observatory,useJPL=True, 
                               verbose=verbose,vis=vis,mjd=mjd)
                rad = angularSeparationRadians(data1['directionRadians'][0], 
                                               data1['directionRadians'][1], 
                                               data2['directionRadians'][0], 
                                               data2['directionRadians'][1])
                print "Separation with %s = %g rad = %g deg = %g arcsec" % (otherBody, rad, rad*180/math.pi, rad*3600*180/math.pi)
    return(mydict)

def jplVsCasa(body='',date=''):
   jpl_pos = planet(body,date,useJPL=True)['directionRadians']
   casa_pos = planet(body,date,useJPL=False)['directionRadians']
   separation = angularSeparationRadiansTuples(jpl_pos,casa_pos)
   print "difference = %f radian = %f arcsec" % (separation, separation*180*3600/np.pi)
   return(separation)

def planet(body='',date='',observatory=JPL_HORIZONS_ID['ALMA'],
           verbose=False, help=False, mjd=None,
           beam='',useJPL=True, standard=defaultEphemeris, subroutine=False,
           apparent=False, vis='', bodyForScan='', scan='',
           savefig='', showplot=False, antennalist='',frequency=345.0):
    """
    This function returns the position and angular size of any Solar System
    body. If useJPL=True (default), it queries the JPL Horizons telnet server
    for exact positions as viewed from the specified observatory.
    If useJPL=False, it will first try to use the casa ephemerides
    (default='Butler-JPL-Horizons 2010').  Note that the casa tables are 
    quantized to one day. If the casa tables fail
    for any reason, it will automatically revert to using JPL's server.
    The dictionory returned is:
      data['directionRadians']
      data['angularDiameter']
      data['rateRadiansPerSecond'] (only present if useJPL=True)
      data['rangeRateKms'] (only present if useJPL=True)
      data['rangeAU'] (only present if useJPL=True)
    body: string name of Solar system body
    date: one possible format of the date string is: '2011-10-31 11:59:59'
    mjd: floating point MJD (alternative to specifying a date string)
    observatory: string name or JPL integer ID (run planet(help=True) for a list)
    beam: FWHM of the observing beam in arcsecs
    standard: the name of the ephemeris table to use (if useJPL=False)
    apparent: get the apparent coordinates rather than J2000
    vis: the name of an ms from which to grab the start time as the date
    bodyForScan: the fieldname in vis to pick the date/time of the first scan
    scan: if not '', then use this scan number, if it is a scan on the body
    savefig: if a filename is given, then use antennalist to generate a visibility plot
    showplot: if True, then use antennalist to generate a visibility plot
    antennalist: if an antenna configuration file is given, then use this one,
          otherwise build a temporary one from the specified measurement set
    frequency: the frequency to use in predictcomp
   
    For further help and examples, run au.planet(help=True) or
    see https://safe.nrao.edu/wiki/bin/view/ALMA/Planet
    -- Todd Hunter
    """
    if (help):
        print "This function returns the position and angular size of any "
        print "Solar System body for the specified date from the specified observatory."
        print "Usage: planet(solarSystemBody, date, observatory='%s', verbose=False," % (JPL_HORIZONS_ID['ALMA'])
        print "              beam='', useJPL=True, standard='%s', apparent=False)"%(defaultEphemeris)
        print "  body: string name of Solar system body"
        print "  date: one possible format of the date string is: '2011-10-31 11:59:59'"
        print "    or simply '2011-10-31' for 0:00 UT. A list of allowed formats for date"
        print "    is at:   http://ssd.jpl.nasa.gov/?horizons_doc#time"
        print "    An alternative is to specify the name of an ms."
        print "  mjd: floating point MJD (alternative to specifying a date string)"
        print "  useJPL: if False, first try the casa ephemerides.  Note that the casa tables"
        print "    are quantized to one day, and can be in error by many arcminutes. If the "
        print "    casa tables fail for any reason, it will automatically revert to using "
        print "    JPL's server.  It may require a few seconds to reach the JPL server."
        print "  observatory: Observatories can be specifed by JPL ID string, or by the "
        print "    following names:"
        for n in JPL_HORIZONS_ID:
            print "     '%s' (which will be converted to = '%s')" % (n, JPL_HORIZONS_ID[n])
        print "     '500' (which will be converted to = 'Geocentric')"
        print "  beam:  If a beam size is included (in arcsec), the expected FWHM will be"
        print "    computed using scipy.signal.convolve() of a Gaussian with a uniform disk."
        print "  apparent: False = the return values are J2000 values as seen from the specified observatory"
        print "  apparent: True = the return values are apparent values as seen from the specified observatory"
        print "  vis: the name of an ms from which to grab the start time as the date"
        print "The dictionary returned is:"
        print "  data['directionRadians']"
        print "  data['angularDiameter']"
        print "  data['rateRadiansPerSecond'] (only present if useJPL=True)"
        print "  data['rangeRateKms'] (only present if useJPL=True)"
        print "  data['rangeAU'] (only present if useJPL=True)"
        return

    if (apparent and useJPL==False):
        print "You cannot request apparent=True with useJPL=False. CASA contains only one coordinate set."
        return
    if (useJPL == False and (body.lower() == 'io' or body.lower()=='europa')):
        print "WARNING: the casa ephemerides are too coarsely sampled for this rapidly moving moon!"
    if (antennalist == '' and vis=='' and (showplot==True or savefig!='')):
        print "To generate a uv plot, you must either specify the name of vis or an antennalist file."
        return
    if ((showplot==True or savefig!='') and useJPL):
        print "To generate a uv plot, you must set useJPL=False."
        return
    if (antennalist != ''):
        if (os.path.exists(antennalist) == False):
            repotable=os.getenv("CASAPATH").split()[0]+"/data/alma/simmos/"
            if (antennalist[-4:] != '.cfg'):
                antennalist += '.cfg'
            if (os.path.exists(repotable+antennalist) == False):
                print "Could not find antennalist file: %s" % (antennalist)
                return
    foundObservatory  = False
    if (type(frequency) == str):
        frequency = float(frequency)
    if (type(observatory) == int):
        observatory = str(observatory)
    elif (type(observatory) == str):
        if (len(observatory) < 1):
            observatory = 'ALMA'
        if (observatory.upper() == 'SMA'):
            observatory = 'MAUNAKEA'
    for n in JPL_HORIZONS_ID:
        if (n.find(observatory) >= 0 or (len(observatory)>2 and observatory.find(n) >= 0)):
            observatory = JPL_HORIZONS_ID[n]
            if (verbose):
                print "Using observatory: %s = %s" % (n, JPL_HORIZONS_ID[n])
            foundObservatory  = True
            break
    if (body[-3:] == '.ms'):
        print "If you want to specify an ms, use the vis parameter."
        return
    if (foundObservatory == False):
        if (observatory.lower().find('geocentric') >= 0):
            observatory = 500
        try:
            o = int(observatory)
            key = []
            try:
                key = find_key(JPL_HORIZONS_ID,observatory)
            except:
                if (key == []):
                    print "Using observatory: %s" % (observatory)
                else:
                    print "Using observatory: %s = %s" % (observatory,key)
                
        except:
            print "Unrecognized observatory = %s" % (observatory)
            print "For a list of codes, see http://ssd.jpl.nasa.gov/horizons.cgi#top"
            return
    if (len(date) < 1 and (vis==None or vis=='')):
        if (mjd == None):
            mjd = getMJD()
            date = mjdToUT(float(mjd))
            print "No date/time or visibility.ms specified, assuming right now=%s" % (date)
        else:
            date = mjdToUT(float(mjd))
            print "Converted MJD=%f to %s" % (mjd,date)
    if (vis != None and vis != ''):
        if (os.path.exists(vis)):
            if (bodyForScan == ''):
                bodyForScan = body
            elif (body == ''):
                body = bodyForScan
            if (bodyForScan == ''):
                # then look for planet names
                fields = getFields(vis)
                fieldsUpperCase = [x.upper() for x in fields]
                checkObjects = ['MERCURY','VENUS','MARS','CERES','PALLAS','VESTA','JUPITER','SATURN',
                                'TITAN','CALLISTO','GANYMEDE','IO','EUROPA','URANUS','NEPTUNE','PLUTO']
                for object in checkObjects:
                    if (object in fieldsUpperCase):
                        bodyForScan = object
                        body = bodyForScan
                        break
                if (bodyForScan == ''):
                    print "No common planets found in the ms. You must specify the body as the first argument."
                    return
            fields = getFields(vis)
            fieldsUpperCase = [x.upper() for x in fields]
            if (bodyForScan.upper() in fieldsUpperCase):
                bodyForScan = fields[fieldsUpperCase.index(bodyForScan.upper())]
                try:
                    mymsmd = createCasaTool(msmdtool)
                    mymsmd.open(vis)
                    scans = mymsmd.scansforfield(bodyForScan)
                    usescan = scans[0]
                    if (scan != ''):
                        scan = int(scan)
                        if (scan in scans):
                            usescan = scan
                            print "Got date from scan %d on %s using msmd" % (usescan, bodyForScan)
                        else:
                            print "Scan %d is not a scan on %s" % (scan, bodyForScan)
                            print "Got date from the first scan on %s (scan %d) using msmd" % (bodyForScan, usescan)
                    else:
                        print "Got date from the first scan on %s (scan %d) using msmd" % (bodyForScan, usescan)
                    mytime = mymsmd.timesforscan(usescan)[0]
                except:
                    print "Getting date from the scan on %s using ValueMapping" % (bodyForScan)
                    vm = ValueMapping(vis)
                    scans = vm.getScansForField(bodyForScan)
                    usescan = scans[0]
                    if (scan != ''):
                        scan = int(scan)
                        if (scan in scans):
                            usescan = scan
                            print "Got date from scan %d on %s" % (usscan, bodyForScan)
                        else:
                            print "Scan %d is not a scan on %s" % (scan, bodyForScan)
                            print "Got date from the first scan on %s (scan %d)" % (bodyForScan, usescan)
                    else:
                        print "Got date from the first scan on %s (scan %d)" % (bodyForScan, usescan)
                    mytime = vm.getTimesForScan(usescan)[0]
                scan = ' from scan %d' % (usescan)
            else:
                scan = ''
                print "Did not find %s in %s" % (bodyForScan.upper(), fieldsUpperCase)
                print "Getting date from the start time of ms"
                mytime = getObservationStart(vis)
            obsdateString = mjdsecToUT(mytime)
            date = obsdateString[:-3]
            print "Got date%s: %s" % (scan,date)
            mjd = mytime/86400.
            epoch = mjdToPredictcomp(mjd)
        else:
            print "Could not open vis = %s" % (vis)
            return
    if (len(body) > 0):
        while (body[-1] == ' ' and len(body) > 0):
            body = body[0:-1]
    else:
        print "You must specify body, or vis and bodyForScan"
        return
    try:
        if (useJPL==False and usePredictComp and
            (observatory in JPL_HORIZONS_ID.keys() or
             observatory in JPL_HORIZONS_ID.values())):
            if (mjd == None):
              if (vis == ''):
                # Need to convert date string to be acceptable to predictcomp
                if (len(date.split()) == 1 and len(date.split()[0])<=10):
                    # only the date was specified, add 0h UT
                    if (verbose): print "Appending 0h"
                    epoch = date + '-00:00:00'
                elif (len(date.split()) > 1):
                    if (verbose): print "Forcing delimiter to be a -"
                    epoch = date.split()[0] + '-' + date.split()[1]
                else:
                    if (date[10] != '-' and date[10] != '/'):
                        if (verbose): print "Changing delimiter to -"
                        epoch = date[0:10] + '-' + date[11:]
                    else:
                        if (verbose): print "Format okay"
                        epoch = date
                mjd = dateStringToMJD(epoch,verbose=False)
            else:
                # convert MJD from command-line, or ms, into a date
                # string for predictcomp
                if (verbose): print "Calling mjdToPredictcomp(%f)" % (mjd)
                epoch = mjdToPredictcomp(mjd)
            if (verbose): print "Using epoch = ", epoch
            
            data = {}
            if (type(imtool) == type):   # casa 4.0.0
                print "Using casa's ephemerides for %s. These are in J2000 coordinates in this casa version (>=4.0.0)" % (body)
                myme = metool()
            else:  # casa 3.x
                print "Using casa's ephemerides for %s. Note these are in apparent coordinates in this casa version (<=3.4)." % (body)
                myme = metool.create()
            if (verbose): print "metool created"
            mepoch = myme.epoch('UTC',epoch) # This ignores the hours portion.
            result =  epoch.split()
            if (len(result) > 1):
                result = result[1].split(':')
                hours = 0
                if (len(result) > 0):
                    hours += int(result[0])
                if (len(result) > 1):
                    hours += int(result[1]) / 60.
                if (len(result) > 2):
                    hours += int(result[2]) / 3600.
                if (verbose):
                    print "Adding %f days" % (hours/24.)
                mepoch['m0']['value'] = mepoch['m0']['value'] + hours/24.
            if (antennalist == '' and (showplot or savefig!='')):
                # create a configuration file from the ms
                antennalist = '/tmp/%s.cfg'%(os.path.basename(vis))
                buildConfigurationFile(vis=vis, output=antennalist)
            if (antennalist != '' and savefig == ''):
                if (vis != ''):
                    savefig = os.path.basename(vis) + '.%s.predictcomp.png' % (body)
                else:
                    savefig = body + '.predictcomp.png'
            if (verbose):
                print "Running predictcomp('%s',standard='%s',epoch='%s', minfreq='345e9Hz', prefix='/tmp/', nfreqs=1, showplot=%s, savefig='%s', antennalist='%s')" % (body,standard,epoch,showplot,savefig,antennalist)
            dirlist = os.listdir('.')
            d = predictcomp(objname=body, standard=standard,
                            epoch=epoch, minfreq='%fGHz'%(frequency),
                            prefix='/tmp/',nfreqs=1,showplot=showplot,savefig=savefig,antennalist=antennalist)
            if (d == None):
                print "Cannot run predictcomp if you don't have write permission in the working directory."
            if (antennalist != ''):
                print "Figure saved in %s" % (savefig)
            dirlist2 = os.listdir('.')
            # remove the .cl file created by predictcomp
            for myfile in dirlist2:
                if (myfile not in dirlist and myfile[-3:] == '.cl'):
                    os.system('rm -rf %s' % myfile)
            data['angularDiameter'] = d['shape']['majoraxis']['value']
            if (d['shape']['majoraxis']['unit'] == 'arcmin'):
                data['angularDiameter'] *= 60
            if (antennalist != ''):
                percentage = getBaselineStats(config=antennalist,
                                       angularSize=data['angularDiameter'],
                                       frequency=frequency,verbose=False)[0]
                print "Percentage of baselines shorter than this angular scale at %.1f GHz = %.3f" % (frequency,percentage)
            data['directionRadians'] = [d['shape']['direction']['m0']['value'],
                                        d['shape']['direction']['m1']['value']]
            directionDegrees = [data['directionRadians'][0]*180/math.pi,
                                data['directionRadians'][1]*180/math.pi
                                ]
            directionRadians = [d['shape']['direction']['m0']['value'],
                                d['shape']['direction']['m1']['value']]
            if (apparent):
                coords = 'Apparent Position'
            else:
                coords = 'J2000 Position'
            if (verbose): print "computeAzElFromRADecMJD is using mjd = ", mjd
            azim, elev = computeAzElFromRADecMJD(directionRadians, mjd, observatory=observatory,verbose=False)
            azim *= 180/np.pi
            elev *= 180/np.pi
            print '%s: %s, %s   Azim, Elev: %.3f, %.3f' % (coords,qa.formxxx('%.12fdeg'%directionDegrees[0],format='hms',prec=5),
                                  qa.formxxx('%.12fdeg'%directionDegrees[1],format='dms',prec=4).replace('.',':',2), azim, elev)
        else:
            if (useJPL==False and (observatory in JPL_HORIZONS_ID.keys() or observatory in JPL_HORIZONS_ID.values())
                and usePredictComp==False):
                print "Will not use casa because predictcomp module is missing."
            if (useJPL==False and usePredictComp):
                print "Will not use casa for observatory=", observatory
            raise
    except:
        fp = FixPosition()
        if (verbose):
            print "Contacting JPL Horizons for %s" % (body)
        data = fp.getRaDecSize(body, date, observatory, verbose, apparent)
    if (data['angularDiameter'] != []):
        if (verbose):
            print "Angular diameter (major axis) = %f arcsec" % (data['angularDiameter'])
        if (beam != ''):
            expectedFWHM = computeExpectedFWHM(float(beam),data['angularDiameter'])
            print 'The expected FWHM with a %.2f" beam is %.2f".' % (float(beam),expectedFWHM)
        if (antennalist != ''):
            percentage = getBaselineStats(config=antennalist,
                                       angularSize=data['angularDiameter'],
                                       frequency=frequency,verbose=False)[0]
            print "Percentage of baselines shorter than this angular scale at %.1f GHz = %.3f" % (frequency,percentage)
    else:
        print "Angular diameter is not available."
    return(data)

def columnStatistics(filename, column, startline=0, delimiter=None):
    """
    Compute basic statistics on one column of an ASCII file.
    column: column number, starting at zero
    startline: starting line, starting from zero
    delimiter: the character(s) that separate columns (default is
               whitespace)
    Returns: mean, median, min, max, std, MAD*.6745, 25%ile, 75%ile
    -- Todd Hunter
    """
    f=open(filename,'r')
    x = []
    for i,line in enumerate(f.readlines()):
        if (i >= startline):
            tokens = line.split(delimiter)
            x.append(float(tokens[column]))
    percentile25 = scoreatpercentile(x, 25)
    percentile75 = scoreatpercentile(x, 75)
    print "Mean=%f, Median=%f, Min=%f, Max=%f, St.Dev=%f\nMAD*0.6745=%f, 25%%ile=%f, 75%%ile=%f" % (np.mean(x),np.median(x),np.min(x),np.max(x),np.std(x),MAD(x),percentile25,percentile75)
    return(np.mean(x),np.median(x),np.min(x),np.max(x),np.std(x),MAD(x),
           percentile25,percentile75)
    
def getxyFromFile(filename,xcol,ycol,delimiter=None,maxLines=None):
    """
    Gets two columns of numeric data from an ASCII file, as numpy arrays.
    xcol: the column number from which to read x-axis data
    ycol: the column number from which to read y-axis data
    If a colon is seen in the xcol data, then assume both columns are
       a sky position in sexagesimal format and convert them to radians.
    delimiter: the string that delimits columns within a row
               (default = None which means whitespace)
    -Todd Hunter
    """
    f = open(filename,'r')
    x = []
    y = []
    for i,line in enumerate(f.readlines()):
        if (len(line.strip()) == 0): continue
        if (line.strip()[0] == '#' or line.strip()[0] == '/'): continue
        if (line.find('Source') >= 0): continue
        tokens = line.strip().split(delimiter)
        if (len(tokens) < xcol or len(tokens) < ycol):
            print "Skipping row %d because there are only %d columns." % (i,len(tokens))
            continue
        # support either 0-based or 1-based column specification
        if (len(tokens) == xcol):
            xcol -= 1
        if (len(tokens) == ycol):
            ycol -= 1
        if (tokens[xcol].find(':') > 0):
            rarad,decrad = radec2rad(tokens[xcol]+' '+tokens[ycol])
            x.append(rarad)
            y.append(decrad)
        else:
            x.append(float(tokens[xcol]))
            y.append(float(tokens[ycol]))
        if (len(x) == maxLines):
            print "Stopping after reading %d data lines from %d file lines" % (maxLines,i+1)
            break
    f.close()
    return np.array(x),np.array(y)

def interpolateTable(filename, xcol, ycol, xvalue, delimiter=None):
    """
    Perform a spline interpolation on a table of data from an ASCII file.
    filename: an ascii file with 2 or more columns that are space-delimited
    xcol: the column number to use for x
    ycol: the column number to use for y
    xvalue: the value of x for which you want to determine y
    delimiter: the string that delimits columns within a row (default = None
               which means whitespace)
    -Todd Hunter
    """
    if (os.path.exists(filename) == False):
        print "File not found"
        return
    x,y = getxyFromFile(filename,xcol,ycol,delimiter)
    if (len(x) < 2):
        print "Not enough data found"
        return
    spline = scipy.interpolate.UnivariateSpline(x, y, s=0)
    return(spline(xvalue))
    
def findZeroCrossing(x,y):
    spline = scipy.interpolate.UnivariateSpline(x, y, s=0)
    x0 = spline.roots()
    if (len(x0) > 0):
        return(x0)
    else:
        return([])
    
def findFWHM(x,y,level=0.5, s=0):
    """
    Measures the FWHM of the specified profile.  This works
    well in a noise-free environment.  The data are assumed to
    be sorted by the x variable.
    x: the position variable
    y: the intensity variable
    level: the signal level for which to find the full width
    s: see help scipy.interpolate.UnivariateSpline
    -Todd Hunter
    """
#    idx = np.argsort(x)
#    x = np.array(x)[idx]
#    y = np.array(y)[idx]
    halfmax = np.max(y)*level
    spline = scipy.interpolate.UnivariateSpline(x, y-halfmax, s=s)
    result = spline.roots()
    if (len(result) == 2):
        x0,x1 = result
        return(abs(x1-x0))
    elif (len(result) == 1):
        return(2*result[0])
    else:
#        print "Warning: reducing %d roots into one (%s -> %f)" % (len(result),str(result),np.median(result))
#        result = 2*np.median(result)
        print "More than two crossings (%d), fitting slope to points near that power level." % (len(result))
#        result = 2*findMedianZeroCrossing(x, y-halfmax)
        result = 2*findZeroCrossingBySlope(x, y-halfmax)
        return(result)

def findMedianZeroCrossing(x, y):
    """
    Finds the x-value for the median zero crossing in y.
    -Todd Hunter
    """
    crossings = []
    for i in range(1,len(x)):
        if (y[i]*y[i-1] < 0):
            separation = abs(y[i]) + abs(y[i-1])
            wt1 = abs(y[i-1])/separation
            wt0 = abs(y[i])/separation
            crossings.append(x[i]*wt1 + x[i-1]*wt0)
    return(np.median(crossings))

def findZeroCrossingBySlope(x, y):
    """
    Finds the x-value for the zero crossing in y.
    -Todd Hunter
    """
    crossings = []
    amplitude = np.max(y)
    xdata = []
    ydata = []
    threshold = 0.1
    while (len(xdata) == 0 and threshold < 0.4):
        threshold += 0.1
        for i in range(1,len(x)):
            if (abs(y[i]) < threshold*amplitude):
                xdata.append(x[i])
                ydata.append(y[i])
#    print "Fitting ydata: ", sorted(np.array(ydata)+0.5)
    if (len(xdata) == 0):
        print "No data found between +-0.4 of half power point."
    slope, intercept = linfit().linfit(xdata,ydata,np.array(ydata)*0.01)
    return(-intercept/slope)

def deconvolveDiskFromBeam(fittedBeam, diskDiameter, tolerance=1e-5):
    """
    Deconvolve a disk from a Gaussian using a series of trial convolutions
    while adjusting the guess accordingly.  This is the inverse of 
    au.computeExpectedFWHM.
    Inputs:
    fittedBeam: this is the geometric mean of the size as fitted in the image
    diskDiameter: this is the expected diameter of the planet (or other 
                  disk-like object), in the same angular units as fittedBeam
    tolerance: the stopping criterion in units of the measured beam size 
    Todd Hunter
    """
    beamGuess = (fittedBeam**2 - diskDiameter**2)**0.5
    error = 1e9
    while (abs(error) > tolerance*fittedBeam):
        fwhm = computeExpectedFWHM(beamGuess, diskDiameter)
        error = fittedBeam-fwhm
        beamGuess += error*0.1
    return(beamGuess)
    
def computeExpectedFWHM(beam_fwhm, disk_diameter_arcsec, disk_diameter_arcsec2=None):
    """
    Performs a convolution of one (or two) top-hat functions with a Gaussian, and
    reports the FWHM of the result.  This is the inverse of au.deconvolveDiskFromBeam.
    -Todd Hunter
    """
    if (disk_diameter_arcsec <= 0):
        return(beam_fwhm)
    p = 1
    M = 1000  # number of points in the profile
    image_size_arcsec = np.max([3*disk_diameter_arcsec,3*beam_fwhm])
    scale_size = image_size_arcsec/np.float(M)
    disk_radius_arcsec = disk_diameter_arcsec*0.5
    sig = beam_fwhm*0.5 / ((2*math.log(2))**0.5) / scale_size
    gaussian = spsig.general_gaussian(M,p,sig)
    r = scale_size*(np.arange(0, M) - (M - 1.0) / 2.0)
    disk = np.zeros(len(r))
    for i in range(len(r)):
        if (np.abs(r[i]) < disk_radius_arcsec):
            disk[i] = 1

    beam = spsig.convolve(gaussian,disk,mode='same')
    beam_fwhm = findFWHM(r,beam)
    if (disk_diameter_arcsec2 != None):
        disk_radius_arcsec = disk_diameter_arcsec2*0.5
        sig = beam_fwhm*0.5 / ((2*math.log(2))**0.5) / scale_size
        gaussian = spsig.general_gaussian(M,p,sig)
        r = scale_size*(np.arange(0, M) - (M - 1.0) / 2.0)
        disk = np.zeros(len(r))
        for i in range(len(r)):
            if (np.abs(r[i]) < disk_radius_arcsec):
                disk[i] = 1
        beam = spsig.convolve(beam,disk,mode='same')
        beam_fwhm = findFWHM(r,beam)
    return(beam_fwhm)

def buildConfigurationFile(vis='', simmospath=None, field='', dropTPpads=False,
                           output='', debug=False, extraPads=[], extraNames=[],
                           includeAntennaNames=False):
    """
    Reads the list of antenna stations in an .ms and creates a .cfg file based
    on the antenna locations in the files in /usr/lib64/casapy/data/alma/simmos.
    For ALMA, the file AOS_Pads_XYZ_ENU.txt is used. The resulting file is
    useful for running simulations on previously-obtained datasets.
    vis: an ms
    simmospath: alternative place to search for observatory .cfg files
    field: if specified, then report the date/time of the first observation of this
           field (ID or name), e.g. for usage in predictcomp
    dropTPpads: if set to True, will exclude pads starting with 'T70', as their
                files do not have the same coordinate system as the others.
    output: the name of the outputfile to write
    extraPads: insert additional pads into the list
    extraNames: the antenna names corresponding to the extraPads
    - Todd Hunter
    """
    if (vis == ''):
        print "Usage: buildConfigurationFile(vis=myvis)"
        return
    if (simmospath == None or simmospath == ''):
        repotable = os.getenv("CASAPATH").split()[0]+"/data/alma/simmos/"
    else:
        repotable = simmospath
        if (repotable[-1] != '/'): 
            repotable += '/'
    observatory = getObservatoryName(vis)
    startdate = mjdsecToUT(getObservationStart(vis))
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/ANTENNA')
    stations = mytb.getcol('STATION')
    if (includeAntennaNames):
        names = mytb.getcol('NAME')
    mytb.close()
    for e in range(len(extraPads)):
        extraPad = extraPads[e]
        if (extraPad not in stations):
            stations = np.append(stations,extraPad)
            if (includeAntennaNames):
                if (len(extraNames) > e):
                    extraName = extraNames[e]
                    if (extraName in names):
                        print "One of the antennas in extraNames (%s) is already in the ms!  Stopping." % (extraName)
                        return
                else:
                    extraName = '????'
                names = np.append(names,extraName)
        else:
            print "One of the pads in extraPads (%s) is already in the ms!  Stopping."  % (extraPad)
            return
    if (output == ''):
        output = vis+'.cfg'
        
    if (os.path.exists(output)):
        if (os.access(output,os.W_OK) == False):
            fileWriteMessage = "Cannot write to the existing file, therefore will write to /tmp"
            output = '/tmp/' + os.path.basename(output)
        else:
            fileWriteMessage = "Overwriting the existing file"
    else:
        # The file does not exist
        if (os.path.basename(output) != output):
            # then a directory tree was given
            if (os.access(os.path.dirname(output),os.W_OK) == False):
                fileWriteMessage = "Cannot write to specified location, therefore will write to /tmp"
                output = '/tmp/' + os.path.basename(output)
            else:
                fileWriteMessage = "Creating new file in specified location"
        elif (os.access('./',os.W_OK) == False):
            fileWriteMessage = "Cannot write to current directory, therefore will write to /tmp"
        else:
            fileWriteMessage = "Creating new file in current directory"
    cfg = open(output, 'w')
    if (observatory.find('VLA')>=0):
        coordsys = '# coordsys=XYZ\n'
        observatory = 'VLA'
        print "Recognized observatory = VLA"
        # Remove "VLA:" and "_" from "VLA:_W8"
        for i,s in enumerate(stations):
            tokens = s.split(':')
            if (len(tokens) > 1):
                stations[i] = tokens[1].strip('_')
                if (len(stations[i]) == 2):
                    stations[i] = stations[i][0] + '0' + stations[i][1]

    elif (observatory.find('ALMA')>=0):
        coordsys = '# coordsys=LOC (local tangent plane)\n'
    else:
        coordsys = '# coordsys=LOC (local tangent plane)\n'
    cfg.write(coordsys)
    cfg.write('# observatory=%s\n' % observatory)
    cfg.write('# x y z diam pad#\n')
    cfg.write('# %s\n' % os.path.basename(vis))
    found = np.zeros(len(stations))
    configs = 6  # number of Cycle 1 configs
    wrote = 0
    dirlist = os.listdir(repotable)
    configs = []
    almafile = os.path.dirname(__file__) + '/AOS_Pads_XYZ_ENU.txt'
    if (debug):
        print "alma file = ", almafile
    configs.append(almafile)
    configs.append('vla.a.cfg')
    configs.append('vla.b.cfg')
    configs.append('vla.c.cfg')
    configs.append('vla.d.cfg')
    configs.append('vla.bna.cfg')
    configs.append('vla.cnb.cfg')
    configs.append('vla.dnc.cfg')
    for c in range(len(configs)):
      cstation = 0
      if (configs[c][0] != '/'):
          cfilename = '%s%s' % (repotable,configs[c])
      else:
          cfilename = configs[c]
      if (os.path.exists(cfilename)):
#        print "Opening ", cfilename
        cfile = open(cfilename, 'r')
        lines = cfile.readlines()
        if (observatory == 'VLA' and cfilename.find('vla')>=0):
            # check if pads names are present yet
            vlapads = False
            for line in lines:
                if (line.find('W') > 0):
                    vlapads = True
            if (vlapads == False):
                print "The VLA configuration files in this version of casa do not include pad names."
                print "You can download the files from here: "
                print "   https://safe.nrao.edu/wiki/bin/view/Main/EVLAConfigFilesForSimmos"
                print "and then use the simmospath parameter to point to them."
                return

        for s in range(len(stations)):
            if (found[s] == 0):
                for line in lines:
                    if (line.find('#') < 0):
                        cstation += 1
                        if (line.find(stations[s]) > 0 or
                            # The following line can be removed once ACA
                            # files have pad names.
                            (c==configs and cstation==int(stations[s][-1]) and stations[s].find('T70')>=0)):
                            found[s] = 1
                            if (debug):
                                print "Found %s in file: %s" % (stations[s],cfilename)
                            if (dropTPpads and stations[s].find('T70')>=0):
                                print "Not writing total power pads to the file."
                            else:
                                if (includeAntennaNames):
                                    line = line.strip('\n') + ' %s\n' % (names[s])
                                    # Could also change 12m to 7m here if a CM antenna is seen
                                    if (float(line.split()[3]) == 12.):
                                        line = line.replace(' 12. ',' 7. ')
                                cfg.write(line)
                                wrote += 1
                            break
        cfile.close()
    cfg.close()
    print fileWriteMessage
    print "Wrote %d of %d antenna stations to: %s" % (wrote,len(stations),output)
    for s in range(len(stations)):
        if (found[s] == 0):
            print "Did not find %s." % (stations[s])
    if (field == ''):
        print "Start of observation = %s" % (startdate)
    else:
        try:
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(vis)
            usemsmd = True
        except:
            usemsmd = False
        if (usemsmd):
            if (type(field) == str):
                if (field.isdigit()):
                    fieldID = int(field)
                    if (fieldID >= mymsmd.nfields()):
                        print "Field ID is too large for this ms."
                        return
                    fieldname = mymsmd.namesforfield(fieldID)
                else:
                    fieldname = field
                    fieldID = mymsmd.fieldsforname(fieldname)
            else:
                fieldID = int(field)
                if (fieldID >= mymsmd.nfields()):
                    print "Field ID (%d) is too large for this ms." % (fieldID)
                    return
                fieldname = mymsmd.namesforfields(fieldID)
            starttime = mymsmd.timesforfield(fieldID)
            mymsmd.done()
        else:
            vm = ValueMapping(vis)
            if (type(field) == str):
                if (field.isdigit()):
                    fieldID = int(field)
                    fieldname = vm.getFieldNamesForFieldId(fieldID)
                else:
                    fieldname = field
                    fieldID = vm.getFieldIdsForFieldName(fieldname)
            else:
                fieldID = int(field)
                fieldname = vm.getFieldNamesForFieldId(fieldID)
            starttime = vm.fieldsForTimes[fieldname]
        starttime = np.sort(np.unique(starttime))[0]
        starttimeString = mjdsecToUT(starttime).split()
        print "First observation of field %s = %s was at %s = %s-%s UT" % (fieldID,fieldname,starttime,starttimeString[0],starttimeString[1])
    return(wrote,len(stations))

def planetPlots(objects='Venus,Mars,Ceres,Vesta,Pallas,Juno,Jupiter,Callisto,Europa,Ganymede,Io,Titan,Uranus,Neptune',
                date='2012-12-20', freqs = [100,230,345,690],  pixels=800,
                standard = 'Butler-JPL-Horizons 2012', alma_cycle=1, longitude=ALMA_LONGITUDE,
                configs = None, showbl0flux=True, keepcl=False, keeppngs=False, verbose=False, gs='gs',pdftk='pdftk'):
    """
    This function will create a grid of amplitude vs. uvdistance visibility
    plots for the specified objects, date, frequencies and configurations.
    The output is a multipage collection of a grid of plots, one
    per object, where rows are configurations and columns are frequencies.

    objects: comma-delimited string of planetary bodies 
    longitude: in degrees east of Greenwich (default = ALMA at -67.7549)
    date: observing date, all plots are a 1-second snapshot at transit 
    freqs: a list of frequencies, in GHz, or a comma-delimited string
    standard: the model in casa to use
    showbl0flux: True/False, list the zero-baseline flux density in the legend
    keepcl: True/False, keep/remove the component lists generated by predictcomp
    keeppngs: True/False, keep/remove individual pngs (leaving only the PDFs)
    alma_cycle: 0 or 1 (will automatically fill in the configs offered) or None
    configs: alternative to alma_cycle, specify one or a list of configurations,
           such as: ['alma_cycle1_1.cfg','alma_cycle1_2.cfg'], or 'alma_cycle1_1.cfg'

    Pre-defined lists of configurations:
    alma_cycle=0:  configs=['alma.cycle0.compact.cfg',
                            'alma.cycle0.extended.cfg',
                            './alma.cycle0.hybrid.cfg',
                            ]
    alma_cycle=1:  configs=['aca_cycle1.cfg','alma_cycle1_1.cfg',
                            'alma_cycle1_2.cfg','alma_cycle1_3.cfg',
                            'alma_cycle1_4.cfg','alma_cycle1_5.cfg',
                            'alma_cycle1_6.cfg']

    -Todd Hunter
    """
    if (usePredictComp == False):
        print "This function is not supported in this casa version because predictcomp is missing."
        return
    if (configs == None):
        if (alma_cycle==0):
            configs = ['alma.cycle0.compact.cfg',
                       'alma.cycle0.extended.cfg',
                       './alma.cycle0.hybrid.cfg'
                       ]
        elif (alma_cycle==1):
            configs = ['aca_cycle1.cfg','alma_cycle1_1.cfg','alma_cycle1_2.cfg',
                       'alma_cycle1_3.cfg','alma_cycle1_4.cfg','alma_cycle1_5.cfg',
                       'alma_cycle1_6.cfg']
        elif (alma_cycle != None):
            print "Unrecognized alma_cycle.  Must be either 0 or 1."
            return
    elif (type(configs) == str):
        configs = configs.split(',')
    if (date[0:4].isdigit()==False or date[5:7].isdigit()==False or date[8:].isdigit()==False):
        print "Invalid date format.  Must be integers:  'YYYY-MM-DD'"
        return
    if (type(objects) == str):
        # convert to a list
        if (objects.find(',')>0):
            objects = objects.split(',')  
        else:
            objects = objects.split()
    if (type(freqs) == str):
        # convert to a list
        if (freqs.find(',')>0):
            freqs = [int(y) for y in freqs.split(',')]
        else:
            freqs = [int(y) for y in freqs.split()]
    pdfs = ''
    leftColumnFig = []
    leftColumnFigs = 0
    initial_dirlist = os.listdir('.')
    foundconfigs = []
    repotable = os.getenv("CASAPATH").split()[0]+"/data/alma/simmos/"
    for config in configs:
        if (os.path.exists(config) or os.path.exists(repotable+config)):
            foundconfigs.append(config)
        else:
            print "Could not find configuration file = %s" % (config)
    configs = foundconfigs
    if (len(configs) < 1):
        print "Could not find any configuration files."
        return
    for obj in objects:
        figs = ''
        for config in configs:
          for freq in freqs:
            config_nopath = config.split('/')[-1]
            savefig = '%s.%s.%s.%dGHz.png' % (obj,config_nopath,date,freq)
            if (verbose): print "Running au.planet('%s', '%s', useJPL=False, standard='%s')"%(obj,date,standard)
            ra,dec = planet(obj,date,useJPL=False,standard=standard,verbose=verbose)['directionRadians']
            if (ra < 0):
                ra += 2*pi
            radecString = rad2radec(ra,dec)
            # Convert the RA (i.e. the LST of transit) into UT for this date
            mjd = lst2mjd(ra, date, longitude)
            print "MJD=%f, LST=%f" % (mjd,ra*12/np.pi)
            ut = mjdToUT(mjd).split()[1]
            epoch = date + '/' + ut
            if (verbose):
                print "Running: predictcomp(objname='%s', epoch='%s', standard='%s', minfreq='%de9Hz', symb='o', antennalist='%s', savefig='%s', nfreqs=1)" % (obj, epoch,standard,freq, config,savefig)
            if (keepcl==False):
                dirlist = os.listdir('.')
            mydict = predictcomp(objname=obj, epoch=epoch,
                                 showbl0flux=showbl0flux,
                                 standard='Butler-JPL-Horizons 2012',
                                 minfreq='%de9'%freq, symb='o', antennalist=config,
                                 savefig=savefig, nfreqs=1)
            if (keepcl==False):
                # remove the .cl file created by predictcomp
                dirlist2 = os.listdir('.')
                for myfile in dirlist2:
                    if (myfile not in dirlist and myfile[-3:] == '.cl'):
#                        print "--------- Removing %s" % myfile
                        os.system('rm -rf %s' % myfile)
            if (freq == freqs[0]):
                # only need to compute this once per object
                maunit = mydict['shape']['majoraxis']['unit']
                mavalue = mydict['shape']['majoraxis']['value']
                if (maunit == 'arcmin'):
                    maunit = '"'
                    mavalue *= 60
                if (mavalue < 1):
                    majoraxisLabel = '%.2f%s' % (mavalue,maunit)
                else:
                    majoraxisLabel = '%.1f%s' % (mavalue,maunit)
                radecStringLabel = direction2radec(mydict['shape']['direction'], prec=0)[:-2] # strip off the decimal part of the declination
                # remove extraneous leading zero from dec
                loc = radecStringLabel.find('+')
                if (loc > 0):
                    radecStringLabel = radecStringLabel[:loc+1] + radecStringLabel[loc+2:]
                else:
                    loc = radecStringLabel.find('-')
                    if (loc > 0):
                        radecStringLabel = radecStringLabel[:loc+1] + radecStringLabel[loc+2:]
            labelSize = 96
            if (config == configs[0]):
                label = str(freq) + ' GHz'
                originalfig = savefig
                savefig = savefig[:-4] + '.labeled.png'
                os.system('rm -f %s' % savefig)
                os.system("convert %s -font Utopia-Regular -pointsize %d label:'%s' -gravity Center +swap -append %s" % (originalfig,labelSize,label,savefig))
            if (freq == freqs[0]):
                # need to insert an additional figure prior to this one
                leftColumnFig.append('left_column_fig%d.png'%leftColumnFigs)
                figs += leftColumnFig[-1] + ' '
                leftColumnFigs += 1
                if (config_nopath[:4] == 'alma'):
                    leftlabel = config_nopath[5:-4]
                else:
                    leftlabel = config_nopath[:-4]
                leftLabelSize = (90*pixels)/800
                os.system("convert -size %dx%d xc:white -pointsize %d -gravity Center -annotate 0 %s %s" % (pixels,pixels, leftLabelSize, leftlabel, leftColumnFig[-1]))
            figs += savefig + ' '
          # end 'for' loop over freqs
        # end 'for' loop over configs
        # Assemble the plots for this object into a single large png
        rows = len(configs)
        cols = len(freqs) + 1  # +1 is for the left column fig
        fname = '%s.%s' % (obj,date)
        cmd = 'montage -tile %dX%d -geometry %dx%d %s %s.png'%(cols,rows,pixels,pixels,figs,fname)
        print "Running %s" % (cmd)
        os.system(cmd)
        # add a global label
        fname2 = '%s.%s.labeled' % (obj,date)
        biglabel = '%s   %s   %s   RA,Dec=%s' % (obj,date,majoraxisLabel,radecStringLabel)
        toplabelSize = 128*pixels/800.
        cmd = "convert %s.png -font Utopia-Regular -pointsize %d label:'%s' -gravity Center +swap -append %s.png" % (fname,toplabelSize,biglabel,fname2)
        print "Running %s" % (cmd)
        os.system(cmd)
        # convert to PDF
        cmd = 'convert %s.png %s.pdf' % (fname2,fname2)
        print "Running %s" % (cmd)
        os.system(cmd)
        pdfs += '%s.pdf ' % (fname2)
        # end 'for' loop over objects
        
    # concatenate PDFs
    final = '%s.pdf' % (date)
    concatenatePDFs(pdfs,final,pdftk=pdftk,gs=gs)
    print "Multipage PDF result left in %s" % (final)
    os.system('rm -rf left_column_fig*.png')
    final_dirlist = os.listdir('.')
    if (keeppngs == False):
        print "Cleaning up pngs." 
        for f in final_dirlist:
            if (f not in initial_dirlist):
                if (f.find('.png') > 0):
                    os.system('rm -f %s' % f)

    # end of planetPlots()

def lstToUT(lst, date, longitude=ALMA_LONGITUDE):
    """
    lst is a string in the format: hh:mm:ss, or a floating point hours
    Date is a string in the format: YYYY-MM-DD
    longitude is degrees East of Greenwich
    Returns a string of the format:  '2012-09-20 00:02:51 UT'
          and floating point UT hours
    """
    if (type(lst) == str):
        h,m,s = lst.split(lst[2])
        lstRadians = (int(h)+int(m)/60.+float(s)/3600.)*np.pi/12.
    else:
        lstRadians = lst*np.pi/12.
    mjd = lst2mjd(lstRadians,date,longitude)
    dateTimeString = mjdToUT(mjd)
    h,m,s = dateTimeString.split()[1].split(':')
    ut = int(h)+int(m)/60.+int(s)/3600.
    return(dateTimeString, ut)

def lst2mjd(lstRadians, date, longitudeDegrees):
    """
    Converts LST, date and longitude to MJD.
    Date is a string in the format: YYYY-MM-DD
    The input longitude is in degrees, where east of Greenwich is positive.
    Returns the mjd in floating point days
    - Todd Hunter
    """
    year = date.split('-')[0]
    SOLAR_TO_SIDEREAL = 1.002737909350795;
    mjd = strDate2MJD(date)
    lstHours = lstRadians*12/np.pi
    lstAtMidnight = ComputeLST(mjd*86400, longitudeDegrees)
    delay = (lstHours - lstAtMidnight) / 24.0
    if (delay < 0.0):
        delay += 1.0
    return(mjd + delay/SOLAR_TO_SIDEREAL);

def buildMinorPlanetPlot(bodies='Venus,Mars,Ceres,Vesta,Pallas,Juno,Jupiter,Saturn,Uranus,Neptune',date='',help=False,cals=[],observatory='ALMA',useJPL=False,standard=defaultEphemeris):
    """
    Takes a list of solar system bodies and a date, and creates a Gildas astro
    script that will plot their elevation vs. time at ALMA.  If useJPL=False
    (default), it will first try to use the casa ephemerides to get the positions
    of the non-major planets in the body list.  If this fails, or if useJPL=True,
    it queries the JPL Horizons telnet server to get the positions.
    Usage: au.buildMinorPlanetPlot(bodies='Venus,Mars,Ceres,Vesta,Pallas,Juno,
        Jupiter,Saturn,Uranus,Neptune',date='',help=False,cals=[],
        observatory='ALMA',useJPL=False,standard='Butler-JPL-Horizons 2010')
    The date format required by Astro is: DD-MMM-YYYY, i.e. 01-apr-2012
    Additional fixed sources can be added as strings, e.g.:
        cals=['3C279 12:56:11.16 -05:47:21.5', '3C273 12:29:06.7 +02:03:08.6']
    For further help and examples, see
    https://safe.nrao.edu/wiki/bin/view/ALMA/BuildMinorPlanetPlot
    -- Todd Hunter
    """
    if (help):
        print "Takes a list of solar system bodies and a date, and creates a Gildas astro"
        print "script that will plot their elev. vs. time at ALMA.  If useJPL=False (default),"
        print "it will first try to use the casa ephemerides to get the positions of the"
        print "non-major planets in the body list.  If this fails, or if useJPL=True,"
        print "then it queries the JPL Horizons telnet server to get the positions."
        print ""
        print "Usage: buildMinorPlanetPlot(bodies='Venus,Mars,Ceres,Vesta,Pallas,Juno,Jupiter,Saturn,Uranus,Neptune',date='',help=False,cals=[],observatory='ALMA',useJPL=False,standard='%s')"%(defaultEphemeris)
        print "  The date format required by Astro is: DD-MMM-YYYY, i.e. 01-apr-2012"
        print "  Additional fixed sources can be added as strings, e.g.:"
        print "   cals=['3C279 12:56:11.166 -05:47:21.52', '3C273 12:29:06.699 +02:03:08.598']"
        print "Observatories can be specifed by JPL ID string, or by the following names:"
        for n in JPL_HORIZONS_ID:
            print "   '%s' (which will be converted to = '%s')" % (n, JPL_HORIZONS_ID[n])
        return
    if (len(date) < 1):
        mydate = datetime.date.today().strftime('%d-%b-%Y')
        print "No date/time specified, assuming today=%s at UT 0:00" % (date)
    else:
        try:
            mydate = datetime.datetime.strptime(date,'%d-%b-%Y')
            # it will bomb here if the format is not correct
            mydate = date
        except:
            print "You need to specify a date like so:  date='01-apr-2012'"
            return

    fname = 'minorplanets.%s'%(mydate)
    f = open(fname, 'w')
    sname = "%s.astro" % mydate
    scriptname = open(sname,'w')
    if (type(cals) != list):
        cals = [cals]
    calnames = []
    for cal in cals:
        tokens = cal.split()
        if (len(tokens)<3):
            print "1)Invalid calibrator string format: ", cal
            return
#        print "tokens = ", tokens
        # remove any spaces in the source name
        myname = ''
        for t in range(len(tokens)-2):
            myname += tokens[t]
        calnames.append(myname.upper())
        if ((tokens[-2].find(':') < 1) or (tokens[-2].find(':') < 1)):
            print "2)Invalid calibrator string format: ", cal
            return
        f.write('%s %s %s LS 0\n'%(calnames[-1],tokens[-2],tokens[-1]))
    bodyList = bodies.split(',')
    for body in bodyList:
        if (body.upper() not in majorPlanets):
            planetData = planet(body,date=mydate,observatory=observatory,
                                verbose=False,useJPL=useJPL,
                                standard=standard,subroutine=True)
            dRad = planetData['directionRadians']
            f.write("%s %s %s LS 0\n"%(str(body).upper(), qa.formxxx('%frad'%(dRad[0]),format='hms',prec=3),
                                      qa.formxxx('%frad'%(dRad[1]),format='dms',prec=2).replace('.',':',2)))
    f.close()
    f = open(sname,"w")
    f.write("set plot landscape\n")
    f.write("pen /weight 2\n")
    f.write("catalog %s\n"%(fname))
    if (observatory == 'OVRO'):
        f.write("observatory -118:16:54.00 +37:13:54.12\n")
    elif (observatory == 'GBT'):
        f.write("observatory -79:50:24.00 +38:25:58.58 0.822 50\n")
    else:
        f.write("observatory %s\n"%(observatory))

    f.write("time 00:00 %s\n"%(mydate))
    f.write("frame horizontal\n")
    f.write("horizon 20 30 40 50 60 70 /source ")
    for body in bodyList:
        if (body.upper() not in majorPlanets):
            f.write(body.upper() + ' ')
    for calname in calnames:
        f.write('%s '%calname)
    f.write('/planet SUN ')
    planetsToWrite = []
    for body in bodyList:
        if (body.upper() in majorPlanets):
            planetsToWrite.append(body.upper())
    for p in majorPlanets:
        if (p in planetsToWrite):
            f.write(p + ' ')
    f.write('/night\n')
    f.write("$rm -f %s.eps\n"%(fname))
    f.write("hard %s.eps /dev eps f\n"%(fname))
    f.write("$convert -rotate 90 -density 108 %s.eps %s.png\n"%(fname,fname))
    f.write("say wrote plot files: %s.ps and %s.png"%(fname,fname))
    print "Wrote %s and %s to be used by gildas astro to create plots." % (fname,sname)
    try:
        shell = os.getenv('SHELL')
    except:
        shell = '/bin/tcsh'
    if (shell.find('csh')>=0):
        print "In Charlottesville, do the following (1-3 can be put in your .cshrc):"
        print "1) setenv GAG_EXEC_SYSTEM x86_64-redhatClient-g95"
        print "2) setenv GAG_ROOT_DIR /opt/local/stow/gildas-exe-dec10c/"
    else:
        print "In Charlottesville, do the following (1-3 can be put in your .bashrc):"
        print '1) export GAG_EXEC_SYSTEM="x86_64-redhatClient-g95"'
        print '2) export GAG_ROOT_DIR="/opt/local/stow/gildas-exe-dec10c/"'
    print "3) source $GAG_ROOT_DIR/etc/login"
    print "4) astro (which runs $GAG_ROOT_DIR/$GAG_EXEC_SYSTEM/bin/astro)"
    print "5) @%s" % (sname)
    return
# end of buildMinorPlanetPlot()

def plotPhaseSolutions(caltables=[], sort='value', threshold=0.0, phasecal=[], drop=1):
    """
    Calls listPhaseSolutions for a series of files and prints summary tables of
    the number of solutions larger than the specified threshhold for each 
    antenna and the angle between the targets and the phase calibrator.  If 
    threshold=0, it also generates a plot of median absolute phase vs. angle 
    between the target and the phase calibrator.

    au.plotPhaseSolutions(caltables=[], sort='value', threshold=0.0, 
                          phasecal=[], drop=1)
       caltables: list of self-calibration gain tables 
       phasecal: The phase-calibrator(s) matching the sequence of caltables.  
                 It can be field ID(s) or field name(s),  scalar or list.
                 If a list, then it must be the same length as caltables. 
       threshold: only use phases with an absolute value larger than this (deg)
       drop: number of highest x-values to drop when fitting the line
    -- Todd Hunter
    """
    if (type(phasecal) == list):
        if (len(caltables) != len(phasecal)):
            print "phasecal must be a scalar or have a length equal to caltables (%d)" % (len(caltables))
            return
    results = {}
    antennas = []
    for c in range(len(caltables)):
        if (type(phasecal) == list):
            phaseCalibrator = phasecal[c]
        else:
            phaseCalibrator = phasecal
        results[caltables[c]] = listPhaseSolutions(caltables[c], sort=sort, threshold=threshold, phasecal=phaseCalibrator)
        antennas += results[caltables[c]]['timestamps'][0]['antennas']
    mjdsec = results[caltables[0]]['timestamps'][0]['mjdsec']
    obsdateString = mjdToUT(mjdsec/86400.)
    print "Observation Time = %f = %s" % (mjdsec,obsdateString)
    print "Antenna  Discrepancies  MostRecentMove"
    Y,M,D = obsdateString.split()[0].split('-')
    obsdate = datetime.date.today().replace(int(Y),int(M),int(D))
    now = "this observation"
    for ant in np.unique(antennas):
        move = getMostRecentMove(ant, before=obsdateString.split()[0])
        y,m,d = move.split('T')[0].split('-')
        movedate = datetime.date.today().replace(int(y),int(m),int(d))
        diff = obsdate - movedate
        if (diff.days < 0):
            print " %s: %2d  (%5d days after %s)" % (ant, antennas.count(ant), abs(diff.days), now)
        else:
            print " %s: %2d  (%5d days before %s)" % (ant, antennas.count(ant), diff.days, now)
    separation = []
    phasecalName = []
    medianphase = []
    meanphase = []
    maxphase = []
    stdphase = []
    madphase = []
    percentile = []
    MSName = results[results.keys()[0]]['MSName']
    [medianPWV, stdPWV] = getMedianPWV(MSName)
    dateString = mjdsecToUT(getObservationStart(MSName)).split()[0]
    print "\nTarget  Angle_to_phase_calibrator"
    for r in range(len(results.keys())):
        caltable = results.keys()[r]
        mjdsec = results[caltable].keys()[0]
        separation.append(results[caltable]['separation'])
        print "%s  %.2f deg" % (results[caltable]['target'], separation[-1])
        phasecalName.append(results[caltable]['phasecal'])
        medianphase.append(results[caltable]['timestamps'][0]['medianphase'])
        meanphase.append(results[caltable]['timestamps'][0]['meanphase'])
        stdphase.append(results[caltable]['timestamps'][0]['stdphase'])
        madphase.append(results[caltable]['timestamps'][0]['madphase'])
        maxphase.append(results[caltable]['timestamps'][0]['maxphase'])
        percentile.append(results[caltable]['timestamps'][0]['percentile'])
    if (threshold > 0):
        print "To generate the plot, set threshold to zero."
    else:
      pb.clf()
      desc = pb.subplot(111)
      separation = np.array(separation)
      medianphase = np.array(medianphase)
      percentile = np.array(percentile)
      if (type(phasecal) == list):
        phasecals = np.unique(phasecal)
      else:
        phasecals = [phasecal]
      pb.hold(True)
      for p in range(len(phasecals)):
        indices = np.where(phasecal == phasecals[p])
        pb.errorbar(separation[indices], medianphase[indices], 
                    fmt='o', color=overlayColors[p], yerr=percentile[indices])
      pb.xlabel('Angular separation between targets and phase calibrator (deg)')
      pb.ylabel('Median absolute self-calibrated phase solution (deg)')
      pb.title('%s  (%s)  median_PWV=%.3f mm' % (MSName,dateString,medianPWV), size=12)
      if (drop>0):
        separation = separation[0:-drop]
        medianphase = medianphase[0:-drop]
        percentile = percentile[0:-drop]
      for p in range(len(percentile)):
        if (percentile[p] <= 0):
            # prevent crash in linfit due to nan
            percentile[p] = 1e-6
      lf = linfit()
      p = lf.linfit(separation, medianphase, percentile)
      pb.plot(pb.xlim(), p[0]*np.array(pb.xlim())+p[1], 'k-')
      pb.ylim([0,pb.ylim()[1]])
      pb.text(0.15, 0.95, 'Y=%.3f+%.3fX'%(p[1],p[0]), transform=desc.transAxes)
      for p in range(len(phasecals)):
        pb.text(0.15, 0.90-0.05*p, '%s'%phasecalName[p], color=overlayColors[p], transform=desc.transAxes)

      desc.xaxis.grid(True,which='major')
      desc.yaxis.grid(True,which='major')
      pngname = '%s.selfcal_phase_vs_separation.png'%(MSName)
      pb.savefig(pngname)
      print "\nplot left in %s" %pngname
      pb.draw()

def listPhaseSolutions(caltable='', sort='value', threshold=0.0, phasecal=None):
    """
    This function is useful for examining the phase solutions of a
    self-cal table to identify antennas with the largest phase
    discrepancies from zero.  Only works for casa >= 3.4.
    au.listPhaseSolutions(caltable='', sort='value', threshold=0.0)
      sort: 'value', 'name', or 'id'
         'value': sort by absolute magnitude of the phase
         'name': sort by antenna name
         'id': sort by antenna ID (often the same as name)
      threshold: only show phases with an absolute value larger than this (deg)
      phasecal: the field ID or name of the phase calibrator (scalar or list)
    Returns a dictionary of the format:
        {'separation':value, 'MSName': ms, 'phasecal': phase_calibrator_name,
         'target': target_name,
         'timestamps': [{'mjdsec': value, 'antennas':['DA45',...],
                         'phases':[10.3,...], 'medianphase':3.2,
                         'meanphase':2.4, 'maxphase':8.0, 'stdphase':1.3},
                         ...]
                         } 
        where antennas are string names, phases are in degrees, and separation is in degrees

    - Todd Hunter
    """
    fulldictionary = {}
    if (os.path.exists(caltable) == False):
        print "Could not find caltable = %s" % (caltable)
        return(fulldictionary)
    tb.open(caltable)
    names = tb.colnames()
    if ('SPECTRAL_WINDOW_ID' not in names):
        print "This appears to be an old-format cal table from casa 3.3.  Not supported."
        return(fulldictionary)
    VisCal = tb.getkeyword('VisCal')      
    MSName = tb.getkeyword('MSName')      
    if (VisCal != 'T Jones'):
        print "This is not a T Jones solution."
        return(fulldictionary)
    AntennaTable = tb.getkeyword('ANTENNA')
    fieldIds = tb.getcol('FIELD_ID')
    fieldId = fieldIds[0]  # Assume all solutions are for the same field
    print "fieldID = %d" % fieldId
    times = tb.getcol('TIME')
    gains = tb.getcol('CPARAM')
#    print "shape(gains) = ", np.shape(gains)
    if (len(gains) == 1):
        gains = gains[0]
    if (len(gains) == 1):
        gains = gains[0]
#    print "len(gains) = ", len(gains)
    antennas = tb.getcol('ANTENNA1')
    phases = np.arctan2(np.imag(gains),np.real(gains))*180.0/math.pi
    uniqueTimes = np.unique(times)
    tb.close()
    tb.open(caltable+'/ANTENNA')
    antennaNames = tb.getcol('NAME')
    tb.close()
    tb.open(caltable+'/FIELD')
    fieldNames = tb.getcol('NAME')
    phaseDirs = tb.getcol('PHASE_DIR').transpose()
    targetDir = [phaseDirs[fieldId][0][0], phaseDirs[fieldId][0][1]]
    # targetDir is now [RA,Dec] in radians
    print "target = %s" % (rad2radec(targetDir[0], targetDir[1], verbose=False))
    if (phasecal != None):
        if (str(phasecal).isdigit()):
            phasecal = int(phasecal)
        elif (phasecal in fieldNames):
            phasecal = fieldNames.index(phasecal)
        else:
            print "Unrecognized field name = ", phasecal
        # phasecal is now a valid FIELD ID
        phasecalDir = [phaseDirs[phasecal][0][0], phaseDirs[phasecal][0][1]]
        # phasecalDir is now [RA,Dec] in radians
        print "phase cal = %s" % (rad2radec(phasecalDir[0], phasecalDir[1], verbose=False))
        separationRadians = angularSeparationRadians(phasecalDir[0], phasecalDir[1], targetDir[0], targetDir[1])
        fulldictionary['separation'] = separationRadians*180/math.pi
        fulldictionary['phasecal'] = fieldNames[phasecal]
    fulldictionary['target'] = fieldNames[fieldId]
    tb.close()
    fulldictionary['timestamps'] = []
    fulldictionary['MSName'] = MSName
    for t in uniqueTimes:
        tdict = {'antennas':[], 'phases':[]}
        indices = np.where(t == times)[0]
        thisTime = times[indices]
        print "Time = %f = %s" % (thisTime[0],mjdToUT(thisTime[0]/86400.))
        thisPhase = phases[indices]
        thisAntenna = antennas[indices]
        if (sort == 'value'):
            indices = np.argsort(np.abs(thisPhase))
        elif (sort == 'name'):
            indices = np.argsort(antennaNames)
        elif (sort == 'id'):
            indices = range(len(thisTime))
        else:
            print "Unrecognized sort type.  Must be 'value', 'name' or 'id'."
            return(fulldictionary)
        for g in range(len(thisTime)):
          if (abs(thisPhase[indices[g]]) > threshold):
            print "%2d %s %+8.3f " % (thisAntenna[indices[g]], 
                                      antennaNames[thisAntenna[indices[g]]], 
                                      thisPhase[indices[g]])
            tdict['antennas'].append(antennaNames[thisAntenna[indices[g]]])
            tdict['phases'].append(thisPhase[indices[g]])
        if (len(tdict['phases']) > 0):
            tdict['medianphase'] = np.median(np.abs(tdict['phases']))
            tdict['meanphase'] = np.mean(np.abs(tdict['phases']))
            tdict['maxphase'] = np.max(np.abs(tdict['phases']))
            tdict['stdphase'] = np.std(np.abs(tdict['phases']))
            tdict['madphase'] = MAD(np.abs(tdict['phases']))
            tdict['percentile25'] = scoreatpercentile(np.abs(tdict['phases']), 25)
            tdict['percentile75'] = scoreatpercentile(np.abs(tdict['phases']), 75)
            tdict['percentile'] = 0.5*(tdict['percentile75']-tdict['percentile25'])
        else:
            tdict['medianphase'] = tdict['meanphase'] = tdict['maxphase'] = 0
            tdict['stdphase'] = tdict['madphase'] = tdict['percentile'] = 0
            tdict['percentile25'] = tdict['percentile75'] = 0
        tdict['mjdsec'] = thisTime[0]
        fulldictionary['timestamps'].append(tdict)
    return(fulldictionary)

def plotbandpassStats(caltable='', chanavg=[], channeldiff=5, title='',usetask=False, resample=True, edge=0):
    """
    Calls plotbandpass on a list of caltables with the following naming scheme:
        caltable+'_smoothXch'
    with the channeldiff option (to compute derivative statistics) and plots
    the resulting MADs vs. the level of channel averaging.
    chanavg: an integer list -- if not specified, then it will search for
             the caltables and build it automatically
    usetask: if True, use the casa task plotbandpass rather than analysisUtils version
    """
    return(plotbp3.plotbandpassStats(caltable, chanavg, channeldiff, title, usetask, resample, edge))
                      
def plotbandpass(caltable='', antenna='', field='', spw='', yaxis='amp',
                 xaxis='chan', figfile='', plotrange=[0,0,0,0], help=False,
                 caltable2='',overlay='', showflagged=False, timeranges='',
                 buildpdf=False, caltable3='',markersize=3, density=108,
                 interactive=True, showpoints='auto', showlines='auto',
                 subplot='22', zoom='', poln='', showatm=False, pwv='auto',
                 gs='gs', convert='convert', chanrange='',
                 solutionTimeThresholdSeconds=30.0, debug=False, vm='',
                 phase='', ms='', showtsky=False, showfdm=False,showatmfield='',
                 lo1=None, showimage=False, showatmPoints=False,parentms='',
                 pdftk='pdftk', channeldiff=False, edge=8, resample=1, vis='',
                 platformingThreshold=10, platformingSigma=5, basebands=None,
                 showBasebandNumber=False, scans='',figfileSequential=False,
                 groupByBaseband=False, cleanup=False, caltable2amplitudeOffset=0,
                 xcolor='b', ycolor='g'):
  """
  This is a tool to plot bandpass solutions faster than plotcal.  It is 
  designed to work on both the old cal table format and the new format of 3.4.
  The source code is in plotbandpass3.py.
  For more detailed help, run au.plotbandpass(help=True) or see examples at:
  http://casaguides.nrao.edu/index.php?title=Plotbandpass
  -- Todd Hunter
  """
  retval = plotbp3.plotbandpass3(caltable, antenna, field, spw, yaxis,
                                 xaxis, figfile, plotrange, help,
                                 caltable2, overlay, showflagged, timeranges,
                                 buildpdf, caltable3, markersize, density,
                                 interactive, showpoints, showlines,
                                 subplot, zoom, poln, showatm, pwv,
                                 gs, convert, chanrange,
                                 solutionTimeThresholdSeconds, debug, vm,
                                 phase, ms, showtsky, showfdm, showatmfield,
                                 lo1, showimage, showatmPoints, parentms,pdftk,
                                 channeldiff, edge, resample, vis,
                                 platformingThreshold, platformingSigma,
                                 basebands, showBasebandNumber, scans,
                                 figfileSequential, groupByBaseband, cleanup,
                                 caltable2amplitudeOffset, xcolor, ycolor)
  return(retval)

def getCOFAForASDM(asdm):
    return(getCOFAForObservatory(getObservatoryNameFromASDM(asdm)))

def getCOFA(ms):
    """
    Return the ITRF coordinates, Longitude and Latitude of the center of the 
    array of the observatory (from the CASA Observatories table) for the 
    specified ms.  - Todd Hunter
    """
    try:
        antTable = ms+'/ANTENNA'
        tb.open(antTable)
    except:
        print "Could not open ANTENNA table: %s" % (antTable)
        return([],[])
    position = tb.getcol('POSITION')
    station = tb.getcol('STATION')
    name = tb.getcol('NAME')
    tb.close()
    try:
        antTable = ms+'/OBSERVATION'
        tb.open(antTable)
        myName = tb.getcell('TELESCOPE_NAME')
        tb.close()
    except:
        print "Could not open OBSERVATION table to get the telescope name: %s" % (antTable)
        myName = ''
        return
    return(getCOFAForObservatory(myName))

def getCOFAForObservatory(observatory):
    """
    Return the ITRF coordinates, Longitude and Latitude of the center of the 
    array of the specified observatory (from the CASA Observatories table).
    - Todd Hunter
    """
    u = simutil.simutil()
    repotable = os.getenv("CASAPATH").split()[0]+"/data/geodetic/Observatories"
    tb.open(repotable)
    Name = tb.getcol('Name')
    myType = ''
    for i in range(len(Name)):
        if (Name[i] == observatory):
            Long = tb.getcell('Long',i)
            Lat = tb.getcell('Lat',i)
            Height = tb.getcell('Height',i)
            myType = tb.getcell('Type',i)
            if (myType == 'ITRF'):
                cx = tb.getcell('X',i)
                cy = tb.getcell('Y',i)
                cz = tb.getcell('Z',i)
            else:
                # WGS84
                output = u.long2xyz(Long*math.pi/180.,Lat*math.pi/180.,Height,myType)
                (cx,cy,cz) = output
            break
    return(cx,cy,cz,Long,Lat)

def plotantsFromASDM(asdm, plotfile='', plotAntennasActualSize=True,
                     includeWeatherStations=False):
    """
    Reads the antenna positions from the ASDM and makes a plot, similar to
    the plotants function in casa.
    Input parameters:
    * asdm: the name of the ASDM
    * plotfile: name of png to produce,  if plotfile==True, then generate a default name 
                from:  asdm.plotants.png
    * plotAntennasActualSize: if True, then the markers will be scaled to match antenna 
              diameter.  If the configuration is larger than 400m, and 
              plotAntennasActualSize==True, then a second plot will be made zoomed into 
              the inner array. 
    * includeWeatherStations: if True, then also show the location of the weather stations
    -Todd Hunter
    """
    xpositions = []
    ypositions = []
    diameters = []
    mydict = readStationFromASDM(asdm) # returns {0:{'name':'A050', 'position':[x,y,z]}}
    antennas, stationIds, diameters = readAntennasFromASDM(asdm,stations=True,diameters=True)
    if (includeWeatherStations):
        for station in mydict.keys():
            if (station not in stationIds):
                antennas.append(mydict[station]['name'])
                stationIds.append(station)
                diameters.append(1.0)
    if (casadef.subversion_revision >= '25324'):
        u = simutil.simutil()
    for antennaStation in stationIds:
        if (casadef.subversion_revision < '25324'):
            xpositions.append(getPadLOC(mydict[antennaStation]['name'])[0])
            ypositions.append(getPadLOC(mydict[antennaStation]['name'])[1])
        else:
            cx,cy,cz,Long,Lat = getCOFAForASDM(asdm)
            x0,y0,z0 = u.itrf2loc(mydict[antennaStation]['position'][0],
                                  mydict[antennaStation]['position'][1],
                                  mydict[antennaStation]['position'][2],
                                  cx,cy,cz)
            xpositions.append(x0)
            ypositions.append(y0)
    maxBaseline = 0
    for i in range(len(xpositions)):
        for j in range(i+1,len(xpositions)):
            baseline = pow(pow(xpositions[i]-xpositions[j],2)+pow(ypositions[i]-ypositions[j],2),0.5)
            if (baseline > maxBaseline):
                maxBaseline = baseline
    plotfile = plotAntennaPositionList(xpositions, ypositions, antennas, diameters, asdm,
                                       plotfile, plotAntennasActualSize)
    if (maxBaseline > 400):
        xlim = [-140,240]
        ylim = [-150,150]
        if (plotfile == ''):
            myinput = raw_input("Press return for next plot (zoom of inner array)")
        else:
            plotfile = plotfile.replace('.png','') + '.zoom.png'
        plotAntennaPositionList(xpositions, ypositions, antennas, diameters, asdm,
                                plotfile, plotAntennasActualSize, xlim, ylim)
    

def plotAntennaPositionList(plotx, ploty, antenna, diam, dataset, plotfile='',
                            plotAntennasActualSize=True, xlim=None, ylim=None):
    """
    Called by plotantsFromASDM and es.listobs2. 
    Input parameters:
    plotx, ploty: list of X and Y components of geocentric position
    antenna: list of antenna names
    diam: list of antenna diameters (meters)
    dataset: the string to put in the title of the plot
    plotfile: if specified, then produce a plot of this name.  if 'True' then
         the plotfile name will be  <dataset>.plotants.png
    -Todd Hunter
    """
    pb.clf()
    zoomed = False
    if (plotAntennasActualSize):
        myaxis = pb.axes()
        for a in range(len(plotx)):
            circ = pb.Circle((plotx[a],ploty[a]), radius=diam[a]*0.5,
                             facecolor='#FFB6C1', edgecolor='k')
            myaxis.add_patch(circ)
        pb.axis('equal')
        if (xlim != None):
            pb.xlim(xlim)
            zoomed = True
        if (ylim != None):
            pb.ylim(ylim)
            zoomed = True
        xlim = pb.xlim() 
        ylim = pb.ylim()  # actual value may vary due to axis('equal')
    else:
        #  Find size of plot
        pxmin = np.min(plotx)
        pymin = np.min(ploty)
        pxmax = np.max(plotx)
        pymax = np.max(ploty)
        psize = np.sqrt((pxmax-pxmin)**2 + (pymax+pymin)**2)
    # set marker size
        mssize = 15.0/300.0*psize
        pb.plot(plotx,ploty,'go',ms=mssize,mfc='#FFB6C1')
        pb.xlim([pxmin-2*mssize, pxmax+2*mssize])
        pb.ylim([pymin-2*mssize, pymax+2*mssize])
    labelsize = 10
    labelsizeMin = 2
    labelsizeMax = 12
    xmean = np.mean(plotx)
    ymean = np.mean(ploty)
    for i in range(0,len(plotx)):
        withinFrame = True
        if (plotAntennasActualSize):
            radiusFromCenter = ((plotx[i]-xmean)**2 + (ploty[i]-ymean)**2)**0.5
            cornerRadius = (((xlim[1]-xlim[0])*0.5)**2 + ((ylim[1]-ylim[0])*0.5)**2)**0.5
            labelsize = np.int(np.round(labelsizeMin + (labelsizeMax-labelsizeMin)*radiusFromCenter/cornerRadius))
            labelsize = labelsizeMin + (labelsizeMax-labelsizeMin)*(radiusFromCenter/cornerRadius)**0.33
            if (xlim != None):
                if (plotx[i] < xlim[0] or plotx[i] > xlim[1]): withinFrame = False
            if (ylim != None):
                if (ploty[i] < ylim[0] or ploty[i] > ylim[1]): withinFrame = False
        if (withinFrame):
            pb.text(plotx[i]-3.0,ploty[i]-5.0,str(i)+'='+antenna[i],size=labelsize)
    mytitle = os.path.basename(dataset)
    if (zoomed):
        mytitle += ' (zoomed)'
    pb.title(mytitle,fontsize=12)
    pb.xlabel('X(m)')
    pb.ylabel('Y(m)')
    if (plotfile != ''):
        if (plotfile == True):
            plotfile = dataset + '.plotants.png'
        pb.savefig(plotfile,format='png',density=108)
        print 'saved antenna plot in %s' % (plotfile)
    return(plotfile)

def obslist(ms,cofa=''):
    """
    Parses the telescope name from the OBSERVATION table, then finds the
    coordinates of the center of the array (COFA), then converts each station
    coordinates into local offsets in meters from the COFA and prints the
    information. You can optionally define the COFA as an antenna ID or name
    via the cofa parameter.  For further help and examples, see:
    http://casaguides.nrao.edu/index.php?title=Obslist
    Todd Hunter
    """
    try:
        antTable = ms+'/ANTENNA'
        tb.open(antTable)
    except:
        print "Could not open ANTENNA table: %s" % (antTable)
        return([],[])
    position = tb.getcol('POSITION')
    station = tb.getcol('STATION')
    name = tb.getcol('NAME')
    tb.close()
    try:
        antTable = ms+'/OBSERVATION'
        tb.open(antTable)
        myName = tb.getcell('TELESCOPE_NAME')
        tb.close()
    except:
        print "Could not open OBSERVATION table to get the telescope name: %s" % (antTable)
        myName = ''
        
    u = simutil.simutil()
    repotable=os.getenv("CASAPATH").split()[0]+"/data/geodetic/Observatories"
    tb.open(repotable)
    Name = tb.getcol('Name')
    cx = position[0][0]
    cy = position[1][0]
    cz = position[2][0]
    myType = ''
    if (cofa == ''):
        for i in range(len(Name)):
            if (Name[i] == myName or Name[i] == myName.upper()):
                Long = tb.getcell('Long',i)
                Lat = tb.getcell('Lat',i)
                Height = tb.getcell('Height',i)
                myType = tb.getcell('Type',i)
                if (myType == 'ITRF'):
                    cx = tb.getcell('X',i)
                    cy = tb.getcell('Y',i)
                    cz = tb.getcell('Z',i)
                else:
                    # WGS84
                    output = u.long2xyz(Long*math.pi/180.,Lat*math.pi/180.,Height,myType)
                    (cx,cy,cz) = output
                break
    else:
        if (str(cofa).isdigit()):
            if (int(cofa) < 0 or int(cofa) >= len(name)):
                print "Invalid antenna ID. (Valid range = 0..%d)" % (len(name)-1)
                return
        else:
            matches = np.where(name == cofa)[0]
            if (len(matches) < 1):
                print "cofa must be either an integer, a blank string, or a valid antenna name"
                return
            else:
                print "Antenna %s has ID %d" % (cofa,matches[0])
                cofa = matches[0]
            cx = position[0][int(cofa)]
            cy = position[1][int(cofa)]
            cz = position[2][int(cofa)]
        myType = 'user'
    if (len(myType) < 1):
        print "Did not find telescope data for %s, using first station as center of array." % (myName)
    tb.close()
    try:
        output = u.irtf2loc(position[0,:],position[1,:],position[2,:],cx,cy,cz)
    except:
        output = u.itrf2loc(position[0,:],position[1,:],position[2,:],cx,cy,cz) # the newer name
    if (len(output) == 2):
        (x,y) = output
    else:
        (x,y,z) = output
    for i in range(len(x)):
        print "Antenna %2d = %s on pad %s, lat/long offset (m) = %+10.4f/%+10.4f" % (i,name[i],station[i],x[i],y[i])
    getBaselineExtrema(ms)
    return

def xyz2long(x, y, z, datum='WGS84'):
    """
    A convenient wrapper for simutil.xyz2long to return the location in 
    degrees.
    - Todd Hunter
    """
    u = simutil.simutil()
    longitude, latitude = np.array(u.xyz2long(x,y,z,datum)) * 180.0 / np.pi
    print "latitude = %+f, longitude = %+f degrees" % (latitude,longitude)
    return (latitude, longitude)
    
def antennaPosition(vis, vis2=None, ant=''):
    """
    This utility prints the XYZ positions from the ANTENNA table for 1 or 
    2 measurement sets.
    If vis2 is specified, the difference in positions is also computed.
    This is meant to help understan antenna position correction algorithms.
    Todd Hunter  (May 2012)
    """
    try:
        antTable = vis+'/ANTENNA'
        tb.open(antTable)
    except:
        print "Could not open ANTENNA table: %s" % (antTable)
        return([],[])
    position = tb.getcol('POSITION')
    station = tb.getcol('STATION')
    names = tb.getcol('NAME')
    tb.close()

    if (vis2 != None):
      try:
          antTable2 = vis2+'/ANTENNA'
          tb.open(antTable2)
      except:
          print "Could not open ANTENNA table: %s" % (antTable2)
          return([],[])
      position2 = tb.getcol('POSITION')
      station2 = tb.getcol('STATION')
      names2 = tb.getcol('NAME')
      tb.close()

    antennas = len(station)
    axis = ['X','Y','Z']
    if (vis2 == None):
        print "           vis1"
    else:
        print "           vis1              vis2        Difference (m)"
    for antenna in range(len(names)):
      if (ant == '' or names[antenna] == ant):
        print "Antenna %02d = %4s on %s: " % (antenna,names[antenna],station[antenna])
        for component in range(3):
            comp = position[component][antenna]
            if (vis2 == None):
                print "  %s: %+.6f" % (axis[component],comp)
            elif (names[antenna] in names2):
                index2 = list(names2).index(names[antenna])
                comp2 = position2[component][index2]
                if (component == 0):
                    print "  %s: %+.6f   %+.6f    %.6f  (%s on %s)" % (axis[component],comp,comp2,comp-comp2,names2[index2],station2[index2])
                else:
                    print "  %s: %+.6f   %+.6f    %.6f" % (axis[component],comp,comp2,comp-comp2)
            else:
                print "  %s: %+.6f" % (axis[component],comp)
    if (vis2 != None):
        for antenna in range(len(names2)):
          if (ant == '' or names2[antenna] == ant):
            if (names2[antenna] not in names):
                print     "                        Antenna %02d = %4s on %s: " % (antenna,names2[antenna],station2[antenna])
                for component in range(3):
                    comp2 = position2[component][antenna]
                    print "  %s: ----------------  %+.6f" % (axis[component],comp2)
            
def antennaPositionASDM(vis, vis2=None, ant='', itrf=False, verbose=False):
    """
    This utility prints the antenna positions from the ASDM_ANTENNA table 
    for 1 or 2 measurement sets.
    If vis2 is specified, the difference in positions is also computed.
    This is meant to help understand antenna position correction algorithms.
    Specifying ant will limit the display to one antenna.
    If itrf=True, then convert positions from relative ENU to absolute ECEF.
    Todd Hunter  (May 2012)
    """
    try:
        antTable = vis+'/ASDM_ANTENNA'
        tb.open(antTable)
    except:
        print "Could not open ASDM_ANTENNA table: %s" % (antTable)
        return([],[])
    position = tb.getcol('position')
    stationId = tb.getcol('stationId')
    names = tb.getcol('name')
    tb.close()
    try:
        antTable = vis+'/ASDM_STATION'
        tb.open(antTable)
    except:
        print "Could not open ASDM_STATION table: %s" % (antTable)
        return([],[])
    station = tb.getcol('name')
    padPosition = tb.getcol('position')
    padStationId = tb.getcol('stationId')
    tb.close()

    if (vis2 != None):
      try:
          antTable2 = vis2+'/ASDM_ANTENNA'
          tb.open(antTable2)
      except:
          print "Could not open ASDM_ANTENNA table: %s" % (antTable2)
          return([],[])
      position2 = tb.getcol('position')
      stationId2 = tb.getcol('stationId')
      names2 = tb.getcol('name')
      tb.close()
      try:
          antTable2 = vis2+'/ASDM_STATION'
          tb.open(antTable2)
      except:
          print "Could not open ASDM_STATION table: %s" % (antTable2)
          return([],[])
      station2 = tb.getcol('name')
      padPosition2 = tb.getcol('position')
      padStationId2 = tb.getcol('stationId')

    antennas = len(station)
    if (itrf):
        axis = ['    X','    Y','    Z']
        cx,cy,cz,long,lat = getCOFA(vis)
        if (vis2 == None):
            print "           vis1"
        else:
            print "     '      vis1            vis2            Difference (m)  (vis1-vis2)"
    else:
        axis = ['East ','North','Up   ']
        if (vis2 == None):
            print "       vis1"
        else:
            print "       vis1        vis2        Difference (m)  (vis1-vis2)"
    for antenna in range(len(names)):
      antindex = list(padStationId).index(stationId[antenna])
      if (itrf):
          # compute antenna XYZ from pad XYZ and ENU correction
          # http://en.wikipedia.org/wiki/Geodetic_system   (ENU to ECEF)
          if (verbose):
              print "antenna%d=%s in vis1 is on %s=%s" % (antenna,names[antenna],
                                                          stationId[antenna],station[antindex])
          phi = lat*math.pi/180.
          lam = math.atan2(padPosition[1][antindex], padPosition[0][antindex])
          itrf_correction = []
          itrf_correction.append(-np.sin(lam)*position[0][antenna] \
                                 -np.sin(phi)*np.cos(lam)*position[1][antenna] + \
                                  np.cos(phi)*np.cos(lam)*position[2][antenna] + \
                                 padPosition[0][antindex])
          itrf_correction.append(+np.cos(lam)*position[0][antenna] \
                                 -np.sin(phi)*np.sin(lam)*position[1][antenna] + \
                                  np.cos(phi)*np.sin(lam)*position[2][antenna] + \
                                 padPosition[1][antindex])
          itrf_correction.append(+np.cos(phi)*position[1][antenna] + \
                                  np.sin(phi)*position[2][antenna] + padPosition[2][antindex])
          if (names[antenna] in names2):
              antenna2 = list(names2).index(names[antenna])
              vis2stationId = stationId2[antenna2]
              ant2index = list(padStationId2).index(vis2stationId)
              if (verbose):
                  print "antenna%d=%s in vis2 is on %s=%s (ant2index=%d)" % (antenna2,
                         names2[antenna2],stationId2[antenna2],station2[ant2index], ant2index)
              itrf_correction2 = []
              phi = lat*math.pi/180.
              lam = math.atan2(padPosition2[1][ant2index], padPosition2[0][ant2index])
              itrf_correction2.append(-np.sin(lam)*position2[0][antenna2] \
                                     -np.sin(phi)*np.cos(lam)*position2[1][antenna2] + \
                                     np.cos(phi)*np.cos(lam)*position2[2][antenna2] + \
                                     padPosition2[0][ant2index])
              itrf_correction2.append(+np.cos(lam)*position2[0][antenna2] \
                                     -np.sin(phi)*np.sin(lam)*position2[1][antenna2] + \
                                     np.cos(phi)*np.sin(lam)*position2[2][antenna2] + \
                                     padPosition2[1][ant2index])
              itrf_correction2.append(+np.cos(phi)*position2[1][antenna2] + \
                                   np.sin(phi)*position2[2][antenna2]+ padPosition2[2][ant2index])
          
      if (ant == '' or names[antenna] == ant):
        print "Antenna %02d = %4s on %s: " % (antenna,names[antenna],station[antindex])
        for component in range(3):
            if (itrf):
                comp = itrf_correction[component]
            else:
                comp = position[component][antenna]
            if (vis2 == None):
                print "%s: %+.6f" % (axis[component], comp)
            elif (names[antenna] in names2):
                if (itrf):
                    comp2 = itrf_correction2[component]
                else:
                    index2 = list(names2).index(names[antenna])
                    antenna2 = list(names2).index(names[antenna])
                    vis2stationId = stationId2[antenna2]
                    ant2index = list(padStationId2).index(vis2stationId)
                    comp2 = position2[component][index2] 
                if (component == 0):
                    print "%s: %+.6f   %+.6f    %+.6f  (%s on %s)" % (axis[component],comp,comp2,comp-comp2,names2[antenna2],station2[ant2index])
                else:
                    print "%s: %+.6f   %+.6f    %+.6f" % (axis[component],comp,comp2,comp-comp2)
            else:
                print "%s: %+.6f" % (axis[component],comp)
    if (vis2 != None):
        for antenna in range(len(names2)):
          if (itrf):
              # compute antenna XYZ from pad XYZ and ENU correction
              # http://en.wikipedia.org/wiki/Geodetic_system   (ENU to ECEF)
              antindex = list(padStationId2).index(stationId2[antenna])
              itrf_correction2 = []
              phi = lat*math.pi/180.
              lam = math.atan2(padPosition2[1][antindex],padPosition2[0][antindex])
              itrf_correction2.append(-np.sin(lam)*position2[0][antenna] \
                                     -np.sin(phi)*np.cos(lam)*position2[1][antenna] + \
                                     np.cos(phi)*np.cos(lam)*position2[2][antenna] + \
                                     padPosition2[0][antindex])
              itrf_correction2.append(+np.cos(lam)*position2[0][antenna] \
                                     -np.sin(phi)*np.sin(lam)*position2[1][antenna] + \
                                     np.cos(phi)*np.sin(lam)*position2[2][antenna] + \
                                     padPosition2[1][antindex])
              itrf_correction2.append(+np.cos(phi)*position2[1][antenna] + \
                                     np.sin(phi)*position2[2][antenna]+ padPosition2[2][antindex])
          
          if (ant == '' or names2[antenna] == ant):
            if (names2[antenna] not in names):
                print     "                  Antenna %02d = %4s on %s: " % (antenna,names2[antenna],station2[antenna])
                for component in range(3):
                    if (itrf):
                        comp2 = itrf_correction2[component]
                        print "%s: ----------------  %+.6f" % (axis[component],comp2)
                    else:
                        comp2 = position2[component][antenna]
                        print "%s: ----------  %+.6f" % (axis[component],comp2)
            

def padPositionASDM(vis, vis2=None, ant=''):
    """
    This utility prints the pad positions from the ASDM_STATION table for 1 
    or 2 measurement sets.
    If vis2 is specified, the difference in positions is also computed.
    This is meant to help understand antenna position correction algorithms.
    Specifying ant will limit the display to one antenna.
    Todd Hunter  (May 2012)
    """
    try:
        antTable = vis+'/ASDM_ANTENNA'
        tb.open(antTable)
    except:
        print "Could not open ASDM_ANTENNA table: %s" % (antTable)
        return([],[])
#    position = tb.getcol('position')
    names = tb.getcol('name')
    tb.close()
    try:
        antTable = vis+'/ASDM_STATION'
        tb.open(antTable)
    except:
        print "Could not open ASDM_STATION table: %s" % (antTable)
        return([],[])
    station = tb.getcol('name')
    position = tb.getcol('position')
    tb.close()

    if (vis2 != None):
      try:
          antTable2 = vis2+'/ASDM_ANTENNA'
          tb.open(antTable2)
      except:
          print "Could not open ASDM_ANTENNA table: %s" % (antTable2)
          return([],[])
#      position2 = tb.getcol('position')
      names2 = tb.getcol('name')
      tb.close()
      try:
          antTable2 = vis2+'/ASDM_STATION'
          tb.open(antTable2)
      except:
          print "Could not open ASDM_STATION table: %s" % (antTable2)
          return([],[])
      station2 = tb.getcol('name')
      position2 = tb.getcol('position')

    antennas = len(station)
    axis = ['X','Y','Z']
    if (vis2 == None):
        print "       vis1"
    else:
        print "       vis1        vis2        Difference (m)  (vis1-vis2)"
    for antenna in range(len(names)):
      if (ant == '' or names[antenna] == ant):
        print "Antenna %02d = %4s on %s: " % (antenna,names[antenna],station[antenna])
        for component in range(3):
            comp = position[component][antenna] 
            if (vis2 == None):
                print "  %s: %+.6f" % (axis[component],comp)
            elif (names[antenna] in names2):
                index2 = list(names2).index(names[antenna])
                comp2 = position2[component][index2] 
                if (component == 0):
                    print "  %s: %+.6f   %+.6f    %+.6f  (%s on %s)" % (axis[component],comp,comp2,comp-comp2,names2[index2],station2[index2])
                else:
                    print "  %s: %+.6f   %+.6f    %+.6f" % (axis[component],comp,comp2,comp-comp2)
            else:
                print "  %s: %+.6f" % (axis[component],comp)
    if (vis2 != None):
        for antenna in range(len(names2)):
          if (ant == '' or names2[antenna] == ant):
            if (names2[antenna] not in names):
                print     "                  Antenna %02d = %4s on %s: " % (antenna,names2[antenna],station2[antenna])
                for component in range(3):
                    comp2 = position2[component][antenna] 
                    print "  %s: ----------  %+.6f" % (axis[component],comp2)
            
def windowFunction(window='', channelAveraging=1, returnValue='FWHM'):
    """
    Print the FWHM and Effective sensitivity bandwidth of each of the ALMA correlator
    window functions, or return the value for a specific choice. The values are taken
    from the tables in Richard Hills' note of April 8, 2012.
    window: one of ['', 'uniform','hanning','welch','cosine','hamming','bartlett',
                    'blackmann','blackmann-harris']  ''=prints the whole table
    channelAveraging: 1, 2, 4, or 8
    returnValue: 'FWHM' or 'EffectiveBW'
    -Todd Hunter
    """
    mydict = {'uniform': {'FWHM': {1: 1.207, 2: 1.639, 4: 4.063, 8: 8.033},
                          'EffectiveBW': {1: 1.0, 2: 2.0, 4: 4.0, 8: 8.0}},
              'hanning': {'FWHM': {1: 2.000, 2: 2.312, 4: 3.970, 8: 7.996},
                          'EffectiveBW':{1: 2.667, 2: 3.200, 4: 4.923, 8: 8.828}},
              'welch': {'FWHM': {1: 1.590, 2: 1.952, 4: 4.007, 8: 8.001},
                        'EffectiveBW':{1: 1.875, 2: 2.565, 4: 4.499, 8: 8.470}},
              'cosine': {'FWHM': {1: 1.639, 2: 2.0, 4: 4.0, 8: 8.0},
                         'EffectiveBW':{1: 2.000, 2: 2.667, 4: 4.571, 8: 8.533}},
              'hamming': {'FWHM': {1: 1.815}, 'EffectiveBW': {1: 2.516}},
              'bartlett': {'FWHM': {1: 1.772}, 'EffectiveBW': {1: 3.000}},
              'blackmann': {'FWHM': {1: 2.299}, 'EffectiveBW': {1: 3.283}},
              'blackmann-harris': {'FWHM': {1: 2.666}, 'EffectiveBW': {1: 3.877}}
              }
    if (window in mydict.keys()):
        if (channelAveraging not in mydict[window]['FWHM'].keys()):
            print "Invalid choice of channelAveraging"
            return
        if (returnValue not in mydict[window].keys()):
            print "Invalid choice of returnValue"
            return
        return(mydict[window][returnValue][channelAveraging])
    else:
        print "%16s  ChanAvg  FWHM  EffectiveBW" % ('Window type')
        for key in ['uniform','hanning','welch','cosine','hamming','bartlett',
                    'blackmann','blackmann-harris']:
            for chanAvg in sorted(mydict[key]['FWHM'].keys()):
                print "%16s     %d    %.3f   %.3f" % (key, chanAvg, mydict[key]['FWHM'][chanAvg],
                                                      mydict[key]['EffectiveBW'][chanAvg]) 

def smoothbandpass(caltable='',window_len=20, window='flat', method='ri' ,
                   avoidflags=True, verbose=False, fullVerbose=False,
                   help=False, log='', outputname=None):
  """
  Unless the outputname is specified, the output table will have
  '_smoothXXwindow_method' appended to the name,
  where 'XX'=window_len and 'window' is the window type.  The window 
  type options are: 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'.
  Method types are 'ri' = real & imaginary or 'ap' = amp & phase.
  The input bandpass file is specified in the caltable. 
  For further help and examples, see http://casaguides.nrao.edu/index.php?title=Smoothbandpass
  -- Ed Fomalont & Todd Hunter, Sep 2011/2013
  """
  if (help):
      print "Usage: smoothbandpass(caltable, window_len=20, window='flat', method='ri',"
      print "           avoidflags=True, verbose=False, fullVerbose=False, help=False, log='')"
      print "Unless the outputname is specified, the output table will have"
      print "  '_smoothXXwindow_method' appended to the name,"
      print "where 'XX'=window_len and 'window' is the window type.  The window "
      print "type options are: 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'."
      print "     (the flat window will produce a moving average smoothing)"
      print "Method types are 'ri' = real & imaginary or 'ap' = amp & phase or 'float'."
      return
#  Set some defaults
  ggr = 0
  ggr = 0
  mytb = createCasaTool(tbtool)
  mytb.open(caltable)
  if (outputname == None):
      smooth_table = caltable+'_smooth%d%s_%s' % (window_len,window,method)
  else:
      smooth_table = outputname
  gainColumnName = 'GAIN'
  spwColumnName = 'CAL_DESC_ID'
  if ('GAIN' not in mytb.colnames()):
      if (caltable.find('tsys')<0):
          print "This is a new-style caltable.  You should not use smoothbandpass, but instead use"
          print "the new on-the-fly channel averaging of the casa 3.4 command bandpass()."
          return
      if (method == 'ri' or method == 'ap'):
          gainColumnName = 'CPARAM'
      elif (method == 'float'):
          gainColumnName = 'FPARAM'
      spwColumnName = 'SPECTRAL_WINDOW_ID'
  if (gainColumnName not in mytb.colnames()):
      print "Mismatch between method parameter and cal table type."
      return
  g=mytb.getcol(gainColumnName)
  flags=mytb.getcol('FLAG')
  antennas=mytb.getcol('ANTENNA1')
  cal_desc_id=mytb.getcol(spwColumnName)
  gsm=g
  p=g.shape
  l1 = p[0]  # polarizations
  l2 = p[2]  # spw+antenna combinations   (size=nspw * nant), i.e. nrows in table
  ld = p[1]  # channels
  chan = range(0,ld)
  if (log != ''):
      f = open(log,'w')
  for i in range (0,l1):
    #   essentially smooth each pol/spw
    for j in range (0,l2):
        if (method == 'float'):
            dreal = g[i,:,j]
        else:
            dcompl = g[i,:,j]
            dreal = np.real(dcompl)
        flag = flags[i,:,j]
        if (method != 'float'):
            dimag = np.imag(dcompl)
        if (avoidflags):
          # Now replace each flagged channel's value with nearest unflagged value in this spw
          channelsToReplace = np.where(flag == 1)[0]
          goodChannels = np.where(flag == 0)[0]
          channelsReplaced = 0
          if (len(goodChannels) > 0 and len(channelsToReplace)>0):
            # only examine spws that are not completely flagged and not completely unflagged
            for mychan in range(len(channelsToReplace)):
               # find the closest unflagged channel
               closestDistance = 1000000
               for good in range(len(goodChannels)):
                   distance = abs(channelsToReplace[mychan]-goodChannels[good])
                   if (distance < closestDistance):
                       closestGoodChannel = good
                       closestDistance = distance
               dreal[channelsToReplace[mychan]] = dreal[goodChannels[closestGoodChannel]]
               if (method != 'float'):
                   dimag[channelsToReplace[mychan]] = dimag[goodChannels[closestGoodChannel]]
               if (fullVerbose):
                   print "row=%d, pol=%d, spw=%d, Ant%d: avoiding flagged channel %d with good channel %d" % (j,i,
                          cal_desc_id[j],antennas[j],channelsToReplace[mychan],goodChannels[closestGoodChannel])
               if (log != ''):
                   f.write("row=%d, pol=%d, spw=%d, Ant%d: avoiding flagged channel %d with good channel %d\n" % (j,i,
                            cal_desc_id[j],antennas[j],channelsToReplace[mychan],goodChannels[closestGoodChannel]))
               channelsReplaced += 1
          if (channelsReplaced > 0 and (verbose or fullVerbose)):
              print "Avoided %d flagged channels on pol=%d, spw=%d, antenna=%d" % (channelsReplaced,i,cal_desc_id[j],antennas[j])
        #   window type and window_len will be options
        if (method == 'ri'):
            ggr = smooth(dreal, window_len, window)
            ggi = smooth(dimag, window_len, window)
            for k in chan:
                gsm[i,k,j] = np.complex(ggr[k],ggi[k])
        elif (method == 'ap'):
            phase = np.arctan2(dimag, dreal)
            amp = np.abs(dcompl)
            ampSmooth = smooth(amp, window_len, window)
            phaseSmooth = smooth(phase, window_len, window)
            dreal = ampSmooth * np.cos(phaseSmooth)
            dimag = ampSmooth * np.sin(phaseSmooth)
            for k in chan:
                gsm[i,k,j] = np.complex(dreal[k],dimag[k])
        elif (method == 'float'):
            gsm[i,:,j] = smooth(dreal, window_len, window)
        else:
            print "Unrecognized method = ", method
            return

  if (log != ''):
      f.close()
  mytb.close()
#   Overwrite smoothed bandpass into already defined output.
  os.system('cp -r %s %s'%(caltable,smooth_table))
  mytb.open(smooth_table, nomodify=False)
  mytb.putcol(gainColumnName, gsm)
  mytb.close()
  print "Smooth solution written to: %s" % (smooth_table)
  return

def getScansForIntentFast(vm,uniqueScans,intent):
  """
  Given a ValueMapping structure and a list of scans, return those
  that have the specified intent.
  This is a faster version of the function in ValueMapping.
  - Todd Hunter
  """
  onsourceScans = []
  for s in uniqueScans:
    scanIntents = vm.getIntentsForScan(s)
    if (intent in scanIntents):
        onsourceScans.append(s)
  return(onsourceScans)

def lstRange(vis, verbose=True, vm='',intent='OBSERVE_TARGET#ON_SOURCE'):
  """
  Compute the LST of start and end of the specified ms.
  For further help and examples, see http://casaguides.nrao.edu/index.php?title=Lstrange
  -- Todd Hunter
  """
  return(lstrange(vis,verbose=verbose,vm=vm,intent=intent))
    
def lstrange(vis, verbose=True, vm='', intent='OBSERVE_TARGET#ON_SOURCE'):
  """
  Compute the LST of start and end of the specified ms.
  For further help and examples, see http://casaguides.nrao.edu/index.php?title=Lstrange
  -- Todd Hunter
  """
  if (os.path.exists('%s/table.dat'%vis)==False):
      print "Could not find %s/table.dat, are you sure this is an ms?" % (vis)
      return
  try:
        antTable = vis+'/OBSERVATION'
        tb.open(antTable)
        observatory = tb.getcell('TELESCOPE_NAME')
#        print "Found observatory = %s" % observatory
        tb.close()
  except:
        observatory = 'ALMA'
        print "Could not open OBSERVATION table to get the telescope name: %s" % (antTable)
        print "Assuming ", observatory

  if (vm == ''):
      print "Running ValueMapping... (this may take a minute)"
      vm = ValueMapping(vis)
  uniqueScans = np.unique(vm.scans)

# This way is really slow:
#  onsourceScans = np.unique(vm.getScansForIntent(intent))
  if (verbose):
      print "Checking intents for each scan..."
  onsourceScans = getScansForIntentFast(vm,uniqueScans,intent)
  if (len(onsourceScans) < 1):
      # "old school" format
      onsourceScans = getScansForIntentFast(vm,uniqueScans,intent.replace('#','.'))
      if (len(onsourceScans) > 0):
          intent = intent.replace('#','.')
  if (verbose):
        print "%s scans = " % (intent), onsourceScans
  i = 0
  wikiline = ''
  wikiline2 = ''
  wikiline3 = 'no onsource time | '
  # First, examine the list of all scans (where i will be 0), then 
  # the list of the on-target scans (where i will be 1).
  for scans in [uniqueScans,onsourceScans]:
   if (len(scans) > 0):
    times = vm.getTimesForScans(scans)
    mjdsecmin = 1e12
    mjdsecmax = 0
    for t in times:
#  This is too slow:
#        mjdsecmin = np.amin([np.amin(t),mjdsecmin])
#        mjdsecmax = np.amax([np.amax(t),mjdsecmax])
#  Assume the times are in ascending order:
        mjdsecmin = np.amin([t[0],mjdsecmin])
        mjdsecmax = np.amax([t[-1],mjdsecmax])
    LST = np.zeros(2)
    [latitude, longitude, obs] = getObservatoryLatLong(observatory)
    LST[0] = ComputeLST(mjdsecmin, longitude)
    LST[1] = ComputeLST(mjdsecmax, longitude)
    if (i == 1):
        style = "on source"
    else:
        style = "of whole SB"
    duration = LST[1]-LST[0]
    duration2 = LST[1]+24-LST[0]
    if (duration2 < duration):
        duration = duration2
    if (verbose):
        print "LST range %s = %.2f to %.2f = %02d:%02d to %02d:%02d (%.1f minutes)" % (style,LST[0],LST[1],
       np.floor(LST[0]),np.floor(60*(LST[0]-np.floor(LST[0]))), np.floor(LST[1]),
       np.floor(60*(LST[1]-np.floor(LST[1]))), duration*60)
    [mjdmin,utmin] = mjdSecondsToMJDandUT(mjdsecmin)
    [mjdmax,utmax] = mjdSecondsToMJDandUT(mjdsecmax)
    if (i==0):
        alltimes = np.array([val for subl in times for val in subl])
        deltaT = 0.5*(abs(np.min(alltimes[np.where(alltimes > mjdsecmin)]) - mjdsecmin) + 
                      abs(np.max(alltimes[np.where(alltimes < mjdsecmax)]) - mjdsecmax))
        clockTimeMinutes = (mjdmax - mjdmin + deltaT/86400.)*1440.
    if (verbose):
        print "MJD range %s = %.4f to %.4f" % (style, mjdmin, mjdmax)
        print " UT range %s = %s to %s" % (style, utmin, utmax)
    tb.open(vis+'/OBSERVATION')
    sbname = 'unknown'
    exec_uid = 'unknown'
    if ('SCHEDULE' in tb.colnames()):
        if (tb.iscelldefined('SCHEDULE',0)):
            sched = tb.getcol('SCHEDULE')
            sbname = '%s' % (sched[0][0].split()[1])  # This is the SB UID.
            exec_uid = '%s' % (sched[1][0].split()[1])
    tb.close()
    if (i==0):
       wikiline2 += "| %s | %s | %s | %s-%s | %02d:%02d-%02d:%02d | %.1f | " % (utmin[0:10],sbname,exec_uid,utmin[10:-6],utmax[11:-6],np.floor(LST[0]),np.floor(60*(LST[0]-np.floor(LST[0]))), np.floor(LST[1]), np.floor(60*(LST[1]-np.floor(LST[1]))), clockTimeMinutes)
       csvline = "%s,%s,%.2f" % (sbname, exec_uid, clockTimeMinutes)
       wikiline += "%s-%s | %02d:%02d-%02d:%02d | %.1f |" % (utmin[0:-6],utmax[11:-6],np.floor(LST[0]),np.floor(60*(LST[0]-np.floor(LST[0]))), np.floor(LST[1]), np.floor(60*(LST[1]-np.floor(LST[1]))),clockTimeMinutes)
    else:
      # print out elevation range for mjdsecmin to mjdsecmax
      # could use TsysExplorer(vis) but it fails at line 1144
      tb.open("%s/POINTING" % vis)
      azel = 1
      try:
        elevation = np.transpose(tb.getcol("DIRECTION")[azel])
        elevTime  = tb.getcol("TIME")
        tb.close()
        t = vm.getTimesForScans(scans[0])[0]
        matches1 = np.where(elevTime > np.min(t[0]))[0]
        matches2 = np.where(elevTime < np.max(t[-1]))[0]
        matches = np.intersect1d(matches1,matches2)
        startElev = elevation[matches[0]]*180/math.pi
        t = vm.getTimesForScans(scans[-1])[0]
        matches1 = np.where(elevTime > np.min(t[0]))[0]
        matches2 = np.where(elevTime < np.max(t[-1]))[0]
        matches = np.intersect1d(matches1,matches2)
        stopElev = elevation[matches[-1]]*180/math.pi
        if (verbose):
            print "Elevation range on %s scans = %.1f-%.1f" % (intent, startElev,stopElev)
        wikiline += "%02d:%02d-%02d:%02d | %.0f-%.0f | " % (np.floor(LST[0]),np.floor(60*(LST[0]-np.floor(LST[0]))), np.floor(LST[1]), np.floor(60*(LST[1]-np.floor(LST[1]))), startElev, stopElev)
        wikiline3 = "%.0f-%.0f | " % (startElev,stopElev)
      except:
        wikiline3 = "pointing table empty | "
        if (verbose):
            print "The pointing table appears to be empty.  Was it deleted because this is a mosaic?"
        wikiline += "%02d:%02d-%02d:%02d | " % (np.floor(LST[0]),np.floor(60*(LST[0]-np.floor(LST[0]))), np.floor(LST[1]), np.floor(60*(LST[1]-np.floor(LST[1]))))
    i += 1
  if (verbose):
      print "wikiline = %s" % (wikiline)
  csvline = 'csvline = %s' % (csvline)
  return (wikiline2, wikiline3,clockTimeMinutes,csvline)
  # end of lstrange()

def findNearestField(ra,dec,raAverageDegrees, decAverageDegrees):
    """
    Finds the field in a list that is nearest to the specified average position.
    ra and dec must be equal-sized lists.
    raAvergeDegrees and decAverageDegrees must be scalar values.
    -- Todd Hunter
    """
    nearestField = -1
    smallestSeparation = 1e15
    for i in range(len(ra)):
        separation = angularSeparation(ra[i],dec[i],raAverageDegrees,decAverageDegrees)
        if (separation < smallestSeparation):
            smallestSeparation = separation
            nearestField = i
    return([nearestField,smallestSeparation])

def plotmosaic(vis='',sourceid='',figfile='', coord='relative', skipsource=-1,
               doplot=True, help=False, sciencespws=False, vm='', debug=False,
               intent='OBSERVE_TARGET#ON_SOURCE'):
    """
    Produce a plot of the pointings with the primary beam FWHM and field names.
    For further help and examples, see http://casaguides.nrao.edu/index.php?title=Plotmosaic
    Required parameters:
    vis: the measurement set

    Optional parameters:
    sourceid: int or string (name or ID)
    figfile: name of the png to produce
    coord: 'relative' or 'absolute'
    skipsource: source ID to avoid
    doplot: if False, then the central field ID is returned as an integer. 
            if True, the a list of values is returned: 
               [central field,  maxRA, minRA, minDec, maxDec]
       where the latter 4 values are in units of arcsec relative to the center.
    sciencespws: if True, then only use the science spws
    vm: a ValueMapping structure (obsolete, only for CASA < 4.1)
    debug: if True, print extra messages
    intent: determine the source IDs to use from this intent (if sourceid='')

    -- Todd Hunter
    """
  
    # open the ms table
    if (coord.find('abs')<0 and coord.find('rel')<0):
        print "Invalid option for coord, must be either 'rel'ative or 'abs'olute."
        return
    mytb = createCasaTool(tbtool)
    try:
        fieldTable = vis+'/FIELD'
        mytb.open(fieldTable)
    except:
        print "Could not open table = %s" % fieldTable 
        return
    delayDir = mytb.getcol('DELAY_DIR')
    sourceID = mytb.getcol('SOURCE_ID')
    name = mytb.getcol('NAME')
    if (type(sourceid) == str):
        try:
            sourceid = int(sourceid)
        except:
            # Source was specified by name, so we
            # need to convert the name to an id.
            matches=np.where(name==sourceid)[0]
            srcs=np.unique(sourceID[matches])
            nsrcs=len(srcs)
            if (nsrcs>1):
                print "More than one source ID matches this name: ",sourceID
                print "Try again using one of these."
                return
            elif (nsrcs==0):
                if (sourceid != ''):
                    print "No sources match this name = %s" % sourceid
                    print "Available sources = ",np.unique(name)
                    return
                else:
                    if (casadef.casa_version >= '4.1.0'):
                        print "No source specified, so using the intent %s." % (intent)
                    else:
                        print "No source specified, so using the first source."
                        sourceid = 0
                        return
            else:
                sourceid = srcs[0]
    #  sourcename = name[sourceid]  # original method, replaced by the line after the 'if' block
    fields = np.array(range(len(sourceID)))
    if (sourceid != ''):
        matches = np.where(sourceID == int(sourceid))[0]
        fields = fields[matches]
        matches = np.where(fields != skipsource)[0]
        fields = fields[matches]
        if (len(fields) < 1):
            print "No fields contain source ID = ", sourceid
            return
        print "Field IDs with matching source ID = ", fields
        sourcename = name[list(sourceID).index(sourceid)]  # protects against the case of non-consecutive source IDs
    else:
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        fields = mymsmd.fieldsforintent(intent)
        if (len(fields) == 0):
            fields = mymsmd.fieldsforintent('*'+intent+'*')
            if (len(fields) == 0):
                print "No fields have intent = %s. Using first field instead." % (intent)
                fields = [0]
        sourcename = mymsmd.namesforfields(fields[0])[0]
        mymsmd.close()
        srcID = sourceID[list(name).index(sourcename)]
        print "Found %d fields for source ID=%d: %s: %s" % (len(fields), srcID, sourcename, str(fields))
    name = mytb.getcol('NAME')
    mytb.close()
    mytb.open(vis)
    antennasWithData = np.sort(np.unique(mytb.getcol('ANTENNA1')))
    mytb.close()
    try:
        antennaTable = vis+'/ANTENNA'
        mytb.open(antennaTable)
    except:
        print "Could not open table = %s" % antennaTable 
        return
    dishDiameter = np.unique(mytb.getcol('DISH_DIAMETER')[antennasWithData])
    mytb.close()
    if (debug): print "dishDiameter = ", dishDiameter
    try:
        spwTable = vis+'/SPECTRAL_WINDOW'
        mytb.open(spwTable)
        num_chan = mytb.getcol('NUM_CHAN')
        refFreqs = mytb.getcol('REF_FREQUENCY')
        spwNames = mytb.getcol('NAME')
        bandNames = []
        for spwName in spwNames:
            bandNames.append(spwName.split('#')[0])
        bandNames = np.unique(bandNames)
        if (debug):
            print "bandNames = ", bandNames
        mytb.close()
    except:
        print "Could not open table = %s" % antennaTable 
        print "Will not print primary beam circles"
        titleString = vis.split('/')[-1]
        dishDiameter =  [0]
    [latitude,longitude,obs] = getObservatoryLatLong('ALMA') 
    if (debug): print "Got observatory longitude = %.3f deg" % (longitude)
    tsysOnlyFields = []
    if (sciencespws):
        if (casadef.casa_version >= '4.1.0'):
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(vis)
            spws = mymsmd.spwsforintent('OBSERVE_TARGET#ON_SOURCE')
            wvrspws = mymsmd.wvrspws()
            print "spws with observe_target = ", spws
            spws = [x for x in spws if x not in wvrspws]
            print "non-WVR = ", spws
            meanRefFreq = []
            for spw in spws:
                meanRefFreq.append(mymsmd.meanfreq(spw))
            meanRefFreq = np.mean(meanRefFreq)
            for f in fields:
                tsysOnly = True
                scans = mymsmd.scansforfield(f)
                for sc in scans:
                    scanIntents = mymsmd.intentsforscan(sc)
                    if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in scanIntents):
                        tsysOnly = False
                if (tsysOnly): tsysOnlyFields.append(f)
            print "fields with Tsys only = ", tsysOnlyFields
            mymsmd.close()
        else:
            if (vm == ''):
                vm = ValueMapping(vis)
            spws = vm.getSpwsForIntent('OBSERVE_TARGET#ON_SOURCE')
            for f in fields:
                tsysOnly = True
                scans = vm.getScansForField(f)
                for sc in scans:
                    scanIntents = vm.getIntentsForScan(sc)
                    if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in scanIntents):
                        tsysOnly = False
                if (tsysOnly): tsysOnlyFields.append(f)
            print "spws with observe_target = ", spws
            print "fields with Tsys only = ", tsysOnlyFields
            matchedNames = np.array(bandNames)[spws]
            matchedRefFreqs = np.array(refFreqs)[spws]
            matches = np.where(matchedNames != 'WVR')
            print "non-WVR = ", matchedNames[matches]
            meanRefFreq = np.mean(matchedRefFreqs[matches])
    else:
        if (3840 in num_chan):
            matches = np.where(num_chan == 3840)[0]
        else:
            matches = np.where(num_chan > 4)[0]  # this kills the WVR and channel averaged data
        meanRefFreq = np.mean(refFreqs[matches])
        myband = freqToBand(meanRefFreq)[0]
        print "Mean frequency = %f GHz (band = %d)" % (meanRefFreq*1e-9, myband)
        # If mean freq is not within one of the observed bands, then recalculate
        if ('ALMA_RB_%02d'%(myband) not in bandNames and len(bandNames) > 1): # old data do not have band names in spw names
            print "Mean frequency is not in any observed band. Recalculating over higher frequencies."
            newFreqs = refFreqs[matches]
            newmatches = np.where(newFreqs > meanRefFreq)[0]
            meanRefFreq = np.mean(newFreqs[newmatches])
            print "Mean frequency = %f GHz" % (meanRefFreq*1e-9)
    lambdaMeters = c_mks / meanRefFreq
    ra = delayDir[0,:][0]*12/math.pi
    dec = delayDir[1,:][0]*180/math.pi
    ra *= 15
    raAverageDegrees = np.mean(ra[fields])
    decAverageDegrees = np.mean(dec[fields])
    cosdec = 1.0/cos(decAverageDegrees*np.pi/180)
  
    # Here we scale by cos(dec) to make then pointing pattern in angle on sky
    raRelativeArcsec = 3600*(ra - raAverageDegrees)*cos(decAverageDegrees*math.pi/180.)
    decRelativeArcsec = 3600*(dec - decAverageDegrees)
  
    markersize = 4
    print "Found %d pointings in this ms" % (shape(ra)[0])
    [centralField,smallestSeparation] = findNearestField(ra[fields],dec[fields],
                                            raAverageDegrees, decAverageDegrees)
    # This next step is crucial, as it converts from the field number 
    # determined from a subset list back to the full list.
    centralField = fields[centralField]
    
    print "Field %d is closest to the center of the area covered (%.1f arcsec away)." % (centralField,smallestSeparation*3600)
    if (doplot==False):
        return(centralField)
    pb.clf()
    maxradius = 0
    desc = pb.subplot(111)
    if (coord.find('abs')>=0):
        raunit = 'deg'  # nothing else is supported (yet)
        desc = pb.subplot(111,aspect=cosdec)
        # SHOW ABSOLUTE COORDINATES
        pb.plot(ra[fields],dec[fields],"k+",markersize=markersize)
        for j in dishDiameter:
            for i in range(len(ra)):
                if (i in fields):
                    if (j > 0):
                        arcsec = 0.5*primaryBeamArcsec(wavelength=lambdaMeters*1000,diameter=j, showEquation=False)
                        radius = arcsec/3600.0
                        if (radius > maxradius):
                            maxradius = radius
                        if (i in tsysOnlyFields):
                            myedgecolor = 'r'
                        else:
                            myedgecolor = 'b'
                            if (len(dishDiameter) > 1 and j < 12):
                                # Draw ACA in black
                                myedgecolor = 'k'
#                        print "Plotting ellipse with radius = ", radius
                        cir = matplotlib.patches.Ellipse((ra[i], dec[i]), width=2*radius*cosdec,
                                                       height=2*radius, facecolor='none', edgecolor=myedgecolor,
                                                       linestyle='dotted')
                        pb.gca().add_patch(cir)
    #                    cir = pb.Circle((ra[i], dec[i]), radius=radius, facecolor='none', edgecolor='b', linestyle='dotted')
        titleString = vis.split('/')[-1]+', %s, average freq. = %.1f GHz, beam = %.1f"'%(sourcename,meanRefFreq*1e-9,2*arcsec)
        resizeFonts(desc, 10)
        if (raunit.find('deg') >= 0):
            pb.xlabel('Right Ascension (deg)')
        else:
            pb.xlabel('Right Ascension (hour)')
        pb.ylabel('Declination (deg)')
        raRange = np.max(ra[fields])-np.min(ra[fields])
        decRange = np.max(dec[fields])-np.min(dec[fields])
        x0 = np.max(ra[fields]) + 1.2*maxradius*cosdec
        x1 = np.min(ra[fields]) - 1.2*maxradius*cosdec
        y1 = np.max(dec[fields]) + 1.2*maxradius
        y0 = np.min(dec[fields]) - 1.2*maxradius
        pb.xlim([x0,x1])
        pb.ylim([y0,y1])
        pb.title(titleString,size=10)
        for i in range(len(ra)):
            if (i in fields):
                pb.text(ra[i]-0.02*raRange, dec[i]+0.02*decRange, str(i),fontsize=12, color='k')
    elif (coord.find('rel')>=0):
        # SHOW RELATIVE COORDINATES
        pb.plot(raRelativeArcsec[fields], decRelativeArcsec[fields], 'k+', markersize=markersize)
        for j in dishDiameter:
            for i in range(len(ra)):
                if (i in fields):
                    if (j > 0):
                        arcsec = 0.5*primaryBeamArcsec(wavelength=lambdaMeters*1000, diameter=j, showEquation=False)
                        radius = arcsec
                        if (radius > maxradius):
                            maxradius = radius
                        if (i in tsysOnlyFields):
                            myedgecolor = 'r'
                        else:
                            myedgecolor = 'b'
                            if (len(dishDiameter) > 1 and j < 12):
                                # Draw ACA in black
                                myedgecolor = 'k'
#                        print "Plotting circle with radius = ", radius
                        cir = pb.Circle((raRelativeArcsec[i], decRelativeArcsec[i]),
                                        radius=radius, facecolor='none', edgecolor=myedgecolor,
                                        linestyle='dotted')
                        pb.gca().add_patch(cir)
        titleString = vis.split('/')[-1]+', %s, average freq. = %.1f GHz, beam = %.1f"'%(sourcename,meanRefFreq*1e-9,2*arcsec)
        resizeFonts(desc, 10)
        raString = qa.formxxx('%fdeg'%(raAverageDegrees), format='hms', prec=2)
        decString = qa.formxxx('%fdeg'%(decAverageDegrees), format='dms', prec=0).replace('.',':',2)
        pb.xlabel('Right ascension offset (arcsec) from %s' % (raString))
        pb.ylabel('Declination offset (arcsec) from %s' % (decString))
        pb.title(titleString,size=10)
        raRange = np.max(raRelativeArcsec[fields])-np.min(raRelativeArcsec[fields])
        decRange = np.max(decRelativeArcsec[fields])-np.min(decRelativeArcsec[fields])
        for i in range(len(ra)):
            if (i in fields):
                if (i in tsysOnlyFields):
                    pb.text(0.05, 0.93, 'Tsys-only fields: %s' % (str(tsysOnlyFields)), transform=desc.transAxes, color='r')
                    mycolor = 'r'
                else:
                    mycolor = 'k'
                pb.text(raRelativeArcsec[i]-0.02*raRange, decRelativeArcsec[i]+0.02*decRange, str(i),fontsize=12, color=mycolor)
        x0 = np.max(raRelativeArcsec[fields]) + 1.2*maxradius # 0.25*raRange
        x1 = np.min(raRelativeArcsec[fields]) - 1.2*maxradius # - 0.25*raRange
        y1 = np.max(decRelativeArcsec[fields]) + 1.2*maxradius # 0.25*decRange
        y0 = np.min(decRelativeArcsec[fields]) - 1.2*maxradius # 0.25*decRange
        mosaicInfo = []
        mosaicInfo.append(centralField)
        mosaicInfo.append(np.max(raRelativeArcsec[fields]) + 2*maxradius)
        mosaicInfo.append(np.min(raRelativeArcsec[fields]) - 2*maxradius)
        mosaicInfo.append(np.max(decRelativeArcsec[fields]) + 2*maxradius)
        mosaicInfo.append(np.min(decRelativeArcsec[fields]) - 2*maxradius)
        pb.xlim(x0,x1)
        pb.ylim(y0,y1)
        pb.axis('equal')
    else:
        print "Invalid option for coord, must be either 'rel'ative or 'abs'olute."
        return
  
    yFormatter = ScalarFormatter(useOffset=False)
    desc.yaxis.set_major_formatter(yFormatter)
    desc.xaxis.set_major_formatter(yFormatter)
    desc.xaxis.grid(True,which='major')
    desc.yaxis.grid(True,which='major')
    if (len(dishDiameter) > 1):
        pb.text(0.04, 0.03, '12m', color='b', transform=desc.transAxes)
        pb.text(0.04, 0.08, '7m', color='k', transform=desc.transAxes)
    pb.draw()
    autoFigureName = "%s.pointings.%s.png" % (vis,coord)
    if (figfile==True):
        try:
          pb.savefig(autoFigureName)
          print "Wrote file = %s" % (autoFigureName)
        except:
          print "WARNING:  Could not save plot file.  Do you have write permission here?"
    elif (len(figfile) > 0):
        try:
          pb.savefig(figfile)
          print "Wrote file = %s" % (figfile)
        except:
          print "WARNING:  Could not save plot file.  Do you have write permission here?"
    else:
          print "To save a plot, re-run with either:"
          print "  plotmosaic('%s',figfile=True) to produce the automatic name=%s" % (vis,autoFigureName)
          print "  plotmosaic('%s',figfile='myname.png')" % (vis)
    if (coord.find('rel')>=0):
        return mosaicInfo
    else:
        return

def plotconfig(telescope='', config='', figfile='', list=False, limits=None,
               gridlines=True, listconfig=False, cofa=[], title='',
               repotable='', antennaSizePercent=0.5, units='m',
               tickSpacing=None, fontsize=12, showPadNames=False):
    """
    Plots pad layout for specified telescope and configuration name. It also returns an
    array containing the baseline lengths, sorted from shortest to longest.
    For further help and examples, see http://casaguides.nrao.edu/index.php?title=Plotconfig
    -- Todd Hunter
    Telescopes and configurations available to plot (there may be more):"
    aca: i, ns, tp
    alma: cycle0.compact, cycle0.extended, 1..28, cycle1_1..6
    carma: a, b, c, d, e
    meerkat
    pdbi: a, b, c, d
    sma: subcompact, compact, compact.n, extended, vextended
    vla: a, bna, b, cnb, c, dnc, d
    WSRT
    telescope='file' option: specify any user filename as config='myfilename'
    figfile: True (for automatic name generation) or a specific filename for the png
    limits: optional parameter for plot range: [x0,x1,y0,y1]
    list: optional Boolean parameter to print the list of baseline lengths
    listconfig: optional Boolean parameter to print the .cfg file
    cofa: center-of-array coordinates [x,y,z]; if [], then use the value in CASA
    title:  title for plot (default is "telescope config")
    repotable: default is the CASA simmos area
    antennaSizePercent: size of antennas to draw in large configurations
    units: 'm' or 'km'
    tickSpacing: change the X & Y axis major tick spacing (in specified units)
    fontsize: for axis labels and tick labels
    """
    z = None
    if (telescope == 'wsrt'):
        telescope = telescope.upper()
    else:
        telescope = telescope.lower()
        
    if (len(str(config)) < 1 and telescope.find('meerkat')<0 and telescope.find('WSRT')<0):
        print "Telescope and configuration available to plot:"
        print "aca: i, ns, tp,  i.loc, nc.loc, tp.loc"
        print "alma: cycle0.compact, cycle0.extended, cycle1_1..6, 1..28"
        print "carma: a, b, c, d, e"
        print "meerkat"
        print "pdbi: a, b, c, d"
        print "sma: subcompact, compact, compact.n, extended, vextended"
        print "vla: a, bna, b, cnb, c, dnc, d"
        print "WSRT"
        print "file: specify any filename as config='myfilename'"
        return
    configString = str(config)
    if (len(str(config)) > 0):
        if (telescope.find('alma')<0):
            if (telescope.find('pdbi')<0):
                configString = '.'+str(config)
            else:
                # PdBI 
                configString = '-'+str(config)
        else:  # ALMA
            if (str(config).find('cycle1')>=0):
                configString = '_' + config
            elif (str(config).isdigit()==False and config.find('alma.out')<0):  # cycle 0
                configString = '.' + config
    if (repotable == ''):
        repotable = os.getenv("CASAPATH").split()[0]+"/data/alma/simmos/"
    if (telescope == 'alma' and str(config).isdigit()):
        #  1
        myfile = repotable+telescope+'.out%02d'%int(config)+".cfg"
    elif (config.find('.cfg')<0): 
        if (configString.find(telescope) >= 0):
            # alma.out01
            myfile = repotable+configString+".cfg"
        else:
            # out01
            myfile = repotable+telescope+configString+".cfg"
    else:  # alma.out01.cfg
        if (configString.find(telescope) >= 0):
            # alma.out01.cfg
            if (configString[0] != '/' and configString[0:2] != './'):
                myfile = repotable+configString
            else:
                myfile = configString
        else:
            # out01.cfg
            if (configString[0] != '/' and configString[0:2] != './'):
                myfile = repotable+telescope+configString
            else:
                myfile = configString
    if (telescope == 'file'):
        myfile = config
    if (os.path.exists(myfile) == False):
        print "Could not locate file = ", myfile
        myfile = config
        if (os.path.exists(myfile) == False):
            print "*Could not locate file = ", myfile
            return
    try:
        fd = open(myfile,'r')
    except:
        print "Could not open file = ", myfile
        return
    columns = []
    line = fd.readline()
    telescopeCOFA = telescope
    while (len(line) > 0):
        if (listconfig):
            print line[:-1]
        if (line.find('#')>=0):
            mystr = line.split('=')
            if (len(mystr) > 1):
                mystr = mystr[1].split('\n')[0]
                if (line.find('observatory')>=0):
                    if (telescope.upper() == 'ACA'):
                        telescopeCOFA = 'ALMA'
                    if (telescope == ''):
                        telescope = line.split('=')[1].strip('\n')
                elif (line.find('coordsys')>=0):
                    coordsys = mystr
                elif (line.find('datum')>=0):
                    datum = mystr
                elif (line.find('zone')>=0):
                    zone = int(mystr)
                elif (line.find('hemisphere')>=0):
                    nors = mystr
        else:
            newcolumns = line.split()
            if (len(newcolumns) > 2):
                if (str.isdigit(newcolumns[-1].replace(".","",1)) or showPadNames):
                    columns.append(newcolumns)
                else:
                    columns.append(newcolumns[0:len(newcolumns)-1])
        line=fd.readline()
    print "Read %d pads for observatory=%s in coordsys=%s (from %s)" % (len(columns), telescope,coordsys, myfile)
    if (coordsys.find('LOC')>=0):
        x = np.array(columns).transpose()[0].astype('float')
        y = np.array(columns).transpose()[1].astype('float')
        z = np.array(columns).transpose()[2].astype('float')
        diameter = np.array(columns).transpose()[3].astype('float')
        if (showPadNames):
            padnames = np.array(columns).transpose()[4].astype('str')
        if (config == 'i.loc' or config == 'ns.loc' or config == 'nc.loc'):
            diameter = 7*(diameter/diameter)
        print "Maximum height difference = %f m" % (np.max(z)-np.min(z))
    else:
        position = np.array(columns).transpose().astype('float')
        diameter = np.array(columns).transpose()[3].astype('float')
        u = simutil.simutil()
        repotable=os.getenv("CASAPATH").split()[0]+"/data/geodetic/Observatories"
        mytb = createCasaTool(tbtool)
        mytb.open(repotable)
        Name = mytb.getcol('Name')
        cx = position[0][0]
        cy = position[1][0]
        cz = position[2][0]
        myType = ''
        if (cofa != []):
            cx,cy,cz = cofa
            if (coordsys.find('UTM') >= 0):
                (position[0],position[1],position[2]) = u.utm2xyz(position[0,:], position[1,:],position[2,:],zone,datum,nors)
        else:
            # Read COFA from CASA
            for i in range(len(Name)):
                if (Name[i] == telescopeCOFA or Name[i] == telescopeCOFA.upper()):
                    Long = mytb.getcell('Long',i)
                    Lat = mytb.getcell('Lat',i)
                    Height = mytb.getcell('Height',i)
                    myType = mytb.getcell('Type',i)
                    if (myType == 'ITRF'):
                        cx = mytb.getcell('X',i)
                        cy = mytb.getcell('Y',i)
                        cz = mytb.getcell('Z',i)
                    else:
                        # WGS84
                        print "COFA in long/lat/height = ", Long, Lat, Height
                        output = u.long2xyz(Long*math.pi/180.,Lat*math.pi/180.,Height,myType)
                        (cx,cy,cz) = output
                        if (coordsys.find('UTM')>=0):
                            (position[0],position[1],position[2]) = u.utm2xyz(position[0,:], position[1,:],position[2,:],zone,datum,nors)
                    print "COFA in x/y/z = ", cx,cy,cz
                    break
            if (len(myType) < 1):
                print "Did not find telescope data for %s, using first station as center of array." % (telescopeCOFA)
            mytb.close()
        print "Using COFA = ", cx, cy, cz
        try:
            output = u.irtf2loc(position[0,:],position[1,:],position[2,:],cx,cy,cz)
        except:
            output = u.itrf2loc(position[0,:],position[1,:],position[2,:],cx,cy,cz)
        if (len(output) == 2):
            (x,y) = output
        else:
            (x,y,z) = output
    lengths = []
    for i in range(len(x)):
        for j in range(i,len(x)):
            if (i != j):
                if (z==None):
                    lengths.append(((x[i]-x[j])**2+(y[i]-y[j])**2)**0.5)
                else:
                    lengths.append(((x[i]-x[j])**2+(y[i]-y[j])**2+(z[i]-z[j])**2)**0.5)
    lengths = np.sort(lengths)
    if (limits == None):
        maxlength = np.max(lengths) # in meters
    else:
        xsize = (limits[1]-limits[0])
        ysize = (limits[3]-limits[2])
        maxlength = 0.5*(ysize+xsize)  # meters or km
        if (units == 'km'):
            maxlength *= 1000
    pb.clf()
    uniqueDiameters = np.unique(diameter)
    print "diameters = ", uniqueDiameters
    adesc = pb.subplot(111)
    pb.subplots_adjust(bottom=np.max([0.1,fontsize/100.])) # make room for baseline stats
    pb.hold(True)
    dcolor = ['b','r']
    axes = pb.axes()
    exaggerated = False
    for d in range(len(uniqueDiameters)):
        diam = uniqueDiameters[d]
        matches = np.where(diam == diameter)[0]
        for m in matches:
            myx = x[m]
            myy = y[m]
            radius= np.max([maxlength*antennaSizePercent*0.01,diameter[m]*0.5])
            if (radius > diameter[m]*0.5):
                exaggerated = True
            if (units == 'km'):
               myx *= 0.001
               myy *= 0.001
               radius *= 0.001
            circ=pb.Circle((myx, myy),radius=radius, color=dcolor[d])
            axes.add_patch(circ)
            if (showPadNames):
                if (limits==None or (myx <= limits[1] and myx >=limits[0] and 
                                     myy <= limits[3] and myy >= limits[1])):
                    pb.text(myx, myy, padnames[m], size=10)
    pb.hold(False)
    if (title == ''):
        configString = config
        limit = 70-len(telescope)
        if (exaggerated):
            limit -= 27
            if (len(configString) > limit):
                configString = '...' + configString[-limit:]
            titleString = '%s: %s (antenna size exaggerated)' % (telescope,configString)
        else:
            if (len(configString) > limit):
                configString = '...' + configString[-limit:]
            titleString = '%s: %s' % (telescope,configString)
        pb.title(titleString,size=14)
    else:
        pb.title(title,size=14)
    pb.text(-0.1,-fontsize/100.,"baselines: min/median/rms/max = %.1f / %.1f / %.1f / %.1f m" % (np.min(lengths),np.median(lengths),np.sqrt(np.mean(lengths**2)),np.max(lengths)),transform=adesc.transAxes)
    if (units == 'km'):
       xlabel = 'X (km)'
       ylabel = 'Y (km)'
    else:
       xlabel = 'X (m)'
       ylabel = 'Y (m)'
    pb.xlabel(xlabel, size=fontsize)
    pb.ylabel(ylabel, size=fontsize)
    if (list):
        for i in range(len(lengths)):
            print "%.1f m" % (lengths[i])
    if (limits != None):
        pb.gcf().set_size_inches(6.0, 6.0*ysize/xsize)
        pb.gca().set_autoscale_on(False)
        pb.xlim([limits[0],limits[1]])
        pb.ylim([limits[2],limits[3]])
    else:
        pb.axis('equal')
    if (True):
        yFormatter = matplotlib.ticker.ScalarFormatter(useOffset=False)
        adesc.yaxis.set_major_formatter(yFormatter)
        xFormatter = matplotlib.ticker.ScalarFormatter(useOffset=False)
        adesc.xaxis.set_major_formatter(xFormatter)
        if (gridlines):
            adesc.yaxis.grid(True,which='major')
            adesc.xaxis.grid(True,which='major')
        if (tickSpacing == None):
            majorTicks = pb.gca().get_xticks()
            print "majorTicks = ", majorTicks
            xmajorTickSpacing = abs(majorTicks[1] - majorTicks[0])
            majorTicks = pb.gca().get_yticks()
            ymajorTickSpacing = abs(majorTicks[1] - majorTicks[0])
            print "xmajor tick spacing = %f, y=%f" % (xmajorTickSpacing, ymajorTickSpacing)
            tickSpacing = np.max([xmajorTickSpacing,ymajorTickSpacing])
        adesc.xaxis.set_major_locator(MultipleLocator(tickSpacing))
        adesc.yaxis.set_major_locator(MultipleLocator(tickSpacing))
    resizeFonts(adesc,fontsize)
    pb.draw()
    if (limits != None):
        # This seems to be necessary in order for the first plot to be square.
        # Subsequent plots become square without these lines present.
        pb.gcf().set_size_inches(6.0, 6.0*ysize/xsize)
        pb.draw()
    if (telescope == 'ALMA' and str(config).isdigit()):
        autoFigureName = "%s.%02d.png" % (telescope,int(str(config)))
    else:
        autoFigureName = "%s.%s.png" % (telescope,config)
    if (figfile == True):
        pb.savefig(autoFigureName)
        print "Wrote file = %s" % (autoFigureName)
    elif (len(figfile) > 0):
        pb.savefig(figfile)
        print "Wrote file = %s" % (figfile)
    else:
        print "To save a plot, re-run with either:"
        print "  plotconfig('%s','%s',figfile=True) to produce the automatic name=%s" % (telescope,config,autoFigureName)
        print "  plotconfig('%s','%s',figfile='myname.png')" % (telescope,config)
    print "min/nextmin/median/mean/rms/max = %.2f / %.2f / %.2f / %.2f / %.2f / %.2f m" % (np.min(lengths),lengths[1],np.median(lengths),np.mean(lengths),np.sqrt(np.mean(lengths**2)),np.max(lengths))
    return(lengths)

class stuffForScienceDataReduction:
    def locatePath(self, pathEnding):
        # This method will locate any file in the active analysisUtils
        # "science" subdirectory tree. You need to call it with the
        # trailing part of the path beyond the ~/AIV/science/ directory.
        # e.g. 'PadData/almaAntPos.txt'
        #
#        print "Looking for %s in the analysisUtils area" % (pathEnding)
        tokens = __file__.split('/')
        mypath = ''
        for i in range(len(tokens)-len(pathEnding.split('/'))):
            mypath += tokens[i] + '/'
        mypath += pathEnding
        return(mypath)

    def correctMyAntennaPositions(self, msName, obsTime='', verbose=True, checkForAntennaMoves=True):

        #casaCmd = 'print "# Correcting for antenna position errors."\n\n'
        casaCmd = ''

        tb.open(msName)
        if 'ASDM_ANTENNA' not in tb.keywordnames() or 'ASDM_STATION' not in tb.keywordnames():
            sys.exit('ERROR: The ANTENNA and/or STATION tables from the ASDM were not transferred to the MS.')
        tb.close()
        try:
            f=open(os.path.expanduser('~/AIV/science/PadData/almaAntPos.txt'), 'r')
        except:
            try:
                mypath = self.locatePath('PadData/almaAntPos.txt')
                f=open(mypath)
            except:
                print "Failed to find path=%s" % (mypath)

        almaAntPos=XmlObjectifier.XmlObject(f.read())
        f.close()

        try:
            g=open(os.path.expanduser('~/AIV/science/PadData/antennaMoves.txt'), 'r')
        except:
            try:
                mypath = self.locatePath('PadData/antennaMoves.txt')
                g=open(mypath)
            except:
                print "Failed to find path=%s" % (mypath)

        gc=g.read().splitlines()
        g.close()

        gc=sorted(gc)

        ij=-1
        antMoves={}
        for line in gc:
            line=line.strip()
            if (len(line) < 1): continue  # added by T. Hunter
            if line[0] == '#': continue
            ele=line.split()
            ij=ij+1
            antMoves[ij]={}
            antMoves[ij]['Date']=datetime.datetime.strptime(ele[0], '%Y-%m-%dT%H:%M')
            antMoves[ij]['Antenna']=ele[1]
            antMoves[ij]['From']=ele[2]
            antMoves[ij]['To']=ele[3]

        baseRunObj = almaAntPos.AntennaPositions.BaselineRun
        if not isinstance(baseRunObj, types.ListType): baseRunObj = [baseRunObj]

        measTime=[]
        for i in range(len(baseRunObj)):
            baseRunObj1 = baseRunObj[i]
            measTime.append(datetime.datetime.strptime(baseRunObj1.getAttribute('measTime'), '%Y-%m-%dT%H:%M:%S'))

        measTime = sorted(enumerate(measTime), key=operator.itemgetter(1), reverse=True)
        sort1 = []
        for i in range(len(measTime)):
            sort1.append(measTime[i][0])

        if obsTime == '':
            tb.open(msName+'/OBSERVATION')
            obsTimeRange = tb.getcol('TIME_RANGE')
            obsTime = (obsTimeRange[0]+obsTimeRange[1])/2.0
            obsTime = ((obsTime/86400.0)+2400000.5-2440587.5)*86400.0
            obsTime = timeUtilities.strftime('%Y-%m-%dT%H:%M:%S', timeUtilities.gmtime(obsTime))
            obsTime = datetime.datetime.strptime(obsTime, '%Y-%m-%dT%H:%M:%S')
            tb.close()
        else:
            obsTime = datetime.datetime.strptime(obsTime, '%Y-%m-%dT%H:%M:%S')

        tb.open(msName+'/ANTENNA')
        antNames = tb.getcol('NAME')
        padNames = tb.getcol('STATION')
        tb.close()

        msAntPos = {}
        for i in range(len(antNames)):
            msAntPos[antNames[i]] = {}
            msAntPos[antNames[i]]['pad'] = padNames[i]

        tb.open(msName+'/ASDM_ANTENNA')
        asdmAntNames = tb.getcol('name')
        asdmAntPositions = tb.getcol('position')
        tb.close()

        for i in range(len(antNames)):
            if antNames[i] not in asdmAntNames: sys.exit('ERROR: Antenna not found.')
            for j in range(len(asdmAntNames)):
                if asdmAntNames[j] == antNames[i]:
                    msAntPos[antNames[i]]['antPos'] = [asdmAntPositions[0][j], asdmAntPositions[1][j], asdmAntPositions[2][j]]
                    break

        tb.open(msName+'/ASDM_STATION')
        asdmPadNames = tb.getcol('name')
        asdmPadPositions = tb.getcol('position')
        tb.close()

        for i in range(len(antNames)):
            if padNames[i] not in asdmPadNames: sys.exit('ERROR: Pad not found.')
            for j in range(len(asdmPadNames)):
                if asdmPadNames[j] == padNames[i]:
                    msAntPos[antNames[i]]['padPos'] = [asdmPadPositions[0][j], asdmPadPositions[1][j], asdmPadPositions[2][j]]
                    break

        for i in range(len(antNames)):

            ij = -1
            antMoves1 = {}
            for j in range(len(antMoves)):
                if antMoves[j]['Antenna'] == antNames[i]:
                    ij = ij+1
                    antMoves1[ij] = antMoves[j]

            if len(antMoves1) == 0:
                sys.exit("ERROR: No antenna move information available for "+str(antNames[i]))
            if obsTime < antMoves1[0]['Date']:
                sys.exit("ERROR: No antenna move information available for "+str(antNames[i]))

            for j in range(len(antMoves1)-1, -1, -1):
                if antMoves1[j]['Date'] <= obsTime: break

            if antMoves1[j]['To'] != padNames[i]:
                if checkForAntennaMoves == True:
                    sys.exit("ERROR: Current data file has antenna "+str(antNames[i])+" on pad "+str(padNames[i])+" while latest move recorded is on pad "+str(antMoves1[j]['To']))
                else:
                    print "ERROR: Current data file has antenna "+str(antNames[i])+" on pad "+str(padNames[i])+" while latest move recorded is on pad "+str(antMoves1[j]['To'])
                    msAntPos.pop(antNames[i])
                    continue

            msAntPos[antNames[i]]['putInTime'] = antMoves1[j]['Date']

        msAntCorr = {}

        for i in msAntPos:

            found = 0

            for j in range(len(baseRunObj)):
                baseRunObj1 = baseRunObj[sort1[j]]
                measTime1 = datetime.datetime.strptime(baseRunObj1.getAttribute('measTime'), '%Y-%m-%dT%H:%M:%S')
                if measTime1 > msAntPos[i]['putInTime'] and measTime1 <= obsTime: # modified
                    antObj = baseRunObj1.Antenna
                    for k in range(len(antObj)):
                        antObj1 = antObj[k]
                        if antObj1.getAttribute('name') == i and antObj1.getAttribute('pad') == msAntPos[i]['pad']:
                            found = 1
                            padPosObj = antObj1.PadPosition
                            brPadPos = [padPosObj.getAttribute('X'), padPosObj.getAttribute('Y'), padPosObj.getAttribute('Z')]
                            antVecObj = antObj1.AntennaVector
                            brAntVec = [antVecObj.getAttribute('X'), antVecObj.getAttribute('Y'), antVecObj.getAttribute('Z')]
                            posErrObj = antObj1.PositionError
                            brPosErr = [posErrObj.getAttribute('X'), posErrObj.getAttribute('Y'), posErrObj.getAttribute('Z')]
                            break
                if found == 1: break # modified

            if found != 1:

                casaCmd = casaCmd + '# Note: no baseline run found for antenna '+i+'.\n\n'

            else:

                if brPadPos[0] == msAntPos[i]['padPos'][0] and brPadPos[1] == msAntPos[i]['padPos'][1] and brPadPos[2] == msAntPos[i]['padPos'][2]:

                    if brAntVec[0] != msAntPos[i]['antPos'][0] or brAntVec[1] != msAntPos[i]['antPos'][1] or brAntVec[2] != msAntPos[i]['antPos'][2]:

                        posDiff = []
                        for j in range(3):
                            posDiff.append(brAntVec[j] - msAntPos[i]['antPos'][j])

                        if sqrt((posDiff[0]/brPosErr[0])**2 + (posDiff[1]/brPosErr[1])**2 + (posDiff[2]/brPosErr[2])**2) > 2:

                            brLat = math.asin(brPadPos[2]/sqrt(brPadPos[0]**2+brPadPos[1]**2+brPadPos[2]**2))
                            brLon = math.atan2(brPadPos[1], brPadPos[0])

                            posDiff1 = []
                            posDiff1.append(-math.sin(brLon)*posDiff[0]-math.cos(brLon)*math.sin(brLat)*posDiff[1]+math.cos(brLon)*math.cos(brLat)*posDiff[2])
                            posDiff1.append(math.cos(brLon)*posDiff[0]-math.sin(brLon)*math.sin(brLat)*posDiff[1]+math.sin(brLon)*math.cos(brLat)*posDiff[2])
                            posDiff1.append(math.cos(brLat)*posDiff[1]+math.sin(brLat)*posDiff[2])

                            if np.linalg.norm(posDiff1) > 2e-3: casaCmd = casaCmd + '# Note: the correction for antenna '+i+' is larger than 2mm.\n\n'

                            msAntCorr[i] = {}
                            msAntCorr[i]['posDiff'] = posDiff1
                            if verbose == True: casaCmd = casaCmd + '# Position for antenna '+i+' is derived from baseline run made on '+str(measTime1)+'.\n\n' # modified

                else:

                    brLat = math.asin(brPadPos[2]/sqrt(brPadPos[0]**2+brPadPos[1]**2+brPadPos[2]**2))
                    brLon = math.atan2(brPadPos[1], brPadPos[0])

                    brPosTot = []
                    brPosTot.append(brAntVec[0] + -math.sin(-brLon)*brPadPos[0]-math.cos(-brLon)*math.sin(-brLat)*brPadPos[1]+math.cos(-brLon)*math.cos(-brLat)*brPadPos[2])
                    brPosTot.append(brAntVec[1] + math.cos(-brLon)*brPadPos[0]-math.sin(-brLon)*math.sin(-brLat)*brPadPos[1]+math.sin(-brLon)*math.cos(-brLat)*brPadPos[2])
                    brPosTot.append(brAntVec[2] + cos(-brLat)*brPadPos[1]+sin(-brLat)*brPadPos[2])

                    msLat = math.asin(msAntPos[i]['padPos'][2]/sqrt(msAntPos[i]['padPos'][0]**2+msAntPos[i]['padPos'][1]**2+msAntPos[i]['padPos'][2]**2))
                    msLon = math.atan2(msAntPos[i]['padPos'][1], msAntPos[i]['padPos'][0])

                    msPosTot = []
                    msPosTot.append(msAntPos[i]['antPos'][0] + -math.sin(-msLon)*msAntPos[i]['padPos'][0]-math.cos(-msLon)*math.sin(-msLat)*msAntPos[i]['padPos'][1]+math.cos(-msLon)*math.cos(-msLat)*msAntPos[i]['padPos'][2])
                    msPosTot.append(msAntPos[i]['antPos'][1] + math.cos(-msLon)*msAntPos[i]['padPos'][0]-math.sin(-msLon)*math.sin(-msLat)*msAntPos[i]['padPos'][1]+math.sin(-msLon)*math.cos(-msLat)*msAntPos[i]['padPos'][2])
                    msPosTot.append(msAntPos[i]['antPos'][2] + math.cos(-msLat)*msAntPos[i]['padPos'][1]+math.sin(-msLat)*msAntPos[i]['padPos'][2])

                    posDiff = []
                    for j in range(3):
                        posDiff.append(brPosTot[j] - msPosTot[j])

                    if sqrt((posDiff[0]/brPosErr[0])**2 + (posDiff[1]/brPosErr[1])**2 + (posDiff[2]/brPosErr[2])**2) > 2:

                        brPosTot1 = []
                        brPosTot1.append(brPadPos[0] + -math.sin(brLon)*brAntVec[0]-math.cos(brLon)*math.sin(brLat)*brAntVec[1]+math.cos(brLon)*math.cos(brLat)*brAntVec[2])
                        brPosTot1.append(brPadPos[1] + math.cos(brLon)*brAntVec[0]-math.sin(brLon)*math.sin(brLat)*brAntVec[1]+math.sin(brLon)*math.cos(brLat)*brAntVec[2])
                        brPosTot1.append(brPadPos[2] + math.cos(brLat)*brAntVec[1]+math.sin(brLat)*brAntVec[2])

                        msPosTot1 = []
                        msPosTot1.append(msAntPos[i]['padPos'][0] + -math.sin(msLon)*msAntPos[i]['antPos'][0]-math.cos(msLon)*math.sin(msLat)*msAntPos[i]['antPos'][1]+math.cos(msLon)*math.cos(msLat)*msAntPos[i]['antPos'][2])
                        msPosTot1.append(msAntPos[i]['padPos'][1] + math.cos(msLon)*msAntPos[i]['antPos'][0]-math.sin(msLon)*math.sin(msLat)*msAntPos[i]['antPos'][1]+math.sin(msLon)*math.cos(msLat)*msAntPos[i]['antPos'][2])
                        msPosTot1.append(msAntPos[i]['padPos'][2] + math.cos(msLat)*msAntPos[i]['antPos'][1]+math.sin(msLat)*msAntPos[i]['antPos'][2])

                        posDiff1 = []
                        for j in range(3):
                            posDiff1.append(brPosTot1[j] - msPosTot1[j])

                        if np.linalg.norm(posDiff1) > 2e-3: casaCmd = casaCmd + '# Note: the correction for antenna '+i+' is larger than 2mm.\n\n'

                        msAntCorr[i] = {}
                        msAntCorr[i]['posDiff'] = posDiff1
                        if verbose == True: casaCmd = casaCmd + '# Position for antenna '+i+' is derived from baseline run made on '+str(measTime1)+'.\n\n' # modified

        gcAntList = []
        for i in msAntCorr: gcAntList.append(i)
        gcAntList = ','.join(gcAntList)

        gcAntParam = []
        gcAntParam0 = []
        for i in msAntCorr:
            for j in range(3):
                gcAntParam.append(str(msAntCorr[i]['posDiff'][j]))
                gcAntParam0.append('0')
        gcAntParam = ','.join(gcAntParam)
        gcAntParam0 = ','.join(gcAntParam0)

        if gcAntList != '':

            casaCmd = casaCmd + "os.system('rm -rf %s.antpos') \n"%(msName)  # Added by CLB
            casaCmd = casaCmd + "gencal(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  caltable = '"+msName+".antpos',\n"
            casaCmd = casaCmd + "  caltype = 'antpos',\n"
            casaCmd = casaCmd + "  antenna = '"+gcAntList+"',\n"
            casaCmd = casaCmd + "  parameter = ["+gcAntParam0+"])\n"
            casaCmd = casaCmd + "#  parameter = ["+gcAntParam+"])\n"

            return casaCmd

        else:

            print "Note: I could not find any offset between the antenna positions in the ASDM and in the database, so I am not including any gencal call."

    def getSpwInfo(self, msName, intent='OBSERVE_TARGET'):

        tb.open(msName+'/STATE')
        obsModes = tb.getcol('OBS_MODE')
        tb.close()

        obsModes1 = []
        for i in range(len(obsModes)):
            if re.search(intent, obsModes[i]) != None:
                obsModes1.append(i)

        if len(obsModes1) == 0:
            if 'OBSERVE_TARGET' in intent: # this is mainly for the cal survey reduction
                print 'WARNING: There seems to be no OBSERVE_TARGET intent in the data.'
                print 'WARNING: I will try with the intent CALIBRATE_PHASE. THIS MAY BE WRONG!!'
                obsModes1 = []
                for i in range(len(obsModes)):
                    if re.search('CALIBRATE_PHASE', obsModes[i]) != None:
                        obsModes1.append(i)
                if len(obsModes1) == 0:
                    print 'WARNING: There seems to be no CALIBRATE_PHASE intent in the data.'
                    print 'WARNING: I will try with the intents CALIBRATE_AMPLI and CALIBRATE_FLUX. THIS MAY BE WRONG!!'
                    obsModes1 = []
                    for i in range(len(obsModes)):
                        if re.search('CALIBRATE_AMPLI|CALIBRATE_FLUX', obsModes[i]) != None:
                            obsModes1.append(i)
                    if len(obsModes1) == 0: sys.exit('ERROR: Intent not found.')
            else:
                #sys.exit('ERROR: Intent not found.')
                print 'WARNING: Intent not found.'
                return {}

        tb.open(msName+'/PROCESSOR')
        tb1 = tb.query("SUB_TYPE == 'ALMA_CORRELATOR_MODE'")
        procIds = tb1.rownumbers()

        if (type(procIds) == int):
            # Added by T. Hunter to prevent crash at 'for' loop when only one value is returned.
            procIds = [procIds]
        tb1.close()
        tb.close()

        tb.open(msName+'/DATA_DESCRIPTION')
        spwIds = tb.getcol('SPECTRAL_WINDOW_ID')
        tb.close()

#         tb.open(msName+'/SPECTRAL_WINDOW')
#         numChans = tb.getcol('NUM_CHAN')
#         refFreq = tb.getcol('REF_FREQUENCY')
#         tb.close()

        tb.open(msName)

        dataDescIds = []
        for i in procIds:
            for j in obsModes1:
                tb1 = tb.query('PROCESSOR_ID == '+str(i)+' AND STATE_ID == '+str(j))
                dataDescIds1 = sorted(dict.fromkeys(tb1.getcol('DATA_DESC_ID')).keys())
                dataDescIds.extend(dataDescIds1)
                tb1.close()
        tb.close()

        dataDescIds = sorted(dict.fromkeys(dataDescIds).keys())

        if intent == 'OBSERVE_TARGET':

            tb.open(msName)

            integTime = []
            for i in dataDescIds:
                tb1 = tb.query('DATA_DESC_ID == '+str(i))
                integTime1 = dict.fromkeys(tb1.getcol('EXPOSURE')).keys()
                if len(integTime1) != 1:
                    print "WARNING: DATA ASSOCIATED TO DATA_DESC_ID="+str(i)+" IN "+msName+" HAVE MORE THAN ONE INTEGRATION TIME."
                integTime.append(integTime1[0])
                tb1.close()
            tb.close()

        tb.open(msName+'/SPECTRAL_WINDOW')
        numChans = tb.getcol('NUM_CHAN')

        spwInfo = {}
        for i in range(len(dataDescIds)):
            if numChans[spwIds[dataDescIds[i]]] != 1:
                spwInfo[spwIds[dataDescIds[i]]] = {}
                spwInfo[spwIds[dataDescIds[i]]]['numChans'] = numChans[spwIds[dataDescIds[i]]]
                spwInfo[spwIds[dataDescIds[i]]]['refFreq'] = tb.getcell('REF_FREQUENCY', spwIds[dataDescIds[i]]) # refFreq[spwIds[dataDescIds[i]]]
                spwInfo[spwIds[dataDescIds[i]]]['basebandNum'] = tb.getcell('BBC_NO', spwIds[dataDescIds[i]])
                spwInfo[spwIds[dataDescIds[i]]]['meanFreq'] = np.mean(tb.getcell('CHAN_FREQ', spwIds[dataDescIds[i]]))
                if intent == 'OBSERVE_TARGET': spwInfo[spwIds[dataDescIds[i]]]['integTime'] = integTime[i]

        tb.close()

        return spwInfo

    def generateTsysCalTable(self, msName, calTableName=[], doplot=True):

        #casaCmd = 'print "# Generation of the Tsys cal table."\n\n'
        casaCmd = ''

        if re.search('^3.3', casadef.casa_version) != None:
            sciNumChans = []
            sciSpwInfo = self.getSpwInfo(msName)
            for i in sciSpwInfo: sciNumChans.append(sciSpwInfo[i]['numChans'])
            sciNumChans = sorted(dict.fromkeys(sciNumChans).keys())
            if len(sciNumChans) != 1: sys.exit('ERROR: Configuration not supported.')

        tsysNumChans = []
        tsysSpwInfo = self.getSpwInfo(msName, intent='CALIBRATE_ATMOSPHERE')
        for i in tsysSpwInfo: tsysNumChans.append(tsysSpwInfo[i]['numChans'])
        tsysNumChans = sorted(dict.fromkeys(tsysNumChans).keys())
        if len(tsysNumChans) != 1: sys.exit('ERROR: Configuration not supported.')
        tsysNumChans = tsysNumChans[0]

        casaCmd = casaCmd + "os.system('rm -rf %s.tsys') \n"%(msName)  # Added by CLB
        if re.search('^3.3', casadef.casa_version) != None:
            casaCmd = casaCmd + "os.system('rm -rf %s.tsys.fdm') \n\n"%(msName)  # Added by CLB
        casaCmd = casaCmd + "gencal(vis = '"+msName+"',\n"
        casaCmd = casaCmd + "  caltable = '"+msName+".tsys',\n"
        casaCmd = casaCmd + "  caltype = 'tsys')\n\n"

        if re.search('^3.3', casadef.casa_version) != None:
            casaCmd = casaCmd + "interTsys = aU.InterpolateTsys('"+msName+".tsys')\n"
            casaCmd = casaCmd + "interTsys.correctBadTimes(force=True)\n"
            casaCmd = casaCmd + "interTsys.assignFieldAndScanToSolution()\n"

        calTableName1 = msName+'.tsys'

        if re.search('^3.3', casadef.casa_version) != None:
            if tsysNumChans < sciNumChans:
                casaCmd = casaCmd + "interTsys.getTdmFdmSpw()\n"
                casaCmd = casaCmd + "interTsys.interpolateTsys()\n"
                calTableName1 = msName+'.tsys' # CLB removed .fdm temporarily for Tsys plotting below

            casaCmd = casaCmd + "clearstat()\n\n"

        if doplot == True:
            chanEdge = 0.0390625
            startChan = int(tsysNumChans * chanEdge)
            endChan = int(tsysNumChans * (1-chanEdge))
            chanrange = str(startChan)+'~'+str(endChan)

    # CLB Added additional Tsys plot:  TDM with overlay='time', atmospheric transmission,
    # a slightly restricted chanrange (to exclude wild edge values), and showing the
    # location of the FDM spws (if present)
            casaCmd = casaCmd + "if applyonly != True: aU.plotbandpass(caltable='%s', overlay='time', \n" %(calTableName1)
            casaCmd = casaCmd + "  xaxis='freq', yaxis='amp', subplot=22, buildpdf=False, interactive=False,\n"
    #        casaCmd = casaCmd + "  showatm=True,pwv='auto',chanrange='5~122',showfdm=True, \n"
            casaCmd = casaCmd + "  showatm=True,pwv='auto',chanrange='"+chanrange+"',showfdm=True, \n"
            casaCmd = casaCmd + "  field='', figfile='%s') \n\n" %(calTableName1+'.plots.overlayTime/'+calTableName1.split('/')[-1])

        if re.search('^3.3', casadef.casa_version) != None:
            if tsysNumChans < sciNumChans:   # CLB added
                calTableName1 += '.fdm'      # CLB added .fdm for following plot
        calTableName.append(calTableName1)
        if doplot == True:
            casaCmd = casaCmd + "\nif applyonly != True: es.checkCalTable('"+calTableName1+"', msName='"+msName+"', interactive=False) \n"

        return casaCmd

    def getCalWeightStats(self, msName):

        sciSpwInfo = self.getSpwInfo(msName, intent='OBSERVE_TARGET|CALIBRATE_BANDPASS')
#         mytb = createCasaTool(tbtool)
#         mytb.open(msName+'/DATA_DESCRIPTION')
#         spwIds = mytb.getcol('SPECTRAL_WINDOW_ID')
#         mytb.close()
# 
#         output = "# Spw Pol Min Mean Max\n"
# 
#         mytb.open(msName)
# 
#         for i in sciSpwInfo:
#             dataDescId = np.where(np.array(spwIds) == i)[0]
#             if len(dataDescId) != 1: sys.exit('ERROR: Too many data desc ids')
#             dataDescId = dataDescId[0]
#             tb1 = mytb.query('DATA_DESC_ID == '+str(dataDescId)+' AND FLAG_ROW != True')
#             calWeightStats = tb1.statistics(column='WEIGHT')
#             for j in calWeightStats.keys():
#                 output = output + '%d %s %.2f %.2f %.2f' %(i, j.split('_')[1], calWeightStats[j]['min'], calWeightStats[j]['mean'], calWeightStats[j]['max'])
#                 if calWeightStats[j]['max'] < 10:
#                     output = output + ' -> OK\n'
#                 else:
#                     output = output + ' -> NOT OK\n'
#             tb1.close()
#         mytb.close()
#         print output
# 
#         f = open(msName+'.calweights', 'w')
#         print >> f, output
#         f.close()

        for i in sciSpwInfo:
            plotms(vis = msName, xaxis = 'time', yaxis = 'weight', spw = str(i), xselfscale = True, yselfscale = True,
                coloraxis = 'field', plotfile = msName + '_weights_spw'+str(i)+'.png', overwrite = True)

    def getFlagStats(self, msName):

        import flag

        flagStats = flag.flag_calc(msName)

        print 'Overall -> %.2f' %(100.0*flagStats['flagged']/flagStats['total'])
        print ''
        print 'Per spw (over total of dataset):'
        for i in flagStats['spw']:
            print i+' -> %.2f' %(100.0*flagStats['spw'][i]['flagged']/flagStats['total'])
        print ''
        print 'Per antenna (over total of dataset):'
        for i in flagStats['antenna']:
            print i+' -> %.2f' %(100.0*flagStats['antenna'][i]['flagged']/flagStats['total'])

    def getImageStats(self, imgName):

        import image

        imgStats = image.image_calc(imgName)

        nChans = len(imgStats['frequency'][0])

        print '# frequency max_in rms_out dynrange'
        for i in range(nChans):
            print str(i) + " %.2f" %(imgStats['frequency'][0][i]/1.0e9) + " %.2g" %(imgStats['max_in'][0][i]) + " %.2g" %(imgStats['rms_out'][0][i]) + " %.2f" %(imgStats['dynrange'][0][i])

    def getPsfStats(self, psfName):

        import psf

        psfStats = psf.psf_calc(psfName)

        nChans = len(psfStats['all_fits']['keyword']['frequency'])

        print '# frequency major_axis error unit minor_axis error unit position_angle error unit'
        for i in range(nChans):
            if psfStats['all_fits']['converged'][0][i] == True:
                print str(i) + " %.2f %.4g %.4g %s %.4g %.4g %s %.4g %.4g %s" %((psfStats['all_fits']['keyword']['frequency'][i]/1.0e9), \
                    psfStats['all_fits']['major_axis'][0][i],psfStats['all_fits']['major_axis_err'][0][i],psfStats['all_fits']['keyword']['major_axis_unit'], \
                    psfStats['all_fits']['minor_axis'][0][i],psfStats['all_fits']['minor_axis_err'][0][i],psfStats['all_fits']['keyword']['minor_axis_unit'], \
                    psfStats['all_fits']['position_angle'][0][i],psfStats['all_fits']['position_angle_err'][0][i],psfStats['all_fits']['keyword']['position_angle_unit'])
            else:
                print str(i) + " %.2f PSF fit did not converge." %(psfStats['all_fits']['keyword']['frequency'][i]/1.0e9)

    def plotAntennas(self, vis, plotfile=''):
        """
        Plot antenna/pad positions in ANTENNA table.
        vis: measurement set
        plotfile: default name is <vis>.plotAntennas.png
        """
        (sitelon, sitelat) = (pb.radians(-67.75), pb.radians(-23.02))
        tb.open(vis+'/ANTENNA')
        ant_pos = tb.getcol('POSITION')
        ant_name = tb.getcol('NAME')
        ant_station = tb.getcol('STATION')
        tb.close()

        config_antennas = {}
        for (i, ant) in enumerate(ant_name):
            config_antennas[ant] = ant_station[i]

        pads = {}
        for (i, pad) in enumerate(ant_station):
            pads[pad] = pb.array(self.shiftAlmaCoord(geoToAlma(sitelon, sitelat, \
                (ant_pos[0][i], ant_pos[1][i], ant_pos[2][i]))))
   # map: with pad names
        plf1 = pb.figure(1)
        pb.clf()
        subpl1 = plf1.add_subplot(1, 1, 1, aspect='equal')
        self.draw_pad_map_in_subplot(subpl1, pads, config_antennas)
        mytitle = vis
        if (len(mytitle) > 55):
            mytitle = '...'+vis[-55:]
        pb.title(mytitle)
        if (plotfile == ''):
            myfigfile = vis + '.plotAntennas.png'
        else:
            myfigfile = plotfile
        pb.savefig(myfigfile,format='png',density=108)
        print "Figure output to %s" % (myfigfile)
        plf1.show()

        ## map: without pad names
        #plf2 = pb.figure(2)
        ##plf2.clf()
        #subpl2 = plf2.add_subplot(1, 1, 1, aspect='equal')
        #self.draw_pad_map_in_subplot(subpl2, pads, config_antennas, showemptypads=False)
        #plf2.show()

    def shiftAlmaCoord(self, pos):
        """
        Arbitrarily shift ALMA coord so that central cluster comes around (0, 0).
        """
        return (pos[0]+480., pos[1]-14380., pos[2])

    #def geoToAlma(self, lon, lat, geo):
    #    """
    #    Convert the geocentric coordinates into the local (horizontal) ones.
    #    """
    #    alma = [0, 0, 0]
    #    alma[0] = - geo[0]*pb.sin(lon) + \
    #                geo[1]*pb.cos(lon)
    #    alma[1] = - geo[0]*pb.cos(lon)*pb.sin(lat) - \
    #                geo[1]*pb.sin(lon)*pb.sin(lat) + \
    #                geo[2]*pb.cos(lat)
    #    alma[2] =   geo[0]*pb.cos(lon)*pb.cos(lat) + \
    #                geo[1]*pb.sin(lon)*pb.cos(lat) + \
    #                geo[2]*pb.sin(lat)
    #    return alma

    def draw_pad_map_in_subplot(self, subpl, pads, antennas, xlimit=None, ylimit=None,
        showemptypads=True):
        """
        Draw a map of pads and antennas on them.

        subpl: a pylab.subplot instance
        pads: a dictionary of antennas {"Name": (X, Y, Z), ...}
        antennas: a dictionary of antennas {"AntennaName": "PadName", ...}
        xlimit, ylimit: lists (or tuples, arrays) for the x and y axis limits.
                        if not given, automatically adjusted.
        showemptypads: set False not to draw pads and their names
        showbaselinelength: set True to display baseline length
        """
        subpl.clear()
        if showemptypads:
            for pad in pads.keys():
                padpos = pads[pad]
                if pad[:1] in ['J', 'N']:
                    radius = 3.5
                else:
                    radius = 6.0
                circ = pb.Circle(padpos[:2], radius)
                subpl.add_artist(circ)
                circ.set_alpha(0.5)
                circ.set_facecolor([1.0, 1.0, 1.0])
                tt = subpl.text(padpos[0]+8., padpos[1]-5., pad)
                pb.setp(tt, size='small', alpha=0.5)

        (xmin, xmax, ymin, ymax) = (9e9, -9e9, 9e9, -9e9)
        for ant in antennas.keys():
            if ant[:2] == 'CM':
                radius = 3.5
            else:
                radius = 6.
            padpos = pads[antennas[ant]]
            circ = pb.Circle(padpos[:2], radius=radius)
            subpl.add_artist(circ)
            circ.set_alpha(1.0)
            circ.set_facecolor([0.8, 0.8, 0.8])
            subpl.text(padpos[0], padpos[1]+2, ant)
            if padpos[0] < xmin: xmin = padpos[0]
            if padpos[0] > xmax: xmax = padpos[0]
            if padpos[1] < ymin: ymin = padpos[1]
            if padpos[1] > ymax: ymax = padpos[1]

        subpl.set_xlabel('X [m]')
        subpl.set_ylabel('Y [m]')
        plotwidth = max(xmax-xmin, ymax-ymin) * 6./10. # extra 1/10 is the margin
        (xcenter, ycenter) = ((xmin+xmax)/2., (ymin+ymax)/2.)
        if xlimit == None:
            subpl.set_xlim(xcenter-plotwidth, xcenter+plotwidth)
        else:
            subpl.set_xlim(xlimit[0], xlimit[1])
        if ylimit == None:
            subpl.set_ylim(ycenter-plotwidth, ycenter+plotwidth)
        else:
            subpl.set_ylim(ylimit[0], ylimit[1])

        ants = antennas.keys()
        ants.sort()

        return None

    def getAntennasForFluxscale2(self, msName, fluxCalId='', refant='', thresh=0.15):

        spwInfo = self.getSpwInfo(msName, intent='CALIBRATE_AMPLI|CALIBRATE_FLUX')

        msmd.open(msName)
        ampSpwIds1 = msmd.spwsforfield(int(fluxCalId))
        msmd.close()

        for i in spwInfo.keys():
            if i not in ampSpwIds1:
                spwInfo.pop(i)

        msSplit = 0

        tb.open(msName)
        colNames = tb.colnames()
        tb.close()

        if 'MODEL_DATA' not in colNames:

            sciSpwIds = sorted(spwInfo.keys())
            sciSpwIds1 = ','.join(['%s' %i for i in sciSpwIds])

            split(vis = msName, outputvis = msName+'.temp', datacolumn = 'data', field = fluxCalId, spw = sciSpwIds1)

            msName = msName+'.temp'

            fixplanets(vis = msName, field = '0', fixuvw = True)
            if re.search('^3.', casadef.casa_version) == None:
                setjy(vis = msName, field = '0', standard = 'Butler-JPL-Horizons 2012', usescratch = True)
            else:
                if re.search('^3.3', casadef.casa_version) == None:
                    setjy(vis = msName, field = '0', standard = 'Butler-JPL-Horizons 2010', usescratch = True)
                else:
                    setjy(vis = msName, field = '0', standard = 'Butler-JPL-Horizons 2010')

            for i in sciSpwIds:
                spwInfo[str(sciSpwIds.index(i))] = spwInfo[i]
                spwInfo.pop(i)

            fluxCalId = '0'

            msSplit = 1

        tb.open(msName+'/DATA_DESCRIPTION')
        spwIds = tb.getcol('SPECTRAL_WINDOW_ID').tolist()
        tb.close()

        uvDist1 = []

        tb.open(msName)

        for i in spwInfo:

            dataDescId = spwIds.index(int(i))
            tb1 = tb.query('FIELD_ID == '+fluxCalId+' AND DATA_DESC_ID == '+str(dataDescId))
            uvw = tb1.getcol('UVW')
            modelData = tb1.getcol('MODEL_DATA')

            uvDist = []
            modelData1 = []
            for j in range(len(uvw[0])):
                uvDist.append(sqrt(uvw[0][j]**2+uvw[1][j]**2))
                modelData1.append(abs(modelData[0][int(spwInfo[i]['numChans'])/2][j]))

            uvDist = np.array(uvDist)
            modelData1 = np.array(modelData1)
            ij = np.where(modelData1 < thresh*max(modelData1))
            if len(ij[0]) != 0: uvDist1.append(min(uvDist[ij]))

        tb.close()

        tb.open(msName+'/ANTENNA')
        antList = tb.getcol('NAME')
        tb.close()

        if len(uvDist1) == 0:

            if msSplit == 1: os.system('rm -Rf '+msName)
            return antList.tolist()

        else:

            uvDist1 = min(np.array(uvDist1))

            baselineLen = getBaselineLengths(msName)

            antList1 = []
            for i in antList:
                for j in baselineLen:
                    if i in j[0] and refant in j[0] and j[1] <= uvDist1:
                        antList1.append(i)
                        break

            while len(antList1) > 1:

                maxBaselineLen = 0.0
                for i in baselineLen:
                    ii = i[0].split('-')
                    if ii[0] in antList1 and ii[1] in antList1 and i[1] > maxBaselineLen: maxBaselineLen = i[1]
                if maxBaselineLen <= uvDist1: break

                avgBaselineLen = []
                for i in antList1:
                    count1 = 0
                    sum1 = 0.0
                    for j in baselineLen:
                        if i in j[0] and re.sub('-?'+i+'-?', '', j[0]) in antList1:
                            count1 = count1+1
                            sum1 = sum1+j[1]
                    avgBaselineLen.append(sum1 / count1)

                j = avgBaselineLen.index(max(avgBaselineLen))
                antList1.pop(j)

            if msSplit == 1: os.system('rm -Rf '+msName)
            return antList1

    def computeMaxGainIgnoring1(self, cparam):
        cparam = np.abs(cparam.flatten())
        indices = np.where(np.round(cparam*1000000.)/1000000. != 1.0)[0]
        cparam = cparam[indices]
        if (len(cparam) == 0):
            return(1.0)  # in case all values are 1.0
        else:
            return(np.max(cparam))

    def checkCalTable(self, calTableName, msName='', interactive=True, subplot=411, fontsize=10.0):
        subplotRows = subplot/100
        if (subplotRows < 1 or subplotRows > 9 or subplot-subplotRows*100 != 11):
            print "subplot must be x11 where x=1..9 (and it only applies to G and T solutions)"
            return

        if (calTableName[-1] == '/'):
            print "checkCalTable(): stripping off the trailing slash from the name"
            calTableName = calTableName[:-1]  # strip off trailing slash if present
        calTableNameNoPath = calTableName.split('/')[-1]
        
        if os.path.isdir(calTableName+'.plots') == True:
            if (interactive == True):
                raw_input("Directory for plots already exists. It will be removed. Press Enter to continue...")
            os.system('rm -Rf '+calTableName+'.plots')

        supportedCalTypes = ['B Jones', 'G Jones', 'B TSYS', 'T Jones']

        if msName == '':
            tb.open(calTableName+'/CAL_DESC')
            msName = dict.fromkeys(tb.getcol('MS_NAME')).keys()
            if len(msName) != 1: sys.exit('ERROR: Too many names.')
            msName = msName[0]
            tb.close()

        tb.open(calTableName)
        calType = (tb.info())['subType']
        if calType not in supportedCalTypes: sys.exit('ERROR: Cal type not supported.')

        if calType == 'B TSYS':
            tb.close()
            spwInfo = self.getSpwInfo(msName)
            tb.open(calTableName)
            showimage = False
            for i in sorted(spwInfo.keys()):
                if spwInfo[i]['refFreq'] > 550e9: showimage = True

            fieldIds = sorted(dict.fromkeys(tb.getcol('FIELD_ID')).keys())
            tb.close()
            vm = ValueMapping(msName)
            for i in fieldIds:
                plotbandpass(caltable=calTableName, overlay='antenna', xaxis='freq', yaxis='amp', subplot=22, buildpdf=False, interactive=interactive, field=str(i), showimage=showimage, vm=vm, figfile=calTableName+'.plots/'+calTableNameNoPath+'.field'+str(i))
            casaCmd  = "# This is what checkCalTable executed:\n"  # Added by CLB
            casaCmd += "#for i in %s:\n" % list(fieldIds)   # Added by CLB
            casaCmd += "#   aU.plotbandpass(caltable='%s', overlay='antenna', xaxis='freq', yaxis='amp', subplot=22, buildpdf=False, interactive=False, field=str(i), showimage=%s, figfile='%s.plots/%s.field'+str(i))\n\n" % (calTableName,showimage,calTableName,calTableNameNoPath)   # Added by CLB
            print casaCmd  # Added by CLB

        if calType == 'B Jones':
            tb.close()
            vm = ValueMapping(msName)
            casaCmd  = "# This is what checkCalTable executed:\n"  # Added by CLB
            if os.path.isdir(calTableName+'_smooth20flat_ri') == True:
                casaCmd += "#aU.plotbandpass(caltable='%s', caltable2='%s_smooth20flat_ri', xaxis='freq', yaxis='both', showatm=True, pwv='auto', subplot=22, buildpdf=False, interactive=False, vm=vm, figfile='%s.plots/%s)\n" % (calTableName,calTableName,calTableName,calTableNameNoPath)   # Added by CLB
                print casaCmd 
                plotbandpass(caltable=calTableName, caltable2=calTableName+'_smooth20flat_ri', xaxis='freq', yaxis='both', showatm=True, pwv='auto', subplot=22, buildpdf=False, interactive=interactive, vm=vm, figfile=calTableName+'.plots/'+calTableNameNoPath)
            else:
                casaCmd += "#aU.plotbandpass(caltable='%s', xaxis='freq', yaxis='both', showatm=True, pwv='auto', subplot=22, buildpdf=False, interactive=False, vm=vm, figfile='%s.plots/%s')\n" % (calTableName,calTableName,calTableNameNoPath)  # Added by CLB
                print casaCmd 
                plotbandpass(caltable=calTableName, xaxis='freq', yaxis='both', showatm=True, pwv='auto', subplot=22, buildpdf=False, interactive=interactive, vm=vm, figfile=calTableName+'.plots/'+calTableNameNoPath)

        if calType in ['G Jones', 'T Jones']:
            # Check the number of spws in the caltable. If greater than 4, need 
            # to run plotcal multiple times for multiple pages.
            
            calStats = {}
            if re.search('^3.3', casadef.casa_version) != None:
                calStats['GAIN_amp'] = (tb.statistics(column='GAIN', complex_value='amp'))['GAIN']
                calStats['GAIN_phase'] = (tb.statistics(column='GAIN', complex_value='phase'))['GAIN']
                spwsInSolution = np.unique(tb.getcol('CAL_DESC_ID'))
            else:
                names = tb.colnames()
                if ('SPECTRAL_WINDOW_ID' in names):  # this is a table from >= 3.4
                    calStats['GAIN_amp'] = (tb.statistics(column='CPARAM', complex_value='amp'))['CPARAM']
                    calStats['GAIN_phase'] = (tb.statistics(column='CPARAM', complex_value='phase'))['CPARAM']
                    # Added by Todd to make the maximum value not be forced to be 1.0
                    calStats['GAIN_amp']['max'] = self.computeMaxGainIgnoring1(tb.getcol('CPARAM'))
                    spwsInSolution = np.unique(tb.getcol('SPECTRAL_WINDOW_ID'))
                else:
                    # This is needed in case the user is running casa 3.4 and wants to examine a 3.3 table
                    calStats['GAIN_amp'] = (tb.statistics(column='GAIN', complex_value='amp'))['GAIN']
                    calStats['GAIN_phase'] = (tb.statistics(column='GAIN', complex_value='phase'))['GAIN']
                    spwsInSolution = np.unique(tb.getcol('CAL_DESC_ID'))
            tb.close()


            tb.open(msName+'/ANTENNA')
            antList = tb.getcol('NAME')
            tb.close()

            os.system('mkdir '+calTableName+'.plots')

            if interactive:
                showgui=True
            else:
                showgui=False

            #if calStats['GAIN_amp']['medabsdevmed'] != 0:
            print "GAIN_amp_min, max = ", calStats['GAIN_amp']['min'], calStats['GAIN_amp']['max']
            if abs(calStats['GAIN_amp']['min']-1) > 0.001 or abs(calStats['GAIN_amp']['max']-1) > 0.001:
                minAmp = calStats['GAIN_amp']['min']
                maxAmp = calStats['GAIN_amp']['max']
                casaCmd  = "# This is what checkCalTable executed:\n"
                casaCmd += "#for i in %s:\n" % list(antList)   
                for i in antList:
                  quitloop = False
                  for startSpw in range(0,len(spwsInSolution),subplotRows):
                    if (len(spwsInSolution) <= subplotRows):
                        plotspw = ''
                        spwnames = ''
                    else:
                        plotspw = range(startSpw,np.min([startSpw+subplotRows,len(spwsInSolution)]))
                        plotspw = list(np.array(spwsInSolution)[plotspw])
                        plotspw = str(plotspw).replace(' ','').strip('[]')
                        spwnames = '.spw' + plotspw[0] + '-' + plotspw[-1]
                    plotcal(caltable=calTableName, xaxis='time', yaxis='amp', antenna=i, iteration='antenna,spw', subplot=subplot, plotrange=[0, 0, minAmp, maxAmp], figfile=calTableName+'.plots/'+calTableNameNoPath+'.amp.'+i+spwnames+'.png', spw=plotspw, fontsize=fontsize,showgui=showgui)
                    if interactive == True:
                        userRawInput = raw_input("Press Enter to continue, q to quit amplitudes, or n to go non-interactive. ")
                        if userRawInput.lower() == 'q':
                            quitloop = True
                            break
                        if userRawInput.lower() == 'n': interactive = False
                        
                    if (i == antList[0]):
                        casaCmd += "#   plotcal(caltable='%s', xaxis='time', yaxis='amp', antenna=i, iteration='antenna,spw', subplot=%d, plotrange=[0, 0, %f, %f], figfile='%s.plots/%s.amp.'+str(i)+'%s.png', spw='%s', showgui=%s)\n" % (calTableName,subplot,minAmp, maxAmp,calTableName,calTableNameNoPath, spwnames, plotspw,showgui)  # Added by CLB
                  if (quitloop): break
                print casaCmd  # Added by CLB
            #if calStats['GAIN_phase']['medabsdevmed'] != 0:
            if abs(calStats['GAIN_phase']['min']) > 0.001 or abs(calStats['GAIN_phase']['max']) > 0.001:
                minPhase = math.degrees(calStats['GAIN_phase']['min'])
                maxPhase = math.degrees(calStats['GAIN_phase']['max'])
                casaCmd  = "# This is what checkCalTable executed:\n"  # Added by CLB
                casaCmd += "#for i in %s:\n" % list(antList)   # Added by CLB
                for i in antList:
                  quitloop = False
                  for startSpw in range(0,len(spwsInSolution),subplotRows):
                    if (len(spwsInSolution) <= subplotRows):
                        plotspw = ''
                        spwnames = ''
                    else:
                        plotspw = range(startSpw,np.min([startSpw+subplotRows,len(spwsInSolution)]))
                        plotspw = list(np.array(spwsInSolution)[plotspw])
                        plotspw = str(plotspw).replace(' ','').strip('[]')
                        spwnames = '.spw' + plotspw[0] + '-' + plotspw[-1]
                    plotcal(caltable=calTableName, xaxis='time', yaxis='phase', antenna=i, iteration='antenna,spw', subplot=subplot, plotrange=[0, 0, minPhase, maxPhase], figfile=calTableName+'.plots/'+calTableNameNoPath+'.phase.'+i+spwnames+'.png', spw=plotspw, fontsize=fontsize,showgui=showgui)
                    if interactive == True:
                        userRawInput = raw_input("Press Enter to continue, q to quit, or n to go non-interactive. ")
                        if userRawInput.lower() == 'q':
                            quitloop = True
                            break
                        if userRawInput.lower() == 'n': interactive = False
                    if (i == antList[0]):
                        casaCmd += "#    plotcal(caltable='%s', xaxis='time', yaxis='phase', antenna=i, iteration='antenna,spw', subplot=%d, plotrange=[0, 0,%f,%f], figfile='%s.plots/%s.phase.'+str(i)+'%s.png', spw='%s', showgui=%s)\n" % (calTableName, subplot, minPhase, maxPhase,calTableName,calTableNameNoPath, spwnames, plotspw,showgui)  # Added by CLB
                  if (quitloop): break
                print casaCmd  # Added by CLB

    def checkCalTable2(self, calTableName, interactive=True):

        casaCmd = ''

        supportedCalTypes = ['B Jones', 'G Jones', 'B TSYS', 'T Jones']

        tb.open(calTableName+'/CAL_DESC')
        msName = dict.fromkeys(tb.getcol('MS_NAME')).keys()
        if len(msName) != 1: sys.exit('ERROR: Too many names.')
        msName = msName[0]
        tb.close()

        tb.open(calTableName)
        calType = (tb.info())['subType']
        if calType not in supportedCalTypes: sys.exit('ERROR: Cal type not supported.')

        if calType == 'B TSYS':
            fieldIds = sorted(dict.fromkeys(tb.getcol('FIELD_ID')).keys())
            tb.close()
            casaCmd = casaCmd + "vm = aU.ValueMapping("+msName+")\n\n"
            casaCmd = casaCmd + "for i in "+str(fieldIds)+":\n"
            casaCmd = casaCmd + "  aU.plotbandpass(caltable = '"+calTableName+"',\n"
            casaCmd = casaCmd + "    overlay = 'antenna',\n"
            casaCmd = casaCmd + "    xaxis = 'freq',\n"
            casaCmd = casaCmd + "    yaxis = 'amp',\n"
            casaCmd = casaCmd + "    subplot = 22,\n"
            casaCmd = casaCmd + "    buildpdf = False,\n"
            casaCmd = casaCmd + "    interactive = "+str(interactive)+",\n"
            casaCmd = casaCmd + "    field = str(i),\n"
            casaCmd = casaCmd + "    vm = vm,\n"
            casaCmd = casaCmd + "    figfile = '"+calTableName+".plots/"+calTableName+".field'+str(i))\n"

        if calType == 'B Jones':
            tb.close()
            casaCmd = casaCmd + "vm = aU.ValueMapping("+msName+")\n\n"
            casaCmd = casaCmd + "aU.plotbandpass(caltable = '"+calTableName+"',\n"
            if os.path.isdir(calTableName+'_smooth20flat_ri') == True:
                casaCmd = casaCmd + "  caltable2 = '"+calTableName+"_smooth20flat_ri',\n"
            else:
                casaCmd = casaCmd + "  #caltable2 = '"+calTableName+"_smooth20flat_ri', # please uncomment this line if you have run smoothbandpass\n"
            casaCmd = casaCmd + "  xaxis = 'freq',\n"
            casaCmd = casaCmd + "  yaxis = 'both',\n"
            casaCmd = casaCmd + "  showatm = True,\n"
            casaCmd = casaCmd + "  pwv = 'auto',\n"
            casaCmd = casaCmd + "  subplot = 22,\n"
            casaCmd = casaCmd + "  buildpdf = False,\n"
            casaCmd = casaCmd + "  interactive = "+str(interactive)+",\n"
            casaCmd = casaCmd + "  vm = vm,\n"
            casaCmd = casaCmd + "  figfile = '"+calTableName+".plots/"+calTableName+"')\n"

        if calType in ['G Jones', 'T Jones']:

            calStats = {}
            calStats['GAIN_amp'] = (tb.statistics(column='GAIN', complex_value='amp'))['GAIN']
            calStats['GAIN_phase'] = (tb.statistics(column='GAIN', complex_value='phase'))['GAIN']
            tb.close()

            tb.open(msName+'/ANTENNA')
            antList = tb.getcol('NAME')
            tb.close()

            os.system('mkdir '+calTableName+'.plots')

            if calStats['GAIN_amp']['medabsdevmed'] != 0:
                minAmp = calStats['GAIN_amp']['min']
                maxAmp = calStats['GAIN_amp']['max']
                for i in antList:
                    plotcal(caltable=calTableName, xaxis='time', yaxis='amp', antenna=i, iteration='antenna,spw', subplot=221, plotrange=[0, 0, minAmp, maxAmp], figfile=calTableName+'.plots/'+calTableName+'.amp.'+i+'.png')
                    if interactive == True:
                        userRawInput = raw_input("Press Enter to continue, q to quit.")
                        if userRawInput.lower() == 'q': break
            if calStats['GAIN_phase']['medabsdevmed'] != 0:
                minPhase = math.degrees(calStats['GAIN_phase']['min'])
                maxPhase = math.degrees(calStats['GAIN_phase']['max'])
                for i in antList:
                    plotcal(caltable=calTableName, xaxis='time', yaxis='phase', antenna=i, iteration='antenna,spw', subplot=221, plotrange=[0, 0, minPhase, maxPhase], figfile=calTableName+'.plots/'+calTableName+'.phase.'+i+'.png')
                    if interactive == True:
                        userRawInput = raw_input("Press Enter to continue, q to quit.")
                        if userRawInput.lower() == 'q': break

        return casaCmd

    def getFieldsForFixPlanets(self, msName):

        tb.open(msName+'/FIELD')
        phaseDir = tb.getcol('PHASE_DIR')
        tb.close()

        fieldIds = []
        for i in range(len(phaseDir[0][0])):
            if phaseDir[0][0][i] == 0 and phaseDir[1][0][i] == 0: fieldIds.append(i)

        return fieldIds

    def runFixPlanets(self, msName):

        fieldIds = self.getFieldsForFixPlanets(msName)

        if len(fieldIds) != 0:

            #casaCmd = 'print "# Running fixplanets on fields with 0,0 coordinates."\n\n'
            casaCmd = ''

            tb.open(msName+'/FIELD')
            fieldNames = tb.getcol('NAME')
            tb.close()

            fieldNames = ['%s' %fieldNames[i] for i in fieldIds]
            fieldNames = ','.join(fieldNames)
            fieldIds = ['%s' %i for i in fieldIds]
            fieldIds = ','.join(fieldIds)

            casaCmd = casaCmd + "fixplanets(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  field = '"+fieldIds+"', # "+fieldNames+"\n"
            casaCmd = casaCmd + "  fixuvw = T)\n"

            return casaCmd

    def applyAprioriCalTables(self, msName, tsys='', wvr='', antpos='', tsysmap='', tsysChanTol=''):

        #casaCmd = 'print "# Application of the WVR, Tsys and antpos cal tables."'
        casaCmd = ''

        if tsys=='' and wvr=='' and antpos=='': sys.exit('ERROR: No cal table specified.')

        gainTable = []
        gainTable.append(tsys)
        gainTable.append(wvr)
        gainTable.append(antpos)
        gainTable = ['%s' %i for i in gainTable if i != '']

        spwInfo = self.getSpwInfo(msName, intent='OBSERVE_TARGET|CALIBRATE_BANDPASS')
        spwIds = sorted(spwInfo.keys())
        spwIds1 = ','.join(['%s' %i for i in spwIds])

        if tsys=='':

            casaCmd = casaCmd + "\n\napplycal(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  spw = '"+spwIds1+"',\n"
            casaCmd = casaCmd + "  gaintable = "+str(gainTable)+",\n"
            if re.search('^3.3', casadef.casa_version) == None:
                casaCmd = casaCmd + "  interp = 'linear,linear',\n"
            else:
                casaCmd = casaCmd + "  interp = 'linear',\n"
            casaCmd = casaCmd + "  calwt = F,\n"
            casaCmd = casaCmd + "  flagbackup = F)\n"

        else:

            if re.search('^3.3', casadef.casa_version) == None:
                if tsysmap == '':
                    casaCmd = casaCmd + "\n\nfrom recipes.almahelpers import tsysspwmap\n"
                    if tsysChanTol == '':
                        casaCmd = casaCmd + "tsysmap = tsysspwmap(vis = '"+msName+"', tsystable = '"+tsys+"')\n\n"
                    else:
                        tsysChanTol = int(tsysChanTol)
                        casaCmd = casaCmd + "tsysmap = tsysspwmap(vis = '"+msName+"', tsystable = '"+tsys+"', tsysChanTol = "+str(tsysChanTol)+")\n\n"
                else:
                    casaCmd = casaCmd + "\n\ntsysmap = "+str(tsysmap)+"\n\n"

            tb.open(msName+'/FIELD')
            sourceIds = tb.getcol('SOURCE_ID')
            sourceNames = tb.getcol('NAME')
            tb.close()

            sourceIds1 = sorted(dict.fromkeys(sourceIds).keys())

            phaseCal = self.getPhaseCal(msName)

#            if os.path.exists(tsys) == True:
#                  tb.open(tsys)
#                  fieldIds = sorted(dict.fromkeys(tb.getcol('FIELD_ID')).keys())
#                  tb.close()
#            else:
#                  intentSources = self.getIntentsAndSourceNames(msName)
#                  fieldIds = intentSources['CALIBRATE_ATMOSPHERE']['id']

            intentSources = self.getIntentsAndSourceNames(msName)
            fieldIds = intentSources['CALIBRATE_ATMOSPHERE']['id']

            for i in sourceIds1:

                fieldIds1 = (np.where(sourceIds == i))[0]
                sourceName = sourceNames[fieldIds1[0]]

                if len(fieldIds1) > 1:
                    j0 = 0
                    fieldIds2 = str(fieldIds1[j0])
                    for j in range(len(fieldIds1)-1):
                        if fieldIds1[j+1] == fieldIds1[j]+1: continue
                        fieldIds2 = fieldIds2 + '~' + str(fieldIds1[j])
                        j0 = j+1
                        fieldIds2 = fieldIds2 + ',' + str(fieldIds1[j0])
                    fieldIds2 = fieldIds2 + '~' + str(fieldIds1[j+1])
                else:
                    fieldIds2 = str(fieldIds1[0])

                fieldIds3 = [j for j in fieldIds1 if j in fieldIds]

#                 if len(fieldIds3) > 1: sys.exit('ERROR: Too many Tsys fields per source.')
                if len(fieldIds3) > 1:
                    print 'WARNING: Too many Tsys fields per source.'
                    fieldIds3[0] = ','.join(['%d' %j for j in fieldIds3])

                if len(fieldIds3) == 0:
                    if i in intentSources['OBSERVE_TARGET']['sourceid']:
                        if phaseCal[sourceName]['phaseCalId'] in fieldIds:
                            fieldIds3 = [phaseCal[sourceName]['phaseCalId']]
                            casaCmd = casaCmd + "\n\n# Note: "+sourceName+" didn't have any Tsys measurement, so I used the one made on "+phaseCal[sourceName]['phaseCalName']+". This is probably Ok."
                        else:
                            casaCmd = casaCmd + "\n\n# Warning: "+sourceName+" didn't have any Tsys measurement, and I couldn't find any close measurement. This is a science target, so this is probably *NOT* Ok."
                            continue
                    elif i in intentSources['CALIBRATE_PHASE']['sourceid']:
                        if len(fieldIds1) != 1: sys.exit('ERROR')
                        found = 0
                        for j in phaseCal.keys():
                            if phaseCal[j]['phaseCalId'] == fieldIds1[0]:
                                found = 1
                                break
                        if found == 1:
                            sourceIds2 = np.unique(phaseCal[j]['sciSourceIds'])
                            if len(sourceIds2) != 1: sys.exit('ERROR')
                            fieldIds3 = []
                            for k in range(len(intentSources['CALIBRATE_ATMOSPHERE']['sourceid'])):
                                if intentSources['CALIBRATE_ATMOSPHERE']['sourceid'][k] == sourceIds2:
                                    fieldIds3.append(intentSources['CALIBRATE_ATMOSPHERE']['id'][k])
                            fieldIds3[0] = ','.join(['%d' %k for k in fieldIds3])
                            casaCmd = casaCmd + "\n\n# Note: "+sourceName+" didn't have any Tsys measurement, so I used the one made on "+j+". This is probably Ok."
                        else:
                            casaCmd = casaCmd + "\n\n# Warning: "+sourceName+" didn't have any Tsys measurement, and I couldn't find any close measurement. This is a phase calibrator, so this is probably *NOT* Ok."
                            continue
                    else:

                        found = 0

                        if len(fieldIds1) == 1:
                            fieldIds1 = fieldIds1[0]
                            if type(phaseCal) != NoneType:
                                for j in phaseCal:
                                    if phaseCal[j]['phaseCalId'] == fieldIds1:
                                        sciSourceIds1 = phaseCal[j]['sciSourceIds']
                                        sciSourceIds1 = sorted(dict.fromkeys(sciSourceIds1).keys())
                                        if len(sciSourceIds1) == 1:
                                            sciSourceIds1 = sciSourceIds1[0]
                                            ij = np.where(np.array(intentSources['CALIBRATE_ATMOSPHERE']['sourceid']) == sciSourceIds1)[0]
                                            if len(ij) == 1:
                                                ij = ij[0]
                                                fieldIds3 = [intentSources['CALIBRATE_ATMOSPHERE']['id'][ij]]
                                                found = 1
                                                break

                        if found == 0:
                            casaCmd = casaCmd + "\n\n# Note: "+sourceName+" didn't have any Tsys measurement, and I couldn't find any close measurement. But this is not a science target, so this is probably Ok."
                            continue

                gainField = []
                for j in range(len(gainTable)): gainField.append('')
                gainField[0] = str(fieldIds3[0])

                gainSpwMap = []
                for j in range(len(gainTable)): gainSpwMap.append("[]")
                gainSpwMap[0] = 'tsysmap'
                gainSpwMap = ','.join(gainSpwMap)

                casaCmd = casaCmd + "\n\napplycal(vis = '"+msName+"',\n"
                casaCmd = casaCmd + "  field = '"+fieldIds2+"',\n"
                casaCmd = casaCmd + "  spw = '"+spwIds1+"',\n"
                casaCmd = casaCmd + "  gaintable = "+str(gainTable)+",\n"
                casaCmd = casaCmd + "  gainfield = "+str(gainField)+",\n"
                if re.search('^3.3', casadef.casa_version) == None:
                    casaCmd = casaCmd + "  interp = 'linear,linear',\n"
                else:
                    casaCmd = casaCmd + "  interp = 'linear',\n"
                if re.search('^3.3', casadef.casa_version) == None: casaCmd = casaCmd + "  spwmap = ["+gainSpwMap+"],\n"
                casaCmd = casaCmd + "  calwt = T,\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"

            casaCmd = casaCmd + "if applyonly != True: es.getCalWeightStats('"+msName+"') \n"

            #casaCmd = casaCmd + "plotms(vis = '"+msName+"',\n"
            #casaCmd = casaCmd + "    xaxis = 'time',\n"
            #casaCmd = casaCmd + "    yaxis = 'wt',\n"
            #casaCmd = casaCmd + "    spw = '"+spwIds1+"',\n"
            #casaCmd = casaCmd + "    antenna = '*&*',\n"
            #casaCmd = casaCmd + "    coloraxis = 'field',\n"
            #casaCmd = casaCmd + "    plotfile = '"+msName+".weights.png')\n"

        return casaCmd

    def getIntentsAndSourceNames(self, msName):

        intentsToSearch = ['CALIBRATE_POINTING', 'CALIBRATE_FOCUS', 'CALIBRATE_BANDPASS', 'CALIBRATE_FLUX', 'CALIBRATE_AMPLI', 'CALIBRATE_PHASE', 'OBSERVE_TARGET', 'CALIBRATE_ATMOSPHERE']

        tb.open(msName+'/STATE')
        obsModes = tb.getcol('OBS_MODE')
        tb.close()

        tb.open(msName+'/FIELD')
        fieldNames = tb.getcol('NAME')
        sourceIds = tb.getcol('SOURCE_ID')
        tb.close()

        tb.open(msName+'/DATA_DESCRIPTION')
        spwIds = tb.getcol('SPECTRAL_WINDOW_ID').tolist()
        tb.close()

        intentSources = {}

        for i in range(len(intentsToSearch)):

            obsModes1 = []
            for j in range(len(obsModes)):
                if re.search(intentsToSearch[i], obsModes[j]) != None:
                    obsModes1.append(j)

            obsModes1 = sorted(dict.fromkeys(obsModes1).keys())

            intentSources[intentsToSearch[i]] = {}

            if len(obsModes1) == 0:

                intentSources[intentsToSearch[i]]['id'] = ['']
                intentSources[intentsToSearch[i]]['idstring'] = ['']
                intentSources[intentsToSearch[i]]['name'] = ['']
                intentSources[intentsToSearch[i]]['spw'] = ['']
                intentSources[intentsToSearch[i]]['sourceid'] = ['']

            else:

                tb.open(msName)

                fieldIds = []
                dataDescIds = []
                for j in obsModes1:
                    tb1 = tb.query('STATE_ID == '+str(j))
                    fieldIds1 = sorted(dict.fromkeys(tb1.getcol('FIELD_ID')).keys())
                    fieldIds.extend(fieldIds1)
                    dataDescIds1 = sorted(dict.fromkeys(tb1.getcol('DATA_DESC_ID')).keys())
                    dataDescIds.extend(dataDescIds1)

                tb.close()

                fieldIds = sorted(dict.fromkeys(fieldIds).keys())
                fieldNames1 = ['%s' %fieldNames[j] for j in fieldIds]
                #fieldNames1 = sorted(dict.fromkeys(fieldNames1).keys())
                dataDescIds = sorted(dict.fromkeys(dataDescIds).keys())
                sourceIds1 = [sourceIds[j] for j in fieldIds]

                if len(fieldIds) != 0:
                    intentSources[intentsToSearch[i]]['id'] = fieldIds
                    fieldIdStrings = []
                    for f in fieldIds:
                        fieldIdStrings.append(str(f))
                    intentSources[intentsToSearch[i]]['idstring'] = fieldIdStrings
                    intentSources[intentsToSearch[i]]['name'] = fieldNames1
                    intentSources[intentsToSearch[i]]['spw'] = [spwIds[k] for k in dataDescIds]
                    intentSources[intentsToSearch[i]]['sourceid'] = sourceIds1
                else:
                    intentSources[intentsToSearch[i]]['id'] = ['']
                    intentSources[intentsToSearch[i]]['idstring'] = ['']
                    intentSources[intentsToSearch[i]]['name'] = ['']
                    intentSources[intentsToSearch[i]]['spw'] = ['']
                    intentSources[intentsToSearch[i]]['sourceid'] = ['']

        return intentSources

    def listOfIntentsWithSources(self, msName):

        intentSources = self.getIntentsAndSourceNames(msName)

        for i in sorted(intentSources.keys()):
            print '# '+i+': '+','.join(sorted(dict.fromkeys(intentSources[i]['name']).keys()))

    def doBandpassCalibration(self, msName, msName1='', bpassCalId='', chanAvg=0.2, refant='', iHaveSplitMyScienceSpw=False, calTableName=[], lowSNR=False, doplot=True):

        #casaCmd = 'print "# Bandpass calibration."\n\n'
        casaCmd = ''

        if msName1 == '': msName1 = msName
        if refant == '': sys.exit('ERROR: No reference antenna specified.')
        if chanAvg > 1: sys.exit('ERROR: The channel averaging bandwidth must be specified as a fraction of the total bandwidth.')
        if lowSNR == True: chanAvg = 1.0

        tb.open(msName+'/FIELD')
        fieldNames = tb.getcol('NAME')
        tb.close()

        if bpassCalId == '':

            intentSources = self.getIntentsAndSourceNames(msName)
            bpassCalId = intentSources['CALIBRATE_BANDPASS']['id']

            if bpassCalId[0] != '':

                if len(bpassCalId) != 1: casaCmd = casaCmd + "# Note: there are more than one bandpass calibrator, I'm picking the first one: "+fieldNames[bpassCalId[0]]+".\n"
                bpassCalId = bpassCalId[0]

            else:

                casaCmd = casaCmd + "# Note: there are no bandpass calibrator, I'm picking a phase calibrator.\n"
                phaseCalId = intentSources['CALIBRATE_PHASE']['id']
                ampCalId = intentSources['CALIBRATE_AMPLI']['id'] + intentSources['CALIBRATE_FLUX']['id']
                ampCalId = [i for i in ampCalId if i != '']
                phaseOnlyCalId = [i for i in phaseCalId if i not in ampCalId]
                if len(phaseOnlyCalId) != 1: casaCmd = casaCmd + "# Note: there are more than one phase calibrator, I'm picking the first one: "+fieldNames[phaseOnlyCalId[0]]+".\n"
                bpassCalId = phaseOnlyCalId[0]

        spwInfo = self.getSpwInfo(msName, intent='OBSERVE_TARGET|CALIBRATE_BANDPASS')
        spwIds = sorted(spwInfo.keys())

#        sciNumChans = []
#        for i in spwInfo: sciNumChans.append(spwInfo[i]['numChans'])
#        sciNumChans = sorted(dict.fromkeys(sciNumChans).keys())
#        if len(sciNumChans) != 1: sys.exit('ERROR: Configuration not supported.')
#        sciNumChans = sciNumChans[0]

        sciNumChans = []
        for i in spwIds: sciNumChans.append(spwInfo[i]['numChans'])
        if len(dict.fromkeys(sciNumChans).keys()) != 1:
            print 'WARNING: This seems to be a mixed-mode dataset, the script generator has been updated, but for some time, please check carefully the script.'

        spwSpec = ''
        for i in range(len(spwIds)):
            if spwSpec != '': spwSpec = spwSpec+','
            startChan = int((spwInfo[spwIds[i]]['numChans'] / 2.) * (1-chanAvg))
            endChan = int((spwInfo[spwIds[i]]['numChans'] / 2.) * (1+chanAvg))
            if iHaveSplitMyScienceSpw == True:
                spwSpec = spwSpec+str(i)
            else:
                spwSpec = spwSpec+str(spwIds[i])
            spwSpec = spwSpec+':'+str(startChan)+'~'+str(endChan)

        calTableName1 = msName1+'.bandpass'
        casaCmd = casaCmd + "os.system('rm -rf %s.ap_pre_bandpass') \n"%(msName1) # Added by CLB
        casaCmd = casaCmd + "\ngaincal(vis = '"+msName1+"',\n"
        casaCmd = casaCmd + "  caltable = '"+msName1+".ap_pre_bandpass',\n"
        casaCmd = casaCmd + "  field = '"+str(bpassCalId)+"', # "+fieldNames[int(bpassCalId)]+"\n"
        casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
        casaCmd = casaCmd + "  solint = 'int',\n"
        casaCmd = casaCmd + "  refant = '"+refant+"',\n"
        casaCmd = casaCmd + "  calmode = 'p')\n"
        if doplot == True:
            casaCmd = casaCmd + "\nif applyonly != True: es.checkCalTable('"+msName1+".ap_pre_bandpass', msName='"+msName1+"', interactive=False) \n\n"
        casaCmd = casaCmd + "os.system('rm -rf %s.bandpass') \n"%(msName1) # Added by CLB
        casaCmd = casaCmd + "bandpass(vis = '"+msName1+"',\n"
        casaCmd = casaCmd + "  caltable = '"+calTableName1+"',\n"
        casaCmd = casaCmd + "  field = '"+str(bpassCalId)+"', # "+fieldNames[int(bpassCalId)]+"\n"
        casaCmd = casaCmd + "  solint = 'inf',\n"
        casaCmd = casaCmd + "  combine = 'scan',\n"
        casaCmd = casaCmd + "  refant = '"+refant+"',\n"
        casaCmd = casaCmd + "  solnorm = T,\n"
        casaCmd = casaCmd + "  bandtype = 'B',\n"
        casaCmd = casaCmd + "  gaintable = '"+msName1+".ap_pre_bandpass')\n"

        minSciNumChans = min(sciNumChans)

        if minSciNumChans > 256:
            if re.search('^3.3', casadef.casa_version) == None:
                casaCmd = casaCmd + "\nos.system('rm -rf %s.bandpass_smooth20ch') \n"%(msName1)
                casaCmd = casaCmd + "\nbandpass(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+calTableName1+'_smooth20ch'+"',\n"
                casaCmd = casaCmd + "  field = '"+str(bpassCalId)+"', # "+fieldNames[int(bpassCalId)]+"\n"
                casaCmd = casaCmd + "  solint = 'inf,20ch',\n"
                casaCmd = casaCmd + "  combine = 'scan',\n"
                casaCmd = casaCmd + "  refant = '"+refant+"',\n"
                casaCmd = casaCmd + "  solnorm = T,\n"
                casaCmd = casaCmd + "  bandtype = 'B',\n"
                casaCmd = casaCmd + "  gaintable = '"+msName1+".ap_pre_bandpass')\n"
                if doplot == True:
                    casaCmd = casaCmd + "\nif applyonly != True: es.checkCalTable('"+calTableName1+'_smooth20ch'+"', msName='"+msName1+"', interactive=False) \n"
            else:
                casaCmd = casaCmd + "\nos.system('rm -rf %s.bandpass_smooth20flat_ri') \n"%(msName1) # Added by CLB
                casaCmd = casaCmd + "\nif applyonly != True: aU.smoothbandpass('"+calTableName1+"') \n"

        if doplot == True:
            casaCmd = casaCmd + "\nif applyonly != True: es.checkCalTable('"+calTableName1+"', msName='"+msName1+"', interactive=False) \n"

        if minSciNumChans > 256:
            if re.search('^3.3', casadef.casa_version) == None:
                calTableName1 = calTableName1+'_smooth20ch'
            else:
                calTableName1 = calTableName1+'_smooth20flat_ri'
        calTableName.append(calTableName1)

        return casaCmd

    def doAprioriFlagging(self, msName):

        #casaCmd = 'print "# A priori flagging."\n\n'
        casaCmd = ''

        intentsToFlag = ['POINTING', 'FOCUS', 'SIDEBAND_RATIO', 'ATMOSPHERE']

        vm = ValueMapping(msName)
        fullIntentList = vm.uniqueIntents

        scanIntentList = []
        for i in intentsToFlag:
            for j in fullIntentList:
                if re.search(i, j) != None:
                    scanIntentList.append('*'+i+'*')
                    break

        scanIntentList = ','.join(scanIntentList)

        tb.open(msName+'/DATA_DESCRIPTION')
        spwIds = tb.getcol('SPECTRAL_WINDOW_ID')
        tb.close()

        tb.open(msName+'/PROCESSOR')
        procType = tb.getcol('TYPE')
        tb.close()

        procType1 = np.where(procType == 'RADIOMETER')[0]

        spwIds1 = []

        tb.open(msName)

        for i in procType1:
            tb1 = tb.query('PROCESSOR_ID == '+str(i))
            dataDescIds1 = tb1.getcol('DATA_DESC_ID')
            dataDescIds1 = np.unique(dataDescIds1)
            for j in dataDescIds1:
                spwIds1.append(spwIds[j])

        tb.close()

        spwIds1 = [i for i in range(len(spwIds)) if i not in spwIds1]

        if len(spwIds1) > 1:
            j0 = 0
            spwIds2 = str(spwIds1[j0])
            for j in range(len(spwIds1)-1):
                if spwIds1[j+1] == spwIds1[j]+1: continue
                spwIds2 = spwIds2 + '~' + str(spwIds1[j])
                j0 = j+1
                spwIds2 = spwIds2 + ',' + str(spwIds1[j0])
            spwIds2 = spwIds2 + '~' + str(spwIds1[j+1])
        else:
            spwIds2 = str(spwIds1[0])

        if re.search('^3.3', casadef.casa_version) != None:
            casaCmd = casaCmd + "flagdata(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  mode = 'manualflag',\n"
            casaCmd = casaCmd + "  spw = '"+spwIds2+"',\n"
            casaCmd = casaCmd + "  autocorr = T,\n"
            casaCmd = casaCmd + "  flagbackup = F)\n\n"
            casaCmd = casaCmd + "flagdata(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  mode = 'manualflag',\n"
            casaCmd = casaCmd + "  intent = '"+scanIntentList+"',\n"
            casaCmd = casaCmd + "  flagbackup = F)\n"
        elif casadef.casa_version >= '4.1.0':
            casaCmd = casaCmd + "flagdata(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  mode = 'manual',\n"
            casaCmd = casaCmd + "  spw = '"+spwIds2+"',\n"
            casaCmd = casaCmd + "  autocorr = T,\n"
            casaCmd = casaCmd + "  flagbackup = F)\n\n"
            casaCmd = casaCmd + "flagdata(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  mode = 'manual',\n"
            casaCmd = casaCmd + "  intent = '"+scanIntentList+"',\n"
            casaCmd = casaCmd + "  flagbackup = F)\n"
        else:
            casaCmd = casaCmd + "tflagdata(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  mode = 'manual',\n"
            casaCmd = casaCmd + "  spw = '"+spwIds2+"',\n"
            casaCmd = casaCmd + "  autocorr = T,\n"
            casaCmd = casaCmd + "  flagbackup = F)\n\n"
            casaCmd = casaCmd + "tflagdata(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  mode = 'manual',\n"
            casaCmd = casaCmd + "  intent = '"+scanIntentList+"',\n"
            casaCmd = casaCmd + "  flagbackup = F)\n"

        tb.open(msName)
        tableNames = tb.keywordnames()
        tb.close()

        if 'FLAG_CMD' in tableNames:

            tb.open(msName+'/FLAG_CMD')
            nFlagRows = tb.nrows()
            tb.close()

            if nFlagRows != 0:

                if re.search('^3.3', casadef.casa_version) == None:
                    casaCmd = casaCmd + "\nflagcmd(vis = '"+msName+"',\n"
                    casaCmd = casaCmd + "  inpmode = 'table',\n"
                    casaCmd = casaCmd + "  useapplied = True,\n"
#                     casaCmd = casaCmd + "  action = 'plot')\n\n"
                    casaCmd = casaCmd + "  action = 'plot',\n"
                    casaCmd = casaCmd + "  plotfile = '"+msName+".flagcmd.png')\n\n"
                    casaCmd = casaCmd + "flagcmd(vis = '"+msName+"',\n"
                    casaCmd = casaCmd + "  inpmode = 'table',\n"
                    casaCmd = casaCmd + "  useapplied = True,\n"
                    casaCmd = casaCmd + "  action = 'apply')\n"
                else:
                    casaCmd = casaCmd + "\nflagcmd(vis = '"+msName+"',\n"
                    casaCmd = casaCmd + "  flagmode = 'table',\n"
                    casaCmd = casaCmd + "  optype = 'plot')\n\n"
                    casaCmd = casaCmd + "flagcmd(vis = '"+msName+"',\n"
                    casaCmd = casaCmd + "  flagmode = 'table',\n"
                    casaCmd = casaCmd + "  optype = 'apply')\n"

        return casaCmd

    def doInitialFlagging(self, msName, msName1='', chanEdge=0.0625, thresh=0.2, iHaveSplitMyScienceSpw=False):

        #specLines = {'Neptune': [[340.0, 352.0]], 'Titan': [[229, 232]]}
        #specLines = {'Neptune': [[340.0, 352.0]]}
        specLines = {'Neptune': [[114.00,116.50], [227.00,234.50], [340.00,351.50], [455.00,467.50], [686.00,696.50], [803.00,810.50]], # CO
            'Titan': [[114.93,115.66], [229.51,231.71], [343.86,347.58], [458.34,463.74], [687.83,694.58], [803.55,809.76], # CO
            [110.19,110.21], [220.30,220.50], [330.39,330.78], [440.47,441.10], [660.68,661.46], [770.74,771.63], [880.83,881.72], # 13CO
            [88.46,88.80], [176.75,177.78], [264.99,266.78], [353.33,355.68], [441.79,444.47], [618.52,622.09], [707.09,710.66], [795.65,799.22], [883.92,887.75], # HCN
            [86.05,86.06], [172.07,172.14], [258.07,258.24], [430.07,430.40], [602.02,602.53], [773.97,774.55], [859.93,860.52], # HC15N
            [86.34,86.34], [172.65,172.71], [258.94,259.09], [431.49,431.83], [604.04,604.49], [776.56,777.08], [862.81,863.33] # H13CN
            ]}

        if msName1 == '': msName1 = msName

        #casaCmd = 'print "# Initial flagging."\n\n'
        casaCmd = ''

        if re.search('^3.3', casadef.casa_version) != None or casadef.casa_version >= '4.1.0':
            casaCmd = casaCmd + "# Flagging shadowed data\n\n"
            casaCmd = casaCmd + "flagdata(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "  mode = 'shadow',\n"
            casaCmd = casaCmd + "  flagbackup = F)\n\n"
        else:
            casaCmd = casaCmd + "# Flagging shadowed data\n\n"
            casaCmd = casaCmd + "tflagdata(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "  mode = 'shadow',\n"
            casaCmd = casaCmd + "  flagbackup = F)\n\n"

        spwInfo = self.getSpwInfo(msName, intent='OBSERVE_TARGET|CALIBRATE_BANDPASS')
        spwIds = sorted(spwInfo.keys())
        if iHaveSplitMyScienceSpw == True: spwIds = range(len(spwIds))

#        sciNumChans = []
#        for i in spwInfo: sciNumChans.append(spwInfo[i]['numChans'])
#        sciNumChans = sorted(dict.fromkeys(sciNumChans).keys())
#        if len(sciNumChans) != 1: sys.exit('ERROR: Configuration not supported.')
#        sciNumChans = sciNumChans[0]
#
#        if sciNumChans <= 256:
#
#            spwSpec = ''
#            for i in spwIds:
#                if spwSpec != '': spwSpec = spwSpec+','
#                spwSpec = spwSpec+str(i)+':0~'+str(long(sciNumChans*chanEdge-1))+';'+str(long(sciNumChans-sciNumChans*chanEdge))+'~'+str(sciNumChans-1)
#
#            if re.search('^3.3', casadef.casa_version) != None:
#                casaCmd = casaCmd + "# Flagging edge channels\n\n"
#                casaCmd = casaCmd + "flagdata(vis = '"+msName1+"',\n"
#                casaCmd = casaCmd + "  mode = 'manualflag',\n"
#                casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
#                casaCmd = casaCmd + "  flagbackup = F)\n\n"
#            else:
#                casaCmd = casaCmd + "# Flagging edge channels\n\n"
#                casaCmd = casaCmd + "tflagdata(vis = '"+msName1+"',\n"
#                casaCmd = casaCmd + "  mode = 'manual',\n"
#                casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
#                casaCmd = casaCmd + "  flagbackup = F)\n\n"

        sciNumChans = []
        for i in sorted(spwInfo.keys()): sciNumChans.append(spwInfo[i]['numChans'])
        if len(dict.fromkeys(sciNumChans).keys()) != 1:
            print 'WARNING: This seems to be a mixed-mode dataset, the script generator has been updated, but for some time, please check carefully the script.'

        spwSpec = ''
        for i in range(len(spwIds)):
            if sciNumChans[i] <= 256:
                if spwSpec != '': spwSpec = spwSpec+','
                spwSpec = spwSpec+str(spwIds[i])+':0~'+str(long(sciNumChans[i]*chanEdge-1))+';'+str(long(sciNumChans[i]-sciNumChans[i]*chanEdge))+'~'+str(sciNumChans[i]-1)

        if spwSpec != '':
            if re.search('^3.3', casadef.casa_version) != None:
                casaCmd = casaCmd + "# Flagging edge channels\n\n"
                casaCmd = casaCmd + "flagdata(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  mode = 'manualflag',\n"
                casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"
            elif casadef.casa_version >= '4.1.0':
                casaCmd = casaCmd + "# Flagging edge channels\n\n"
                casaCmd = casaCmd + "flagdata(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  mode = 'manual',\n"
                casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"
            else:
                casaCmd = casaCmd + "# Flagging edge channels\n\n"
                casaCmd = casaCmd + "tflagdata(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  mode = 'manual',\n"
                casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"

        spwInfo = self.getSpwInfo(msName, intent='CALIBRATE_AMPLI|CALIBRATE_FLUX')

        if len(spwInfo) != 0:

            spwIds = sorted(spwInfo.keys())
            if iHaveSplitMyScienceSpw == True: spwIds = range(len(spwIds))

            intentSources = self.getIntentsAndSourceNames(msName)
            calFieldIds = intentSources['CALIBRATE_AMPLI']['id'] + intentSources['CALIBRATE_FLUX']['id']
            calFieldIds = [i for i in calFieldIds if i != '']
            calFieldNames = intentSources['CALIBRATE_AMPLI']['name'] + intentSources['CALIBRATE_FLUX']['name']
            calFieldNames = [i for i in calFieldNames if i != '']

            for i in range(len(calFieldIds)):
                if calFieldNames[i] in specLines.keys():
                    for j in specLines[calFieldNames[i]]:
                        for k in range(len(spwIds)):
                            spwId1 = int(sorted(spwInfo.keys())[k])
                            chanRange = getChanRangeFromFreqRange(vis = msName, spwid = spwId1, minf = j[0]*1.e9, maxf = j[1]*1.e9)
                            if chanRange == [-1, -1]: continue
                            if (chanRange[1]-chanRange[0]) / (spwInfo[spwId1]['numChans']*1.) > thresh: print '# Warning: more than '+str(thresh*100)+'% of spw '+str(spwIds[k])+' on '+calFieldNames[i]+' will be flagged due to atmospheric line.'
                            spwSpec = str(spwIds[k])+':'+str(chanRange[0])+'~'+str(chanRange[1])

                            if re.search('^3.3', casadef.casa_version) != None:
                                casaCmd = casaCmd + "# Flagging atmospheric line(s)\n\n"
                                casaCmd = casaCmd + "flagdata(vis = '"+msName1+"',\n"
                                casaCmd = casaCmd + "  mode = 'manualflag',\n"
                                casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
                                casaCmd = casaCmd + "  field = '"+str(calFieldIds[i])+"',\n"
                                casaCmd = casaCmd + "  flagbackup = F)\n\n"
                            elif casadef.casa_version >= '4.1.0':
                                casaCmd = casaCmd + "# Flagging atmospheric line(s)\n\n"
                                casaCmd = casaCmd + "flagdata(vis = '"+msName1+"',\n"
                                casaCmd = casaCmd + "  mode = 'manual',\n"
                                casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
                                casaCmd = casaCmd + "  field = '"+str(calFieldIds[i])+"',\n"
                                casaCmd = casaCmd + "  flagbackup = F)\n\n"
                            else:
                                casaCmd = casaCmd + "# Flagging atmospheric line(s)\n\n"
                                casaCmd = casaCmd + "tflagdata(vis = '"+msName1+"',\n"
                                casaCmd = casaCmd + "  mode = 'manual',\n"
                                casaCmd = casaCmd + "  spw = '"+spwSpec+"',\n"
                                casaCmd = casaCmd + "  field = '"+str(calFieldIds[i])+"',\n"
                                casaCmd = casaCmd + "  flagbackup = F)\n\n"

        return casaCmd

    def generateWVRCalTable(self, msName, calTableName=[], refant='', smooth=True, doplot=True):

        #casaCmd = 'print "# Generation and time averaging of the WVR calibration table."\n\n'
        casaCmd = ''

        tb.open(msName+'/OBSERVATION')
        obsTimeRange = tb.getcol('TIME_RANGE')
        tb.close()
        obsTimeStart = ((obsTimeRange[0]/86400.0)+2400000.5-2440587.5)*86400.0
        obsTimeStart = timeUtilities.strftime('%Y-%m-%dT%H:%M:%S', timeUtilities.gmtime(obsTimeStart))
        if obsTimeStart > '2013-01-21T00:00:00':
            wvrTimeOffset = 0
        else:
            wvrTimeOffset = -1

        tb.open(msName+'/ANTENNA')
        antNames = tb.getcol('NAME')
        tb.close()

        found = 0
        for i in antNames:
            if re.search('^CM[0-9]+', i) == None: found = 1
        if found == 0:
            calTableName.append('')
            return casaCmd

        intentSources = self.getIntentsAndSourceNames(msName)

        sciSourceId = intentSources['OBSERVE_TARGET']['sourceid']
        sciSourceId1 = dict.fromkeys(sciSourceId).keys()
        if sciSourceId1[0] != '':
            #if len(sciSourceId1) != 1: casaCmd = casaCmd + "# Warning: there are more than one science target, I'm picking the lowest id. Please check this is right.\n\n"
            sciSourceName = intentSources['OBSERVE_TARGET']['name'][sciSourceId.index(min(sciSourceId1))]
            sciSourceId = min(sciSourceId1)

            phaseCal = self.getPhaseCal(msName)

        casaCmd = casaCmd + "os.system('rm -rf %s.wvr') \n\n"%(msName)

        if re.search('^3.3', casadef.casa_version) != None:
            #casaCmd = casaCmd + "os.system(" + '"' + "wvrgcal --ms "+msName+" --output "+msName+".wvr --toffset -1 --statsource '"+sciSourceName+"' --segsource"
            casaCmd = casaCmd + "os.system(" + '"' + "wvrgcal --ms "+msName+" --output "+msName+".wvr --toffset "+str(wvrTimeOffset)+" --segsource"
            if sciSourceId1[0] != '':
                #if len(phaseCal) == 1: casaCmd = casaCmd + " --tie '"+str(phaseCal[sciSourceName]['phaseCalId'])+","+str(sciSourceId)+"'"
                if len(phaseCal) == 1: casaCmd = casaCmd + " --statsource '"+sciSourceName+"' --tie '"+str(phaseCal[sciSourceName]['phaseCalId'])+","+str(sciSourceId)+"'"
            casaCmd = casaCmd + ' | tee '+msName+'.wvrgcal")\n\n'
        else:
            casaCmd = casaCmd + "mylogfile = casalog.logfile()\n"
            casaCmd = casaCmd + "casalog.setlogfile('"+msName+".wvrgcal')\n\n"
            casaCmd = casaCmd + "wvrgcal(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  caltable = '"+msName+".wvr',\n"
            casaCmd = casaCmd + "  toffset = "+str(wvrTimeOffset)
            if sciSourceId1[0] != '':
                casaCmd = casaCmd + ",\n  tie = "+str([','.join([i, phaseCal[i]['phaseCalName']]) for i in phaseCal])+",\n"
                casaCmd = casaCmd + "  statsource = '"+sciSourceName+"')\n\n"
            else:
                casaCmd = casaCmd + ")\n\n"
            casaCmd = casaCmd + "casalog.setlogfile(mylogfile)\n\n"

        calTableName1 = msName+'.wvr'

        if (casadef.casa_version >= '4.2.0'):
            casaCmd = casaCmd + "# This is a temporary workaround, which will be included in a future version of CASA\n\n"
            casaCmd = casaCmd + "tb.open('"+calTableName1+"', nomodify=False)\n"
            casaCmd = casaCmd + "count = 0\n"
            casaCmd = casaCmd + "numrows = tb.nrows()\n"
            casaCmd = casaCmd + "mycparamcol = tb.getcol('CPARAM')\n"
            casaCmd = casaCmd + "for i in range(0, numrows):\n"
            casaCmd = casaCmd + "    if mycparamcol[0][0][i] == (1.+0.j):\n"
            casaCmd = casaCmd + "        tb.putcell('FLAG', i, [[True]])\n"
            casaCmd = casaCmd + "        count += 1\n"
            casaCmd = casaCmd + "tb.close()\n"
            casaCmd = casaCmd + "del mycparamcol\n"
            casaCmd = casaCmd + "if(numrows>0):\n"
            casaCmd = casaCmd + "    print 'Flagged', count, 'of', numrows, 'solutions =', 100.*count/float(numrows),'%'\n\n\n"

        spwInfo = self.getSpwInfo(msName)
        integTime = []
        for i in spwInfo: integTime.append(spwInfo[i]['integTime'])
        integTime = dict.fromkeys(integTime).keys()
        if len(integTime) != 1: casaCmd = casaCmd + "# Warning: more than one integration time found on science data, I'm picking the lowest value. Please check this is right.\n\n"
        integTime = min(integTime)

        if smooth == True and integTime > 1.152:
            casaCmd = casaCmd + "os.system('rm -rf %s.wvr.smooth') \n\n"%(msName)
            casaCmd = casaCmd + "smoothcal(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  tablein = '"+msName+".wvr',\n"
            casaCmd = casaCmd + "  caltable = '"+msName+".wvr.smooth',\n"
            casaCmd = casaCmd + "  smoothtype = 'mean',\n"
            casaCmd = casaCmd + "  smoothtime = "+str(integTime)+")\n\n\n"
            calTableName1 = msName+'.wvr.smooth'

        calTableName.append(calTableName1)

        if doplot == True:
    # CLB added plots of WVR cross-correlations
            sciSpwInfo = self.getSpwInfo(msName)     # added by Todd on Sep 12, 2012
            sciSpw0 = sorted(sciSpwInfo.keys())[0]   # added by Todd on Sep 12, 2012
            casaCmd = casaCmd + "if applyonly != True: aU.plotWVRSolutions(caltable='%s', spw='%s', antenna='%s',\n" %(calTableName1,sciSpw0,refant)
            casaCmd = casaCmd + "  yrange=[-180,180],subplot=22, interactive=False,\n"
            casaCmd = casaCmd + "  figfile='%s') \n\n" %(calTableName1+'.plots/'+calTableName1.split('/')[-1])
            casaCmd = casaCmd + "#Note: If you see wraps in these plots, try changing yrange or unwrap=True \n"
            casaCmd = casaCmd + "#Note: If all plots look strange, it may be a bad WVR on the reference antenna.\n"
            casaCmd = casaCmd + "#      To check, you can set antenna='' to show all baselines.\n"

        if casadef.casa_version < '4.2.0':

            tb.open(msName+'/DATA_DESCRIPTION')
            spwIds = tb.getcol('SPECTRAL_WINDOW_ID')
            tb.close()

            tb.open(msName+'/PROCESSOR')
            procType = tb.getcol('TYPE')
            tb.close()

            procType1 = np.where(procType == 'RADIOMETER')[0]

            spwIds1 = []

            tb.open(msName)

            for i in procType1:
                tb1 = tb.query('PROCESSOR_ID == '+str(i))
                dataDescIds1 = tb1.getcol('DATA_DESC_ID')
                dataDescIds1 = np.unique(dataDescIds1)
                for j in dataDescIds1:
                    spwIds1.append(str(spwIds[j]))

            tb.close()

            spwIds1 = ','.join(spwIds1)

            if re.search('^3.3', casadef.casa_version) != None:
                casaCmd = casaCmd + "\n\nflagdata(vis = '"+msName+"',\n"
                casaCmd = casaCmd + "  mode = 'manualflag',\n"
                casaCmd = casaCmd + "  spw = '"+spwIds1+"',\n"
                casaCmd = casaCmd + "  autocorr = T,\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"
            elif re.search('^4.1', casadef.casa_version) != None:
                casaCmd = casaCmd + "\n\nflagdata(vis = '"+msName+"',\n"
                casaCmd = casaCmd + "  mode = 'manual',\n"
                casaCmd = casaCmd + "  spw = '"+spwIds1+"',\n"
                casaCmd = casaCmd + "  autocorr = T,\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"
#             elif casadef.casa_version >= '4.2.0':
#                 casaCmd = casaCmd + "\n\nflagdata(vis = '"+msName+"',\n"
#                 casaCmd = casaCmd + "  mode = 'manual',\n"
#                 casaCmd = casaCmd + "  spw = '"+spwIds1+"',\n"
#                 casaCmd = casaCmd + "  flagbackup = F)\n\n"
            else:
                casaCmd = casaCmd + "\n\ntflagdata(vis = '"+msName+"',\n"
                casaCmd = casaCmd + "  mode = 'manual',\n"
                casaCmd = casaCmd + "  spw = '"+spwIds1+"',\n"
                casaCmd = casaCmd + "  autocorr = T,\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"

        return casaCmd

    def readWvrgcalOutput(self, fname):

        if fname == '': sys.exit('ERROR: You must specify a file name.')

        f = open(fname)
        fc = f.read()
        f.close()

        fc1 = re.findall('[0-9]{4}\-[0-9]{2}\-[0-9]{2} [0-9]{2}\:[0-9]{2}\:[0-9]{2}\tINFO\twvrgcal\:\:\:\:casa\t[0-9]+ +[A-Z]{2}[0-9]{2} +[A-Za-z]+ +[A-Za-z]+ +[0-9.e+-]+ +[0-9.e+-]+', fc)

        wvrInfo = {}

        wvrInfo['ants'] = {}

        for i in range(len(fc1)):

            fc2 = fc1[i].split('\t')[3].split()

            wvrInfo['ants'][fc2[1]] = {}
            wvrInfo['ants'][fc2[1]]['RMS'] = float(fc2[4])
            wvrInfo['ants'][fc2[1]]['Disc'] = float(fc2[5])

        wvrInfo['stats'] = {}

        for i in ['RMS', 'Disc']:

            values1 = []
            for j in wvrInfo['ants'].keys():
                values1.append(wvrInfo['ants'][j][i])

            wvrInfo['stats'][i] = {}
            wvrInfo['stats'][i]['mean'] = np.mean(values1)
            wvrInfo['stats'][i]['median'] = np.median(values1)
            wvrInfo['stats'][i]['std'] = np.std(values1)
            wvrInfo['stats'][i]['MAD'] = np.median(abs(values1-np.median(values1))) / 0.6745

            wvrInfo['stats'][i]['outliers'] = []

            outliers1 = []
            for j in wvrInfo['ants'].keys():
                if abs(wvrInfo['ants'][j][i]-wvrInfo['stats'][i]['median']) >= 3 * wvrInfo['stats'][i]['MAD']:
                    outliers1.append(j)

            if len(j) != 0:
                wvrInfo['stats'][i]['outliers'] = outliers1

        return wvrInfo

    def clearPointingTable(self, msName):

        #casaCmd = 'print "# Clearing the pointing table."\n\n'
        casaCmd = ''

        casaCmd = casaCmd + "tb.open('"+msName+"/POINTING', nomodify = False)\n"
        casaCmd = casaCmd + "a = tb.rownumbers()\n"
        casaCmd = casaCmd + "tb.removerows(a)\n"
        casaCmd = casaCmd + "tb.close()\n"

        return casaCmd

    def fluxscale2(self, caltable='', refFieldId='', preavg=1, removeOutliers=False, msName='', writeToFile=False):

        setjyModels = ['Mars', 'Jupiter', 'Uranus', 'Neptune', 'Pluto', 'Io', 'Europa', 'Ganymede', 'Callisto', 'Titan', 'Triton', 'Ceres', 'Pallas', 'Vesta', 'Juno', 'Victoria', 'Davida']

        tb.open(caltable+'/SPECTRAL_WINDOW')
        spwChanFreq = tb.getcol('CHAN_FREQ')[0]
        tb.close()

        tb.open(caltable+'/FIELD')
        fieldNames = tb.getcol('NAME')
        tb.close()

        tb.open(caltable)

        calFieldIds = tb.getcol('FIELD_ID')
        calFieldIds = sorted(dict.fromkeys(calFieldIds).keys())
        calFieldNames = [fieldNames[i] for i in calFieldIds]

        if refFieldId == '':
            refFieldId = [i for i in calFieldIds if fieldNames[i] in setjyModels]
            if len(refFieldId) == 0: return {}
            refFieldId = refFieldId[0]
            print 'You have not specified a reference field id, I have picked one automatically: '+fieldNames[refFieldId]
        else:
            refFieldId = int(refFieldId)

        ampGains = {}

        for fieldId in calFieldIds:

            ampGains[fieldId] = {}

            tb1 = tb.query('FIELD_ID == '+str(fieldId))
            times1 = tb1.getcol('TIME')
            times1 = sorted(dict.fromkeys(times1).keys())

            while len(times1) != 0:

                ij = sorted(np.where(np.abs([tt-times1[0] for tt in times1]) < preavg)[0], reverse=True)

                times2 = []
                for i in ij:
                    times2.append(times1[i])
                    times1.pop(i)
                time3 = np.mean(times2)

                tb1 = tb.query('FIELD_ID == '+str(fieldId)+' AND TIME >= '+str(time3-preavg/2.)+' AND TIME <= '+str(time3+preavg/2.))

                spwIds = tb1.getcol('SPECTRAL_WINDOW_ID')
                if len(spwIds) == 0: continue # why this test??
                spwIds = sorted(dict.fromkeys(spwIds).keys())

                ampGains[fieldId][time3] = {}

                for i in spwIds:

                    tb1 = tb.query('FIELD_ID == '+str(fieldId)+' AND TIME >= '+str(time3-preavg/2.)+' AND TIME <= '+str(time3+preavg/2.)+' AND SPECTRAL_WINDOW_ID == '+str(i))

                    antIds = tb1.getcol('ANTENNA1')
                    if len(antIds) == 0: continue # why this test?
                    antIds = sorted(dict.fromkeys(antIds).keys())

                    for j in antIds:

                        tb1 = tb.query('FIELD_ID == '+str(fieldId)+' AND TIME >= '+str(time3-preavg/2.)+' AND TIME <= '+str(time3+preavg/2.)+' AND SPECTRAL_WINDOW_ID == '+str(i)+' AND ANTENNA1 == '+str(j))

                        gains1 = tb1.getcol('CPARAM')
                        if len(gains1) == 0: continue # why this test?
                        flags1 = tb1.getcol('FLAG')

                        for k in range(len(gains1)):

                            ampGains1 = []
                            for l in range(len(gains1[k][0])):
                                if flags1[k][0][l] == False: ampGains1.append(abs(gains1[k][0][l]))

                            if len(ampGains1) != 0:
                                if i not in ampGains[fieldId][time3].keys(): ampGains[fieldId][time3][i] = {}
                                if k not in ampGains[fieldId][time3][i].keys(): ampGains[fieldId][time3][i][k] = {}
                                ampGains[fieldId][time3][i][k][j] = np.mean(ampGains1)

        tb.close()

        if refFieldId not in ampGains.keys(): sys.exit('ERROR: Reference field id not found.')

        ampGains1 = {}

        for fieldId in ampGains.keys():
            if fieldId == refFieldId: continue
            for timeId in ampGains[fieldId].keys():
                for spwId in ampGains[fieldId][timeId].keys():
                    for polId in ampGains[fieldId][timeId][spwId].keys():
                        for antId in ampGains[fieldId][timeId][spwId][polId].keys():
                            timeIds2 = []
                            ampGains2 = []
                            for timeId1 in ampGains[refFieldId].keys():
                                if spwId in ampGains[refFieldId][timeId1].keys():
                                    if polId in ampGains[refFieldId][timeId1][spwId].keys():
                                        if antId in ampGains[refFieldId][timeId1][spwId][polId].keys():
                                            timeIds2.append(timeId1)
                                            ampGains2.append(ampGains[refFieldId][timeId1][spwId][polId][antId])
                            if len(ampGains2) != 0:
                                if fieldId not in ampGains1.keys(): ampGains1[fieldId] = {}
                                if timeId not in ampGains1[fieldId].keys(): ampGains1[fieldId][timeId] = {}
                                if spwId not in ampGains1[fieldId][timeId].keys(): ampGains1[fieldId][timeId][spwId] = {}
                                if polId not in ampGains1[fieldId][timeId][spwId].keys(): ampGains1[fieldId][timeId][spwId][polId] = {}
                                if len(ampGains2) == 1:
                                    ampGains1[fieldId][timeId][spwId][polId][antId] = (ampGains[fieldId][timeId][spwId][polId][antId] / ampGains2[0])**2
                                else:
                                    ampGainsLin = scipy.interpolate.interp1d(timeIds2, ampGains2)
                                    ampGains1[fieldId][timeId][spwId][polId][antId] = (ampGains[fieldId][timeId][spwId][polId][antId] / ampGainsLin(timeId))**2

        ampGains2 = {}

        for fieldId in ampGains1.keys():
            for timeId in ampGains1[fieldId].keys():
                for spwId in ampGains1[fieldId][timeId].keys():
                    for polId in ampGains1[fieldId][timeId][spwId].keys():
                        ampGains3 = []
                        for antId in ampGains1[fieldId][timeId][spwId][polId].keys(): ampGains3.append(ampGains1[fieldId][timeId][spwId][polId][antId])
                        if len(ampGains3) != 0:
                            if removeOutliers == True:
                                ampGainsMedian = np.median(ampGains3)
                                ampGainsMAD = np.median(abs(ampGains3-ampGainsMedian)) / 0.6745
                                ampGains3 = [k for k in ampGains3 if abs(k-ampGainsMedian) < 3*ampGainsMAD]
                            if fieldId not in ampGains2.keys(): ampGains2[fieldId] = {}
                            if timeId not in ampGains2[fieldId].keys(): ampGains2[fieldId][timeId] = {}
                            if spwId not in ampGains2[fieldId][timeId].keys(): ampGains2[fieldId][timeId][spwId] = {}
                            if polId not in ampGains2[fieldId][timeId][spwId].keys(): ampGains2[fieldId][timeId][spwId][polId] = {}
                            ampGains2[fieldId][timeId][spwId][polId]['mean'] = np.mean(ampGains3)
                            ampGains2[fieldId][timeId][spwId][polId]['stddev'] = np.std(ampGains3)

        ampGains3 = {}

        for fieldId in ampGains2.keys():
            timeId3 = []
            for timeId in ampGains2[fieldId].keys(): timeId3.append(timeId)
            timeId3 = np.mean(timeId3)
            timeId3 = ((timeId3/86400.0)+2400000.5-2440587.5)*86400.0
            timeId3 = timeUtilities.strftime('%Y-%m-%dT%H:%M:%S', timeUtilities.gmtime(timeId3))
            for timeId in ampGains2[fieldId].keys():
                for spwId in ampGains2[fieldId][timeId].keys():
                    for polId in ampGains2[fieldId][timeId][spwId].keys():
                        if fieldId not in ampGains3.keys(): ampGains3[fieldId] = {}
                        if timeId3 not in ampGains3[fieldId].keys(): ampGains3[fieldId][timeId3] = {}
                        if spwId not in ampGains3[fieldId][timeId3].keys(): ampGains3[fieldId][timeId3][spwId] = {}
                        if polId not in ampGains3[fieldId][timeId3][spwId].keys(): ampGains3[fieldId][timeId3][spwId][polId] = {}
            for spwId in ampGains3[fieldId][timeId3].keys():
                for polId in ampGains3[fieldId][timeId3][spwId].keys():
                    ampGainsMeans4 = []
                    ampGainsStd4 = []
                    for timeId in ampGains2[fieldId].keys():
                        if spwId in ampGains2[fieldId][timeId].keys():
                            if polId in ampGains2[fieldId][timeId][spwId].keys():
                                ampGainsMeans4.append(ampGains2[fieldId][timeId][spwId][polId]['mean'])
                                ampGainsStd4.append(ampGains2[fieldId][timeId][spwId][polId]['stddev'])
                    sum1 = 0.
                    sum2 = 0.
                    for k in range(len(ampGainsMeans4)):
                        sum1 += ampGainsMeans4[k]/ampGainsStd4[k]**2
                        sum2 += 1./ampGainsStd4[k]**2
                    ampGains3[fieldId][timeId3][spwId][polId]['mean'] = sum1 / sum2
                    ampGains3[fieldId][timeId3][spwId][polId]['stddev'] = sqrt(1. / sum2)

        if writeToFile == True:

            if msName == '': sys.exit('ERROR: Please provide an ms name.')

            f1 = open(caltable+'.fluxscale2', 'w')

            print >> f1, "#################################################################################################"
            print >> f1, "# Measurements on ?? at Band ?? produced by ??"
            print >> f1, "# ASDM used: "+msName.replace('.ms', '')
            print >> f1, "#"
            print >> f1, "# WVR correction applied"
            print >> f1, "# Additional flags applied in: ??"
            print >> f1, "# Using reference antenna: ??"
            print >> f1, "# Bandpass calibrator: ??"
            print >> f1, "# Absolute Flux Density from: "+fieldNames[refFieldId]
            print >> f1, "#"
            print >> f1, "#           source scan elev"

            tb.open(caltable)
            scanList = tb.getcol('SCAN_NUMBER')
            tb.close()

            scanList = np.unique(scanList)

            fieldNames1 = []
            msmd.open(msName)
            for i in scanList:
                fieldNames1.append(msmd.fieldsforscan(scan=i, asnames=True)[0])
            msmd.close()

            azimuth1 = []
            elevation1 = []

            for i in range(len(scanList)):

                scanInfo1 = getWeather(msName, scan=str(scanList[i]))[0]

                print >> f1, '# %16s %3d  %5.2f' %(fieldNames1[i], scanList[i], scanInfo1['elevation'])

                azimuth1.append(scanInfo1['azimuth'])
                elevation1.append(scanInfo1['elevation'])

            print >> f1, "#"
            print >> f1, "# Data Format[Units]:"
            print >> f1, "# sourceName , ra [Hour:Min:Sec] , ra_err [arcsec], dec [Degree:Min:Sec],dec_err [arcsec],"
            print >> f1, "# frequency [Hz], flux [Jy], flux_err [Jy],"
            print >> f1, "# degree [%], degree_err [%],  angle [deg], angle_err [deg],"
            print >> f1, "# min_baseline [klambda], max_baseline [klambda], date_observed [YYYY-MM-DDT]"
            print >> f1, "# NE means No Entry"
            print >> f1, "#"
            print >> f1, "#"
            print >> f1, "#################################################################################################"
            print >> f1, "#    source                       freq        S     dS     %P    d%P uvmin   uvmax     Date"

            for fieldId in ampGains3.keys():

                ij = np.where(np.array(fieldNames1) == fieldNames[fieldId])[0]
                if len(ij) != 0:
                    uvmax = []
                    for k in ij: uvmax.append(getBaselineStats(msName, azimuth=azimuth1[k], elevation=elevation1[k], verbose=False)[2])
                    uvmax = '%7.1f' %(-1.*np.mean(uvmax))
                else:
                    uvmax = 'NE'

                for timeId in ampGains3[fieldId].keys():
                    for spwId in ampGains3[fieldId][timeId].keys():
                        if len(ampGains3[fieldId][timeId][spwId].keys()) != 1: continue # to remove when going full polarization
                        for polId in ampGains3[fieldId][timeId][spwId].keys():
                            print >> f1, '%12s, NE, NE, NE, NE, %7.2fE+09, %5.4f, %5.4f, NE, NE, NE, NE, %7.1f, %s, %10s' \
                                %(fieldNames[fieldId], spwChanFreq[spwId]/1.e9, ampGains3[fieldId][timeId][spwId][polId]['mean'], ampGains3[fieldId][timeId][spwId][polId]['stddev'], 0, uvmax, timeId[0:10])

            print >> f1, "#"
            print >> f1, "#################################################################################################"

            f1.close()

        return ampGains3

    def getFieldsForSetjy(self, msName):

        setjyModels = ['Venus', 'Mars', 'Jupiter', 'Uranus', 'Neptune', 'Pluto', 'Io', 'Europa', 'Ganymede', 'Callisto', 'Titan', 'Triton', 'Ceres', 'Pallas', 'Vesta', 'Juno', 'Victoria', 'Davida']

        #tb.open(msName+'/FIELD')
        #fieldNames = tb.getcol('NAME')
        #tb.close()

        intentSources = self.getIntentsAndSourceNames(msName)
        ampSourceIds = intentSources['CALIBRATE_AMPLI']['id'] + intentSources['CALIBRATE_FLUX']['id']
        ampSourceIds = [i for i in ampSourceIds if i != '']
        ampSourceNames = intentSources['CALIBRATE_AMPLI']['name'] + intentSources['CALIBRATE_FLUX']['name']
        ampSourceNames = [i for i in ampSourceNames if i != '']

        fieldIds = []
        for i in range(len(ampSourceNames)):
            for j in setjyModels:
                if re.search(j, ampSourceNames[i], re.IGNORECASE) != None: fieldIds.append(ampSourceIds[i])

        fieldIds = sorted(np.unique(fieldIds).tolist())

        return fieldIds

    def getFluxesFromSourceTable(self, msName):

        sourceFluxes = {}

        tb.open(msName)
        keywordnames1 = tb.keywordnames()
        tb.close()

        if 'ASDM_SOURCE' in keywordnames1:

            tb.open(msName + '/ASDM_SOURCE')

            for i in range(tb.nrows()):

                if tb.iscelldefined('frequency', i) == False or tb.iscelldefined('flux', i) == False: continue

                sourceId = tb.getcell('sourceId', i)
                sourceName = tb.getcell('sourceName', i)

                frequency1 = tb.getcell('frequency', i).tolist()
                flux1 = tb.getcell('flux', i).tolist()

                if len(frequency1) != len(flux1): sys.exit('ERROR: The number of frequencies and flux values do not match.')
                if len(frequency1) != 1: print "WARNING: There are more than one flux values."

                for j in range(len(flux1)):
                    if flux1[j][1] != 0: print "WARNING: Source "+sourceName+" has a non-0 value for Q."
                    if flux1[j][2] != 0: print "WARNING: Source "+sourceName+" has a non-0 value for U."
                    if flux1[j][3] != 0: print "WARNING: Source "+sourceName+" has a non-0 value for V."

                if sourceId not in sourceFluxes: sourceFluxes[sourceId] = {}
                if 'sourceName' not in sourceFluxes[sourceId]: sourceFluxes[sourceId]['sourceName'] = sourceName
                if 'frequency' not in sourceFluxes[sourceId]: sourceFluxes[sourceId]['frequency'] = []
                if 'flux' not in sourceFluxes[sourceId]: sourceFluxes[sourceId]['flux'] = []

                for j in range(len(frequency1)):
                    if frequency1[j] not in sourceFluxes[sourceId]['frequency']:
                        sourceFluxes[sourceId]['frequency'].append(frequency1[j])
                        sourceFluxes[sourceId]['flux'].append(flux1[j][0])

            tb.close()

        return sourceFluxes

    def runSetjy(self, msName, msName1='', iHaveSplitMyScienceSpw=False):

        if msName1 == '': msName1 = msName

        casaCmd = ''

        fieldIds = self.getFieldsForSetjy(msName)

        if fieldIds != []:

            #casaCmd = 'print "# Putting a model for the flux calibrator(s)."\n\n'

            tb.open(msName+'/FIELD')
            fieldNames = tb.getcol('NAME')
            tb.close()

            fieldNames = ['%s' %fieldNames[i] for i in fieldIds]
            fieldNames = ','.join(fieldNames)
            fieldIds = ['%s' %i for i in fieldIds]
            fieldIds1 = ','.join(fieldIds)

            spwInfo = self.getSpwInfo(msName, intent='CALIBRATE_AMPLI|CALIBRATE_FLUX')
            spwIds = sorted(spwInfo.keys())
            if iHaveSplitMyScienceSpw == True: spwIds = range(len(spwIds))
            spwIds = ['%s' %i for i in spwIds]
            spwIds = ','.join(spwIds)

            casaCmd = casaCmd + "setjy(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "  field = '"+fieldIds1+"', # "+fieldNames+"\n"
            casaCmd = casaCmd + "  spw = '"+spwIds+"',\n"
            if re.search('^3.', casadef.casa_version) == None:
                casaCmd = casaCmd + "  standard = 'Butler-JPL-Horizons 2012')\n\n"
            else:
                casaCmd = casaCmd + "  standard = 'Butler-JPL-Horizons 2010')\n\n"

            casaCmd = casaCmd + "os.system('rm -rf %s.setjy.field*.png') \n"%(msName1)
            casaCmd = casaCmd + "for i in "+str(fieldIds)+":\n"
            casaCmd = casaCmd + "  plotms(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "    xaxis = 'uvdist',\n"
            casaCmd = casaCmd + "    yaxis = 'amp',\n"
            casaCmd = casaCmd + "    ydatacolumn = 'model',\n"
            casaCmd = casaCmd + "    field = i,\n"
            casaCmd = casaCmd + "    spw = '"+spwIds+"',\n"
            casaCmd = casaCmd + "    avgchannel = '9999',\n"
            casaCmd = casaCmd + "    coloraxis = 'spw',\n"
            casaCmd = casaCmd + "    plotfile = '"+msName1+".setjy.field'+i+'.png')\n"

        else:

            intentSources = self.getIntentsAndSourceNames(msName)
            intentSources1 = intentSources['CALIBRATE_FLUX']

            if len(intentSources1['sourceid']) != 0:

#                 fluxCalSourceId = intentSources1['sourceid']
#                 if len(fluxCalSourceId) != 1: sys.exit("ERROR: There are more than one flux calibrator.")
#                 fluxCalSourceId = fluxCalSourceId[0]
#                 fluxCalSourceName = intentSources1['name'][0]
#                 fluxCalFieldIds = intentSources1['id']
# 
#                 sourceFluxes = self.getFluxesFromSourceTable(msName)

                sourceFluxes = self.getFluxesFromSourceTable(msName)

                fluxCalSourceId = intentSources1['sourceid']

                if len(fluxCalSourceId) > 1:
                    print "WARNING: THERE ARE MORE THAN ONE FLUX CALIBRATOR. I WILL PICK THE FIRST ONE. THIS MAY BE WRONG."
                    fluxCalSourceId = [j for j in fluxCalSourceId if j in sourceFluxes.keys()]

                if len(fluxCalSourceId) == 0: sys.exit("ERROR: There are no flux calibrator.")

                fluxCalSourceId = fluxCalSourceId[0]

                fluxCalSourceName = intentSources1['name'][intentSources1['sourceid'].index(fluxCalSourceId)]

                if len(intentSources1['sourceid']) > 1:
                    tb.open(msName+'/FIELD')
                    tb1 = tb.query('SOURCE_ID == '+str(fluxCalSourceId))
                    fluxCalFieldIds1 = tb1.rownumbers().tolist()
                    tb1.close()
                    tb.close()
                    fluxCalFieldIds = [j for j in fluxCalFieldIds1 if j in intentSources1['id']]
                else:
                    fluxCalFieldIds = intentSources1['id']

                if fluxCalSourceId in sourceFluxes:

                    if fluxCalSourceName != sourceFluxes[fluxCalSourceId]['sourceName']: sys.exit("ERROR: Source names do not match.")

                    fluxCalFieldIds = ['%s' %i for i in fluxCalFieldIds]
                    fluxCalFieldIds = ','.join(fluxCalFieldIds)

                    vm = ValueMapping(msName)

                    spwInfo = self.getSpwInfo(msName, intent='CALIBRATE_FLUX')
                    spwIds = sorted(spwInfo.keys())

                    spwMeanFreq = []
                    for j in spwIds: spwMeanFreq.append(vm.spwInfo[j]['meanFreq'])

                    if iHaveSplitMyScienceSpw == True: spwIds = range(len(spwIds))

                    for j in range(len(spwIds)):

                        frequency1 = []
                        for k in sourceFluxes[fluxCalSourceId]['frequency']: frequency1.append(abs(k-spwMeanFreq[j]))
                        ij = frequency1.index(min(frequency1))

                        frequency1 = sourceFluxes[fluxCalSourceId]['frequency'][ij]
                        flux1 = sourceFluxes[fluxCalSourceId]['flux'][ij]
                    
                        casaCmd = casaCmd + "setjy(vis = '"+msName1+"',\n"
                        casaCmd = casaCmd + "  field = '"+fluxCalFieldIds+"', # source name = "+fluxCalSourceName+"\n"
                        casaCmd = casaCmd + "  spw = '"+str(spwIds[j])+"', # center frequency of spw = "+str(spwMeanFreq[j]/1.e9)+"GHz\n"
                        if (casadef.casa_version >= '4.2.0'): casaCmd = casaCmd + "  standard = 'manual',\n"
                        casaCmd = casaCmd + "  fluxdensity = ["+str(flux1)+", 0, 0, 0]) # frequency of measurement = "+str(frequency1/1.e9)+"GHz\n\n"


        return casaCmd

    def doGainCalibration(self, msName, msName1='', refant='', bandpass='', iHaveSplitMyScienceSpw=False, gaintypeForAmp='T', doplot=True, calFieldsOnly=True, phaseOffsetCalTableName=[]):

        if msName1 == '': msName1 = msName
        if refant == '': sys.exit('ERROR: No reference antenna specified.')
        if bandpass == '': sys.exit('ERROR: No bandpass cal table specified.')

        tb.open(msName+'/FIELD')
        fieldNames = tb.getcol('NAME')
        tb.close()

        fieldIds = range(len(fieldNames))

        intentSources = self.getIntentsAndSourceNames(msName)
        sciFieldIds = intentSources['OBSERVE_TARGET']['id']
        if sciFieldIds[0] == '': print 'WARNING: THERE SEEMS TO BE NO SCIENCE FIELD'

        if calFieldsOnly == True:
            calFieldIds = [i for i in fieldIds if i not in sciFieldIds]
        else:
            calFieldIds = [i for i in fieldIds]

        if len(calFieldIds) == '': sys.exit('ERROR: There seems to be no calibrator field.')

        calFieldNames = [fieldNames[i] for i in calFieldIds]
        calFieldNames = ','.join(calFieldNames)

        if len(calFieldIds) > 1:
            j0 = 0
            calFieldIds1 = str(calFieldIds[j0])
            for j in range(len(calFieldIds)-1):
                if calFieldIds[j+1] == calFieldIds[j]+1: continue
                calFieldIds1 = calFieldIds1 + '~' + str(calFieldIds[j])
                j0 = j+1
                calFieldIds1 = calFieldIds1 + ',' + str(calFieldIds[j0])
            calFieldIds1 = calFieldIds1 + '~' + str(calFieldIds[j+1])
        else:
            calFieldIds1 = str(calFieldIds[0])

        spwInfo = self.getSpwInfo(msName)
        spwIds = sorted(spwInfo.keys())

###

        casaCmd = ''

        spwInfo1 = self.getSpwInfo(msName, intent = 'CALIBRATE_PHASE')
        spwIds1 = sorted(spwInfo1.keys())

        if spwIds != spwIds1 and sciFieldIds[0] != '':

            print 'WARNING: THIS SEEMS TO BE A BW-SWITCHING OR B2B-TRANSFER OBSERVATION. THE FORMER IS SUPPORTED, THE LATTER NOT ENTIRELY YET.'

            bpassCalId = intentSources['CALIBRATE_BANDPASS']['id']
            if bpassCalId[0] == '': sys.exit('ERROR: There are no bandpass calibrator.')
            if len(bpassCalId) != 1: casaCmd = casaCmd + "# Note: there are more than one bandpass calibrator, I'm picking the first one: "+fieldNames[bpassCalId[0]]+".\n"
            bpassCalId = bpassCalId[0]

            casaCmd = casaCmd + "os.system('rm -rf %s.phase_pre_offsets_inf') \n"%(msName1)
            casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "  caltable = '"+msName1+".phase_pre_offsets_inf',\n"
            casaCmd = casaCmd + "  field = '"+str(bpassCalId)+"',\n"
            casaCmd = casaCmd + "  solint = 'inf',\n"
            casaCmd = casaCmd + "  refant = '"+refant+"',\n"
            casaCmd = casaCmd + "  gaintype = 'G',\n"
            casaCmd = casaCmd + "  calmode = 'p',\n"
            casaCmd = casaCmd + "  gaintable = '"+bandpass+"')\n\n"

            if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".phase_pre_offsets_inf', msName='"+msName1+"', interactive=False) \n\n"

            if iHaveSplitMyScienceSpw == True:
                casaCmd = casaCmd + "phasemap = range("+str(len(spwIds+spwIds1))+")\n"
            else:
                casaCmd = casaCmd + "phasemap = range("+str(max(spwIds+spwIds1)+1)+")\n"

            spwIds3 = sorted(spwIds+spwIds1)

            for i in spwIds3:
                if i in spwIds1:
                    if iHaveSplitMyScienceSpw == True:
                        casaCmd = casaCmd + "phasemap["+str(spwIds3.index(i))+"] = "+str(spwIds3.index(i))+"\n"
                    else:
                        casaCmd = casaCmd + "phasemap["+str(i)+"] = "+str(i)+"\n"
                else:
                    spwIds2 = []
                    for j in spwIds1:
                        if spwInfo[i]['basebandNum'] == spwInfo1[j]['basebandNum']:
                            spwIds2.append(tuple([j, abs(spwInfo[i]['meanFreq']-spwInfo1[j]['meanFreq'])]))
                    if len(spwIds2) != 0:
                        spwIds2 = [j for j in sorted(spwIds2, key=lambda x:x[1])]
                        if iHaveSplitMyScienceSpw == True:
                            casaCmd = casaCmd + "phasemap["+str(spwIds3.index(i))+"] = "+str(spwIds3.index(spwIds2[0][0]))+"\n"
                        else:
                            casaCmd = casaCmd + "phasemap["+str(i)+"] = "+str(spwIds2[0][0])+"\n"
                    else:
                        sys.exit('ERROR: Could not pair spw.')

            casaCmd = casaCmd + "\nos.system('rm -rf %s.phase_offsets_inf') \n"%(msName1)
            casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "  caltable = '"+msName1+".phase_offsets_inf',\n"
            casaCmd = casaCmd + "  field = '"+str(bpassCalId)+"',\n"
            casaCmd = casaCmd + "  solint = 'inf',\n"
            casaCmd = casaCmd + "  refant = '"+refant+"',\n"
            casaCmd = casaCmd + "  gaintype = 'G',\n"
            casaCmd = casaCmd + "  calmode = 'p',\n"
            casaCmd = casaCmd + "  gaintable = ['"+bandpass+"', '"+msName1+".phase_pre_offsets_inf'],\n"
            casaCmd = casaCmd + "  interp = ['', 'linearPD'],\n"
            casaCmd = casaCmd + "  spwmap = [[], phasemap])\n\n"

            if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".phase_offsets_inf', msName='"+msName1+"', interactive=False) \n\n"

            phaseOffsetCalTableName.append(msName1+'.phase_offsets_inf')

###

        #if iHaveSplitMyScienceSpw == True: spwIds = range(len(spwIds))

        fluxCalId = self.getFieldsForSetjy(msName)

        #casaCmd = 'print "# Gain calibration."\n\n'
        #casaCmd = ''

        if len(fluxCalId) == 0:
            casaCmd = casaCmd + "os.system('rm -rf %s.phase_int') \n"%(msName1)
            casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "  caltable = '"+msName1+".phase_int',\n"
            casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
            casaCmd = casaCmd + "  solint = 'int',\n"
            casaCmd = casaCmd + "  refant = '"+refant+"',\n"
            casaCmd = casaCmd + "  gaintype = 'G',\n"
            casaCmd = casaCmd + "  calmode = 'p',\n"
            casaCmd = casaCmd + "  gaintable = '"+bandpass+"')\n\n"

            if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".phase_int', msName='"+msName1+"', interactive=False) \n\n"

            intentSources1 = intentSources['CALIBRATE_FLUX']

            if len(intentSources1['sourceid']) != 0:

#                 fluxCalSourceId = intentSources1['sourceid']
#                 if len(fluxCalSourceId) != 1: sys.exit("ERROR: There are more than one flux calibrator.")
#                 fluxCalSourceId = fluxCalSourceId[0]
#                 fluxCalSourceName = intentSources1['name'][0]
#                 fluxCalFieldIds = intentSources1['id']
# 
#                 sourceFluxes = self.getFluxesFromSourceTable(msName)

                sourceFluxes = self.getFluxesFromSourceTable(msName)

                fluxCalSourceId = intentSources1['sourceid']

                if len(fluxCalSourceId) > 1:
                    print "WARNING: THERE ARE MORE THAN ONE FLUX CALIBRATOR. I WILL PICK THE FIRST ONE. THIS MAY BE WRONG."
                    fluxCalSourceId = [j for j in fluxCalSourceId if j in sourceFluxes.keys()]

                if len(fluxCalSourceId) == 0: sys.exit("ERROR: There are no flux calibrator.")

                fluxCalSourceId = fluxCalSourceId[0]

                fluxCalSourceName = intentSources1['name'][intentSources1['sourceid'].index(fluxCalSourceId)]

                if len(intentSources1['sourceid']) > 1:
                    tb.open(msName+'/FIELD')
                    tb1 = tb.query('SOURCE_ID == '+str(fluxCalSourceId))
                    fluxCalFieldIds1 = tb1.rownumbers().tolist()
                    tb1.close()
                    tb.close()
                    fluxCalFieldIds = [j for j in fluxCalFieldIds1 if j in intentSources1['id']]
                else:
                    fluxCalFieldIds = intentSources1['id']

                if fluxCalSourceId in sourceFluxes:

                    if fluxCalSourceName != sourceFluxes[fluxCalSourceId]['sourceName']: sys.exit("ERROR: Source names do not match.")

                    fluxCalId = fluxCalFieldIds[:]

            if len(fluxCalId) != 0:

                if len(fluxCalId) > 1: casaCmd = casaCmd + "# Note: There are more than one flux calibrator in this dataset, I'm using the first one.\n\n"
                fluxCalId = fluxCalId[0]

                casaCmd = casaCmd + "os.system('rm -rf %s.ampli_inf') \n"%(msName1)
                casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".ampli_inf',\n"
                casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
                casaCmd = casaCmd + "  solint = 'inf',\n"
                casaCmd = casaCmd + "  refant = '"+refant+"',\n"
                casaCmd = casaCmd + "  gaintype = '"+gaintypeForAmp+"',\n"
                casaCmd = casaCmd + "  calmode = 'a',\n"
                casaCmd = casaCmd + "  gaintable = ['"+bandpass+"', '"+msName1+".phase_int'])\n\n"

                if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".ampli_inf', msName='"+msName1+"', interactive=False) \n\n"

                casaCmd = casaCmd + "os.system('rm -rf %s.flux_inf') \n"%(msName1)
                casaCmd = casaCmd + "os.system('rm -rf %s.fluxscale') \n"%(msName1)
                casaCmd = casaCmd + "mylogfile = casalog.logfile()\n"
                casaCmd = casaCmd + "casalog.setlogfile('"+msName1+".fluxscale')\n\n"
                casaCmd = casaCmd + "fluxscale(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".ampli_inf',\n"
                casaCmd = casaCmd + "  fluxtable = '"+msName1+".flux_inf',\n"
                casaCmd = casaCmd + "  reference = '"+str(fluxCalId)+"') # "+fieldNames[fluxCalId]+"\n\n"
                casaCmd = casaCmd + "casalog.setlogfile(mylogfile)\n\n"
                casaCmd = casaCmd + "if applyonly != True: es.fluxscale2(caltable = '"+msName1+".ampli_inf', removeOutliers=True, msName='"+msName+"', writeToFile=True, preavg=10000)\n\n"

            else:

                casaCmd = casaCmd + "os.system('rm -rf %s.flux_inf') \n"%(msName1)
                casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".flux_inf',\n"
                casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
                casaCmd = casaCmd + "  solint = 'inf',\n"
                casaCmd = casaCmd + "  refant = '"+refant+"',\n"
                casaCmd = casaCmd + "  gaintype = '"+gaintypeForAmp+"',\n"
                casaCmd = casaCmd + "  calmode = 'a',\n"
                casaCmd = casaCmd + "  gaintable = ['"+bandpass+"', '"+msName1+".phase_int'])\n\n"

                if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".flux_inf', msName='"+msName1+"', interactive=False) \n\n"

                #casaCmd = casaCmd + "mylogfile = casalog.logfile()\n"
                #casaCmd = casaCmd + "casalog.setlogfile('"+msName1+".fluxscale')\n\n"
                #casaCmd = casaCmd + "fluxscale(vis = '"+msName1+"',\n"
                #casaCmd = casaCmd + "  caltable = '"+msName1+".ampli_inf',\n"
                #casaCmd = casaCmd + "  fluxtable = '"+msName1+".flux_inf',\n"
                #casaCmd = casaCmd + "  reference = fluxCalId)\n\n"
                #casaCmd = casaCmd + "casalog.setlogfile(mylogfile)\n\n"

        else:

            if len(fluxCalId) > 1: casaCmd = casaCmd + "# Note: There are more than one Solar system object in this dataset, I'm using the first one as flux calibrator.\n\n"
            fluxCalId = fluxCalId[0]

            tb.open(msName+'/ANTENNA')
            antList = tb.getcol('NAME')
            tb.close()

            antList1 = self.getAntennasForFluxscale2(msName, fluxCalId=str(fluxCalId), refant=refant)

            if len(antList) == len(antList1):

                casaCmd = casaCmd + "os.system('rm -rf %s.phase_int') \n"%(msName1)
                casaCmd = casaCmd + "\ngaincal(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".phase_int',\n"
                casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
                casaCmd = casaCmd + "  solint = 'int',\n"
                casaCmd = casaCmd + "  refant = '"+refant+"',\n"
                casaCmd = casaCmd + "  gaintype = 'G',\n"
                casaCmd = casaCmd + "  calmode = 'p',\n"
                casaCmd = casaCmd + "  gaintable = '"+bandpass+"')\n\n"

                if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".phase_int', msName='"+msName1+"', interactive=False) \n\n"

                casaCmd = casaCmd + "os.system('rm -rf %s.ampli_inf') \n"%(msName1)
                casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".ampli_inf',\n"
                casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
                casaCmd = casaCmd + "  solint = 'inf',\n"
                casaCmd = casaCmd + "  refant = '"+refant+"',\n"
                casaCmd = casaCmd + "  gaintype = '"+gaintypeForAmp+"',\n"
                casaCmd = casaCmd + "  calmode = 'a',\n"
                casaCmd = casaCmd + "  gaintable = ['"+bandpass+"', '"+msName1+".phase_int'])\n\n"

                if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".ampli_inf', msName='"+msName1+"', interactive=False) \n\n"

                casaCmd = casaCmd + "os.system('rm -rf %s.flux_inf') \n"%(msName1)
                casaCmd = casaCmd + "os.system('rm -rf %s.fluxscale') \n"%(msName1)
                casaCmd = casaCmd + "mylogfile = casalog.logfile()\n"
                casaCmd = casaCmd + "casalog.setlogfile('"+msName1+".fluxscale')\n\n"
                casaCmd = casaCmd + "fluxscale(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".ampli_inf',\n"
                casaCmd = casaCmd + "  fluxtable = '"+msName1+".flux_inf',\n"
                casaCmd = casaCmd + "  reference = '"+str(fluxCalId)+"') # "+fieldNames[fluxCalId]+"\n\n"
                casaCmd = casaCmd + "casalog.setlogfile(mylogfile)\n\n"
                casaCmd = casaCmd + "if applyonly != True: es.fluxscale2(caltable = '"+msName1+".ampli_inf', removeOutliers=True, msName='"+msName+"', writeToFile=True, preavg=10000)\n\n"

            else:

                if sciFieldIds[0] != '':
                    phaseCal = self.getPhaseCal(msName)  # Added by CLB
                    phaseCalNames = []  # Added by CLB
                    phaseCalIds = []
                    for i in phaseCal:  # Added by CLB
                        phaseCalNames.append(phaseCal[i]['phaseCalName']) # Added by CLB
                        phaseCalIds.append(phaseCal[i]['phaseCalId'])

                if len(antList1) < 2:
                    print 'WARNING: THE SOLAR SYSTEM OBJECT SEEMS TO BE EXTREMELY RESOLVED'
                    print 'WARNING: I COULD NOT FIND A SUBSET OF ANTENNAS ON WHICH TO RUN GAINCAL'
                    print 'WARNING: YOU SHOULD LOOK AT THE DATA, AND THEN UPDATE THE SCRIPT'

                casaCmd += "# Note: the Solar system object used for flux calibration is highly resolved on some baselines.\n"
                casaCmd += "# Note: we will first determine the flux of the phase calibrator(s) on a subset of antennas.\n\n"

                if re.search('^3.', casadef.casa_version) == None:
                    casaCmd += "delmod"
                else:
                    casaCmd += "clearcal"

                if sciFieldIds[0] != '':
#                     casaCmd += "('%s',field='%s')\n\n" % (msName1, ",".join(map(str,list(np.unique(phaseCalNames))))) # Added by CLB
                    casaCmd += "('%s',field='%s')\n\n" % (msName1, ",".join(map(str,list(np.unique(phaseCalIds))))) # Added by CLB
                else:
#                     casaCmd += "('%s',field='%s')\n\n" % (msName1, ",".join(map(str,list(np.unique(calFieldNames)))))
                    casaCmd += "('%s',field='%s')\n\n" % (msName1, ",".join(map(str,list(np.unique(calFieldIds)))))

                numAntList1 = len(antList1)
                antList1 = ','.join(antList1)

                casaCmd = casaCmd + "os.system('rm -rf %s.phase_short_int') \n"%(msName1)
                casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".phase_short_int',\n"
                casaCmd = casaCmd + "  field = '"+str(fluxCalId)+"', # "+fieldNames[fluxCalId]+"\n"
                casaCmd = casaCmd + "  selectdata = T,\n"
                casaCmd = casaCmd + "  antenna = '"+str(antList1)+"&',\n"
                casaCmd = casaCmd + "  solint = 'int',\n"
                casaCmd = casaCmd + "  refant = '"+refant+"',\n"

                if numAntList1 < 5:
                    casaCmd = casaCmd + "  minblperant = "+str(numAntList1-1)+",\n"
                    casaCmd = casaCmd + "  minsnr = 2.0,\n"

                casaCmd = casaCmd + "  gaintype = 'G',\n"
                casaCmd = casaCmd + "  calmode = 'p',\n"
                casaCmd = casaCmd + "  gaintable = '"+bandpass+"')\n\n"

###

                calFieldIds1 = [str(i) for i in calFieldIds if i != fluxCalId]
                calFieldIds1 = ','.join(calFieldIds1)

                calFieldNames = [fieldNames[i] for i in calFieldIds if i != fluxCalId]
                calFieldNames = ','.join(calFieldNames)

                casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".phase_short_int',\n"
                casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
                casaCmd = casaCmd + "  selectdata = T,\n"
                casaCmd = casaCmd + "  solint = 'int',\n"
                casaCmd = casaCmd + "  refant = '"+refant+"',\n"

                if numAntList1 < 5:
                    casaCmd = casaCmd + "  minblperant = "+str(numAntList1-1)+",\n"
                    casaCmd = casaCmd + "  minsnr = 2.0,\n"

                casaCmd = casaCmd + "  gaintype = 'G',\n"
                casaCmd = casaCmd + "  calmode = 'p',\n"
                casaCmd = casaCmd + "  append = T,\n"
                casaCmd = casaCmd + "  gaintable = '"+bandpass+"')\n\n"

###

                if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".phase_short_int', msName='"+msName1+"', interactive=False) \n\n"

                calFieldIds1 = [str(i) for i in calFieldIds]
                calFieldIds1 = ','.join(calFieldIds1)

                calFieldNames = [fieldNames[i] for i in calFieldIds]
                calFieldNames = ','.join(calFieldNames)

                casaCmd = casaCmd + "os.system('rm -rf %s.ampli_short_inf') \n"%(msName1)
                casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".ampli_short_inf',\n"
                casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
                casaCmd = casaCmd + "  selectdata = T,\n"
#                casaCmd = casaCmd + "  antenna = '"+str(antList1)+"&',\n"
                casaCmd = casaCmd + "  solint = 'inf',\n"
                casaCmd = casaCmd + "  refant = '"+refant+"',\n"

                if numAntList1 < 5:
                    casaCmd = casaCmd + "  minblperant = "+str(numAntList1-1)+",\n"
                    casaCmd = casaCmd + "  minsnr = 2.0,\n"

                casaCmd = casaCmd + "  gaintype = '"+gaintypeForAmp+"',\n"
                casaCmd = casaCmd + "  calmode = 'a',\n"
                casaCmd = casaCmd + "  gaintable = ['"+bandpass+"', '"+msName1+".phase_short_int'])\n\n"

                if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".ampli_short_inf', msName='"+msName1+"', interactive=False) \n\n"

                casaCmd = casaCmd + "os.system('rm -rf %s.flux_short_inf') \n"%(msName1)
                casaCmd = casaCmd + "os.system('rm -rf %s.fluxscale') \n"%(msName1)
                casaCmd = casaCmd + "mylogfile = casalog.logfile()\n"
                casaCmd = casaCmd + "casalog.setlogfile('"+msName1+".fluxscale')\n\n"
                casaCmd = casaCmd + "fluxscale(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  caltable = '"+msName1+".ampli_short_inf',\n"
                casaCmd = casaCmd + "  fluxtable = '"+msName1+".flux_short_inf',\n"
                casaCmd = casaCmd + "  reference = '"+str(fluxCalId)+"') # "+fieldNames[fluxCalId]+"\n\n"
                casaCmd = casaCmd + "casalog.setlogfile(mylogfile)\n\n"
                casaCmd = casaCmd + "if applyonly != True: es.fluxscale2(caltable = '"+msName1+".ampli_short_inf', removeOutliers=True, msName='"+msName+"', writeToFile=True, preavg=10000)\n\n"

                if sciFieldIds[0] != '':

                    casaCmd = casaCmd + "f = open('"+msName1+".fluxscale')\n"
                    casaCmd = casaCmd + "fc = f.readlines()\n"
                    casaCmd = casaCmd + "f.close()\n\n"

                    #phaSourceId = intentSources['CALIBRATE_PHASE']['sourceid']
                    #ampSourceId = intentSources['CALIBRATE_AMPLI']['sourceid']
                    #phaOnlySourceId = [i for i in phaSourceId if i not in ampSourceId]
                    #phaOnlySourceId1 = dict.fromkeys(phaOnlySourceId).keys()
                    #if len(phaOnlySourceId1) != 1: casaCmd = casaCmd + "# Warning: there are more than one phase calibrator, I'm picking the one with the highest id. Please check this is right.\n\n"
                    #phaOnlySourceId = max(phaOnlySourceId1)

                    phaseCal = self.getPhaseCal(msName)
                    phaseCalNames = []
                    for i in phaseCal:
                        phaseCalNames.append(phaseCal[i]['phaseCalName'])

                    casaCmd = casaCmd + "for phaseCalName in "+str(list(set(phaseCalNames)))+":\n"
                    casaCmd = casaCmd + "  for i in range(len(fc)):\n"
                    #casaCmd = casaCmd + "    if re.search('Flux density for '+phaseCalName+' in SpW=[0-9]+ is: [0-9]+\.[0-9]+', fc[i]) != None:\n"
                    casaCmd = casaCmd + "    if fc[i].find('Flux density for '+phaseCalName) != -1 and re.search('in SpW=[0-9]+(?: \(.*?\))? is: [0-9]+\.[0-9]+', fc[i], re.DOTALL|re.IGNORECASE) != None:\n"
                    #casaCmd = casaCmd + "      line = (re.findall('in SpW=[0-9]+ is: [0-9]+\.[0-9]+', fc[i]))[0]\n"
                    casaCmd = casaCmd + "      line = (re.search('in SpW=[0-9]+(?: \(.*?\))? is: [0-9]+\.[0-9]+', fc[i], re.DOTALL|re.IGNORECASE)).group(0)\n"
                    casaCmd = casaCmd + "      spwId = (line.split('='))[1].split()[0]\n"
                    casaCmd = casaCmd + "      flux = float((line.split(':'))[1].split()[0])\n"
                    casaCmd = casaCmd + "      setjy(vis = '"+msName1+"',\n"
                    casaCmd = casaCmd + "        field = phaseCalName.replace(';','*;').split(';')[0],\n"
                    casaCmd = casaCmd + "        spw = spwId,\n"
                    if (casadef.casa_version >= '4.2.0'): casaCmd = casaCmd + "        standard = 'manual',\n"
                    casaCmd = casaCmd + "        fluxdensity = [flux,0,0,0])\n\n"


                    casaCmd = casaCmd + "os.system('rm -rf %s.phase_int') \n"%(msName1)
                    casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
                    casaCmd = casaCmd + "  caltable = '"+msName1+".phase_int',\n"
                    casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
                    casaCmd = casaCmd + "  solint = 'int',\n"
                    casaCmd = casaCmd + "  refant = '"+refant+"',\n"
                    casaCmd = casaCmd + "  gaintype = 'G',\n"
                    casaCmd = casaCmd + "  calmode = 'p',\n"
                    casaCmd = casaCmd + "  gaintable = '"+bandpass+"')\n\n"

                    if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".phase_int', msName='"+msName1+"', interactive=False) \n\n"

                    casaCmd = casaCmd + "os.system('rm -rf %s.flux_inf') \n"%(msName1)
                    casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
                    casaCmd = casaCmd + "  caltable = '"+msName1+".flux_inf',\n"
                    casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
                    casaCmd = casaCmd + "  solint = 'inf',\n"
                    casaCmd = casaCmd + "  refant = '"+refant+"',\n"
                    casaCmd = casaCmd + "  gaintype = '"+gaintypeForAmp+"',\n"
                    casaCmd = casaCmd + "  calmode = 'a',\n"
                    casaCmd = casaCmd + "  gaintable = ['"+bandpass+"', '"+msName1+".phase_int'])\n\n"

                    if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".flux_inf', msName='"+msName1+"', interactive=False) \n\n"

                    #casaCmd = casaCmd + "mylogfile = casalog.logfile()\n"
                    #casaCmd = casaCmd + "casalog.setlogfile('"+msName1+".fluxscale')\n\n"
                    #casaCmd = casaCmd + "fluxscale(vis = '"+msName1+"',\n"
                    #casaCmd = casaCmd + "  caltable = '"+msName1+".ampli_inf',\n"
                    #casaCmd = casaCmd + "  fluxtable = '"+msName1+".flux_inf',\n"
                    #casaCmd = casaCmd + "  reference = '"+str(phaOnlySourceId)+"') # "+fieldNames[phaOnlySourceId]+"\n\n"
                    #casaCmd = casaCmd + "casalog.setlogfile(mylogfile)\n\n"

        if sciFieldIds[0] != '':
            casaCmd = casaCmd + "os.system('rm -rf %s.phase_inf') \n"%(msName1)
            casaCmd = casaCmd + "gaincal(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "  caltable = '"+msName1+".phase_inf',\n"
            casaCmd = casaCmd + "  field = '"+calFieldIds1+"', # "+calFieldNames+"\n"
            casaCmd = casaCmd + "  solint = 'inf',\n"
            casaCmd = casaCmd + "  refant = '"+refant+"',\n"
            casaCmd = casaCmd + "  gaintype = 'G',\n"
            casaCmd = casaCmd + "  calmode = 'p',\n"
            casaCmd = casaCmd + "  gaintable = '"+bandpass+"')\n\n"

            if doplot == True: casaCmd = casaCmd + "if applyonly != True: es.checkCalTable('"+msName1+".phase_inf', msName='"+msName1+"', interactive=False) \n"

        return casaCmd

    def getRefAntenna(self, msName, minEl=30, percentile=85):

        tb.open(msName+'/ANTENNA')
        antList = tb.getcol('NAME').tolist()
        antDiam = tb.getcol('DISH_DIAMETER').tolist()
        tb.close()

        baselineLen = getBaselineLengths(msName)

        antInfo = {}

        for i in antList:
            antInfo[i] = {}
            minLen = 100000.
            maxLen = 0.
            otherAntOnMinLen = ''
            for j in baselineLen:
                if i in j[0]:
                    if j[1] < minLen:
                        minLen = j[1]
                        antList1 = j[0].split('-')
                        antList1.pop(antList1.index(i))
                        otherAntOnMinLen = antList1[0]
                    if j[1] > maxLen: maxLen = j[1]
            antInfo[i]['otherAntOnMinLen'] = otherAntOnMinLen
            antInfo[i]['minLen'] = minLen
            antInfo[i]['maxLen'] = maxLen

        minLen = []
        for i in antInfo: minLen.append(antInfo[i]['minLen'])
        ij = int(ceil(percentile*len(minLen)/100.)-1)
        minLen1 = sorted(minLen)[ij]

        refAnt = ''
        maxLen = 100000.

        for i in antInfo:
            #if re.search('CM[0-9]{2}', i) != None: continue
            diam1 = []
            diam1.append(antDiam[antList.index(i)])
            diam1.append(antDiam[antList.index(antInfo[i]['otherAntOnMinLen'])])
            if antInfo[i]['minLen'] > minLen1: continue
            if antInfo[i]['minLen'] < max(diam1) / sin(radians(minEl)): continue
            if antInfo[i]['maxLen'] < maxLen:
                refAnt = i
                maxLen = antInfo[i]['maxLen']

        return refAnt

    def applyBandpassAndGainCalTables(self, msName, msName1='', bandpass='', phaseForCal='', phaseForSci='', flux='', phaseOffsetCalTableName='', useForLoop=True):

        #casaCmd = 'print "# Application of the bandpass and gain cal tables."\n\n'
        casaCmd = ''

        if bandpass == '' or phaseForCal == '' or phaseForSci == '' or flux == '': sys.exit('ERROR: Missing table(s).')
        if msName1 == '': msName1 = msName

        tb.open(msName+'/FIELD')
        fieldNames = tb.getcol('NAME')
        tb.close()

        fieldIds = range(len(fieldNames))

        intentSources = self.getIntentsAndSourceNames(msName)
        sciFieldIds = intentSources['OBSERVE_TARGET']['id']
        if sciFieldIds[0] == '': sys.exit('ERROR: There seems to be no science field.')

        calFieldIds = [i for i in fieldIds if i not in sciFieldIds]
        if len(calFieldIds) == '': sys.exit('ERROR: There seems to be no calibrator field.')

        if (casadef.casa_version >= '4.1.0'):

            msmd.open(msName)
            hasdata = []
            for i in calFieldIds:
                calFieldIntents = msmd.intentsforfield(i)
                hasdata1 = 0
                for j in calFieldIntents:
                    if re.search('^CALIBRATE_(POINTING|ATMOSPHERE|WVR)', j) == None:
                        hasdata1 = 1
                        break
                hasdata.append(hasdata1)
            msmd.close()

            calFieldIds = [calFieldIds[i] for i in range(len(calFieldIds)) if hasdata[i] == 1]

        phaseCal = self.getPhaseCal(msName)
        phaseCalFieldIds = []
        for j in phaseCal:
            phaseCalFieldIds.append(phaseCal[j]['phaseCalId'])
        phaseCalFieldIds = sorted(dict.fromkeys(phaseCalFieldIds).keys())
        calFieldIds = [i for i in calFieldIds if i not in phaseCalFieldIds]
        calFieldIds1 = [str(i) for i in calFieldIds]

        calFieldNames = [fieldNames[i] for i in calFieldIds]
        calFieldNames = ','.join(calFieldNames)

        gainTable = []
        gainTable.append(bandpass)
        gainTable.append(phaseForCal)
        gainTable.append(flux)

        if useForLoop == True:
            casaCmd = casaCmd + "for i in "+str(calFieldIds1)+": # "+calFieldNames+"\n"
            casaCmd = casaCmd + "  applycal(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "    field = i,\n"
            casaCmd = casaCmd + "    gaintable = "+str(gainTable)+",\n"
            casaCmd = casaCmd + "    gainfield = ['', i, i],\n"
            if re.search('^3.3', casadef.casa_version) == None:
                casaCmd = casaCmd + "    interp = 'linear,linear',\n"
            else:
                casaCmd = casaCmd + "    interp = 'linear',\n"
            casaCmd = casaCmd + "    calwt = F,\n"
            casaCmd = casaCmd + "    flagbackup = F)\n"
        else:
            for i in calFieldIds:
                casaCmd = casaCmd + "applycal(vis = '"+msName1+"',\n"
                casaCmd = casaCmd + "  field = '"+str(i)+"', # "+fieldNames[i]+"\n"
                casaCmd = casaCmd + "  gaintable = "+str(gainTable)+",\n"
                casaCmd = casaCmd + "  gainfield = ['', '"+str(i)+"', '"+str(i)+"'],\n"
                if re.search('^3.3', casadef.casa_version) == None:
                    casaCmd = casaCmd + "  interp = 'linear,linear',\n"
                else:
                    casaCmd = casaCmd + "  interp = 'linear',\n"
                casaCmd = casaCmd + "  calwt = F,\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"

        gainTable = []
        gainTable.append(bandpass)
        gainTable.append(phaseForSci)
        gainTable.append(flux)

        if re.search('^3.3', casadef.casa_version) == None:
            gainTableInterp = "'linear,linear'"
        else:
            gainTableInterp = "'linear'"

        gainTableSpwMap = ''

        if len(phaseOffsetCalTableName) != 0:
            gainTable.append(phaseOffsetCalTableName[0])
            gainTableInterp = "['', 'linearPD', '', '']"
            gainTableSpwMap = "[[], phasemap, [], []]"

        for i in phaseCalFieldIds:

            sciFieldIds = []
            sciFieldNames = []
            for j in phaseCal:
                if phaseCal[j]['phaseCalId'] == i:
                    sciFieldIds1 = phaseCal[j]['sciFieldIds']
                    for k in sciFieldIds1: sciFieldIds.append(k)
                    sciFieldNames.append(j)
            sciFieldIds = sorted(sciFieldIds)
            sciFieldNames = ','.join(sciFieldNames)

            if len(sciFieldIds) > 1:
                j0 = 0
                sciFieldIds1 = str(sciFieldIds[j0])
                for j in range(len(sciFieldIds)-1):
                    if sciFieldIds[j+1] == sciFieldIds[j]+1: continue
                    sciFieldIds1 = sciFieldIds1 + '~' + str(sciFieldIds[j])
                    j0 = j+1
                    sciFieldIds1 = sciFieldIds1 + ',' + str(sciFieldIds[j0])
                sciFieldIds1 = sciFieldIds1 + '~' + str(sciFieldIds[j+1])
            else:
                sciFieldIds1 = str(sciFieldIds[0])

            casaCmd = casaCmd + "\napplycal(vis = '"+msName1+"',\n"
            casaCmd = casaCmd + "  field = '"+str(i)+","+sciFieldIds1+"', # "+sciFieldNames+"\n"
            casaCmd = casaCmd + "  gaintable = "+str(gainTable)+",\n"
            if len(phaseOffsetCalTableName) != 0:
                casaCmd = casaCmd + "  gainfield = ['', '"+str(i)+"', '"+str(i)+"', ''], # "+fieldNames[i]+"\n"
            else:
                casaCmd = casaCmd + "  gainfield = ['', '"+str(i)+"', '"+str(i)+"'], # "+fieldNames[i]+"\n"
            casaCmd = casaCmd + "  interp = "+gainTableInterp+",\n"
            if gainTableSpwMap != '': casaCmd = casaCmd + "  spwmap = "+gainTableSpwMap+",\n"
            casaCmd = casaCmd + "  calwt = F,\n"
            casaCmd = casaCmd + "  flagbackup = F)\n"

        return casaCmd

    def getPhaseCal(self, msName):
        print "Running ValueMapping"
        vm = ValueMapping(msName)
        print "Completed ValueMapping"
        scanList = vm.uniqueScans

        phaseOnlyScanList = []
        for i in scanList:
            scanIntents = vm.getIntentsForScan(i)
            isPhaseOnlyScan = 1
            for j in scanIntents:
                scanIntent = (j.split('#'))[0]
                if re.search('^CALIBRATE_((PHASE)|(WVR))$', scanIntent) == None:
                    isPhaseOnlyScan = 0
                    break
            if isPhaseOnlyScan == 1: phaseOnlyScanList.append(i)

        if len(phaseOnlyScanList) != 0:

            phaseCal = {}

            for i in phaseOnlyScanList:
                scanField = vm.getFieldsForScan(i)
                if len(scanField) != 1: sys.exit('ERROR: Unexpected number of fields.')
                scanField = scanField[0]
                if scanField not in phaseCal:
                    phaseCal[scanField] = {}
                    phaseCal[scanField]['scans'] = []
                phaseCal[scanField]['scans'].append(i)

            for i in phaseCal:
                scanList = range(min(phaseCal[i]['scans']), max(phaseCal[i]['scans'])+1)
                scanList = [j for j in scanList if j not in phaseCal[i]['scans']]
                fieldList = []
                for j in scanList:
                    fieldList1 = vm.getFieldsForScan(j)
                    for k in fieldList1: fieldList.append(k)
                fieldList = sorted(dict.fromkeys(fieldList).keys())
                phaseCal[i]['fieldNames'] = fieldList

            tb.open(msName+'/FIELD')
            fieldNames = tb.getcol('NAME')
            sourceIds = tb.getcol('SOURCE_ID')
            tb.close()

            intentSources = self.getIntentsAndSourceNames(msName)
            sciFieldIds = intentSources['OBSERVE_TARGET']['id']
            if sciFieldIds[0] == '': sys.exit('ERROR: There seems to be no science field.')
            sciFieldNames = intentSources['OBSERVE_TARGET']['name']

            phaseCal1 = {}

            for i in sciFieldNames:
                phaseCal1[i] = {}
                sciFieldIds1 = np.where(fieldNames == i)[0].tolist()
                sciFieldIds1 = [j for j in sciFieldIds1 if j in sciFieldIds]
                sciSourceIds1 = [sourceIds[j] for j in sciFieldIds1]
                phaseCal1[i]['sciFieldIds'] = sciFieldIds1
                phaseCal1[i]['sciSourceIds'] = sciSourceIds1
                phaseCalNames = []
                phaseCalFirstScan = []
                for j in phaseCal:
                    if i in phaseCal[j]['fieldNames']:
                        phaseCalNames.append(j)
                        phaseCalFirstScan.append(min(phaseCal[j]['scans']))
                if len(phaseCalNames) == 0 or len(phaseCalFirstScan) == 0:
                    print "WARNING: I couldn't find reliably a phase cal for field "+i+" so I picked the first one in the list, note this may be wrong."
                    j = phaseCal.keys()[0]
                    phaseCalNames.append(j)
                    phaseCalFirstScan.append(min(phaseCal[j]['scans']))
                phaseCal1[i]['phaseCalName'] = phaseCalNames[phaseCalFirstScan.index(min(phaseCalFirstScan))]
                #phaseCalId = np.where(fieldNames == phaseCal1[i]['phaseCalName'])[0].tolist()
                #phaseCalId = [j for j in phaseCalId if j in intentSources['CALIBRATE_PHASE']['id']]
                phaseCalId = []
                for j in vm.getFieldIdsForFieldName(phaseCal1[i]['phaseCalName']):
                    if min(phaseCalFirstScan) in vm.getScansForFieldID(j): phaseCalId.append(j)
                phaseCalId = sorted(dict.fromkeys(phaseCalId).keys())
                if len(phaseCalId) != 1: sys.exit('ERROR: Possible confusion between field ids.')
                phaseCal1[i]['phaseCalId'] = phaseCalId[0]
                phaseCal1[i]['allPhaseCalNames'] = phaseCalNames

            return phaseCal1

    def doFluxCalibration(self, msNames, fluxFile='allFluxes.txt', refant=''):

        if type(msNames).__name__ == 'str': msNames = [msNames]

        if os.path.exists(fluxFile) == False: sys.exit('ERROR: Flux file '+fluxFile+' does not seem to exist in the current directory.')

        casaCmd = 'print "# Flux calibration of the data."\n\n'

#         for i in range(len(msNames)): casaCmd = casaCmd + self.split2(msNames[i], outMsName=msNames[i]+'.cal')

        f = open(fluxFile, 'r')
        fc = f.readlines()
        f.close()

        msName = []
        fieldName = []
        spwId = []
        fluxVal = []

        for line in fc:

            if len(line) == 0 or line.isspace() == True or line.lstrip()[0] == '#': continue

            casaCmd = casaCmd + '# ' + line

            line = line.split('"')
            fieldName.append(line[1])
            line = line[2].split()
            spwId.append(line[0])
            fluxVal.append(line[3])
            msName.append(line[5])

        msName = np.array(msName)
        fieldName = np.array(fieldName)

        casaCmd = casaCmd + '\n'

        for i in range(len(msName)):

            if msName[i] not in msNames: sys.exit('ERROR: Missing dataset.')

            casaCmd = casaCmd + "setjy(vis = '"+msName[i]+"',\n"
            casaCmd = casaCmd + "  field = '"+fieldName[i]+"',\n"
            casaCmd = casaCmd + "  spw = '"+spwId[i]+"',\n"
            if (casadef.casa_version >= '4.2.0'): casaCmd = casaCmd + "  standard = 'manual',\n"
            casaCmd = casaCmd + "  fluxdensity = ["+fluxVal[i]+", 0, 0, 0])\n\n"

        for i in range(len(msNames)):

            calFieldNames = np.unique(fieldName[np.where(msName == msNames[i])])
            calFieldNames = ','.join(calFieldNames)

            #myRefAnt = self.getRefAntenna(msNames[i])
            myRefAnt = refant
            if myRefAnt == '': myRefAnt = self.getRefAntenna(msNames[i])
            casaCmd = casaCmd + "os.system('rm -rf %s.ampli_inf') \n"%(msNames[i])
            casaCmd = casaCmd + "gaincal(vis = '"+msNames[i]+"',\n"
            casaCmd = casaCmd + "  caltable = '"+msNames[i]+".ampli_inf',\n"
            casaCmd = casaCmd + "  field = '"+calFieldNames+"',\n"
            casaCmd = casaCmd + "  solint = 'inf',\n"
            casaCmd = casaCmd + "  combine = 'scan',\n"
            casaCmd = casaCmd + "  refant = '"+myRefAnt+"',\n"
            casaCmd = casaCmd + "  gaintype = 'T',\n"
            casaCmd = casaCmd + "  calmode = 'a')\n\n"

            phaseCal = self.getPhaseCal(msNames[i])

            for sciFieldName in phaseCal.keys():

                sciFieldIds = phaseCal[sciFieldName]['sciFieldIds']

                if len(sciFieldIds) > 1:
                    j0 = 0
                    sciFieldIds1 = str(sciFieldIds[j0])
                    for j in range(len(sciFieldIds)-1):
                        if sciFieldIds[j+1] == sciFieldIds[j]+1: continue
                        sciFieldIds1 = sciFieldIds1 + '~' + str(sciFieldIds[j])
                        j0 = j+1
                        sciFieldIds1 = sciFieldIds1 + ',' + str(sciFieldIds[j0])
                    sciFieldIds1 = sciFieldIds1 + '~' + str(sciFieldIds[j+1])
                else:
                    sciFieldIds1 = str(sciFieldIds[0])

                casaCmd = casaCmd + "applycal(vis = '"+msNames[i]+"',\n"
                casaCmd = casaCmd + "  field = '"+str(phaseCal[sciFieldName]['phaseCalId'])+","+sciFieldIds1+"', # "+phaseCal[sciFieldName]['phaseCalName']+","+sciFieldName+"\n"
                casaCmd = casaCmd + "  gaintable = '"+msNames[i]+".ampli_inf',\n"
                casaCmd = casaCmd + "  gainfield = '"+str(phaseCal[sciFieldName]['phaseCalId'])+"', # "+phaseCal[sciFieldName]['phaseCalName']+"\n"
                casaCmd = casaCmd + "  calwt = F,\n"
                casaCmd = casaCmd + "  flagbackup = F)\n\n"

        if len(msNames) > 1:
            casaCmd = casaCmd + 'print "# Concatenating the data."\n\n'
            casaCmd = casaCmd + "concat(vis = "+str([i for i in msNames])+",\n"
            casaCmd = casaCmd + "  concatvis = 'calibrated.ms')\n\n"

        return casaCmd

    def generateFluxFile(self, msNames, outfile='allFluxes.txt'):

        if type(msNames).__name__ == 'str': msNames = [msNames]

        msNames = sorted(msNames)

        spwInfo = self.getSpwInfo(msNames[0])
        spwIds = sorted(spwInfo.keys())

        vm = ValueMapping(msNames[0])
        spwMeanFreq = []
        for i in spwIds: spwMeanFreq.append(vm.spwInfo[i]['meanFreq'] / 1.e9)

        fluxVal = {}

        for i in range(len(msNames)):

            spwInfo = self.getSpwInfo(msNames[i])
            if sorted(spwInfo.keys()) != spwIds: sys.exit('ERROR: The number of spw ids is not the same in all datasets.')

            vm = ValueMapping(msNames[i])
            for j in range(len(spwIds)):
                if vm.spwInfo[spwIds[j]]['meanFreq'] / 1.e9 != spwMeanFreq[j]: print 'WARNING: The mean frequency of spw '+str(spwIds[j])+' of dataset '+msNames[i]+' differs from that of the first dataset.'

            if os.path.exists(msNames[i]+'.fluxscale') != True:
                print 'WARNING: Could not find a .fluxscale file associated to '+msNames[i]+'. Looking for any .fluxscale file.'
                msNameBase = re.findall('^uid___[0-9a-z]+_[0-9a-z]+_[0-9a-z]+', msNames[i], re.IGNORECASE)
                if len(msNameBase) != 1:
                    print 'WARNING: I failed.'
                    continue
                msNameBase = msNameBase[0]
                fluxscaleFilename = glob.glob('*.fluxscale')
                if len(fluxscaleFilename) == 0:
                    print 'WARNING: I failed.'
                    continue
                found = 0
                for j in range(len(fluxscaleFilename)):
                    if re.search(msNameBase, fluxscaleFilename[j]) != None:
                        fluxscaleFilename = fluxscaleFilename[j]
                        print 'Found '+fluxscaleFilename
                        found = 1
                        break
                if found == 0:
                    print 'WARNING: I failed.'
                    continue
            else:
                fluxscaleFilename = msNames[i]+'.fluxscale'

            f = open(fluxscaleFilename, 'r')
            fc = f.readlines()
            f.close()

            for j in range(len(fc)):
                if re.search('Flux density for .+ in SpW=[0-9]+(?: \(.*?\))? is: [0-9]+\.[0-9]+ \+/- [0-9]+\.[0-9]+', fc[j], re.DOTALL|re.IGNORECASE) != None:
                    line = (re.findall('Flux density for .+ in SpW=[0-9]+(?: \(.*?\))? is: [0-9]+\.[0-9]+ \+/- [0-9]+\.[0-9]+', fc[j], re.DOTALL|re.IGNORECASE))[0]
                    fieldName = (re.findall('for .+ in', line, re.IGNORECASE))[0]
                    fieldName = fieldName[4:len(fieldName)-3]
                    spwId = (re.findall('in SpW=[0-9]+', line, re.IGNORECASE))[0]
                    spwId = int((spwId.split('='))[1])
                    flux = (re.findall('is: [0-9]+\.[0-9]+ \+/- [0-9]+\.[0-9]+', line, re.IGNORECASE))[0]
                    flux1 = float(flux.split()[1])
                    error1 = float(flux.split()[3])
                    if fieldName not in fluxVal: fluxVal[fieldName] = {}
                    if spwId not in fluxVal[fieldName]:
                        fluxVal[fieldName][spwId] = {}
                        fluxVal[fieldName][spwId]['flux'] = []
                        fluxVal[fieldName][spwId]['error'] = []
                        fluxVal[fieldName][spwId]['msName'] = []
                    fluxVal[fieldName][spwId]['flux'].append(flux1)
                    fluxVal[fieldName][spwId]['error'].append(error1)
                    fluxVal[fieldName][spwId]['msName'].append(msNames[i])

        #if len(fluxVal) == 0: sys.exit('ERROR: No fluxscale file found.')

        if len(fluxVal) != 0:
            for fieldName in fluxVal:
                for spwId in fluxVal[fieldName]:
                    sum1 = 0.
                    sum2 = 0.
                    for i in range(len(fluxVal[fieldName][spwId]['flux'])):
                        sum1 = sum1 + fluxVal[fieldName][spwId]['flux'][i] / fluxVal[fieldName][spwId]['error'][i]**2
                        sum2 = sum2 + 1. / fluxVal[fieldName][spwId]['error'][i]**2
                    meanFlux = sum1 / sum2
                    #meanFlux = np.mean(fluxVal[fieldName][spwId]['flux'])
                    fluxVal[fieldName][spwId]['meanFlux'] = meanFlux

        obsTime = []
        calFieldNames = []

        for msName in msNames:

            tb.open(msName+'/OBSERVATION')
            obsTimeRange = tb.getcol('TIME_RANGE')
            tb.close()

            obsTime1 = (obsTimeRange[0]+obsTimeRange[1])/2.0
            obsTime1 = ((obsTime1/86400.0)+2400000.5-2440587.5)*86400.0
            obsTime1 = timeUtilities.strftime('%Y-%m-%dT%H:%M:%S', timeUtilities.gmtime(obsTime1))
            obsTime.append(obsTime1)

#            intentSources = self.getIntentsAndSourceNames(msName)
#            bpassCalFieldName = intentSources['CALIBRATE_BANDPASS']['name']

            phaseCal = self.getPhaseCal(msName)
            phaseCalFieldNames = []
            for i in phaseCal.keys(): phaseCalFieldNames.append(phaseCal[i]['allPhaseCalNames'])

            calFieldNames1 = []
#            for i in bpassCalFieldName: calFieldNames1.append(i)
            for i in phaseCalFieldNames:
                for j in i: calFieldNames1.append(j)
            calFieldNames1 = sorted(dict.fromkeys(calFieldNames1).keys())
            calFieldNames.append(calFieldNames1)

        calFieldNames2 = []
        for i in calFieldNames:
            for j in i: calFieldNames2.append(j)
        calFieldNames2 = sorted(dict.fromkeys(calFieldNames2).keys())

        f1 = open(outfile, 'w')

        for fieldName in calFieldNames2:

            print >> f1, ''

            for spwId in spwIds:
                for msName in msNames:

                    fieldName1 = '"'+fieldName+'"'
                    line = '%50s ' %fieldName1 + '%5d ' %spwId + '%10.2f ' %spwMeanFreq[spwIds.index(spwId)]

                    found = 0
                    if fieldName in fluxVal:
                        if spwId in fluxVal[fieldName]:
                            if msName in fluxVal[fieldName][spwId]['msName']:
                                k = fluxVal[fieldName][spwId]['msName'].index(msName)
                                line = line + '%12.5f ' %fluxVal[fieldName][spwId]['flux'][k]
                                found = 1
                    if found == 0: line = line + '           -'

                    found = 0
                    if fieldName in fluxVal:
                        if spwId in fluxVal[fieldName]:
                            line = line + '%12.5f ' %fluxVal[fieldName][spwId]['meanFlux']
                            found = 1
                    if found == 0: line = line + '           -'

                    k = msNames.index(msName)
                    line = line + '%25s ' %obsTime[k] + ' %40s' %msName

                    print >> f1, line

        f1.close()

    def split2(self, msName, msName1='', outMsName='', splitMyScienceSpw=False, timebin=0., iHaveSplitMyScienceSpw=False):

        #casaCmd = 'print "# Splitting the data."\n\n'
        casaCmd = ''

        if msName1 == '': msName1 = msName
        if outMsName == '': outMsName = msName1+'.split'

        spwInfo = self.getSpwInfo(msName, intent='OBSERVE_TARGET|CALIBRATE_BANDPASS')

        spwIds = sorted(spwInfo.keys())
        if iHaveSplitMyScienceSpw == True: spwIds = range(len(spwIds))
        spwIds = ['%d' %i for i in spwIds]
        spwIds = ','.join(spwIds)

        numChans = []
        for i in sorted(spwInfo.keys()): numChans.append(spwInfo[i]['numChans'])
        if max(numChans) <= 256 and timebin != 0: casaCmd = casaCmd + "# Important note: the correlator mode for this dataset was TDM, you may want not to do any time averaging.\n\n"

        casaCmd = casaCmd + "os.system('rm -rf %s') \n"%(outMsName)
        casaCmd = casaCmd + "split(vis = '"+msName1+"',\n"
        casaCmd = casaCmd + "  outputvis = '"+outMsName+"',\n"
        casaCmd = casaCmd + "  datacolumn = 'corrected',\n"
        if splitMyScienceSpw == True: casaCmd = casaCmd + "  spw = '"+spwIds+"',\n"
        if timebin != 0.: casaCmd = casaCmd + "  timebin = '"+str(timebin)+"s',\n"
        casaCmd = casaCmd + "  keepflags = T)\n\n"

        return casaCmd

    def runCleanOnSource(self, msName, sourceId='', searchForLines=True, chanWid=1, angScale=0, iHaveSplitMyScienceSpw=False):

        import bisect
        import itertools
#        import matplotlib.pyplot as plt

        optimumImsize = [216, 256, 360, 432, 640, 800, 1000, 1296, 1600, 2048]

        casaCmd = 'print "# Running clean."\n\n'

        tb.open(msName+'/FIELD')
        sourceIds = tb.getcol('SOURCE_ID')
        fieldNames = tb.getcol('NAME')
        tb.close()

        if sourceId == '':
            casaCmd = casaCmd + '# You have not specified a source Id, I will assume you want to clean the science target(s).\n\n'
            intentSources = self.getIntentsAndSourceNames(msName)
            sourceId = sorted(dict.fromkeys(intentSources['OBSERVE_TARGET']['sourceid']).keys())
            sourceId = ['%s' %i for i in sourceId]

        im.open(msName)
        imInfo = im.advise()
        im.close()

        if re.search('^3.', casadef.casa_version) == None:
            if imInfo[2]['unit'] != 'arcsec': sys.exit('ERROR: Cell unit not supported.')
            cellsizeInArcsec = imInfo[2]['value'] * 0.5
        else:
            if imInfo['cell']['unit'] != 'arcsec': sys.exit('ERROR: Cell unit not supported.')
            cellsizeInArcsec = imInfo['cell']['value'] * 0.5

        if cellsizeInArcsec > 0.2:
            cellsizeInArcsec = np.int(cellsizeInArcsec*20)/20.0
        else:
            cellsizeInArcsec = np.int(cellsizeInArcsec*100)/100.0

        if searchForLines == True: specLines = self.searchForLines(msName, chanWid=chanWid, angScale=angScale)

        save_stdout = sys.stdout
        sys.stdout = open('plotmosaic.output', 'w')
        plt.ioff()

        for i in sourceId:

            fieldIds1 = (np.where(sourceIds == int(i)))[0]
            if len(fieldIds1) > 1:
                j0 = 0
                fieldIds2 = str(fieldIds1[j0])
                for j in range(len(fieldIds1)-1):
                    if fieldIds1[j+1] == fieldIds1[j]+1: continue
                    fieldIds2 = fieldIds2 + '~' + str(fieldIds1[j])
                    j0 = j+1
                    fieldIds2 = fieldIds2 + ',' + str(fieldIds1[j0])
                fieldIds2 = fieldIds2 + '~' + str(fieldIds1[j+1])
            else:
                fieldIds2 = str(fieldIds1[0])

            spwInfo = self.getSpwInfo(msName)
            spwIds = sorted(spwInfo.keys())
            if iHaveSplitMyScienceSpw == True: spwIds = range(len(spwIds))

            mosaicInfo = plotmosaic(msName, sourceid=i, coord='relative')

            if len(fieldIds1) > 1:
                fieldAtCenter = str(mosaicInfo[0])
            else:
                fieldAtCenter = fieldIds2

            xImsizeInArcsec = abs(mosaicInfo[2] - mosaicInfo[1])
            yImsizeInArcsec = abs(mosaicInfo[4] - mosaicInfo[3])

            xImsizeInCells = xImsizeInArcsec/cellsizeInArcsec
            yImsizeInCells = yImsizeInArcsec/cellsizeInArcsec
            j = bisect.bisect_right(optimumImsize, xImsizeInCells)
            if j != len(optimumImsize): xImsizeInCells = optimumImsize[j]
            j = bisect.bisect_right(optimumImsize, yImsizeInCells)
            if j != len(optimumImsize): yImsizeInCells = optimumImsize[j]

            if searchForLines == True and int(i) in specLines:
                spwIds1 = []
                for j in spwIds:
                    if j not in specLines[int(i)]:
                        spwIds1.append(str(j))
                    else:
                        spwIds2 = []
                        for k in specLines[int(i)][j]:
                            for ij in range(k[0], k[1]+1):
                                spwIds2.append(ij)
                        spwIds3 = [ij for ij in range(spwInfo[j]['numChans']) if ij not in spwIds2]
                        spwIds4 = []
                        for ij, k in itertools.groupby(enumerate(spwIds3), lambda (x, y): y - x):
                            k = list(k)
                            spwIds4.append(str(k[0][1]) + '~' + str(k[-1][1]))
                        spwIds1.append(str(j) + ':' + ';'.join(spwIds4))
                        #spwIds2 = str(j) + ':0~'
                        #for k in specLines[int(i)][j]:
                        #    spwIds2 = spwIds2 + str(k[0]-1) + ';' + str(k[1]+1) + '~'
                        #spwIds2 = spwIds2 + str(spwInfo[j]['numChans'])
                        #spwIds1.append(spwIds2)
            else:
                spwIds1 = ['%s' %j for j in spwIds]

            spwIds1 = ','.join(spwIds1)

            casaCmd = casaCmd + "clean(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  imagename = '"+msName+".image.continuum.source"+i+"',\n"
            casaCmd = casaCmd + "  field = '"+fieldIds2+"', # "+fieldNames[fieldIds1[0]]+"\n"
            casaCmd = casaCmd + "  spw = '"+spwIds1+"',\n"
            casaCmd = casaCmd + "  mode = 'mfs',\n"
            if len(fieldIds1) > 1: casaCmd = casaCmd + "  imagermode = 'mosaic',\n"
            casaCmd = casaCmd + "  interactive = T,\n"
            casaCmd = casaCmd + "  imsize = ["+str(xImsizeInCells)+", "+str(yImsizeInCells)+"],\n"
            casaCmd = casaCmd + "  cell = '"+str(cellsizeInArcsec)+"arcsec',\n"
            casaCmd = casaCmd + "  phasecenter = "+fieldAtCenter+",\n"
            casaCmd = casaCmd + "  weighting = 'briggs',\n"
            casaCmd = casaCmd + "  robust = 0.5)\n\n"

            if searchForLines == True:
                if int(i) in specLines:
                    for j in specLines[int(i)]:
                        for k in specLines[int(i)][j]:
                            casaCmd = casaCmd + "clean(vis = '"+msName+"',\n"
                            casaCmd = casaCmd + "  imagename = '"+msName+".image.line.source"+i+".spw"+str(j)+".chans"+str(k[0])+"-"+str(k[1])+"',\n"
                            casaCmd = casaCmd + "  field = '"+fieldIds2+"', # "+fieldNames[fieldIds1[0]]+"\n"
                            casaCmd = casaCmd + "  spw = '"+str(j)+"',\n"
                            casaCmd = casaCmd + "  mode = 'channel',\n"
                            casaCmd = casaCmd + "  nchan = "+str((k[1]+1-k[0])/chanWid)+",\n"
                            casaCmd = casaCmd + "  start = "+str(k[0])+",\n"
                            casaCmd = casaCmd + "  width = "+str(chanWid)+",\n"
                            if casadef.casa_version >= '4.2.0':
                                casaCmd = casaCmd + "  interpolation = 'linear',\n"
                            else:
                                casaCmd = casaCmd + "  interpolation = 'nearest',\n"
                            if len(fieldIds1) > 1: casaCmd = casaCmd + "  imagermode = 'mosaic',\n"
                            casaCmd = casaCmd + "  interactive = T,\n"
                            casaCmd = casaCmd + "  imsize = ["+str(xImsizeInCells)+", "+str(yImsizeInCells)+"],\n"
                            casaCmd = casaCmd + "  cell = '"+str(cellsizeInArcsec)+"arcsec',\n"
                            casaCmd = casaCmd + "  phasecenter = "+fieldAtCenter+",\n"
                            casaCmd = casaCmd + "  weighting = 'briggs',\n"
                            casaCmd = casaCmd + "  robust = 0.5)\n\n"

        plt.ion()
        sys.stdout = save_stdout
        os.system('rm plotmosaic.output')

        return casaCmd

    def getRADecStringForField(self, msName, fieldId=''):

        if fieldId == '': sys.exit('ERROR: No field Id specified.')

        fieldRADec = getRADecForField(msName, int(fieldId))
        fieldRA = math.degrees(fieldRADec[0][0])
        fieldDec = math.degrees(fieldRADec[1][0])

        fieldRA = fieldRA/15.
        fieldRAh = int(fieldRA)
        fieldRAm = int(fieldRA%1*60)
        fieldRAs = (fieldRA%1*60)%1*60

        sign = int(abs(fieldDec)/fieldDec)

        fieldDec = abs(fieldDec)
        fieldDecd= int(fieldDec)
        fieldDecm= int(fieldDec%1*60)
        fieldDecs= (fieldDec%1*60)%1*60

        if(sign==+1):
            return "J2000 %02dh%02dm%05.2fs +%02dd%02dm%05.2fs" %(fieldRAh,fieldRAm,fieldRAs,fieldDecd,fieldDecm,fieldDecs)
        elif(sign==-1):
            return "J2000 %02dh%02dm%05.2fs -%02dd%02dm%05.2fs" %(fieldRAh,fieldRAm,fieldRAs,fieldDecd,fieldDecm,fieldDecs)

    def searchForLines(self, msName, fieldId='', chanWid=1, angScale=0, cutOff=0.2, minLineWid=3, chanPadding=1):

        import itertools
#         if (plotxyAvailable == False):
#             print "es.searchForLines needs to be updated to not use plotxy in this version of casa"
#             return
        vm = ValueMapping(msName)

        tb.open(msName)
        dataColNames = tb.colnames()
        tb.close()

        if 'CORRECTED_DATA' in dataColNames:
            dataCol = 'corrected'
        else:
            dataCol = 'data'

        tb.open(msName+'/FIELD')
        sourceIds = tb.getcol('SOURCE_ID')
        tb.close()

        intentSources = self.getIntentsAndSourceNames(msName)
        sciSourceIds = intentSources['OBSERVE_TARGET']['sourceid']
        sciSourceIds = sorted(dict.fromkeys(sciSourceIds).keys())

        spwInfo = self.getSpwInfo(msName)
        spwIds = sorted(spwInfo.keys())

        specLines = {}

        for i in sciSourceIds:

            fieldIds1 = (np.where(sourceIds == i))[0]
            fieldIds1 = [j for j in fieldIds1 if j in intentSources['OBSERVE_TARGET']['id']]

            for fid in fieldIds1:

                if fieldId != '' and fid != int(fieldId): continue

                for j in spwIds:

                    spwChanFreqs = vm.spwInfo[j]['chanFreqs']

                    if angScale != 0:
                        maxFreq = max(spwChanFreqs) / 1e9
                        uvRange = '0~'+str((72000. / maxFreq)/angScale)+'m'
                    else:
                        uvRange = ''

                    sum1 = {}
                    count1 = {}
                    for k in ['real', 'imag']:
                        sum1[k] = {}
                        count1[k] = {}

                        if casadef.casa_version <= '3.4.0':

                            plotxy(vis = msName, xaxis = 'chan', yaxis = k, datacolumn = dataCol, selectdata = True, antenna = '*&*', uvrange = uvRange, spw = str(j), field = str(fid),
                                   averagemode = 'vector', timebin = 'all', crossscans = True, crossbls = True, width = str(chanWid), interactive = False, figfile = 'plotxy.'+k+'.txt')
                            f = open('plotxy.'+k+'.txt', 'r')
                            fc = f.readlines()
                            f.close()
                            for line in fc:
                                line = line.strip()
                                if line == '': continue
                                ele1 = line.split()
                                chan1 = int(ele1[0])
                                comp1 = float(ele1[1])
                                if chan1 not in sum1[k].keys():
                                    sum1[k][chan1] = 0.
                                    count1[k][chan1] = 0
                                sum1[k][chan1] = sum1[k][chan1] + comp1
                                count1[k][chan1] = count1[k][chan1] + 1
                            os.system('rm -f plotxy.'+k+'.txt')

                        elif casadef.casa_version >= '4.2.0':

                            plotms(vis = msName, xaxis = 'chan', yaxis = k, ydatacolumn = dataCol, selectdata = True, antenna = '', uvrange = uvRange, spw = str(j), field = str(fid),
                                   averagedata = True, avgtime = '1e8', avgscan = True, avgbaseline = True, avgchannel = str(chanWid), interactive = False, plotfile = 'plotms.'+k+'.txt', expformat = 'txt', overwrite = True)
                            f = open('plotms.'+k+'.txt', 'r')
                            fc = f.readlines()
                            f.close()
                            for line in fc:
                                line = line.strip()
                                if line == '': continue
                                if line[0] == '#': continue
                                ele1 = line.split()
                                chan1 = int(round(float(ele1[0])/chanWid))
                                comp1 = float(ele1[1])
                                if chan1 not in sum1[k].keys():
                                    sum1[k][chan1] = 0.
                                    count1[k][chan1] = 0
                                sum1[k][chan1] = sum1[k][chan1] + comp1
                                count1[k][chan1] = count1[k][chan1] + 1
                            os.system('rm -f plotms.'+k+'.txt')

                        else:

                            sys.exit('ERROR: version of CASA not supported.')

                    chanMax = max([max(sum1['real']), max(sum1['imag'])])

                    avg1 = []
                    for chan1 in range(chanMax+1):
                        if chan1 in sum1['real'] and chan1 in sum1['imag']:
                            avg1.append(sqrt( (sum1['real'][chan1]/count1['real'][chan1])**2 + (sum1['imag'][chan1]/count1['imag'][chan1])**2))
                        else:
                            avg1.append(0)

                    plt.clf()
                    #plt.plot(range(0, len(avg1)*chanWid, chanWid), avg1)
                    plt.plot([spwChanFreqs[ij]/1.e9 for ij in range(0, len(avg1)*chanWid, chanWid)], avg1)
                    plt.savefig(msName+'.source'+str(i)+'.field'+str(fid)+'.spw'+str(j)+'.png')

                    hist, bin_edges = np.histogram(avg1, bins=int(ceil(sqrt(len(avg1)))))
                    ij = np.where(hist >= cutOff * max(hist))[0]
                    max1 = bin_edges[max(ij)+1]

                    k = 0
                    while k <= len(avg1)-minLineWid:
                        if avg1[k] > max1:
                            for kl in range(k, len(avg1)):
                                if avg1[kl] <= max1: break
                            if kl-k >= minLineWid:
                                specLine = [(k-chanPadding)*chanWid, (kl+chanPadding)*chanWid-1]
                                if i not in specLines: specLines[i] = {}
                                if j not in specLines[i]: specLines[i][j] = []
                                specLines[i][j].append(specLine)
                            k = kl-1
                        k = k+1

                    if i in specLines:
                        if j in specLines[i]:
                            specLines1 = []
                            for k in specLines[i][j]:
                                for kl in range(k[0], k[1]+1): specLines1.append(kl)
                            specLines1 = sorted(dict.fromkeys(specLines1).keys())
                            specLines2 = []
                            for kl, k in itertools.groupby(enumerate(specLines1), lambda (x, y): y - x):
                                k = list(k)
                                specLines2.append([k[0][1], k[-1][1]])
                            specLines[i][j] = specLines2

        return specLines


    def saveFlags(self, msName, name=''):

        if name == '': sys.exit('ERROR: Missing version name.')

        #casaCmd = 'print "# Saving flag column to version '+name+'"\n\n'
        casaCmd = ''

        if name == 'Original':
            casaCmd = casaCmd + "\nif not os.path.exists('"+msName+".flagversions/Original.flags'):\n"
            casaCmd = casaCmd + "  flagmanager(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "    mode = 'save',\n"
            casaCmd = casaCmd + "    versionname = '"+name+"')\n\n"
        else:
            casaCmd = casaCmd + "\nflagmanager(vis = '"+msName+"',\n"
            casaCmd = casaCmd + "  mode = 'save',\n"
            casaCmd = casaCmd + "  versionname = '"+name+"')\n\n"

        return casaCmd

    def saveFlagStats(self, msName, name='', statsFile=''):

        if name == '': sys.exit('ERROR: You must specify a version name.')

        time1 = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        if os.path.exists(statsFile) == False:
            f = open(statsFile, 'w')
            f.write('{}')
            f.close()

        f = open(statsFile)
        stats1 = eval(f.read())
        f.close()

        af.open(msName)
        af.selectdata()
        af.parsesummaryparameters()
        af.init()
        stats2 = af.run()
        af.done()

        clearstat()

        if 'report0' not in stats2.keys(): sys.exit('ERROR: Unexpected dictionnary.')
        if 'spw' not in stats2['report0'].keys(): sys.exit('ERROR: Unexpected dictionnary.')
        spwIds = stats2['report0']['spw'].keys()

        tb.open(msName+'/SPECTRAL_WINDOW')
        spwNames = tb.getcol('NAME')
        tb.close()

        for i in spwIds:
            if int(i) not in range(len(spwNames)): sys.exit('ERROR: Missing spectral window.')
            stats2['report0']['spw'][i]['name'] = spwNames[int(i)]

        ij = stats1.keys()
        if len(ij) != 0:
            ij = max(ij)
        else:
            ij = -1

        stats1[ij+1] = {}
        stats1[ij+1]['time'] = time1
        stats1[ij+1]['name'] = name
        stats1[ij+1]['summary'] = stats2['report0']

        f = open(statsFile, 'w')
        f.write(repr(stats1))
        f.close()

        return stats1

    def fixForCSV2453(self, msName):

        setjyModels = ['Mars', 'Jupiter', 'Uranus', 'Neptune', 'Pluto', 'Io', 'Europa', 'Ganymede', 'Callisto', 'Titan', 'Triton', 'Ceres', 'Pallas', 'Vesta', 'Juno', 'Victoria', 'Davida']
        setjyModels = [i.upper() for i in setjyModels]

        vm = ValueMapping(msName)

        for i in vm.uniqueFields:
            if i.upper() not in setjyModels: continue
            scanList = vm.getScansForField(i)
            for j in scanList:
                scanIntents = vm.getIntentsForScan(j).tolist()
                if 'CALIBRATE_DELAY#ON_SOURCE' in scanIntents:
                    editIntents(msName, field=i, scan=j, newintents='AMPLITUDE', append=True)

    def fixForICT331(self, asdmName):

        f = open(asdmName+'/Scan.xml')
        fc = f.read()
        f.close()

        blocks = re.findall('<row>.*?</row>', fc, re.DOTALL|re.MULTILINE)
        if len(blocks) == 0: sys.exit('Found 0 block.')

        scanIntents = {}

        for i in range(len(blocks)):

            scanNumber = re.findall('<scanNumber>.*?</scanNumber>', blocks[i])[0]
            scanNumber = int(scanNumber.replace('<scanNumber>', '').replace('</scanNumber>', ''))

            scanIntents1 = re.findall('<scanIntent>.*?</scanIntent>', blocks[i])[0]
            scanIntents1 = scanIntents1.replace('<scanIntent>', '').replace('</scanIntent>', '')
            scanIntents1 = re.findall('[A-Za-z_]+', scanIntents1)
            scanIntents1 = [j for j in scanIntents1 if j != 'CALIBRATE_WVR']

            scanIntents[scanNumber] = scanIntents1

        f = open(asdmName+'/Main.xml')
        fc = f.read()
        f.close()

        blocks = re.findall('<row>.*?</row>', fc, re.DOTALL|re.MULTILINE)
        if len(blocks) == 0: sys.exit('Found 0 block.')        

        needsFix = False
        needsSyscalRegen = False

        for i in range(len(blocks)):

            scanNumber = re.findall('<scanNumber>.*?</scanNumber>', blocks[i])[0]
            scanNumber = int(scanNumber.replace('<scanNumber>', '').replace('</scanNumber>', ''))

            stateIds = re.findall('<stateId>.*?</stateId>', blocks[i])[0]
            stateIds = stateIds.replace('<stateId>', '').replace('</stateId>', '').strip()

            if re.search('null', stateIds) != None:

                print 'Scan '+str(scanNumber)+' is affected.'

                needsFix = True
                if 'CALIBRATE_ATMOSPHERE' in scanIntents[scanNumber]: needsSyscalRegen = True

                stateIds1 = stateIds.replace('null_', 'State_')

                block = blocks[i].replace(stateIds, stateIds1)
                if len(re.findall(blocks[i], fc)) != 1: sys.exit('ERROR')
                fc = fc.replace(blocks[i], block)

        if needsFix == True:

            os.system('cp '+asdmName+'/Main.xml '+asdmName+'/Main.xml.old')

            f = open(asdmName+'/Main.xml', 'w')
            f.write(fc)
            f.close()

            print 'Main.xml was fixed. (The previous version was copied to "Main.xml.old".)'

            if needsSyscalRegen:
                print 'NOTE: YOU WILL NEED TO REGENERATE THE SYSCAL TABLE.'

    def checkRMS(self, msNames='', cycle='', numAnts='', timeOnSource='', numFieldsPerSource='', maxFlag=0.1, groupFieldsByRADec=False, groupSpwsByFreq=False):

        # groupSpwsByFreq will need implementation!! remember to check spw ids from one field to the next

        print 'WARNING: THIS WAS NOT TESTED FOR SESSIONS'
        print 'WARNING: OPTION groupSpwsByFreq NOT IMPLEMENTED YET'

        if msNames == '': sys.exit('ERROR: YOU MUST SPECIFY A LIST (CALIBRATED) MEASUREMENT SETS')

        if '*' in msNames:
            msNames = glob.glob(msNames)
            msNames = sorted(msNames)

        if type(msNames) is str:
            msNames = [msNames]

        if timeOnSource == '': sys.exit('ERROR: YOU MUST SPECIFY A TIME ON SOURCE')
        timeOnSource = float(timeOnSource)

        if numFieldsPerSource == '':
            print 'WARNING: YOU HAVE NOT SPECIFIED A NUMBER OF FIELDS PER SOURCE'
        else:
            numFieldsPerSource = int(numFieldsPerSource)

        if cycle == '' and numAnts == '': sys.exit('ERROR: YOU MUST SPECIFY EITHER A CYCLE OR A NUMBER OF ANTENNAS')
        if cycle != '' and numAnts != '': sys.exit('ERROR: YOU CANNOT SPECIFY A CYCLE AND A NUMBER OF ANTENNAS')

        if cycle != '':
            if int(cycle) == 1:
                numAnts_ACA = 9
                numAnts_BL12 = 32
            else:
                sys.exit('ERROR: CYCLE NOT SUPPORTED')
        else:
            numAnts = int(numAnts)

        maxRatios = {3:1.1, 6:1.1, 7:1.15, 9:1.2}

        maxFlag = float(maxFlag)

        mydict = {}
        array = ''

        for i in range(len(msNames)):

            msName = msNames[i]

            print '# Processing -> ', msName

            msmd.open(msName)
            sciSpwIds = msmd.spwsforintent('OBSERVE_TARGET#ON_SOURCE')
            wvrSpwIds = msmd.wvrspws()
            sciFieldIds = msmd.fieldsforintent('OBSERVE_TARGET#ON_SOURCE')
            antennaNames = msmd.antennanames()

            sciSpwIds = np.array([j for j in sciSpwIds if j not in wvrSpwIds])

            sciSpwMeanFreq = []
            sciSpwChanWidth = []
            sciSpwChanNum = []
            for j in sciSpwIds:
                sciSpwMeanFreq.append(msmd.meanfreq(j))
                sciSpwChanWidth1 = np.unique(msmd.chanwidths(j))
                if len(sciSpwChanWidth1) != 1: sys.exit('ERROR')
                sciSpwChanWidth.append(sciSpwChanWidth1[0])
                sciSpwChanNum.append(msmd.nchan(j))

            msmd.close()

            numCMAnts = 0
            for j in range(len(antennaNames)):
                if re.search('^CM', antennaNames[j]) != None:
                    numCMAnts += 1
            if 1. * numCMAnts / len(antennaNames) > 0.5:
                array1 = 'ACA'
            else:
                array1 = 'BL12'
            if array == '':
                array = array1
            else:
                if array != array1: sys.exit('ERROR: THE FIRST DATASET WAS IDENTIFIED AS '+array+' WHILE THE CURRENT ONE IS IDENTIFIED AS '+array1)

            tb.open(msName+'/FIELD')
            sourceIds = tb.getcol('SOURCE_ID')
            fieldDirs = tb.getcol('PHASE_DIR')
            tb.close()

            sourceIds1 = np.unique(sourceIds[sciFieldIds])

            print '# Found ', len(sourceIds1), ' source(s)'

            tb.open(msName+'/SOURCE')
            sourceIds2 = tb.getcol('SOURCE_ID')
            sourceNames2 = tb.getcol('NAME')
            sourceDirs2 = tb.getcol('DIRECTION')
            tb.close()

            tb.open(msName+'/DATA_DESCRIPTION')
            spwId2DataDescId = tb.getcol('SPECTRAL_WINDOW_ID').tolist()
            tb.close()

            tb.open(msName+'/SPECTRAL_WINDOW')
            spwNames = tb.getcol('NAME').tolist()
            tb.close()

            tb.open(msName)

            for j in range(len(sourceIds1)):

                ij = np.where(sourceIds2 == sourceIds1[j])

                sourceName = np.unique(sourceNames2[ij])
                sourceDir = sourceDirs2.swapaxes(0,1)[ij]
                sourceDir = sourceDir.swapaxes(0,1)
                if len(sourceName) != 1 or len(np.unique(sourceDir[0])) != 1 or len(np.unique(sourceDir[1])) != 1: sys.exit('ERROR')
                sourceName = sourceName[0]
                sourceDir = [np.unique(sourceDir[0])[0], np.unique(sourceDir[1])[0]]

                found = 0

                if len(mydict.keys()) == 0:
                    k = 0
                else:
                    for k in mydict.keys():
                        if mydict[k]['sourceName'] == sourceName and mydict[k]['sourceDir'] == sourceDir:
                            found = 1
                            break
                    if found == 0:
                        k = max(mydict.keys()) + 1

                if found == 0:
                    mydict[k] = {}
                    mydict[k]['sourceName'] = sourceName
                    mydict[k]['sourceDir'] = sourceDir
                    mydict[k]['perField'] = {}

                sciFieldIds1 = np.where(sourceIds == sourceIds1[j])[0]
                sciFieldIds1 = [kl for kl in sciFieldIds1 if kl in sciFieldIds]

                for ij in sciFieldIds1:

                    found = 0

                    if len(mydict[k]['perField'].keys()) == 0:
                        kl = 0
                    else:
                        if groupFieldsByRADec == True:
                            for kl in mydict[k]['perField'].keys():
                                if mydict[k]['perField'][kl]['fieldDir'] == [ str(fieldDirs[0][0][ij]), str(fieldDirs[1][0][ij]) ]:
                                    found = 1
                                    break
                        else:
                            if sciFieldIds1.index(ij) in mydict[k]['perField'].keys():
                                kl = sciFieldIds1.index(ij)
                                found = 1
                            else:
                                kl = max(mydict[k]['perField'].keys()) + 1

                    if found == 0:
                        mydict[k]['perField'][kl] = {}
                        mydict[k]['perField'][kl]['fieldDir'] = [ str(fieldDirs[0][0][ij]), str(fieldDirs[1][0][ij]) ]
                        mydict[k]['perField'][kl]['perSpw'] = {}

                    for ij1 in sciSpwIds:

                        found = 0

                        if len(mydict[k]['perField'][kl]['perSpw'].keys()) == 0:
                            kl1 = 0
                        else:
                            if groupSpwsByFreq == True:
                                sys.exit('ERROR')
                            else:
                                if sciSpwIds.tolist().index(ij1) in mydict[k]['perField'][kl]['perSpw'].keys():
                                    kl1 = sciSpwIds.tolist().index(ij1)
                                    found = 1
                                else:
                                    kl1 = max(mydict[k]['perField'][kl]['perSpw'].keys()) + 1

                        if found == 0:
                            mydict[k]['perField'][kl]['perSpw'][kl1] = {}

                        tb1 = tb.query('DATA_DESC_ID == '+str(spwId2DataDescId.index(ij1))+' AND FIELD_ID == '+str(ij))
                        if tb1.nrows() == 0: continue

                        exp1 = np.unique(tb1.getcol('EXPOSURE'))
                        if len(exp1) != 1: sys.exit('ERROR')
                        exp1 = exp1[0]

                        if 'exp' not in mydict[k]['perField'][kl]['perSpw'][kl1].keys():
                            mydict[k]['perField'][kl]['perSpw'][kl1]['exp'] = exp1
                        else:
                            if mydict[k]['perField'][kl]['perSpw'][kl1]['exp'] != exp1: sys.exit('ERROR')

                        if 'meanFreq' not in mydict[k]['perField'][kl]['perSpw'][kl1].keys():
                            mydict[k]['perField'][kl]['perSpw'][kl1]['meanFreq'] = sciSpwMeanFreq[sciSpwIds.tolist().index(ij1)]
#                             mydict[k]['perField'][kl]['perSpw'][kl1]['band'] = getBand(sciSpwMeanFreq[sciSpwIds.tolist().index(ij1)])
                            band1 = re.findall('ALMA_RB_[0-9]+', spwNames[ij1])
                            if len(band1) != 1: sys.exit('ERROR')
                            mydict[k]['perField'][kl]['perSpw'][kl1]['band'] = int(band1[0].split('_')[2])
                        else:
                            if mydict[k]['perField'][kl]['perSpw'][kl1]['meanFreq'] != sciSpwMeanFreq[sciSpwIds.tolist().index(ij1)]:
                                print 'WARNING: THE MEAN FREQUENCY OF SPW ', ij1, ' OF CURRENT MS DOES NOT MATCH THE MEAN FREQUENCY OF THE SAME SPW OF THE FIRST MS'

                        if 'chanWidth' not in mydict[k]['perField'][kl]['perSpw'][kl1].keys():
                            mydict[k]['perField'][kl]['perSpw'][kl1]['chanWidth'] = sciSpwChanWidth[sciSpwIds.tolist().index(ij1)]
                        else:
                            if mydict[k]['perField'][kl]['perSpw'][kl1]['chanWidth'] != sciSpwChanWidth[sciSpwIds.tolist().index(ij1)]:
                                print 'WARNING: THE CHANNEL WIDTH OF SPW ', ij1, ' OF CURRENT MS DOES NOT MATCH THE MEAN FREQUENCY OF THE SAME SPW OF THE FIRST MS'

                        if 'chanNum' not in mydict[k]['perField'][kl]['perSpw'][kl1].keys():
                            mydict[k]['perField'][kl]['perSpw'][kl1]['chanNum'] = sciSpwChanNum[sciSpwIds.tolist().index(ij1)]
                        else:
                            if mydict[k]['perField'][kl]['perSpw'][kl1]['chanNum'] != sciSpwChanNum[sciSpwIds.tolist().index(ij1)]:
                                print 'WARNING: THE NUMBER OF CHANNELS OF SPW ', ij1, ' OF CURRENT MS DOES NOT MATCH THE MEAN FREQUENCY OF THE SAME SPW OF THE FIRST MS'

                        tb1 = tb.query('FLAG_ROW == FALSE AND DATA_DESC_ID == '+str(spwId2DataDescId.index(ij1))+' AND FIELD_ID == '+str(ij))
                        if tb1.nrows() > 0:

                            ant1 = tb1.getcol('ANTENNA1')
                            ant2 = tb1.getcol('ANTENNA2')
                            flag1 = tb1.getcol('FLAG')
                            flag2 = flag1.swapaxes(1,2)

                            nchan1 = len(flag2[0])

                            if 'nvis' not in mydict[k]['perField'][kl]['perSpw'][kl1].keys():
                                nvis1 = 0
                            else:
                                nvis1 = mydict[k]['perField'][kl]['perSpw'][kl1]['nvis']

                            for ij2 in range(len(ant1)):

                                if ant1[ij2] == ant2[ij2]: continue

                                flag3 = []
                                for ij3 in range(2):
                                    flag3.append(1. * len(np.where(np.array(flag2[ij3][ij2]) == True)[0]) / nchan1)

                                if len(np.where(np.array(flag3) > maxFlag)[0]) == 0:
                                    nvis1 += 1

                            mydict[k]['perField'][kl]['perSpw'][kl1]['nvis'] = nvis1

                        else:

                            mydict[k]['perField'][kl]['perSpw'][kl1]['nvis'] = 0

            tb1.close()
            tb.close()

        if cycle != '':
            if array == 'ACA':
                numAnts = numAnts_ACA
            else:
                numAnts = numAnts_BL12

        for i in mydict.keys():

            if numFieldsPerSource == '':
                numFieldsPerSource = len(mydict[i]['perField'].keys())
            else:
                if len(mydict[i]['perField'].keys()) != numFieldsPerSource: sys.exit('ERROR: THE OBSERVED NUMBER OF FIELDS PER SOURCE DOES NOT MATCH THE SPECIFIED NUMBER')

            for j in mydict[i]['perField'].keys():
                for k in mydict[i]['perField'][j]['perSpw'].keys():
                    nvis1 = mydict[i]['perField'][j]['perSpw'][k]['nvis']
                    if nvis1 != 0:
                        mydict[i]['perField'][j]['perSpw'][k]['ratio'] = np.sqrt( ( numAnts * (numAnts-1) * (timeOnSource * 60. / numFieldsPerSource) ) / (2. * nvis1 * exp1) )
                    else:
                        mydict[i]['perField'][j]['perSpw'][k]['ratio'] = float('inf')

        for i in mydict.keys():

            mydict[i]['perSpw'] = {}
    
            ij = []
            band = []
            for j in mydict[i]['perField'].keys():
                for k in mydict[i]['perField'][j]['perSpw'].keys():
                    ij.append(k)
                    band.append(mydict[i]['perField'][j]['perSpw'][k]['band'])
            ij = np.unique(ij)
            band = np.unique(band)
            if len(band) != 1: sys.exit('ERROR')

            for j in ij:

                mydict[i]['perSpw'][j] = {}
                mydict[i]['perSpw'][j]['band'] = band[0]
                mydict[i]['perSpw'][j]['ratio'] = {}

                ratio1 = []
                for k in mydict[i]['perField'].keys():
                    ratio1.append(mydict[i]['perField'][k]['perSpw'][j]['ratio'])

                mydict[i]['perSpw'][j]['ratio']['min'] = np.min(ratio1)
                mydict[i]['perSpw'][j]['ratio']['max'] = np.max(ratio1)
                mydict[i]['perSpw'][j]['ratio']['median'] = np.median(ratio1)

        print '---------'
        print 'Number of executions = ', len(msNames)

        for i in mydict.keys():

            print '\nSource name = ', mydict[i]['sourceName']
            print 'Number of fields found = ', len(mydict[i]['perField'].keys())
            print 'Maximum rms ratio across all fields, per spw:\n'

            for j in mydict[i]['perSpw'].keys():

                line = str(j)+' -> '+str(mydict[i]['perSpw'][j]['ratio']['max'])+' -> '

                if mydict[i]['perSpw'][j]['ratio']['max'] < maxRatios[mydict[i]['perSpw'][j]['band']]:
                    line += 'PASS'
                else:
                    line += 'FAIL -> need '+str(len(msNames) * ( (1./maxRatios[mydict[i]['perSpw'][j]['band']])**2 - (1./mydict[i]['perSpw'][j]['ratio']['max'])**2 ))+' additional executions'

                print line

        return mydict

    def fixForCSV2555(self, msName):

        print 'INFO: Running routine fixForCSV2555 on '+msName

#         msmd.open(msName)
#         scanList = msmd.scannumbers()
#         for i in scanList:
#             fieldList = msmd.fieldsforscan(i)
#             if len(fieldList) != 1:
#                 print 'WARNING: Scan '+str(i)+' has more than one field.'
#         msmd.close()

        corr = False

        tb.open(msName+'/SOURCE')

        sourceNames = tb.getcol('NAME')
        sourceDirs = tb.getcol('DIRECTION')
        sourceDirs = np.transpose(sourceDirs)
        sourceDirs = np.array([tuple(i) for i in sourceDirs])

        tb.close()

        tb.open(msName+'/FIELD', nomodify=False)

        fieldNameList = tb.getcol('NAME')

#         k = -1
        sourceInfo = []

        for i in range(tb.nrows()):

            fieldName = tb.getcell('NAME', rownr=i)

            ij = np.where(sourceNames == fieldName)
            if len(ij) == 0: sys.exit('ERROR')

            sourceDirs1 = [sourceDirs[j].tolist() for j in ij[0]]

            sourceDirs2 = [tuple(sourceDirs1[0])]
            for j in range(1, len(sourceDirs1)):
                if tuple(sourceDirs1[j]) in sourceDirs2: continue
                sourceDirs2.append(tuple(sourceDirs1[j]))

            if len(sourceDirs2) == 1:

                if tuple([fieldName, sourceDirs2[0]]) not in sourceInfo:

                    sourceInfo.append(tuple([fieldName, sourceDirs2[0]]))
#                     k += 1

                k = sourceInfo.index(tuple([fieldName, sourceDirs2[0]]))

            else:

                fieldDir = tb.getcell('PHASE_DIR', rownr=i)
                fieldDir = tuple(np.transpose(fieldDir)[0])

                if fieldDir not in sourceDirs2: sys.exit('ERROR')

                if tuple([fieldName, fieldDir]) not in sourceInfo:

                    sourceInfo.append(tuple([fieldName, fieldDir]))
#                     k += 1

                k = sourceInfo.index(tuple([fieldName, fieldDir]))

            if tb.getcell('SOURCE_ID', rownr=i) != k:
                tb.putcell('SOURCE_ID', rownr=i, thevalue=k)
                corr = True

        tb.close()

        tb.open(msName+'/SOURCE', nomodify=False)

        for i in range(tb.nrows()):

            sourceName = tb.getcell('NAME', rownr=i)
            sourceDir = tb.getcell('DIRECTION', rownr=i)
            sourceDir = tuple(sourceDir.tolist())

            k = -1
            found = 0
            for j in range(len(sourceInfo)):
                if sourceName == sourceInfo[j][0] and sourceDir == sourceInfo[j][1]:
                    k = j
                    found = 1
                    break

            if found == 0:
                print 'WARNING: IT LOOKS BAD... THERE IS IN THE SOURCE TABLE A LINE WITH A DIRECTION THAT IS NOT PRESENT IN THE FIELD TABLE.'
                for j in range(len(sourceInfo)):
                    if sourceName == sourceInfo[j][0]:
                        k = j
                        found = 1
                        print "WARNING: ASSIGNING THE SOURCE ID OF '"+sourceInfo[j][0]+"' TO '"+sourceName+"'. IF THIS OBJECT IS NOT A SOLAR SYSTEM OBJECT, THEN IT IS VERY BAD, PLEASE REPORT TO JAO (E.G. ERIC V.); OTHERWISE, IT IS PROBABLY FINE."
                        break

            if found == 0: sys.exit('ERROR')

            if tb.getcell('SOURCE_ID', rownr=i) != k:
                tb.putcell('SOURCE_ID', rownr=i, thevalue=k)
                corr = True

        tb.close()

        clearstat()

        if corr == True:
            print 'INFO: Some issues were found, and corrected.'
        else:
            print 'INFO: No issue found.'

        print 'INFO: Finished running routine fixForCSV2555 on '+msName

    def listobs3(self, msName, figfile = '', colorby = 'intent'):

#        import matplotlib.pyplot as plt

        if colorby not in ['', 'intent', 'spw']: sys.exit('ERROR')
        if (casadef.casa_version < '4.1.0') and colorby == 'spw': sys.exit('ERROR')

        colors = ['blue', 'cyan', 'red', 'green', 'magenta', 'yellow', 'orange', 'blue', 'cyan', 'red', 'green', 'magenta', 'yellow', 'orange']
        intents = ['OBSERVE_TARGET#ON_SOURCE', 'CALIBRATE_PHASE#ON_SOURCE', 'CALIBRATE_BANDPASS#ON_SOURCE', 'CALIBRATE_AMPLI#ON_SOURCE', \
            'CALIBRATE_FLUX#ON_SOURCE', 'CALIBRATE_ATMOSPHERE#ON_SOURCE', 'CALIBRATE_POINTING#ON_SOURCE', 'CALIBRATE_SIDEBAND_RATIO#ON_SOURCE', \
            'CALIBRATE_POLARIZATION#ON_SOURCE', 'CALIBRATE_DELAY#ON_SOURCE']

        if (casadef.casa_version >= '4.1.0'):

            msmd.open(msName)        
            scanList = msmd.scannumbers()
            scanTimes1 = msmd.timesforscan(1)
            scanTimes2 = msmd.timesforscan(scanList[len(scanList)-1])

            if colorby == 'spw':

                spwList1 = msmd.chanavgspws()
                spwList2 = msmd.wvrspws()

                spwList = []
                for i in scanList:
                    spwList3 = msmd.spwsforscan(i)
                    spwList3 = [j for j in spwList3 if j not in spwList1]
                    spwList3 = [j for j in spwList3 if j not in spwList2]
                    spwList.append(tuple(spwList3))

                spwList = np.unique(spwList)
                spwList = [list(j) for j in spwList]

        else:

            vm = ValueMapping(msName)
            scanList = vm.uniqueScans
            scanTimes1 = vm.getTimesForScan(1)
            scanTimes2 = vm.getTimesForScan(scanList[len(scanList)-1])

        obsStart = scanTimes1.min()
        obsEnd = scanTimes2.max()
        obsDuration = (obsEnd-obsStart) / 60.

        fig = plt.figure(figsize=(14,9))
        ax = fig.add_subplot(111)

        for i in scanList:

            if (casadef.casa_version >= '4.1.0'):

                scanTimes = msmd.timesforscan(i)
                scanIntent = msmd.intentsforscan(i)
            
            else:

                scanTimes = vm.getTimesForScan(i)
                scanIntent = vm.getIntentsForScan(i)

            scanStartTime = (scanTimes.min() - obsStart) / 60.
            scanDuration = (scanTimes.max() - scanTimes.min()) / 60.

            for j in range(len(intents)):

                if intents[j] in scanIntent:

                    scanY = 5*j

                    label1 = ''

                    if colorby == '':
                        scanColor = colors[0]

                    if colorby == 'intent':
                        scanColor = colors[scanY/5]

                    if colorby == 'spw':

                        spwList3 = msmd.spwsforscan(i)
                        spwList3 = [k for k in spwList3 if k not in spwList1]
                        spwList3 = [k for k in spwList3 if k not in spwList2]

                        scanColor = colors[spwList.index(spwList3)]
                        
                    ax.broken_barh([(scanStartTime, scanDuration)] , (scanY, 5), facecolors=scanColor)
                    ax.annotate(str(i), (scanStartTime, scanY+6))

        if (casadef.casa_version >= '4.1.0'):
            msmd.close()

        if colorby == 'spw':
            for i in range(len(spwList)):
                print spwList[i], ' -> ', colors[i]

        ax.set_ylim(0, len(intents)*5+2.5)
        ax.set_xlim(-1, obsDuration+1)
        ax.set_xlabel('Minutes since start of observation')
        ax.set_yticks(np.array(range(len(intents)))*5+2.5)
        intents1 = [j.replace('#ON_SOURCE', '').replace('CALIBRATE', 'CAL').replace('OBSERVE', 'OBS').replace('SIDEBAND', 'SB') for j in intents]
        ax.set_yticklabels(intents1)
        ax.grid(True)

        obsStart=((obsStart/86400.0)+2400000.5-2440587.5)*86400.0
        obsEnd=((obsEnd/86400.0)+2400000.5-2440587.5)*86400.0
        plt.title('Measurement set = '+msName+' - Start time = '+timeUtilities.strftime('%Y-%m-%dT%H:%M:%S', timeUtilities.gmtime(obsStart))+' - End time = '+timeUtilities.strftime('%Y-%m-%dT%H:%M:%S', timeUtilities.gmtime(obsEnd)), fontsize = 12)

        if figfile != '': fig.savefig(figfile)

    def addReducScriptStep(self, fx=None, stepTitles=None, thisStepTitle=None, stepText=None, indent='  ', applyonly=False):
        # prints new step to file fx,
        # returns modified version of stepTitles

        applyonly = False ## to be removed once we move to CASA4.2

        if not (type(fx)==file):
            raise Exception("fx must be a file open for writing")

        if not (type(stepTitles)==dict):
            raise Exception("stepTitles must be a dictionary")
        currentNum = len(stepTitles)

        if not (type(thisStepTitle)==str):
            raise Exception("thisStepTitle must be a string")

        if not (type(stepText)==str):
            raise Exception("stepText must be a string")

        if not (type(indent)==str and len(indent)>1):
            raise Exception("indent must be a string of spaces with a length >= 2")

        stepText = indent + stepText.replace('\n','\n'+indent)

        print >> fx, "# "+thisStepTitle
        print >> fx, "mystep = "+str(currentNum)

        if applyonly == False:
            print >> fx, "if(mystep in thesteps):"
        else:
            print >> fx, "if(mystep in thesteps or applyonly == True):"

        print >> fx, indent+"casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')"
        print >> fx, indent+"print 'Step ', mystep, step_title[mystep]\n"
        print >> fx, stepText+"\n"

        stepTitles[currentNum] = thisStepTitle

        return stepTitles

    def prependReducScriptHeader(self, fx=None, stepTitles=None, scriptTitle='', indent='  '):

        if not (type(fx)==file):
            raise Exception("fx must be a file open for writing")

        if not (type(stepTitles)==dict):
            raise Exception("stepTitles must be a dictionary")

        if not (type(indent)==str and len(indent)>1):
            raise Exception("indent must be a string of spaces with a length >= 2")

#         myheader = "# ALMA Data Reduction Script\n\n" \
#                    + "# " + scriptTitle + "\n\n" \
#                    + "thesteps = []\n" \
#                    + "step_title = "+str(stepTitles).replace("'," , "',\n             " )+'\n\n' \
#                    + "if 'applyonly' not in globals(): applyonly = False\n" \
#                    + "if applyonly != True:\n" \
#                    + indent + "try:\n" \
#                    + indent + indent + "print 'List of steps to be executed ...', mysteps\n" \
#                    + indent + indent + "thesteps = mysteps\n" \
#                    + indent + "except:\n" \
#                    + indent + indent + "print 'global variable mysteps not set.'\n" \
#                    + indent + "if (thesteps==[]):\n" \
#                    + indent + indent + "thesteps = range(0,len(step_title))\n" \
#                    + indent + indent + "print 'Executing all steps: ', thesteps\n\n" \
#                    + "# The Python variable 'mysteps' will control which steps\n" \
#                    + "# are executed when you start the script using\n" \
#                    + "#   execfile('scriptForCalibration.py')\n" \
#                    + "# e.g. setting\n" \
#                    + "#   mysteps = [2,3,4]" \
#                    + "# before starting the script will make the script execute\n" \
#                    + "# only steps 2, 3, and 4\n" \
#                    + "# Setting mysteps = [] will make it execute all steps.\n"

# to be removed once we move to CASA4.2
        myheader = "# ALMA Data Reduction Script\n\n" \
                   + "# " + scriptTitle + "\n\n" \
                   + "thesteps = []\n" \
                   + "step_title = "+str(stepTitles).replace("'," , "',\n             " )+'\n\n' \
                   + "if 'applyonly' not in globals(): applyonly = False\n" \
                   + "try:\n" \
                   + indent + "print 'List of steps to be executed ...', mysteps\n" \
                   + indent + "thesteps = mysteps\n" \
                   + "except:\n" \
                   + indent + "print 'global variable mysteps not set.'\n" \
                   + "if (thesteps==[]):\n" \
                   + indent + "thesteps = range(0,len(step_title))\n" \
                   + indent + "print 'Executing all steps: ', thesteps\n\n" \
                   + "# The Python variable 'mysteps' will control which steps\n" \
                   + "# are executed when you start the script using\n" \
                   + "#   execfile('scriptForCalibration.py')\n" \
                   + "# e.g. setting\n" \
                   + "#   mysteps = [2,3,4]" \
                   + "# before starting the script will make the script execute\n" \
                   + "# only steps 2, 3, and 4\n" \
                   + "# Setting mysteps = [] will make it execute all steps.\n"

        sname = fx.name

        fx.close()
        fx = open(sname, 'r+')
        old = fx.read() # read everything in the file
        fx.seek(0) # rewind
        fx.write(myheader +"\n"+ old) # prepend the header

        return True

    def generateReducScript(self, msNames='', step='calib', corrAntPos=True, timeBinForFinalData=0., refant='', bpassCalId='', chanWid=1, angScale=0, run=False, lowSNR=False, projectCode='', schedblockName='', queue='', state='', upToTimeForState=2, useLocalAlmaHelper=False, tsysChanTol=1, sdQSOflux=1, runPhaseClosure=False, skipSyscalChecks=False):

        from almahelpers_localcopy import tsysspwmap

        if state != '':

            password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
            top_level_url = 'http://www.alma.cl/~evillard/ProjectTracking/Cycle1/ScriptGenerator'
            password_mgr.add_password(None, top_level_url, 'scriptgen', 'jT9w3M7y')
            handler = urllib2.HTTPBasicAuthHandler(password_mgr)
            opener = urllib2.build_opener(handler)
            allBlocks = opener.open('http://www.alma.cl/~evillard/ProjectTracking/Cycle1/ScriptGenerator/'+state+'.txt').read().splitlines()

            utcDateNow = datetime.datetime.utcnow()

            if state in ['QA0_PASS', 'QA0_FAIL']:

                msNames = []

                for i in range(len(allBlocks)):

                    block1 = allBlocks[i].strip()
                    if re.search('^\*', block1) == None: continue

                    execblockUid = re.findall('uid://[A-Za-z0-9]+/[A-Za-z0-9]+/[A-Za-z0-9]+', block1)
                    if len(execblockUid) != 1: continue
                    execblockUid = execblockUid[0]

                    stateDate = re.findall('\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}', block1)
                    if len(stateDate) != 1: continue
                    stateDate = stateDate[0]

                    stateDate = datetime.datetime.strptime(stateDate, '%Y-%m-%d %H:%M:%S')
                    dateDiff = utcDateNow - stateDate
                    dateDiff = dateDiff.days + dateDiff.seconds / 86400.

                    if dateDiff < upToTimeForState/24.: msNames.append(execblockUid)
    
                for i in range(len(msNames)): msNames[i] = re.sub(':|/', '_', msNames[i])
                print 'Found the following EBs: '+str(msNames)

        if queue != '':

            if os.path.isfile(queue) == False: sys.exit('ERROR: queue file does not exist.')
            f = open(queue)
            fc = f.readlines()
            f.close()

            ij = -1
            queue1 = {}

            for i in range(len(fc)):

                line = fc[i].strip()
                if len(line) == 0: continue
                if line[0] == '#': continue

                if re.search('^uid\:\/\/[0-9a-z]+\/[0-9a-z]+\/[0-9a-z]+', line, re.IGNORECASE) != None:
                    ij += 1
                    queue1[ij] = {}
                    queue1[ij]['execblockUid'] = re.findall('^uid\:\/\/[0-9a-z]+\/[0-9a-z]+\/[0-9a-z]+', line, re.IGNORECASE)[0]

                if re.search('^201[0-9]\.[0-9]\.[0-9]{5}.[A-Z] ', line, re.IGNORECASE) != None:
                    ij += 1
                    queue1[ij] = {}
                    queue1[ij]['projectCode'] = re.findall('^201[0-9]\.[0-9]\.[0-9]{5}.[A-Z]', line, re.IGNORECASE)[0]
                    queue1[ij]['schedblockName'] = re.findall('(?<=^201[0-9]\.[0-9]\.[0-9]{5}.[A-Z] ).+', line, re.IGNORECASE)[0].strip()

            msNames = []
            for i in queue1:
                if 'execblockUid' in queue1[i]:
                    msNames.append(queue1[i]['execblockUid'])
            msNames = sorted(msNames)
            self.generateReducScript(msNames=msNames, step=step, refant=refant, bpassCalId=bpassCalId, run=run, lowSNR=lowSNR)
#            print "self.generateReducScript(msNames="+str(msNames)+", step='"+step+"', refant='"+refant+"', bpassCalId='"+bpassCalId+"', run="+str(run)+", lowSNR="+str(lowSNR)+")"

            for i in queue1:
                if 'projectCode' in queue1[i] and 'schedblockName' in queue1[i]:
                    self.generateReducScript(projectCode=queue1[i]['projectCode'], schedblockName=queue1[i]['schedblockName'], step=step, refant=refant, bpassCalId=bpassCalId, run=run, lowSNR=lowSNR)
#                    print "self.generateReducScript(projectCode='"+queue1[i]['projectCode']+"', schedblockName='"+queue1[i]['schedblockName']+"', step='"+step+"', refant='"+refant+"', bpassCalId='"+bpassCalId+"', run="+str(run)+", lowSNR="+str(lowSNR)+")"

            return(0)

        if re.search('^3.3', casadef.casa_version) == None:
            print 'WARNING: You are currently running another version of CASA than 3.3. Probably 3.4.'
            print 'WARNING: The scripts have been ported, but for a bit of time, please be careful with the output.'
            print 'WARNING: If you observe any issue or strange behavior, please send an email to Eric V. (evillard@alma.cl)'
#            raw_input('Hit a key to proceed.')

        if type(msNames).__name__ == 'str': msNames = [msNames]
###        if type(msNames).__name__ == 'str': msNames = glob.glob(msNames)
###        for i in range(len(msNames)): msNames[i] = msNames[i].rstrip(os.path.sep)

        if projectCode != '' and schedblockName != '' and step in ['calib', 'all']:

            password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
            top_level_url = 'http://www.alma.cl/~evillard/ProjectTracking/Cycle1/DataReducer'
            password_mgr.add_password(None, top_level_url, 'datareducer', 'X9cm0a')
            handler = urllib2.HTTPBasicAuthHandler(password_mgr)
            opener = urllib2.build_opener(handler)
            allExecblocks = opener.open('http://www.alma.cl/~evillard/ProjectTracking/Cycle1/DataReducer/allExecblocks_QA0_PASS.txt').read().splitlines()

            msNames = []
            schedblockUids = []
            for i in range(len(allExecblocks)):
                if allExecblocks[i].strip() == '': continue
                block1 = allExecblocks[i].split('\t')
                if block1[0].strip() == projectCode and block1[2].strip() == schedblockName:
                    msNames.append(block1[4].strip())
                    schedblockUids.append(block1[3].strip())
            schedblockUids = sorted(dict.fromkeys(schedblockUids).keys())
            if len(schedblockUids) != 1: sys.exit('ERROR: Found zero SB, or more than one.')

            for i in range(len(msNames)): msNames[i] = re.sub(':|/', '_', msNames[i])
            print 'Found the following EBs: '+str(msNames)

            valid_chars = "-_%s%s" % (string.ascii_letters, string.digits)
            schedblockName1 = ''.join(i for i in schedblockName if i in valid_chars)
            schedblockDir = 'SB_'+projectCode+'_'+schedblockName1
            if os.path.isdir(schedblockDir) == True:
                i = 0
                while os.path.isdir(schedblockDir+'_'+str(i)) == True: i += 1
                schedblockDir = schedblockDir+'_'+str(i)
            print 'Creating directory: ', schedblockDir
            os.mkdir(schedblockDir)
            print 'Changing current working directory to: ', schedblockDir
            os.chdir(schedblockDir)

        currDir = os.getcwd()
###        msNames = sorted(msNames)

###        for i in range(len(msNames)):

        if step == 'softreg':
            asis1 = 'Antenna Station Receiver Source CalAtmosphere CalWVR'
        else:
            asis1 = 'Antenna Station Receiver Source CalAtmosphere CalWVR'

        i = 0

        while i < len(msNames):

            msNames[i] = msNames[i].rstrip(os.path.sep)

            if re.search('^uid\:\/\/[0-9a-z]+\/[0-9a-z]+\/[0-9a-z]+$', msNames[i], re.IGNORECASE) != None:
                msNames[i] = re.sub(':|/', '_', msNames[i])

            if re.search('^uid___[0-9a-z]+_[0-9a-z]+_[0-9a-z]+$', msNames[i], re.IGNORECASE) != None:
                if os.path.exists(msNames[i]) == True:
                    if os.path.exists(msNames[i]+'.ms') == False:
                        print 'WARNING: The asdm exists, but the ms does not exist, running importasdm.'
                        importasdm(msNames[i], asis=asis1)
                elif os.path.exists('../'+msNames[i]):  # Added by Todd for people outside JAO
                    importasdm('../'+msNames[i], vis='./'+msNames[i]+'.ms', asis=asis1)
                else:
                    if os.path.exists(msNames[i]+'.ms') == False:
                        print 'WARNING: Neither the asdm nor the ms exists, running asdmExport.'
                        os.system('asdmExport '+msNames[i])
                        if os.path.exists(msNames[i]+'.tar') == True:
                            os.system('tar xvf '+msNames[i]+'.tar')
                        print 'WARNING: The ms does not exist, running importasdm.'
                        importasdm(msNames[i], asis=asis1)
                msNames[i] = msNames[i]+'.ms'
            else:
                if os.path.exists(msNames[i]) == False:
                    msName1 = glob.glob(msNames[i])
                    if len(msName1) == 0: sys.exit('ERROR: '+msNames[i]+' does not seem to exist in the current directory.')
                    msNames.pop(i)
                    for j in msName1: msNames.insert(i, j)

            i = i+1

        msNames = sorted(msNames)

        for i in range(len(msNames)):

            if step not in ['fluxcal', 'imaging']: self.fixForCSV2555(msNames[i])

            if os.getlogin == 'aod':
                self.listOfIntentsWithSources(msNames[i])
                self.listobs3(msNames[i], figfile=msNames[i]+'.listobs3.png')
                self.plotAntennas(msNames[i])
                tosInfo = timeOnSource(msNames[i])

            spwInfo = self.getSpwInfo(msNames[i])
            spwIds = sorted(spwInfo.keys())
            vm = ValueMapping(msNames[i])
            spwScans = vm.getScansForSpw(spwIds[0]).tolist()
            for j in spwIds:
                if vm.getScansForSpw(j).tolist() != spwScans:
                    print 'WARNING: The scans are not the same for all science spws.'
                    print 'WARNING: The script generator is not compatible with this, it will very likely fail.'
                    print 'WARNING: If it does not fail, do not expect the reduction script to be good. Please check it carefully.'
#                    raw_input('Hit a key to proceed.')

        if step == 'wvr':

            for msName in msNames:

                f1 = open(msName+'.scriptForWVRCalibration.py', 'w')
                print >> f1, "import re\n"
                print >> f1, "es = aU.stuffForScienceDataReduction() \n\n"
                print >> f1, "if re.search('^"+re.findall('^[0-9]+.[0-9]+.[0-9]+', casadef.casa_version)[0]+"', casadef.casa_version) == None:"
                print >> f1, " sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: "+re.findall('^[0-9]+.[0-9]+', casadef.casa_version)[0]+"')\n\n"

                myRefAnt = refant
                if myRefAnt == '': myRefAnt = self.getRefAntenna(msName)
                print >> f1, "# Using reference antenna = "+myRefAnt+"\n"

                print >> f1, self.doAprioriFlagging(msName)
                print >> f1, self.generateWVRCalTable(msName)
                print >> f1, "es.wvr_stat(ms1='"+msName+"', refAnt='"+myRefAnt+"', qa2_output_dir='./')\n"

                f1.close()

        if step == 'softreg':

            msNamesDir = []

            for msName in msNames:

                mystepdict = {}
                mystepindent = "  "

                #msName = re.search('uid___[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9]+\.ms', msNames[i])
                #if msName == None: sys.exit('ERROR: '+msNames[i]+' does not seem to be a standard ms.')
                #msName = msName.group(0)
                #if os.path.exists(msName) == False: sys.exit('ERROR: '+msNames[i]+' does not seem to exist in the current directory.')

                if run == True:
                    os.chdir(currDir)
                    subDir = 'EB'+str(msNames.index(msName))+'_'+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]
                    os.mkdir(subDir)
                    msNamesDir.append(subDir)
#                    os.system('mv '+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+'* '+subDir)
                    os.system('mv '+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+'.* '+subDir)
                    os.chdir(subDir)

                tsysmap = ''
                if re.search('^3.3', casadef.casa_version) == None and useLocalAlmaHelper == True:
                    os.system('rm -Rf '+msName+'.tsys.temp')
                    gencal(vis = msName, caltable = msName+'.tsys.temp', caltype = 'tsys')
                    tsysmap = tsysspwmap(vis = msName, tsystable = msName+'.tsys.temp', tsysChanTol=tsysChanTol)
                    os.system('rm -Rf '+msName+'.tsys.temp')
                    vm = ValueMapping(msName)
                    spwInfo = self.getSpwInfo(msName)
                    spwIds = sorted(spwInfo.keys())
                    for j in spwIds:
#                        if tsysmap[j] == -1:
                        spwIntents = vm.getIntentsForSpw(tsysmap[j])
                        if 'CALIBRATE_ATMOSPHERE#ON_SOURCE' not in spwIntents:
                            sys.exit('ERROR: INCOMPLETE TSYS SPW MAPPING!')

                f1 = open(msName+'.scriptForSoftwareCheckout.py', 'w')
                print >> f1, "import re\n"
                print >> f1, "es = aU.stuffForScienceDataReduction() \n\n"
                print >> f1, "if re.search('^"+re.findall('^[0-9]+.[0-9]+.[0-9]+', casadef.casa_version)[0]+"', casadef.casa_version) == None:"
                print >> f1, " sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: "+re.findall('^[0-9]+.[0-9]+', casadef.casa_version)[0]+"')\n\n"

                tempStdout = sys.stdout
                sys.stdout = f1
                self.listOfIntentsWithSources(msName)
                sys.stdout = tempStdout

                myRefAnt = refant
                if myRefAnt == '': myRefAnt = self.getRefAntenna(msName)
                print >> f1, "\n# Using reference antenna = "+myRefAnt+"\n"

                print >> f1, 'print "# A priori calibration"\n'
                stext = self.runFixPlanets(msName)
                if stext != None: self.addReducScriptStep(f1, mystepdict, "Running fixplanets on fields with 0,0 coordinates", stext, mystepindent)

                stext = "os.system('rm -rf %s.listobs')\n" %(msName) # Added by CLB
                stext += "listobs(vis = '"+msName+"',\n  listfile = '"+msName+".listobs')\n\n" # Modified by CLB
                stext += "f = open('"+msName+".listobs')\nfc = f.read()\nf.close()\n\n"
                stext += "scanList = re.findall('(?<=[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9] - [0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]).*', fc)\nf = open('"+msName+".scanlist', 'w')\nf.write(repr(scanList))\nf.close()\n\n"
                stext += "spwList = re.findall('.*ALMA_RB_[0-9]{2}#BB_[0-9]#SW-[0-9]{2}#.*', fc)\nf = open('"+msName+".spwlist', 'w')\nf.write(repr(spwList))\nf.close()\n\n"
                self.addReducScriptStep(f1, mystepdict, "listobs", stext, mystepindent)

                stext = "tos1 = aU.timeOnSource('"+msName+"')\n\nf = open('"+msName+".timeonsource', 'w')\nf.write(repr(tos1))\nf.close()\n\n"
                self.addReducScriptStep(f1, mystepdict, "timeOnSource", stext, mystepindent)

                stext = "tempStdout = sys.stdout\n\nsys.stdout = open('"+msName+".sbgains1', 'w')\nSBinfo = aU.plotSBGain('"+msName+"', doplot = False)\n\nsys.stdout = tempStdout\n\n"
                stext += "f = open('"+msName+".sbgains', 'w')\nf.write(repr(SBinfo))\nf.close()\n\n"
                self.addReducScriptStep(f1, mystepdict, "SB gains", stext, mystepindent)

                stext = "ptgResults = aU.plotPointingResultsFromASDM('"+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+"', doplot=False, thresholdArcsec=10.0, fractionOfScansBad=0.6)"
                stext += "\n\nf = open('"+msName+".pointingresults', 'w')\nf.write(repr(ptgResults))\nf.close()\n\n"
                self.addReducScriptStep(f1, mystepdict, "Pointing results", stext, mystepindent)

                stext = self.doAprioriFlagging(msName)
                self.addReducScriptStep(f1, mystepdict, "A priori flagging", stext, mystepindent)

                stext = "es.saveFlagStats('"+msName+"', name='after a priori flagging', statsFile='"+msName+".flagstats')"
                self.addReducScriptStep(f1, mystepdict, "Saving flag stats after a priori flagging", stext, mystepindent)

                wvrCalTableName = []
                stext = self.generateWVRCalTable(msName, wvrCalTableName, refant=myRefAnt, doplot=False)
                if stext != '':
                    stext += "wvrInfo = es.readWvrgcalOutput('"+msName+".wvrgcal')\n\nf = open('"+msName+".wvrgcal2', 'w')\nf.write(repr(wvrInfo))\nf.close()\n\n"
                    stext += "#es.wvr_stat(ms1='"+msName+"', refAnt='"+myRefAnt+"', qa2_output_dir='./')\n\n"
                self.addReducScriptStep(f1, mystepdict, "Generation and time averaging of the WVR cal table", stext, mystepindent)

                tsysCalTableName = []
                stext = self.generateTsysCalTable(msName, tsysCalTableName, doplot=False)
                stext += "tempStdout = sys.stdout\n\nsys.stdout = open('"+msName+".negativetsys', 'w')\naU.detectNegativeTsys('"+msName+"', edge=8)\n\n"
                stext += "sys.stdout = open('"+msName+".negativetrec', 'w')\naU.detectNegativeTrx('"+msName+"', edge=8)\n\nsys.stdout = tempStdout\n\n"
                stext += "mydict = aU.plotbandpass('"+tsysCalTableName[0]+"', interactive=False, channeldiff=6)\n\n"
                stext += "f = open('"+tsysCalTableName[0]+".platforming', 'w')\nf.write(repr(mydict['platforming']))\nf.close()\n\n"
                self.addReducScriptStep(f1, mystepdict, "Generation of the Tsys cal table", stext, mystepindent)

                stext = self.applyAprioriCalTables(msName, tsys=tsysCalTableName[0], wvr=wvrCalTableName[0], tsysmap=tsysmap)
                self.addReducScriptStep(f1, mystepdict, "Application of the WVR and Tsys cal tables", stext, mystepindent)

                stext = "es.saveFlagStats('"+msName+"', name='after applying WVR and Tsys cal tables', statsFile='"+msName+".flagstats')"
                self.addReducScriptStep(f1, mystepdict, "Saving flag stats after applying WVR and Tsys cal tables", stext, mystepindent)

                stext = self.split2(msName, splitMyScienceSpw=True, timebin=timeBinForFinalData)
                self.addReducScriptStep(f1, mystepdict, "Split out science SPWs and time average", stext, mystepindent)

                print >> f1, 'print "# Calibration"\n'
                stext = self.doInitialFlagging(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True)
                self.addReducScriptStep(f1, mystepdict, "Initial flagging", stext, mystepindent)

                stext = "es.saveFlagStats('"+msName+".split', name='after initial flagging', statsFile='"+msName+".flagstats')"
                self.addReducScriptStep(f1, mystepdict, "Saving flag stats after initial flagging", stext, mystepindent)

                stext = self.runSetjy(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True)
                self.addReducScriptStep(f1, mystepdict, "Putting a model for the flux calibrator(s)", stext, mystepindent)
                bpassCalTableName = []
                stext = self.doBandpassCalibration(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True, refant=myRefAnt, calTableName=bpassCalTableName, lowSNR=lowSNR, doplot=False)
                stext += "mydict = aU.plotbandpass('"+bpassCalTableName[0]+"', interactive=False, channeldiff=6)\n\n"
                stext += "f = open('"+bpassCalTableName[0]+".platforming', 'w')\nf.write(repr(mydict['platforming']))\nf.close()\n\n"
                self.addReducScriptStep(f1, mystepdict, "Bandpass calibration", stext, mystepindent)
                stext = self.doGainCalibration(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True, refant=myRefAnt, bandpass=bpassCalTableName[0], doplot=False, calFieldsOnly=False)
                stext += "sys.stdout = open('"+msName+".delayjumps', 'w')\nes.detectDelayJumps(msname = '"+msName+"')\n\nsys.stdout = tempStdout\n\n"
                self.addReducScriptStep(f1, mystepdict, "Gain calibration", stext, mystepindent)

                stext = self.applyBandpassAndGainCalTables(msName, msName1=msName+'.split', bandpass=bpassCalTableName[0], phaseForCal=msName+'.split.phase_int', phaseForSci=msName+'.split.phase_inf', flux=msName+'.split.flux_inf')
                self.addReducScriptStep(f1, mystepdict, "Application of the bandpass and gain cal tables", stext, mystepindent)

                stext = "es.saveFlagStats('"+msName+".split', name='after applying bandpass and gain cal tables', statsFile='"+msName+".flagstats')"
                self.addReducScriptStep(f1, mystepdict, "Saving flag stats after applying bandpass and gain cal tables", stext, mystepindent)

                if runPhaseClosure == True:
                    stext = "clos1 = aU.phaseClosureStats('"+msName+"', chanEdge = 0.4)\n\nf = open('"+msName+".phaseclosure', 'w')\nf.write(repr(clos1))\nf.close()\n\n"
                    self.addReducScriptStep(f1, mystepdict, "Check of phase closures (on bandpass calibrator scan)", stext, mystepindent)

                stext = "es.analyseSoftregOutputs('"+msName+"')"
                self.addReducScriptStep(f1, mystepdict, "Final assessment", stext, mystepindent)

                self.prependReducScriptHeader(f1, mystepdict, "Calibration", mystepindent)

                f1.close()

                print "\n\nName of generated script -> "+msName+".scriptForSoftwareCheckout.py"

            if run == True:
                for msName in msNames:
                    os.chdir(os.path.join(currDir, msNamesDir[msNames.index(msName)]))
                    clearstat()
                    subprocess.call(['casapy', '-r', casadef.casa_version, '--nologger', '-c', msName+'.scriptForSoftwareCheckout.py'])

        if step in ['calib', 'all']:

            msNamesDir = []

            for msName in msNames:

                mystepdict = {}
                mystepindent = "  "

                #msName = re.search('uid___[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9]+\.ms', msNames[i])
                #if msName == None: sys.exit('ERROR: '+msNames[i]+' does not seem to be a standard ms.')
                #msName = msName.group(0)
                #if os.path.exists(msName) == False: sys.exit('ERROR: '+msNames[i]+' does not seem to exist in the current directory.')

                if run == True:
                    os.chdir(currDir)
                    subDir = 'EB'+str(msNames.index(msName))+'_'+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]
                    os.mkdir(subDir)
                    msNamesDir.append(subDir)
#                    os.system('mv '+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+'* '+subDir)
                    os.system('mv '+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+'.* '+subDir)
                    os.chdir(subDir)

                tsysmap = ''
                if re.search('^3.3', casadef.casa_version) == None and skipSyscalChecks == False:

                    print "\n*** ANALYSIS OF TSYS TABLE ***"

                    print "\n*** SEARCH FOR NEGATIVE TSYS ***"
                    detectNegativeTsys(vis = msName, edge = 8, showfield = True)

                    print "\n*** SEARCH FOR NEGATIVE TREC ***"
                    detectNegativeTrx(vis = msName, edge = 8, showfield = True)

                    os.system('rm -Rf '+msName+'.tsys.temp')
                    gencal(vis = msName, caltable = msName+'.tsys.temp', caltype = 'tsys')

                    print "\n*** SEARCH FOR MISSING SCANS IN SYSCAL TABLE ***"

                    msmd.open(msName)
                    scans1 = sorted(msmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE').tolist())
                    msmd.close()

                    tb.open(msName+'.tsys.temp')                    
                    scans2 = sorted(np.unique(tb.getcol('SCAN_NUMBER')).tolist())
                    tb.close()

                    if len(scans1) == 0 or len(scans2) == 0 or scans1 != scans2:
                        sys.exit('ERROR: THE SYSCAL TABLE IS MISSING ONE (OR MORE) SCAN(S). IT MAY BE NECESSARY TO RE-GENERATE IT.')
                    else:
                        print "-> OK"

                    if useLocalAlmaHelper == True:
                        tsysmap = tsysspwmap(vis = msName, tsystable = msName+'.tsys.temp', tsysChanTol=tsysChanTol)
                        vm = ValueMapping(msName)
                        spwInfo = self.getSpwInfo(msName)
                        spwIds = sorted(spwInfo.keys())
                        for j in spwIds:
#                        if tsysmap[j] == -1:
                            spwIntents = vm.getIntentsForSpw(tsysmap[j])
                            if 'CALIBRATE_ATMOSPHERE#ON_SOURCE' not in spwIntents:
                                sys.exit('ERROR: INCOMPLETE TSYS SPW MAPPING!')

                    os.system('rm -Rf '+msName+'.tsys.temp')


                f1 = open(msName+'.scriptForCalibration.py', 'w')
                print >> f1, "import re\n"
                print >> f1, "import os\n"
                print >> f1, "if applyonly != True: es = aU.stuffForScienceDataReduction() \n\n"
                print >> f1, "if re.search('^"+re.findall('^[0-9]+.[0-9]+.[0-9]+', casadef.casa_version)[0]+"', casadef.casa_version) == None:"
                print >> f1, " sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: "+re.findall('^[0-9]+.[0-9]+', casadef.casa_version)[0]+"')\n\n"

                tempStdout = sys.stdout
                sys.stdout = f1
                self.listOfIntentsWithSources(msName)
                sys.stdout = tempStdout

                myRefAnt = refant
                if myRefAnt == '': myRefAnt = self.getRefAntenna(msName)
                print >> f1, "\n# Using reference antenna = "+myRefAnt+"\n"

                stext = "if os.path.exists('"+msName+"') == False:\n"
                stext += "  importasdm('"+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+"', asis='"+asis1+"')"
                stext += "\nif applyonly != True: es.fixForCSV2555('"+msName+"')"
                self.addReducScriptStep(f1, mystepdict, "Import of the ASDM", stext, mystepindent, applyonly=True)

                stext = "from recipes.almahelpers import fixsyscaltimes\nfixsyscaltimes(vis = '"+msName+"')"
                self.addReducScriptStep(f1, mystepdict, "Fix of SYSCAL table times", stext, mystepindent, applyonly=True)

                print >> f1, 'print "# A priori calibration"\n'
                stext = self.runFixPlanets(msName)
                if stext != None: self.addReducScriptStep(f1, mystepdict, "Running fixplanets on fields with 0,0 coordinates", stext, mystepindent, applyonly=True)

                stext = "os.system('rm -rf %s.listobs')\n" %(msName) # Added by CLB
                stext += "listobs(vis = '"+msName+"',\n  listfile = '"+msName+".listobs')\n\n" # Modified by CLB
                self.addReducScriptStep(f1, mystepdict, "listobs", stext, mystepindent)
                stext = self.doAprioriFlagging(msName)
                self.addReducScriptStep(f1, mystepdict, "A priori flagging", stext, mystepindent)
                wvrCalTableName = []
                stext = self.generateWVRCalTable(msName, wvrCalTableName, refant=myRefAnt)
                self.addReducScriptStep(f1, mystepdict, "Generation and time averaging of the WVR cal table", stext, mystepindent)
                tsysCalTableName = []
                stext = self.generateTsysCalTable(msName, tsysCalTableName)
                self.addReducScriptStep(f1, mystepdict, "Generation of the Tsys cal table", stext, mystepindent)

                if corrAntPos == True:
                    stext = self.correctMyAntennaPositions(msName)
                    if stext != None:
                        self.addReducScriptStep(f1, mystepdict, "Generation of the antenna position cal table", stext, mystepindent)
                        stext = self.applyAprioriCalTables(msName, tsys=tsysCalTableName[0], wvr=wvrCalTableName[0], antpos=msName+'.antpos', tsysmap=tsysmap, tsysChanTol=tsysChanTol)
                        self.addReducScriptStep(f1, mystepdict, "Application of the WVR, Tsys and antpos cal tables", stext, mystepindent, applyonly=True)
                    else:
                        stext = self.applyAprioriCalTables(msName, tsys=tsysCalTableName[0], wvr=wvrCalTableName[0], tsysmap=tsysmap, tsysChanTol=tsysChanTol)
                        self.addReducScriptStep(f1, mystepdict, "Application of the WVR and Tsys cal tables", stext, mystepindent, applyonly=True)
                else:
                    stext = self.applyAprioriCalTables(msName, tsys=tsysCalTableName[0], wvr=wvrCalTableName[0], tsysmap=tsysmap, tsysChanTol=tsysChanTol)
                    self.addReducScriptStep(f1, mystepdict, "Application of the WVR and Tsys cal tables", stext, mystepindent, applyonly=True)

                stext = self.split2(msName, splitMyScienceSpw=True, timebin=timeBinForFinalData)
                self.addReducScriptStep(f1, mystepdict, "Split out science SPWs and time average", stext, mystepindent, applyonly=True)

                print >> f1, 'print "# Calibration"\n'
                stext = "os.system('rm -rf %s.split.listobs')\n" % (msName) # Added by CLB
                # following line changed to += by CLB
                stext += "listobs(vis = '"+msName+".split',\n  listfile = '"+msName+".split.listobs')\n\n" \
                    + self.clearPointingTable(msName+'.split') \
                    + self.saveFlags(msName+'.split', name='Original')
                self.addReducScriptStep(f1, mystepdict, "Listobs, clear pointing table, and save original flags", stext, mystepindent)
                stext = self.doInitialFlagging(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True)
                self.addReducScriptStep(f1, mystepdict, "Initial flagging", stext, mystepindent)
                stext = self.runSetjy(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True)
                self.addReducScriptStep(f1, mystepdict, "Putting a model for the flux calibrator(s)", stext, mystepindent)
                stext = self.saveFlags(msName+'.split', name='BeforeBandpassCalibration')
                self.addReducScriptStep(f1, mystepdict, "Save flags before bandpass cal", stext, mystepindent, applyonly=True)
                bpassCalTableName = []
                stext = self.doBandpassCalibration(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True, refant=myRefAnt, calTableName=bpassCalTableName, lowSNR=lowSNR)
                self.addReducScriptStep(f1, mystepdict, "Bandpass calibration", stext, mystepindent)
                stext = self.saveFlags(msName+'.split', name='BeforeGainCalibration')
                self.addReducScriptStep(f1, mystepdict, "Save flags before gain cal", stext, mystepindent, applyonly=True)
                phaseOffsetCalTableName = []
                stext = self.doGainCalibration(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True, refant=myRefAnt, bandpass=bpassCalTableName[0], phaseOffsetCalTableName=phaseOffsetCalTableName)
                self.addReducScriptStep(f1, mystepdict, "Gain calibration", stext, mystepindent)
                stext = self.saveFlags(msName+'.split', name='BeforeApplycal')
                self.addReducScriptStep(f1, mystepdict, "Save flags before applycal", stext, mystepindent, applyonly=True)
# to be removed once we move to CASA4.2
#                 stext = "\nif applyonly == True:\n  flagmanager(vis = '"+msName+".split',\n    mode = 'restore',\n    versionname = 'BeforeApplycal')\n\n"
#                 self.addReducScriptStep(f1, mystepdict, "Restore flags before applycal", stext, mystepindent, applyonly=True)
                stext = self.applyBandpassAndGainCalTables(msName, msName1=msName+'.split', bandpass=bpassCalTableName[0], phaseForCal=msName+'.split.phase_int', phaseForSci=msName+'.split.phase_inf', flux=msName+'.split.flux_inf', phaseOffsetCalTableName=phaseOffsetCalTableName)
                self.addReducScriptStep(f1, mystepdict, "Application of the bandpass and gain cal tables", stext, mystepindent, applyonly=True)

                stext = self.split2(msName, msName1=msName+'.split', outMsName=msName+'.split.cal')
                self.addReducScriptStep(f1, mystepdict, "Split out corrected column", stext, mystepindent, applyonly=True)

                self.prependReducScriptHeader(f1, mystepdict, "Calibration", mystepindent)

                f1.close()

            if run == True:
                for msName in msNames:
                    os.chdir(os.path.join(currDir, msNamesDir[msNames.index(msName)]))
                    clearstat()
                    subprocess.call(['casapy', '-r', casadef.casa_version, '--nologger', '-c', msName+'.scriptForCalibration.py'])

        if step == 'fluxcal':

            if os.path.exists('allFluxes.txt') == False:
                self.generateFluxFile(msNames)
            else:
                print 'File allFluxes.txt already exists, it will be loaded.'

            myRefAnt = refant # note: no need to run getRefAntenna because it will be called in doFluxCalibration if refant=''
            f1 = open('scriptForFluxCalibration.py', 'w')
            print >> f1, "import re\n"
            print >> f1, "if re.search('^"+re.findall('^[0-9]+.[0-9]+.[0-9]+', casadef.casa_version)[0]+"', casadef.casa_version) == None:"
            print >> f1, " sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: "+re.findall('^[0-9]+.[0-9]+', casadef.casa_version)[0]+"')\n\n"
            print >> f1, self.doFluxCalibration(msNames, refant=myRefAnt)
            f1.close()

            if run == True:
                clearstat()
                subprocess.call(['casapy', '-r', casadef.casa_version, '--nologger', '-c', 'scriptForFluxCalibration.py'])

        if step == 'imaging':

            if len(msNames) > 1: sys.exit('ERROR: the script generator does not support (yet) imaging of multiple datasets.')
            msNames = msNames[0]

            f1 = open('scriptForImaging.py', 'w')
            print >> f1, "import re\n"
            print >> f1, "if re.search('^"+re.findall('^[0-9]+.[0-9]+.[0-9]+', casadef.casa_version)[0]+"', casadef.casa_version) == None:"
            print >> f1, " sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: "+re.findall('^[0-9]+.[0-9]+', casadef.casa_version)[0]+"')\n\n"
            print >> f1, self.runCleanOnSource(msNames, chanWid=chanWid, angScale=angScale)
            f1.close()

        if step == 'calsurvey':

            mystepdict = {}
            mystepindent = "  "

            for msName in msNames:

                #msName = re.search('uid___[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9]+\.ms', msNames[i])
                #if msName == None: sys.exit('ERROR: '+msNames[i]+' does not seem to be a standard ms.')
                #msName = msName.group(0)
                #if os.path.exists(msName) == False: sys.exit('ERROR: '+msNames[i]+' does not seem to exist in the current directory.')

                tsysmap = ''
                if re.search('^3.3', casadef.casa_version) == None and skipSyscalChecks == False:

                    print "\n*** ANALYSIS OF TSYS TABLE ***"

                    print "\n*** SEARCH FOR NEGATIVE TSYS ***"
                    detectNegativeTsys(vis = msName, edge = 8, showfield = True)

                    print "\n*** SEARCH FOR NEGATIVE TREC ***"
                    detectNegativeTrx(vis = msName, edge = 8, showfield = True)

                    os.system('rm -Rf '+msName+'.tsys.temp')
                    gencal(vis = msName, caltable = msName+'.tsys.temp', caltype = 'tsys')

                    print "\n*** SEARCH FOR MISSING SCANS IN SYSCAL TABLE ***"

                    msmd.open(msName)
                    scans1 = msmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
                    msmd.close()

                    tb.open(msName+'.tsys.temp')                    
                    scans2 = np.unique(tb.getcol('SCAN_NUMBER'))
                    tb.close()

                    if (scans1 == scans2).all():
                        print "-> OK"
                    else:
                        sys.exit('ERROR: THE SYSCAL TABLE IS MISSING ONE (OR MORE) SCAN(S). IT MAY BE NECESSARY TO RE-GENERATE IT.')

                    if useLocalAlmaHelper == True:
                        tsysmap = tsysspwmap(vis = msName, tsystable = msName+'.tsys.temp', tsysChanTol=tsysChanTol)
                        vm = ValueMapping(msName)
                        spwInfo = self.getSpwInfo(msName)
                        spwIds = sorted(spwInfo.keys())
                        for j in spwIds:
#                        if tsysmap[j] == -1:
                            spwIntents = vm.getIntentsForSpw(tsysmap[j])
                            if 'CALIBRATE_ATMOSPHERE#ON_SOURCE' not in spwIntents:
                                sys.exit('ERROR: INCOMPLETE TSYS SPW MAPPING!')

                    os.system('rm -Rf '+msName+'.tsys.temp')

                f1 = open(msName+'.scriptForCalibration.py', 'w')
                print >> f1, "import re\n"
                print >> f1, "es = aU.stuffForScienceDataReduction() \n\n"
                print >> f1, "if re.search('^"+re.findall('^[0-9]+.[0-9]+.[0-9]+', casadef.casa_version)[0]+"', casadef.casa_version) == None:"
                print >> f1, " sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: "+re.findall('^[0-9]+.[0-9]+', casadef.casa_version)[0]+"')\n\n"

                myRefAnt = refant
                if myRefAnt == '': myRefAnt = self.getRefAntenna(msName)
                print >> f1, "# Using reference antenna = "+myRefAnt+"\n"

                print >> f1, 'print "# A priori calibration"\n'
                stext = self.runFixPlanets(msName)
                if stext != None: self.addReducScriptStep(f1, mystepdict, "Running fixplanets on fields with 0,0 coordinates", stext, mystepindent)

                stext = "os.system('rm -rf %s.listobs')\n" %(msName) # Added by CLB
                stext += "listobs(vis = '"+msName+"',\n  listfile = '"+msName+".listobs')\n\n" # Modified by CLB
                self.addReducScriptStep(f1, mystepdict, "listobs", stext, mystepindent)
                stext = self.doAprioriFlagging(msName)
                self.addReducScriptStep(f1, mystepdict, "A priori flagging", stext, mystepindent)
                wvrCalTableName = []
                stext = self.generateWVRCalTable(msName, wvrCalTableName)
                self.addReducScriptStep(f1, mystepdict, "Generation and time averaging of the WVR cal table", stext, mystepindent)
                tsysCalTableName = []
                stext = self.generateTsysCalTable(msName, tsysCalTableName)
                self.addReducScriptStep(f1, mystepdict, "Generation of the Tsys cal table", stext, mystepindent)

                if corrAntPos == True:
                    stext = self.correctMyAntennaPositions(msName)
                    self.addReducScriptStep(f1, mystepdict, "Generation of the antenna position cal table", stext, mystepindent)
                    stext = self.applyAprioriCalTables(msName, tsys=tsysCalTableName[0], wvr=wvrCalTableName[0], antpos=msName+'.antpos', tsysmap=tsysmap)
                    self.addReducScriptStep(f1, mystepdict, "Application of the WVR, Tsys and antpos cal tables", stext, mystepindent)
                else:
                    stext = self.applyAprioriCalTables(msName, tsys=tsysCalTableName[0], wvr=wvrCalTableName[0])
                    self.addReducScriptStep(f1, mystepdict, "Application of the WVR and Tsys cal tables", stext, mystepindent)

                stext = self.split2(msName, splitMyScienceSpw=True, timebin=timeBinForFinalData)
                self.addReducScriptStep(f1, mystepdict, "Split out science SPWs and time average", stext, mystepindent)

                print >> f1, 'print "# Calibration"\n'
                stext = "os.system('rm -rf %s.split.listobs')\n" % (msName) # Added by CLB
                # following line changed to += by CLB
                stext += "listobs(vis = '"+msName+".split',\n  listfile = '"+msName+".split.listobs')\n\n" \
                    + self.clearPointingTable(msName+'.split') \
                    + self.saveFlags(msName+'.split', name='Original')
                self.addReducScriptStep(f1, mystepdict, "Listobs, clear pointing table, and save original flags", stext, mystepindent)
                stext = self.doInitialFlagging(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True)
                self.addReducScriptStep(f1, mystepdict, "Initial flagging", stext, mystepindent)
                stext = self.runSetjy(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True)
                self.addReducScriptStep(f1, mystepdict, "Putting a model for the flux calibrator(s)", stext, mystepindent)
                stext = self.saveFlags(msName+'.split', name='BeforeBandpassCalibration')
                self.addReducScriptStep(f1, mystepdict, "Save flags before bandpass cal", stext, mystepindent)
                bpassCalTableName = []
                stext = self.doBandpassCalibration(msName, msName1=msName+'.split', bpassCalId=bpassCalId, iHaveSplitMyScienceSpw=True, refant=myRefAnt, calTableName=bpassCalTableName)
                self.addReducScriptStep(f1, mystepdict, "Bandpass calibration", stext, mystepindent)
                stext = self.saveFlags(msName+'.split', name='BeforeGainCalibration')
                self.addReducScriptStep(f1, mystepdict, "Save flags before gain cal", stext, mystepindent)
                stext = self.doGainCalibration(msName, msName1=msName+'.split', iHaveSplitMyScienceSpw=True, refant=myRefAnt, bandpass=bpassCalTableName[0], gaintypeForAmp='T')
                self.addReducScriptStep(f1, mystepdict, "Gain calibration", stext, mystepindent)

                self.prependReducScriptHeader(f1, mystepdict, "Calibration", mystepindent)

                f1.close()

            if run == True:
                for msName in msNames:
                    clearstat()
                    subprocess.call(['casapy', '-r', casadef.casa_version, '--nologger', '-c', msName+'.scriptForCalibration.py'])

        if step == 'SDeff':

            msNamesDir = []

            for msName in msNames:

                if run == True:
                    os.chdir(currDir)
                    subDir = 'EB'+str(msNames.index(msName))+'_'+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]
                    os.mkdir(subDir)
                    msNamesDir.append(subDir)
#                    os.system('mv '+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+'* '+subDir)
                    os.system('mv '+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+'.* '+subDir)
                    os.chdir(subDir)

                fieldNames = self.getIntentsAndSourceNames(msName)['OBSERVE_TARGET']['name']
                fieldNames = sorted(dict.fromkeys(fieldNames).keys())
                if len(fieldNames) != 1: sys.exit('ERROR: Unexpected number of fields.')
                fieldNames = fieldNames[0]
                if fieldNames.upper() in ['VENUS', 'MARS', 'JUPITER', 'URANUS', 'NEPTUNE', 'IO', 'EUROPA', 'GANYMEDE', 'CALLISTO', 'TITAN', 'CERES', 'JUNO', 'PALLAS', 'VESTA', 'HYGEIA']:
                    print 'Observation type = SSO'
                    sdEffType = 'SSO'
                else:
                    print 'Observation type = QSO'
                    sdEffType = 'QSO'

                tb.open(msName+'/OBSERVATION')
                obsTimeRange = tb.getcol('TIME_RANGE')
                obsTime = (obsTimeRange[0]+obsTimeRange[1])/2.0
                obsTime = ((obsTime/86400.0)+2400000.5-2440587.5)*86400.0
                obsTime = timeUtilities.strftime('%Y-%m-%dT%H:%M:%S', timeUtilities.gmtime(obsTime))
                tb.close()

                mystepdict = {}
                mystepindent = "  "

                f1 = open(msName+'.scriptForSDefficiencies.py', 'w')
                print >> f1, "import re\n"
                print >> f1, "es = aU.stuffForScienceDataReduction()\n"
                print >> f1, "import analysisUtilsForSD as aUsd\n\n"
                print >> f1, "if re.search('^"+re.findall('^[0-9]+.[0-9]+.[0-9]+', casadef.casa_version)[0]+"', casadef.casa_version) == None:"
                print >> f1, " sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: "+re.findall('^[0-9]+.[0-9]+', casadef.casa_version)[0]+"')\n\n"

                asdmName1 = re.findall('^uid___[0-9a-z]+_[0-9a-z]+_[0-9a-z]+', msName, re.IGNORECASE)[0]

                stext = "aUsd.continuumReducer2('"+asdmName1+"')"
                self.addReducScriptStep(f1, mystepdict, "Make continuum images", stext, mystepindent)

                tb.open(msName+'/ANTENNA')
                antNames = tb.getcol('NAME')
                tb.close()

                antNames1 = []
                for i in antNames:
                    if re.search('^CM[0-9]+', i) == None: antNames1.append(i)
                if len(antNames1) == 0: sys.exit('ERROR: No antenna to process.')

                vm = ValueMapping(msName)
                sciScans = vm.getScansForIntent('OBSERVE_TARGET#ON_SOURCE').tolist()
                sciScans = [str(i) for i in sciScans]
                sciScans = ','.join(sciScans)

                weatherInfo = {}
                for i in antNames1:
                    weatherInfo[i] = getWeather(msName, antenna=i, scan=sciScans)[0]

                spwInfo = self.getSpwInfo(msName)
                spwIds = sorted(spwInfo.keys())

                stext = ''

                for i in antNames1:
                    for j in spwIds:

                        msName1 = asdmName1 + '.' + i + '.cal.ms'
                        imgName1 = asdmName1 + '.' + i + '.SPW' + str(j) + '.SF.im'

                        stext += "aUsd.SdImDWtApp(ms_SD = '"+msName1+"',\n  im_SD = '"+imgName1+"',\n  outimage = '"+imgName1+".wt',\n  spwid = "+str(j)+",\n  gridfunc = 'SF')\n"

                    stext += '\n'

                self.addReducScriptStep(f1, mystepdict, "Mitigating noisy effect at edge of SD image", stext, mystepindent)

                if sdEffType == 'SSO':

                    stext = 'ssoParams = {}\n\n'

                    for i in antNames1:

                        msName1 = asdmName1 + '.' + i + '.cal.ms'

                        stext += "ssoParams['"+i+"'] = {}\n"
                        stext += "s = aUsd.sso_params('"+msName1+"')\n\n"

                        stext += "for i in "+str(spwIds)+":\n\n"
                        stext += "  s.setSpwId(int(i))\n"
                        stext += "  s.doCalc()\n"
                        stext += "  ssoResults = s.getResults()\n\n"
                        stext += "  ssoParams['"+i+"'][i] = {}\n"
                        stext += "  ssoParams['"+i+"'][i]['eqsize'] = ( ssoResults['Apparent Size'][0][0] + ssoResults['Apparent Size'][1][0] ) / 2.\n"
                        stext += "  ssoParams['"+i+"'][i]['psize'] = ( ssoResults['Apparent Size'][0][1] + ssoResults['Apparent Size'][1][1] ) / 2.\n"
                        stext += "  ssoParams['"+i+"'][i]['pnang'] = ( ssoResults['Apparent Size'][0][2] + ssoResults['Apparent Size'][1][2] ) / 2.\n"
                        stext += "  ssoParams['"+i+"'][i]['btemp'] = ( ssoResults['Brightness Temperature'][0] + ssoResults['Brightness Temperature'][1] ) / 2.\n\n"

                    stext += "f = open('"+msName+".ssoParams.txt', 'w')\n"
                    stext += "print >> f, ssoParams\n"
                    stext += "f.close()\n\n"

                    self.addReducScriptStep(f1, mystepdict, "Obtain apparent size and brightness temperature for Solar system object", stext, mystepindent)

                stext = 'sdEffs = {}\n\n'

                for i in antNames1:

                    msName1 = asdmName1 + '.' + i + '.cal.ms'

                    stext += "for i in "+str(spwIds)+":\n\n"
                    stext += "  a = aUsd.analysis_sdim('"+asdmName1+"."+i+".SPW'+str(i)+'.SF.im.wt')\n"

                    if sdEffType == 'SSO':
                        stext += "  a.setSSOParams(eqsize = ssoParams['"+i+"'][i]['eqsize'],\n    psize = ssoParams['"+i+"'][i]['psize'],\n    pnang = ssoParams['"+i+"'][i]['pnang'],\n    btemp = ssoParams['"+i+"'][i]['btemp'])\n"
                        stext += "  a.doSSOAnalysis(antbeam = True)\n"
                        stext += "  results = a.getSSOResults()\n"
                        stext += "  #a.showSSOModel()\n"
                        stext += "  #a.showSSOResults()\n\n"
                    else:
                        stext += "  a.setQSOFlux("+str(sdQSOflux)+")\n"
                        stext += "  a.doQSOAnalysis()\n"
                        stext += "  results = a.getQSOResults()\n"
                        stext += "  #a.showSdBeam()\n\n"

                    stext += "  ij = len(sdEffs)\n"
                    stext += "  sdEffs[ij] = {}\n"
                    stext += "  sdEffs[ij]['execBlockUid'] = '"+asdmName1+"'\n"
                    stext += "  sdEffs[ij]['obsTime'] = '"+obsTime+"'\n"
                    stext += "  sdEffs[ij]['antennaName'] = '"+i+"'\n"
                    stext += "  sdEffs[ij]['spwId'] = i\n"
                    stext += "  sdEffs[ij]['frequency'] = results['Frequency']/1e9\n"
                    stext += "  sdEffs[ij]['meanElevation'] = "+str(weatherInfo[i]['elevation'])+"\n"
                    stext += "  sdEffs[ij]['meanTemp'] = "+str(weatherInfo[i]['temperature'])+"\n"
                    stext += "  sdEffs[ij]['meanWindSpeed'] = "+str(weatherInfo[i]['windspeed'])+"\n"
                    stext += "  sdEffs[ij]['effectiveBeamSize'] = results['Effective Beam Size'].tolist()\n"
                    stext += "  sdEffs[ij]['mainBeamEfficiency'] = results['Main Beam Efficiency']\n\n"

                stext += "f = open('"+msName+".sdEfficiencies.txt', 'w')\n"
                stext += "print >> f, sdEffs\n"
                stext += "f.close()\n\n"

                self.addReducScriptStep(f1, mystepdict, "Obtain efficiencies and (effective) beam size", stext, mystepindent)

                self.prependReducScriptHeader(f1, mystepdict, "Calculation of SD efficiencies", mystepindent)

                f1.close()

#         if step in ['SDcalib', 'SDcalibLine', 'SDcalibCont']:
        if step in ['SDcalibLine', 'SDcalibCont']:

            if casadef.casa_version < '4.2.0': sys.exit('ERROR: PLEASE USE CASA 4.2 OR LATER FOR SD DATA REDUCTION')

            msNamesDir = []

            for msName in msNames:

                mystepdict = {}
                mystepindent = "  "

                if run == True:
                    os.chdir(currDir)
                    subDir = 'EB'+str(msNames.index(msName))+'_'+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]
                    os.mkdir(subDir)
                    msNamesDir.append(subDir)
#                    os.system('mv '+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+'* '+subDir)
                    os.system('mv '+re.findall('.+(?=\.ms)', msName, re.IGNORECASE)[0]+'.* '+subDir)
                    os.chdir(subDir)

                tsysmap = ''
                if re.search('^3.3', casadef.casa_version) == None:

                    print "\n*** ANALYSIS OF TSYS TABLE ***"

                    print "\n*** SEARCH FOR NEGATIVE TSYS ***"
                    detectNegativeTsys(vis = msName, edge = 8, showfield = True)

                    print "\n*** SEARCH FOR NEGATIVE TREC ***"
                    detectNegativeTrx(vis = msName, edge = 8, showfield = True)

                    os.system('rm -Rf '+msName+'.tsys.temp')
                    gencal(vis = msName, caltable = msName+'.tsys.temp', caltype = 'tsys')

                    print "\n*** SEARCH FOR MISSING SCANS IN SYSCAL TABLE ***"

                    msmd.open(msName)
                    scans1 = msmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
                    if ('CALIBRATE_ATMOSPHERE#REFERENCE' in msmd.intents()):
                        # The presence of extra AtmCals with a REFERENCE intent will cause scans1 != scans2
                        scansWithZeroLevel = msmd.scansforintent('CALIBRATE_ATMOSPHERE#REFERENCE')
                        scans1 = np.array(sorted(list(set(scans1)-set(scansWithZeroLevel))))
                    msmd.close()

                    tb.open(msName+'.tsys.temp')                    
                    scans2 = np.unique(tb.getcol('SCAN_NUMBER'))
                    tb.close()

                    if (scans1 == scans2).all():
                        print "-> OK"
                    else:
                        print "scans1 = ", scans1
                        print "scans2 = ", scans2
                        sys.exit('ERROR: THE SYSCAL TABLE IS MISSING ONE (OR MORE) SCAN(S). IT MAY BE NECESSARY TO RE-GENERATE IT.')

                    if useLocalAlmaHelper == True:
                        tsysmap = tsysspwmap(vis = msName, tsystable = msName+'.tsys.temp', tsysChanTol=tsysChanTol)
                        vm = ValueMapping(msName)
                        spwInfo = self.getSpwInfo(msName)
                        spwIds = sorted(spwInfo.keys())
                        for j in spwIds:
#                        if tsysmap[j] == -1:
                            spwIntents = vm.getIntentsForSpw(tsysmap[j])
                            if 'CALIBRATE_ATMOSPHERE#ON_SOURCE' not in spwIntents:
                                sys.exit('ERROR: INCOMPLETE TSYS SPW MAPPING!')

                    os.system('rm -Rf '+msName+'.tsys.temp')

                f1 = open(msName+'.scriptForSDCalibration.py', 'w')
                print >> f1, "import re\n"
                print >> f1, "import filltsys\n"
                print >> f1, "es = aU.stuffForScienceDataReduction()\n"
                print >> f1, "if re.search('^"+re.findall('^[0-9]+.[0-9]+.[0-9]+', casadef.casa_version)[0]+"', casadef.casa_version) == None:"
                print >> f1, " sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: "+re.findall('^[0-9]+.[0-9]+', casadef.casa_version)[0]+"')\n\n"

                tempStdout = sys.stdout
                sys.stdout = f1
                self.listOfIntentsWithSources(msName)
                sys.stdout = tempStdout

                stext = self.runFixPlanets(msName)
                if stext != None: self.addReducScriptStep(f1, mystepdict, "Running fixplanets on fields with 0,0 coordinates", stext, mystepindent)

                stext = "os.system('rm -rf %s.listobs')\n" %(msName) # Added by CLB
                stext += "listobs(vis = '"+msName+"',\n  listfile = '"+msName+".listobs')\n\n" # Modified by CLB
                stext += "aU.getTPSampling(vis = '"+msName+"', showplot = True, plotfile = '"+msName+".sampling.png')"
                self.addReducScriptStep(f1, mystepdict, "listobs", stext, mystepindent)

                tb.open(msName+'/ANTENNA')
                antNames = tb.getcol('NAME').tolist()
                tb.close()

                if (casadef.casa_version >= '4.2.2'):

                    stext = "for i in "+str(antNames)+":\n  os.system('rm -Rf "+msName+".'+i+'*')\n\n"
                    stext += "sdsave(filename = '"+msName+"',\n  splitant = True,\n  outfile = '"+msName+".asap',\n  overwrite = True)\n\n"
                    self.addReducScriptStep(f1, mystepdict, "Split by antenna", stext, mystepindent)

                else:

                    stext = "for i in "+str(antNames)+":\n  os.system('rm -Rf "+msName+".'+i+'*')\n\n"
                    stext += "sd.splitant(filename = '"+msName+"',\n  outprefix = '"+msName+"',\n  overwrite = True)\n\n"
                    self.addReducScriptStep(f1, mystepdict, "Split by antenna", stext, mystepindent)

                asapNames = [msName+'.'+i+'.asap' for i in antNames]
                asapNames = sorted(asapNames)

                stext = ''
                for i in asapNames:
                    stext += "os.system('rm -Rf "+i+".sdlist')\n"
                    stext += "sdlist(infile = '"+i+"',\n  outfile = '"+i+".sdlist')\n\n"
                self.addReducScriptStep(f1, mystepdict, "sdlist", stext, mystepindent)

                stext = self.SDfillTsysSolutions(asapNames, msName=msName, doplot=True)
                self.addReducScriptStep(f1, mystepdict, "Filling the Tsys solutions in the dataset", stext, mystepindent)

### this will need a cleaner implementation

                spwInfo = self.getSpwInfo(msName)
                vm = ValueMapping(msName)

                chanFlags = {}

                for i in sorted(spwInfo.keys()):
                    if vm.spwInfo[i]['bandwidth'] > 1875000000:
                        chanEdge = int((vm.spwInfo[i]['numChannels'] - (1875000000. / vm.spwInfo[i]['bandwidth']) * vm.spwInfo[i]['numChannels']) / 2.)
                        maskflag = str([[0, chanEdge-1], [vm.spwInfo[i]['numChannels']-chanEdge, vm.spwInfo[i]['numChannels']-1]])
                        if maskflag not in chanFlags.keys():
                            chanFlags[maskflag] = []
                        chanFlags[maskflag].append(i)

                stext = ''

                if (casadef.casa_version >= '4.2.2'):
                    for i in asapNames:
                        for maskflag in chanFlags.keys():
                            maskflag1 = eval(maskflag)
                            maskflag2 = []
                            for j in range(len(maskflag1)):
                                maskflag2.append('~'.join([str(k) for k in maskflag1[j]]))
                            maskflag2 = ';'.join(maskflag2)
                            spwmaskflag = []
                            for j in chanFlags[maskflag]:
                                spwmaskflag.append(str(j)+':'+maskflag2)
                            spwmaskflag = ','.join(spwmaskflag)
                            stext += "sdflag(infile = '"+i+"',\n  mode = 'manual',\n  spw = '"+spwmaskflag+"',\n  overwrite = True)\n\n"
                else:
                    for i in asapNames:
                        for maskflag in chanFlags.keys():
                            stext += "sdflag2(infile = '"+i+"',\n  specunit = 'channel',\n  mode = 'manual',\n  ifs = "+str(chanFlags[maskflag])+",\n  maskflag = "+maskflag+",\n  overwrite = True)\n\n"

                self.addReducScriptStep(f1, mystepdict, "Do initial flagging", stext, mystepindent)

###

                if step == 'SDcalibLine':

                    stext = self.SDdoCalibration(asapNames, msName=msName, calmode='ps')
                    self.addReducScriptStep(f1, mystepdict, "Calibration of the data into Kelvins", stext, mystepindent)

                    asapNames = [i+'.cal' for i in asapNames]

                    stext = self.SDdoBaselineSubtraction(asapNames, msName=msName)
                    self.addReducScriptStep(f1, mystepdict, "Subtracting the baseline", stext, mystepindent)

                    asapNames = [i+'.bl' for i in asapNames]

                else:

                    stext = self.SDdoCalibration(asapNames, msName=msName, calmode='otfraster')
                    self.addReducScriptStep(f1, mystepdict, "Calibration of the data into Kelvins", stext, mystepindent)

                    asapNames = [i+'.cal' for i in asapNames]

                stext = ''
                for i in asapNames:
                    stext += "os.system('rm -Rf "+i+".ms')\n\n"
                    stext += "sdsave(infile = '"+i+"',\n  outfile = '"+i+".ms',\n  outform = 'MS2')\n\n"
                self.addReducScriptStep(f1, mystepdict, "Converting ASAP -> MS", stext, mystepindent)

                asapNames = [i+'.ms' for i in asapNames]

                spwInfo = self.getSpwInfo(msName)
                spwIds = sorted(spwInfo.keys())
                spwIds = [str(i) for i in spwIds]

                stext = ''

                if len(asapNames) > 1:
#                     for i in asapNames:
#                         stext += "os.system('rm -Rf "+i+".split')\n\n"
#                         stext += "split(vis = '"+i+"',\n  outputvis = '"+i+".split',\n  spw = '"+','.join(spwIds)+"',\n  datacolumn = 'float_data')\n\n"
#                     asapNames = [i+'.split' for i in asapNames]
                    stext += "os.system('rm -Rf "+msName+".cal')\n\n"
                    stext += "concat(vis = [ \\\n    '"+"', \\\n    '".join(asapNames)+"' ], \\\n  concatvis = '"+msName+".cal')\n\n"
#                     stext += "os.system('rm -Rf "+msName+".cal.split')\n\n"
#                     stext += "split(vis = '"+msName+".cal',\n  outputvis = '"+msName+".cal.split',\n  spw = '"+','.join(spwIds)+"',\n  datacolumn = 'float_data')\n\n"
#                 else:
#                     stext += "os.system('rm -Rf "+msName+".cal.split')\n\n"
#                     stext += "split(vis = '"+asapNames[0]+"',\n  outputvis = '"+msName+".cal.split',\n  spw = '"+','.join(spwIds)+"',\n  datacolumn = 'float_data')\n\n"

                self.addReducScriptStep(f1, mystepdict, "Split and concatenation", stext, mystepindent)

                self.prependReducScriptHeader(f1, mystepdict, "Calibration", mystepindent)

                f1.close()

            if run == True:
                for msName in msNames:
                    os.chdir(os.path.join(currDir, msNamesDir[msNames.index(msName)]))
                    clearstat()
                    subprocess.call(['casapy', '-r', casadef.casa_version, '--nologger', '-c', msName+'.scriptForSDCalibration.py'])

        # end of generateReducScript()

    def analyseSoftregOutputs(self, msName):

        f1 = open(msName + '.fullreport.txt', 'w')

        if os.path.exists(msName+'.phaseclosure'):

            print >> f1, "\n### Analysis of phase closure ###\n"

            print >> f1, "This is done on the scan of the bandpass calibrator."
            print >> f1, "The check will be PASS if the abs of the mean of all phase closures below is less than 0.5 deg.\n"

            f = open(msName+'.phaseclosure')
            fc = eval(f.read())
            f.close()

            print >> f1, "scan_id spw_id     min     max    mean  stddev\n"
            
            flag = 0
            for i in fc.keys():
                for j in fc[i].keys():
                    print >> f1, "%7i %6i %7.2f %7.2f %7.2f %7.2f" %(i, j, fc[i][j]['min'], fc[i][j]['max'], fc[i][j]['mean'], fc[i][j]['stddev'])
                    if fc[i][j]['mean'] > 0.5:
                        flag = 1

            if flag == 1:
                print >> f1, '\nCheck for phase closure -> FAIL'
                print 'Check for phase closure -> FAIL'
            else:
                print >> f1, '\nCheck for phase closure -> PASS'
                print 'Check for phase closure -> PASS'

        if os.path.exists(msName+'.sbgains'):

            print >> f1, "\n### Analysis of sideband ratios ###\n"

            print >> f1, "The check will be PASS if ...\n"

            f = open(msName+'.sbgains1')
            fc = f.read()
            f.close()

            fc1 = re.findall('.* for Pol [XY] =.*', fc)
            print >> f1, '\n'+'\n'.join(fc1)+'\n'

            f = open(msName+'.sbgains')
            fc = eval(f.read())
            f.close()

            flag = 0
            if len(fc[2]) > 0:
                flag = 1
                print >> f1, 'List of suspects:\n'
                print >> f1, 'ant_name BB_id pol_id SB_ratio\n'
                for i in fc[2].keys():
                    for j in fc[2][i].keys():
                        for k in fc[2][i][j].keys():
                            print >> f1, "%8s %5i %6i %8.2f" %(i, j, k, fc[2][i][j][k])
            else:
                print >> f1, 'No suspect found'

            if flag == 1:
                print >> f1, '\nCheck for sideband ratios -> FAIL'
                print 'Check for sideband ratios -> FAIL'
            else:
                print >> f1, '\nCheck for sideband ratios -> PASS'
                print 'Check for sideband ratios -> PASS'

        if os.path.exists(msName+'.wvrgcal2'):

            print >> f1, "\n### Analysis of WVR data ###\n"

            print >> f1, "The check will be PASS if ...\n"

            f = open(msName+'.wvrgcal2')
            fc = eval(f.read())
            f.close()

            print >> f1, "ant_name  Disc   RMS\n"
            for i in fc['ants'].keys():
                print >> f1, "%8s %5i %5i" %(i, fc['ants'][i]['Disc'], fc['ants'][i]['RMS'])
            
            flag = 0
            if len(fc['stats']['Disc']['outliers']) > 0 or len(fc['stats']['RMS']['outliers']) > 0:
                flag = 1
                print >> f1, '\nList of suspects:\n'
                outliers = []
                for i in fc['stats']['Disc']['outliers']: outliers.append(i)
                for i in fc['stats']['RMS']['outliers']: outliers.append(i)
                outliers = sorted(np.unique(outliers))
                print >> f1, ','.join(outliers)
            else:
                print >> f1, '\nNo suspect found'

            if flag == 1:
                print >> f1, '\nCheck for wvrgcal Disc/RMS -> FAIL'
                print 'Check for wvrgcal Disc/RMS -> FAIL'
            else:
                print >> f1, '\nCheck for wvrgcal Disc/RMS -> PASS'
                print 'Check for wvrgcal Disc/RMS -> PASS'

        if os.path.exists(msName+'.negativetrec'):

            print >> f1, "\n### Analysis of Syscal table (search for negative Trec) ###\n"

            print >> f1, "The check will be PASS if ...\n"

            f = open(msName+'.negativetrec')
            fc = f.read()
            f.close()

            flag = 0
            fc1 = re.findall(' *[0-9]+ *\[ *[0-9]+=[A-Za-z0-9]+, *[0-9]+,.*', fc)
            if len(fc1) != 0:
                fc3 = []
                for i in range(len(fc1)):
                    fc2 = fc1[i].replace(',', '').replace('[', '').replace(']', '').replace('=', ' ').split()
                    antName = fc2[2]
                    spwId = fc2[3]
                    polId = fc2[5]
                    fc3.append(tuple([antName, spwId, polId]))
                fc3 = np.unique(fc3)
                print >> f1, '\nList of suspects:'
                print >> f1, "\nant_name spw_id pol_id\n"
                for i in range(len(fc3)):
                    print >> f1, "%8s %6s %6s" %(fc3[i][0], fc3[i][1], fc3[i][2])

                fc2 = re.findall('A total of [0-9]+ negative Trx values encountered out of [0-9]+ possible \([0-9.]+\%\).', fc)[0]
                num1 = float(re.findall('[0-9.]+', fc2)[0])
                num2 = float(re.findall('[0-9.]+', fc2)[1])
                percent1 = 100.*num1/num2
                print >> f1, "\nFound %i negative Trec values, out of %i, which amounts to %.2f %%." %(num1, num2, percent1)
                if percent1 > 5:
                    flag = 1
            else:
                print >> f1, '\nNo suspect found'
            
            if flag == 1:
                print >> f1, '\nCheck for negative Trec -> FAIL'
                print 'Check for negative Trec -> FAIL'
            else:
                print >> f1, '\nCheck for negative Trec -> PASS'
                print 'Check for negative Trec -> PASS'

        if os.path.exists(msName+'.negativetsys'):

            print >> f1, "\n### Analysis of Syscal table (search for negative Tsys) ###\n"

            print >> f1, "The check will be PASS if ...\n"

            f = open(msName+'.negativetsys')
            fc = f.read()
            f.close()

            flag = 0
            fc1 = re.findall(' *[0-9]+ *\[ *[0-9]+=[A-Za-z0-9]+, *[0-9]+,.*', fc)
            if len(fc1) != 0:
                fc3 = []
                for i in range(len(fc1)):
                    fc2 = fc1[i].replace(',', '').replace('[', '').replace(']', '').replace('=', ' ').split()
                    antName = fc2[2]
                    spwId = fc2[3]
                    polId = fc2[6]
                    fc3.append(tuple([antName, spwId, polId]))
                fc3 = np.unique(fc3)
                print >> f1, '\nList of suspects:'
                print >> f1, "\nant_name spw_id pol_id\n"
                for i in range(len(fc3)):
                    print >> f1, "%8s %6s %6s" %(fc3[i][0], fc3[i][1], fc3[i][2])

                fc2 = re.findall('A total of [0-9]+ negative values encountered out of [0-9]+ possible \([0-9.]+\%\).', fc)[0]
                num1 = float(re.findall('[0-9.]+', fc2)[0])
                num2 = float(re.findall('[0-9.]+', fc2)[1])
                percent1 = 100.*num1/num2
                print >> f1, "\nFound %i negative Tsys values, out of %i, which amounts to %.2f %%." %(num1, num2, percent1)
                if percent1 > 5:
                    flag = 1
            else:
                print >> f1, '\nNo suspect found'
            
            if flag == 1:
                print >> f1, '\nCheck for negative Tsys -> FAIL'
                print 'Check for negative Tsys -> FAIL'
            else:
                print >> f1, '\nCheck for negative Tsys -> PASS'
                print 'Check for negative Tsys -> PASS'

#         if os.path.exists(tsysCalTableName[0]+'.platforming'): #### need change here
# 
#             f = open(tsysCalTableName[0]+'.platforming') #### need change here
#             fc = eval(f.read())
#             f.close()
#             
#             flag = 0
#             if len(fc) > 0:
#                 flag = 1
# 
#             if flag == 1:
#                 print 'Check for platforming in Tsys -> NOT OK'
#             else:
#                 print 'Check for platforming in Tsys -> OK'

#         if os.path.exists(bpassCalTableName[0]+'.platforming'): #### need change here
# 
#             f = open(bpassCalTableName[0]+'.platforming') #### need change here
#             fc = eval(f.read())
#             f.close()
#             
#             flag = 0
#             if len(fc) > 0:
#                 flag = 1
# 
#             if flag == 1:
#                 print 'Check for platforming in bandpass -> NOT OK'
#             else:
#                 print 'Check for platforming in bandpass -> OK'

        if os.path.exists(msName+'.delayjumps'):

            print >> f1, "\n### Analysis of phase data (search for delay jumps) ###\n"

            print >> f1, "The check will be PASS if ...\n"

            f = open(msName+'.delayjumps')
            fc = f.read()
            f.close()

            flag = 0
            fc1 = re.findall('[0-9]+-[0-9]+-[0-9]+T[0-9]+\:[0-9]+\:[0-9]+ +[A-Za-z0-9]+', fc)
            if len(fc1) != 0:
                flag = 1
                print >> f1, '\nList of suspects:'
                print >> f1, "\nant_name spw_id pol_id\n"
                for i in range(len(fc1)):
                    fc2 = fc1[i].split()[1].split('spw')
                    antName = fc2[0]
                    spwId = fc2[1].split('pol')[0]
                    polId = fc2[1].split('pol')[1]
                    print >> f1, "%8s %6s %6s" %(antName, spwId, polId)
            else:
                print >> f1, '\nNo suspect found'

            if flag == 1:
                print >> f1, '\nCheck for delay jumps -> FAIL'
                print 'Check for delay jumps -> FAIL'
            else:
                print >> f1, '\nCheck for delay jumps -> PASS'
                print 'Check for delay jumps -> PASS'

        f1.close()

    def ampcal_uvdist(self, ms2='', qa2_output_dir='', spw='', antenna='', correlation=''):

        """
        qa2_scripts/ampcal_uvdist.py

        This program plots the calibrated and the model visibility
        data for the selected source (usually a solar system object)
        The spw parameter is needed by the pipeline QA2 script since the pipeline never splits.
        The antenna parameter will plot only the data from the specified antennas. This should
           only be used by the pipeline QA2 script which calls this function twice, once with
           antenna='' and once with a list of antennas.

        INPUTS NEEDED:

           Assumes data base is ms2
           But need ss_object as name of source


        OUTPUTS:

        The calibrated and model amplitudes for the selected field
        number is placed in

           qa2_output_dir+'+ss_object+'_.png'


        USEAGE: assumes ms2 as the visibility data set.  Program looks for
        the relevant files.

        ss_object = 'Callisto'
        execfile ('ampcal_uvdist.py')

        """
        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        ss_object = self.getIntentsAndSourceNames(ms2)['CALIBRATE_AMPLI']['name'][0]
        if (ss_object == ''):
            ss_object = self.getIntentsAndSourceNames(ms2)['CALIBRATE_FLUX']['name'][0]

        # plotxy fails for single-polarization data.
        # It also cannot overplot a model created with usescratch=False, so we will
        # use this work-around in all cases when we switch to casa 4.0.0. - T. Hunter
        pols = self.findNumberOfPolarizations(ms2)
        if (os.path.exists('%sampcal_uvdist_labeled.png' % (qa2_output_dir))):
            os.system('rm %sampcal_uvdist_labeled.png' % (qa2_output_dir))
        if (antenna == ''):
            if (os.path.exists('%sampcal_uvdist.png' % (qa2_output_dir))):
                os.system('rm %sampcal_uvdist.png' % (qa2_output_dir))
        else:
            if (os.path.exists('%sampcal_uvdist_antenna_subset.png' % (qa2_output_dir))):
                os.system('rm %sampcal_uvdist_antenna_subset.png' % (qa2_output_dir))
        if casadef.casa_version >= '4.2.0':
            plotmsparm="showgui=False,"
        else:
            plotmsparm=""
        if (pols < 2 or casadef.casa_version >= '4.0.0'):
            if (antenna == ''):
                figfile = '%sampcal_uvdist.png' % (qa2_output_dir)
                figfileModel = '%sampcal_uvdist_model.png' % (qa2_output_dir)
                figfileCorrected = '%sampcal_uvdist_corrected.png' % (qa2_output_dir)
            else:
                figfile = '%sampcal_uvdist_antenna_subset.png' % (qa2_output_dir)
                figfileModel     = '%sampcal_uvdist_model_antenna_subset.png' % (qa2_output_dir)
                figfileCorrected = '%sampcal_uvdist_corrected_antenna_subset.png' % (qa2_output_dir)

            cmd="plotms("+plotmsparm+"vis='%s', xaxis = 'uvdist', yaxis = 'amp', ydatacolumn = 'model', title='%s Model', field='%s', averagedata=True, avgtime='30', avgchannel='8000', plotfile='%s', coloraxis='spw', overwrite=True, spw='%s', antenna='%s', correlation='%s')" % (ms2,ss_object,ss_object,figfileModel,spw,antenna, correlation)
            print "Running "+cmd
            exec cmd
#            print "Running plotms(vis='%s', xaxis = 'uvdist', yaxis = 'amp', ydatacolumn = 'model', title='%s Model', field='%s', averagedata=True, avgtime='30', avgchannel='8000', plotfile='%s', coloraxis='spw', overwrite=True, spw='%s', antenna='%s', correlation='%s')" % (ms2,ss_object,ss_object,figfileModel,spw,antenna, correlation)
#            plotms(showgui=False,vis=ms2, xaxis = 'uvdist', yaxis = 'amp', ydatacolumn = 'model', title='%s Model'%(ss_object),
#                   field = ss_object, averagedata=True, avgtime = '30', avgchannel = '8000',
#                   plotfile='%s'%(figfileModel), coloraxis='spw', overwrite=True, spw=spw,
#                   antenna=antenna, correlation=correlation)

            cmd="plotms("+plotmsparm+"vis='%s', xaxis = 'uvdist', yaxis = 'amp', ydatacolumn = 'corrected', title='%s Corrected Data', field='%s', averagedata=True, avgtime='30', avgchannel='8000', plotfile='%s', coloraxis='spw', overwrite=True, spw='%s', antenna='%s', correlation='%s')" % (ms2,ss_object,ss_object,figfileCorrected,spw,antenna,correlation)
            print "Running "+cmd
            exec cmd
#            print "Running plotms(vis='%s', xaxis = 'uvdist', yaxis = 'amp', ydatacolumn = 'corrected', title='%s Corrected Data', field='%s', averagedata=True, avgtime='30', avgchannel='8000', plotfile='%s', coloraxis='spw', overwrite=True, spw='%s', antenna='%s', correlation='%s')" % (ms2,ss_object,ss_object,figfileCorrected,spw,antenna,correlation)
#            plotms(showgui=False,vis=ms2, xaxis = 'uvdist', yaxis = 'amp', ydatacolumn = 'corrected',
#                   title='%s Corrected Data'%(ss_object),
#                   field = ss_object, averagedata=True, avgtime = '30', avgchannel = '8000',
#                   plotfile='%s'%(figfileCorrected), coloraxis='spw', overwrite=True, spw=spw,
#                   antenna=antenna, correlation=correlation)
            # The following is for pipeline
            os.system("montage -tile 2x1 -geometry 1000x1000+0+0 %s %s %s"%(figfileModel,figfileCorrected,figfile))
        else:
            print "Running plotxy(vis='%s', xaxis='uvdist', yaxis='amp', field='%s', antenna='%s', overplot=False, datacolumn='model', averagemode='vector', timebin='30', width='4000', interactive=False, spw='%s')" % (ms2,ss_object,antenna,spw)
            plotxy(vis=ms2,
                   xaxis = 'uvdist', yaxis = 'amp',
                   field = ss_object,
                   antenna = antenna,
                   overplot = False, datacolumn = 'model',
                   averagemode = 'vector',
                   timebin = '30', width = '4000',
                   interactive = False, spw=spw)

            if (antenna == ''):
                figfile = '%sampcal_uvdist.png' % (qa2_output_dir)
            else:
                figfile = '%sampcal_uvdist_antenna_subset.png' % (qa2_output_dir)
                
            print "Running plotxy(vis='%s', xaxis='uvdist', yaxis='amp', field='%s', antenna='%s', overplot=True, datacolumn='corrected', averagemode='vector', timebin='30', width='4000', plotsymbol=',', interactive=False, figfile='%s', spw='%s')" % (ms2,ss_object,antenna,figfile,spw)
            plotxy(vis=ms2,
                   xaxis = 'uvdist', yaxis = 'amp',
                   field = ss_object,
                   antenna = antenna,
                   overplot = True, datacolumn = 'corrected',
                   averagemode = 'vector',
                   timebin = '30', width = '4000', plotsymbol = ',',
                   interactive = False,
                   figfile = figfile, spw=spw)

    def pickSubplotGrid(self, nant):
        nsub1 = 7; nsub2 = 7
        if nant <43: nsub1 = 6; nsub2 = 7
        if nant <37: nsub1 = 6; nsub2 = 6
        if nant <31: nsub1 = 6; nsub2 = 5
        if nant <26: nsub1 = 5; nsub2 = 5
        if nant <21: nsub1 = 4; nsub2 = 5
        if nant <17: nsub1 = 4; nsub2 = 4
        if nant <13: nsub1 = 3; nsub2 = 4
        return(nsub1, nsub2)

    def ant_amp_temporal(self, ms2='', phase_cal='', caltable='', qa2_output_dir=''):

        """
        ant_amp_temporal.py

        This program plots the antenna-based gains obtained from the
        phase calibrators---used to calibrate the target


        INPUTS NEEDED:

           Assumes original table is in ms2
           caltable must be specified
           phase_cal should be specified


        OUTPUTS:

        The phase plots for each antenna are placed in

           ant_amp_temporal.png'


        USEAGE: assumes ms2 as the visibility data set.  Program looks for
        the relevant files.

        phase_cal = '2'
        caltable = ms2+'.flux_inf'
        execfile ('ant_amp_temporal.py')

        """
        import pylab as pl

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)

        #  Plot calibrator gains

        #  Get antenna paramters

        tb.open(ms2+'/ANTENNA')
        ant_names=tb.getcol('NAME')
        nant = len(ant_names)
        tb.close()

        #  Get gaintable

        tb.open(caltable)
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
        else:
            calFormat = 33  # <= casa 3.3
        flag = tb.getcol('FLAG')
        tb1 = tb.query('FIELD_ID == '+str(phase_cal))
        flags = tb1.getcol('FLAG')
        if (len(flags) == 0):
            tb1.close()
            tb.close()
#            raise Exception('ant_amp_temporal: no rows found for FIELD_ID '+
#                            phase_cal +  ' in caltable '+ caltable +
#                            '.  You may need to re-run es.generateQA2Report and specify a' +
#                            ' different phase calibrator using the phase_cal parameter (e.g. phase_cal="3").')
            print 'ant_amp_temporal: no rows found for FIELD_ID '+ phase_cal +  ' in caltable '+ caltable + \
                  '.  Is the phase calibrator completely flagged?  You may need to re-run es.generateQA2Report and specify a' + \
                  ' different phase calibrator using the phase_cal parameter (e.g. phase_cal="3").'
            return

        keep = np.where(flags[0][0]==False)[0]
        print "Kept %d of %d unflagged solutions" % (len(keep), len(flags[0][0]))
        time = tb1.getcol('TIME')[keep]
        time = time-time[0]+5.0
        ant = tb1.getcol('ANTENNA1')[keep]
        if (calFormat == 33):
            gain = tb1.getcol('GAIN')[0][0][keep]
            spw = tb1.getcol('CAL_DESC_ID')[keep]
            if (len(tb1.getcol('GAIN')) == 1):
                Gsolution = False
            else:
                Gsolution = True
                gain2 = tb1.getcol('GAIN')[1][0][keep]
        else:
            gain = tb1.getcol('CPARAM')[0][0][keep]
            spw = tb1.getcol('SPECTRAL_WINDOW_ID')[keep]
            if (len(tb1.getcol('CPARAM')) == 1):
                Gsolution = False
            else:
                Gsolution = True
                gain2 = tb1.getcol('CPARAM')[1][0][keep]
        field = tb1.getcol('FIELD_ID')[keep]
        g = np.abs(gain)
        gg = g  #[0][0]
        if (Gsolution):
            gg2 = np.abs(gain2)
            print "This is a G solution."
        else:
            print "This is a T solution."

        tb.close()
        tb1.close()
        spw_un = np.unique(spw)
        ant_un = np.unique(ant)
        nspw = len(spw_un)
        nant = len(ant_un)
        ggf = []
        for i in range (0, len(gg)):
            if gg[i] != 1.0: 
                ggf.append(gg[i])
            if (Gsolution):
                if gg2[i] != 1.0: 
                    ggf.append(gg2[i])

        gmin = np.min(ggf)
        gmax = np.max(ggf)
        gmed = np.median(ggf)
        gmin = 0.8*gmin
        if gmax > 5.0*gmed:
            gmax = 5.0*gmed

        gmin = 0.0
        gmax = 1.1*gmax
        tmin = np.min(time)
        tmax = np.max(time)
        tincd = 3600.0
        tdiff = np.int((0.8*tmax-tmin)/tincd) * tincd
        while (tdiff == 0):
            tincd *= 0.5
            tdiff = np.int((0.8*tmax-tmin)/tincd) * tincd
            
        tmin = tmin - (tmax-tmin)*0.2
        tmax = tmax * 1.2
#        print 'gain range ', gmin, gmax
#        print 'time range ', tmin, tmax

        #  Set up plots

        #  Formatting of plots
        nsub3 = 0
        nsub1, nsub2 = self.pickSubplotGrid(nant)

        #  Loop over antenna
        pl.clf()
        color = ['b','r','g','y']
        color += ['k','m','c','b']
        color += color
        for iant in ant_un:
            nsub3 = nsub3 + 1
            for ispw in range(0,nspw):
                gamp = []
                gamp2 = []
                tamp = []
                tamp2 = []
                for pt in range(0,len(gg)):
                    if (ant[pt]==iant) and (spw[pt]==spw_un[ispw]) and (gg[pt] != 1.0):
                        gamp.append(gg[pt])
                        tamp.append(time[pt])
                    if (Gsolution):
                        if (ant[pt]==iant) and (spw[pt]==spw_un[ispw]) and (gg2[pt] != 1.0):
                            gamp2.append(gg2[pt])
                            tamp2.append(time[pt])
                    #
                #
                desc = pl.subplot(nsub1,nsub2,nsub3)
                pl.subplots_adjust(hspace=0.30, wspace=0.20)
                if (Gsolution):
#                    print "len(tamp) = %d, len(gamp) = %d, len(gamp2) = %d" % (len(tamp),len(gamp),len(gamp2))
                    pl.plot(tamp,gamp,'%so'%(color[ispw]), tamp2,gamp2,'%s+'%(color[ispw]))
                else:
                    pl.plot(tamp,gamp,'%so'%(color[ispw]))
                        

                pl.ylim (gmin,gmax)
                pl.xlim (tmin,tmax)
                if nsub3 != 1:
                    desc.set_yticklabels([])
                else:
                    pl.ylabel('Amplitude')
                pl.setp(plt.gca().get_ymajorticklabels(), size=8)

                pl.xticks(np.arange(0.0,tmax,tdiff))
                pl.setp(plt.gca().get_xmajorticklabels(), size=8)
                if nsub3 != nant:
                    desc.set_xticklabels([])
                else:
                    pl.xlabel('Time (sec)')

                pl.title('AMP '+ant_names[iant], size=12)

        print "Saving %s" % (qa2_output_dir+'ant_amp_temporal.png')
        pl.savefig(qa2_output_dir+'ant_amp_temporal.png')

    def ant_gain_check(self, ms2='', qa2_output_dir='', caltable=None, verbose=True, field=''):

        """
        ant_gain_check.py

        This is an experimental python script that determines the statistics
        of the pre-bandpass gain levels calibration.  It is meant to determine
        any bad antennas/pol/spws.

        INPUTS NEEDED:

           optional cal table, else 
           assumes table is in ms2+'.ap_pre_bandpass'

        OUTPUTS:

        The ascii output file lists the relative gains of all data streams

        qa2_output_dir+'ant_gain_check.txt'

        USEAGE: assumes ms2 as the visibility data set

        execfile ('ant_gain_check.py')

        """

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)

        #  Get antenna paramters
        if (ms2 != ''):
            tb.open(ms2+'/ANTENNA')
            ant_names=tb.getcol('NAME')
            tb.close()
            npol = self.findNumberOfPolarizations(ms2)
        else:
            print "Assuming npol=2. If not correct, then set ms2."
            npol = 2

        #  Get gaintable
        if caltable==None:
            caltable = ms2+'.ap_pre_bandpass'
        tb.open(caltable)
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
        else:
            calFormat = 33  # <= casa 3.3
        if (field != ''):
            mytb = tb.query('FIELD_ID == %s' % field)
            mytime = mytb.getcol('TIME')
            if (len(mytime) == 0):
                # The requested calibrator is not present, so use all (usually one).
                mytb = tb
        else:
            mytb = tb
        time = mytb.getcol('TIME')
        time = time-time[0]+5.0
        ant = mytb.getcol('ANTENNA1')
        flags = mytb.getcol('FLAG')
        if (calFormat == 33):
            gain = mytb.getcol('GAIN')
            spw = mytb.getcol('CAL_DESC_ID')
        else:
            gain = mytb.getcol('CPARAM')
            spw = mytb.getcol('SPECTRAL_WINDOW_ID')
        g = np.abs(gain)
        nrows = len(ant)
        tb.close()
        spw_un = np.unique(spw)
        ant_un = np.unique(ant)
        nspw = len(spw_un)
        nant = len(ant_un)
        if (ms2 == ''):
            ant_names = np.array(['xxxx']*nant)
            print "rows = %d" % (nrows)
        #  Get average g
        npts = g.shape[2]
        gg = []
        # to allow this to be run on a (non-normalized) BP table:
        nch=g.shape[1]
        # The np.min() is needed for full-polarization data.
        #        for i in range(0,np.min([npol,2])):
        for i in range(len(g)):  # necessary for T solutions to avoid crash
            for j in range(0,npts):
                for k in range(0,nch):
                    if (flags[i][k][j] == False): gg.append(g[i][k][j])
#                    if g[i][k][j] != 1.0: gg.append(g[i][k][j])

        gavg = np.median(gg)

        #   Open file for writing
        zfileRes = qa2_output_dir+'ant_gain_check.txt'
        os.system('rm -f '+zfileRes)
        f = open (zfileRes, 'w')
        if (verbose):
            print 'opening file '+zfileRes
        f.write('\n\n')
        f.write('************************************************************************** \n')
        f.write('\n')
        f.write('                    MEDIAN GAIN VALUE = %8.3F \n\n' % (gavg))
        f.write('                RELATIVE ANTENNA GAIN FOR BANDPASS OBSERVATION \n\n')
        f.write(' Antenna       ')
        for ispw in spw_un.tolist(): # in the split file, spws start at 0
            f.write('SPW%2d' % ispw)
            if (ispw != spw_un.tolist()[-1]):
                f.write('             ')
            else:
                f.write('\n')
        f.write('    ' + '        X        Y'*len(spw_un.tolist()) + '\n')

        #  get a gain,phase for each ant, spw stream

        g_xall = []
        g_yall = []
        low_gain = 0.90
        high_gain = 1.10

        #  Get gain and phase average and rms for each stream (both pols)

        for iant in range(0,nant):
            gant_xavg = []
            gant_yavg = []
            gant_xrms = []
            gant_yrms = []
            g_xstar = []
            g_ystar = []
            for ispw in spw_un.tolist(): # in the split file, spws start at 0
                g_x = []
                g_y = []
                for j in range(0,nrows):
                    if (iant == ant[j]) & (ispw == spw[j]):
                        for k in range(0,nch):
#                            if g[0][k][j] != 1.0:
                            if (flags[0][k][j] == False):
                                g_x.append(g[0][k][j])

#                            if g[1][k][j] != 1.0:
                            if (len(flags) > 1):
                                if (flags[1][k][j] == False):
                                    g_y.append(g[1][k][j])
                    if (len(g_x) > 0):
                        g_xavg = np.average(g_x)/gavg
                        g_xvar = np.var(g_x)/gavg
                    else:
                        g_xavg = 0
                        g_xvar = 0
                    if (len(g_y) > 0):
                        g_yavg = np.average(g_y)/gavg
                        g_yvar = np.var(g_y)/gavg
                    else:
                        g_yavg = 0
                        g_yvar = 0

                gant_xavg.append(g_xavg)
                if (len(g_x) > 0):
                    if (g_xavg > high_gain) or (g_xavg < low_gain):
                        g_xstar.append('**')
                    else:
                        g_xstar.append('  ')
                else:
                    g_xstar.append('flagged')
                gant_xrms.append(np.sqrt(g_xvar))
                gant_yavg.append(g_yavg)
                gant_yrms.append(np.sqrt(g_yvar))

                if (len(g_y) > 0):
                    if (g_yavg > high_gain) or (g_yavg < low_gain):
                        g_ystar.append('**')
                    else:
                        g_ystar.append('  ')
                elif (len(g) > 1):
                    g_ystar.append('flagged')
                else:
                    g_ystar.append('   T   ')


            if (g_xstar[0] == 'flagged'):
                g_xstarstring = ' flagged'
            else:
                g_xstarstring = '%6.2f%2s' % (gant_xavg[0],g_xstar[0])
            if (g_ystar[0] == 'flagged'):
                g_ystarstring = ' flagged'
            elif (g_ystar[0] == '   T   '):
                g_ystarstring = '    T   '
            else:
                g_ystarstring = '%6.2f%2s' % (gant_yavg[0],g_ystar[0])

            f.write('%3d-%4s %s %s' % (iant, ant_names[iant], g_xstarstring, 
                                        g_ystarstring))
            for ispw in range(1,nspw-1):
                if (g_xstar[ispw] == 'flagged'):
                    g_xstarstring = ' flagged'
                else:
                    g_xstarstring = '%6.2f%2s' % (gant_xavg[ispw],g_xstar[ispw])
                if (g_ystar[ispw] == 'flagged'):
                    g_ystarstring = ' flagged'
                elif (g_ystar[ispw] == '   T   '):
                    g_ystarstring = '    T   '
                else:
                    g_ystarstring = '%6.2f%2s' % (gant_yavg[ispw],g_ystar[ispw])
                f.write (' %s %s' % (g_xstarstring, g_ystarstring))

            if (g_xstar[nspw-1] == 'flagged'):
                g_xstarstring = ' flagged'
            else:
                g_xstarstring = '%6.2f%2s' % (gant_xavg[nspw-1],g_xstar[nspw-1])
            if (g_ystar[nspw-1] == 'flagged'):
                g_ystarstring = ' flagged'
            elif (g_ystar[nspw-1] == '   T   '):
                g_ystarstring = '    T   '
            else:
                g_ystarstring = '%6.2f%2s' % (gant_yavg[nspw-1],g_ystar[nspw-1])
            f.write (' %s %s\n' % (g_xstarstring, g_ystarstring))

        f.write ('\n ** means outside of normalized range: %6.2f to %6.2f \n ' % (low_gain, high_gain))

        f.close()
        if (verbose):
            os.system('cat '+zfileRes)

    def findNumberOfPolarizations(self, ms2):
        #  Find number of pols, assuming it is the same for all spws!
        #  Thus this should only be called after the science spws have been split out.
        tb.open(ms2 +'/DATA_DESCRIPTION')
        polId = tb.getcol('POLARIZATION_ID')
        tb.close()
        if (len(polId) <= 4):
            # This is the traditional way of computing it for Cycle 0 data.
            tb.open(ms2 +'/POLARIZATION')
            corrProdRow = tb.selectrows(polId)
            corrProd = corrProdRow.getcell('CORR_PRODUCT', 0)
        else:
            # Since cycles 0 and 1 have only 4 spws, here we can guess that the data
            # have not been split, so pick the first science spw. - Todd Hunter
            #    Get a science spw
            spwdict = self.getSpwInfo(ms2)
            firstScienceSpw = spwdict.keys()[0]
#            print "first science spw = ", firstScienceSpw
            # This is the way that the pipeline datasets (which are never split) require it.
            tb.open(ms2 +'/POLARIZATION')
            corrProd = tb.getcell('CORR_PRODUCT',polId[firstScienceSpw])
        tb.close()
        corrProd = corrProd.transpose()
        nPol = corrProd.shape[0]
        return(nPol)

    def ant_phase_temporal(self, ms2='', caltable='', phase_cal='', qa2_output_dir=''):

        """
        ant_phase_temporal.py

        This program plots the antenna-based phases obtained from the
        phase calibrators---used to calibrate the target


        INPUTS NEEDED:

           Assumes original table is in ms2
           caltable must be specified
           phase_cal


        OUTPUTS:

        The phase plots for each antenna are placed in

             ant_phase_temporal.png'


        USEAGE: assumes ms2 as the visibility data set.  Program looks for
        the relevant files.

        caltable = ms2+'.gain_inf'
        execfile ('qa2_plot_bandpass.py')

        """

        import pylab as pl
        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)

        #  Plot calibrator phases


        #  Get antenna paramters

        tb.open(ms2+'/ANTENNA')
        ant_names=tb.getcol('NAME')
        nant = len(ant_names)
        tb.close()

        polsInData = self.findNumberOfPolarizations(ms2)
        print "Found %d polarizations in the data" % (polsInData)
        
        #  Get gaintable

        tb.open(caltable)
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
        else:
            calFormat = 33  # <= casa 3.3
        tb1 = tb.query('FIELD_ID == '+phase_cal)
        flags = tb1.getcol('FLAG')
        pols = np.shape(flags)[0]
        print "Found %d polarizations in the caltable" % (pols)
        if (polsInData == 1):
            pols = 1  # the other pol will be present in solution but completely flagged,
                      # so leaving pols=2 will cause a crash in the 'for' loop below.
        
        if(len(flags)==0):
            tb1.close()
            tb.close()
#            raise Exception('ant_phase_temporal: no rows found for FIELD_ID '+
#                            phase_cal +  ' in caltable '+ caltable)
            print 'ant_phase_temporal: no rows found for FIELD_ID '+ phase_cal +  ' in caltable '+ caltable +'. Is the phase calibrator totally flagged?'
            return
        ant = []
        timex = []
        timey = []
        px = []
        py = []
        for p in range(pols):
            keep = np.where(flags[p][0]==False)[0]
            time = tb1.getcol('TIME')[keep]
            time = time-time[0]+5.0
            ant = tb1.getcol('ANTENNA1')[keep]
            if (calFormat == 33):
                gain = tb1.getcol('GAIN')[p][0][keep]
                spw = tb1.getcol('CAL_DESC_ID')[keep]
            else:
                gain = tb1.getcol('CPARAM')[p][0][keep]
                spw = tb1.getcol('SPECTRAL_WINDOW_ID')[keep]
            field = tb1.getcol('FIELD_ID')[keep]
            phs = np.arctan2(np.imag(gain),np.real(gain))*180.0 / np.pi
            if (p==0):
                px = phs
                timex = time
            else:
                py = phs
                timey = time
        tb1.close()
        tb.close()
        nphases = len(ant)
        spw_un = np.unique(spw)
        ant_un = np.unique(ant)
        nant = len(ant_un)

        #  Set up plots
        tmin = np.min(time)
        tmax = np.max(time)
        tincd = 3600.0
        tdiff = np.int((0.8*tmax-tmin)/tincd) * tincd
        while (tdiff == 0):
            tincd *= 0.5
            tdiff = np.int((0.8*tmax-tmin)/tincd) * tincd
        tmin = tmin - (tmax-tmin)*0.2
        tmax = tmax * 1.2


        #  Formatting of plots
        nsub1, nsub2 = self.pickSubplotGrid(nant)
        nsub3 = 0

        #  Loop over antenna
        pl.close()
        for iant in ant_un:
            if ant_names[iant] != 'junk':
                nsub3 = nsub3 + 1
                for ispw in spw_un:
                    pxphase = []
                    pyphase = []
                    tampx = []
                    tampy = []
                    for pt in range(0,nphases):
                        if (ant[pt]==iant) and (spw[pt]==ispw):
#                        if (iant == 6):
#                            print "Appending spw %d" % (ispw)
                            if(pt<len(timex)):
                                tampx.append(timex[pt])
                                pxphase.append(px[pt])
                            if(pt<len(timey)):
                                tampy.append(timey[pt])
                                pyphase.append(py[pt])


                    nn = len(pxphase)
                    if nn >0:
                        for i in range (1,nn):
                            pdiff = pxphase[i]-pxphase[i-1]
                            pdiff = np.mod(pdiff+900.0,360.0)-180.0
                            pxphase[i] = pxphase[i-1] + pdiff
                            if (len(pyphase) > 0):
                                pdiff = pyphase[i]-pyphase[i-1]
                                pdiff = np.mod(pdiff+900.0,360.0)-180.0
                                pyphase[i] = pyphase[i-1] + pdiff

                        pxavg = np.median(pxphase)
                        pxphase = pxphase - pxavg
                        if (len(pyphase) > 0):
                            pyavg = np.median(pyphase)
                            pyphase = pyphase - pyavg
                        desc = pl.subplot(nsub1,nsub2,nsub3)
                        pl.subplots_adjust(hspace=0.30, wspace=0.20)
                        if (pols > 1):
                            pl.plot(tampx,pxphase,'bo',tampy,pyphase,'go')
                        else:
                            pl.plot(tampx,pxphase,'bo')
                        pl.ylim (-190.0, 190.0)
                        if nsub3 != 1:
                            desc.set_yticklabels([])
                        else:
                            pl.ylabel('Phase (deg)')

                        pl.xticks(np.arange(0.0,tmax,tdiff))
                        pl.setp(plt.gca().get_xmajorticklabels(), size=8)
                        pl.setp(plt.gca().get_ymajorticklabels(), size=8)
                        pl.yticks([-180,-90,0,90,180])
                        if nsub3 != nant:
                            desc.set_xticklabels([])
                        else:
                            pl.xlabel('Time (sec)')

                        pl.title('PHS '+ant_names[iant], size=12)

        pl.savefig(qa2_output_dir+'ant_phase_temporal.png')

    def bandpass_plot(self, ms2='', qa2_output_dir='', bandpassShowFlaggedSolutions=False):

        """
        band_pass.py

        This program plots the bandpass.  It will plot both the original and/or
        the smoothed or BPOLY solution for comparison.

        INPUTS NEEDED:

           None.  assumes original table is in ms2+'.bandpass',
                  smooth table is in           ms2+'.smooth_20flat_ri'
                  or bpoly table is in         ms2+'.bpoly'

        OUTPUTS:

        The plots are put in several files with the name form:


        USEAGE: assumes ms2 as the visibility data set.  Program looks for
        the relevant files.

        execfile ('bandpass_plot.py')
        """
        import numpy
        import pylab as pl
        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)

        caltable = ms2+'.bandpass'
        caltable2 = 'N'
        overlay_table = False
        # casa 3.3 method
        if os.path.exists(caltable+'_smooth20flat_ri'):
            caltable2 = caltable+'_smooth20flat_ri'

        # casa 3.4 method
        if os.path.exists(caltable+'_smooth20ch'):
            caltable2 = caltable+'_smooth20ch'

        if os.path.exists(caltable+'_bpoly'):
            caltable2 = caltable+'_bpoly'

        if caltable2 != 'N': overlay_table = True

        #  Plot bandpass amp

        pl.close()
        tb.open (caltable)
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
            spw = tb.getcol('SPECTRAL_WINDOW_ID')
        else:
            calFormat = 33  # <= casa 3.3
            spw = tb.getcol('CAL_DESC_ID')
        spw_un = numpy.unique(spw)
        nsub1 = len(spw_un)
        nsub2 = 1
        nsub3 = 0
        for ispw in spw_un:
            nsub3 = nsub3 + 1
            if (calFormat == 33):
                tb1 = tb.query('CAL_DESC_ID=='+str(ispw))
                g = tb1.getcol('GAIN')
            else:
                tb1 = tb.query('SPECTRAL_WINDOW_ID=='+str(ispw))
                g = tb1.getcol('CPARAM')
            flags = tb1.getcol('FLAG')
            ant = tb1.getcol('ANTENNA1')
            gbp = numpy.abs(g)
            gch = []
            n0 = gbp.shape[0]
            n1 = gbp.shape[1]
            n2 = gbp.shape[2]
            chan = range(0,n1)
            for ich in range(0,n1):
                gsum = 0.0
                for pol in range(0,n0):
                    for iant in range(0,n2):
                        gsum = gsum + gbp[pol][ich][iant]
                gch.append(gsum/n0/n2)
            adesc = pl.subplot(nsub1, nsub2, nsub3)
            pl.subplots_adjust(hspace=0.40, wspace=0.0)
            if (bandpassShowFlaggedSolutions):
                pl.plot(chan,gch,'b,')
            else:
                unflaggedChans = np.unique(np.where(flags==False)[1])
                pl.plot(np.array(chan)[unflaggedChans],np.array(gch)[unflaggedChans],'b,')
                pl.xlim([np.min(chan), np.max(chan)])
            pl.title('Avg Bandpass for spw '+str(ispw), fontsize=12)
#            if nsub3 < nsub1: pl.xticks([])
            pl.setp(adesc.get_xticklabels(), fontsize=8)
        tb.close()
        pl.xlabel('Channel')

        if caltable2 != 'N':
            nsub3 = 0
            for ispw in spw_un:
                nsub3 = nsub3 + 1
                tb.open(caltable2)
                names = tb.colnames()
                if ('CAL_DESC_ID' not in names):
                    calFormat = 34  # >= casa 3.4
                    tb1 = tb.query('SPECTRAL_WINDOW_ID=='+str(ispw))
                    g = tb1.getcol('CPARAM')
                else:
                    calFormat = 33  # <= casa 3.3
                    tb1 = tb.query('CAL_DESC_ID=='+str(ispw))
                    g = tb1.getcol('GAIN')
                ant = tb1.getcol('ANTENNA1')
                gbp = numpy.abs(g)
                tb.close()
                gch = []
                n0 = gbp.shape[0]
                n1 = gbp.shape[1]
                n2 = gbp.shape[2]
                chan = range(0,n1)
                for ich in range(0,n1):
                    gsum = 0.0
                    for pol in range(0,n0):
                        for iant in range(0,n2):
                            gsum = gsum + gbp[pol][ich][iant]
                    gch.append(gsum/n0/n2)
                pl.subplot(nsub1, nsub2, nsub3)
                pl.subplots_adjust(hspace=0.40, wspace=0.0)
                if (calFormat == 34):
                    # we now use solint='20ch' which reduces num_chan by x20
                    pl.plot(np.array(chan)*20, gch, 'r,')
                else:
                    pl.plot(chan,gch,'r,')


        pl.savefig(qa2_output_dir+'bandpass_avg.png')

    def bandpass_rms(self, ms2='', refAnt='', qa2_output_dir=''):

        """
        bandpass_rms.py

        This is an experimental python script that determines the rms channel
        to channel scatter in the bandpass.  It can be used to determine if
        smoothing or BPOLY is needed.

        INPUTS NEEDED:

           None.  assumes table is in ms2+'.bandpass'

        OUTPUTS:

        The ascii output file lists the relative gains of all data streams

        bandpass_rms.txt'

        USEAGE: assumes ms2 as the visibility data set

        execfile ('bandpass_rms.py')

        """

        import numpy
        import pylab as pl

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        caltable = ms2+'.bandpass'

# Someday, we might want to show stats for the smoothed solution
# instead. - Todd
#        caltable = ms2+'.bandpass_smooth20ch'
#        if (os.path.exists(caltable) == False):
#            caltable = ms2+'.bandpass'

        #  Get antenna parameters

        tb.open(ms2+'/ANTENNA')
        ant_names=tb.getcol('NAME')
        nant = len(ant_names)
#        print 'number of antenna ', nant,'  refant = ', refAnt
        tb.close()

        #  Get bandpass table

        supportMixedModes = True  # used while debugging new code
        tb.open(caltable)
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
        else:
            calFormat = 33  # <= casa 3.3
        time=tb.getcol('TIME')
        time = time-time[0]+5.0
        ant = tb.getcol('ANTENNA1')
        if (calFormat == 33):
            gain = tb.getcol('GAIN')
            spw = tb.getcol('CAL_DESC_ID')
        else:
            if (supportMixedModes):
                gain = []
                for i in range(len(time)):
                    gain.append(tb.getcell('CPARAM', i))  # support mixed modes
            else:  # old code
                gain = tb.getcol('CPARAM')
            spw = tb.getcol('SPECTRAL_WINDOW_ID')

        if (supportMixedModes and calFormat>=34):
            fg = []
            g = []
            p = []
            for i in range(len(time)):
                fg.append(tb.getcell('FLAG', i))   # support mixed modes
                g.append(numpy.abs(gain[i]))
                p.append(numpy.arctan2(numpy.imag(gain[i]),numpy.real(gain[i]))*180.0 / numpy.pi)
#            print "len(g) = ", len(g)             # nrows
#            print "len(g[0]) = ", len(g[0])       # 2 = npols
#            print "len(g[0][0]) = ", len(g[0][0]) # 240 = nchan
            g = zip(*g)  # np.transpose(g,(1,2,0)) works for non-mixed modes
            p = zip(*p)  # np.transpose(p,(1,2,0)) works for non-mixed modes
            newg = []
            newp = []
            for i in range(len(g)):
                newg.append(zip(*g[i]))
                newp.append(zip(*p[i]))
            g = newg
            p = newp
        else: # old code
            fg = tb.getcol('FLAG')
            g = numpy.abs(gain)
            p = numpy.arctan2(numpy.imag(gain),numpy.real(gain))*180.0 / numpy.pi
            # shapes should be [npol, nchan, nrows]

        clen = len(g[0])  # e.g., will be 3840 for FDM non-mixed modes
#        print "clen = ", clen
        tb.close()
        ns=len(ant) # number of solutions (i.e. rows) in the table
        ant_un = numpy.unique(ant)
        spw_un = numpy.unique(spw)
        nspw = len(spw_un)
        nch = len(g[1])

        #  Get avg gain and rms for each stream (both pols)

        zfileRes = qa2_output_dir+'bandpass_rms.txt'
        os.system('rm -f '+zfileRes)
        print 'creating file '+zfileRes
        f = open (zfileRes, 'w')

        f.write('\n\n')
        f.write('************************************************************************* \n')
        f.write('\n')
        f.write('      NORMALIZED BANDPASS AMPLITUDE RMS OVER '+str(nch)+' CHANNELS \n')
        f.write('          using table %s  \n\n' % (caltable))
        f.write('  Antenna      ')
        for ispw in spw_un:
            f.write('SPW%d'%ispw)
            if (ispw == spw_un[-1]):
                f.write('\n')
            else:
                f.write('           ')
        f.write('      ')
        for ispw in spw_un:
            f.write('       X      Y')
        f.write('\n')
        gall_rms_x = []
        gall_rms_y = []
        rms_med = []
        for iant in ant_un:
            for ispw in spw_un:
                gspw_x = []
                gspw_y = []
                for j in range(0,ns):  
                    if (iant == ant[j]) and (ispw == spw[j]):
                        for ic in range (int(0.05*clen),int(0.95*clen)):
                            if (supportMixedModes):
                                gspw_x.append(g[0][ic][j])  # support mixed modes (g is now a list not an array)
                                gspw_y.append(g[1][ic][j])
                            else:  # old code
                                gspw_x.append(g[0,ic,j])
                                gspw_y.append(g[1,ic,j])
                            #
                        #
                    #
                #
                grms_x = numpy.sqrt(numpy.var(gspw_x))
                grms_y = numpy.sqrt(numpy.var(gspw_y))
                rms_med.append(grms_x)
                rms_med.append(grms_y)
                if ispw == 0:
                    f1string = ('%3d-%4s  %6.3f %6.3f  '% (iant,ant_names[iant], grms_x,grms_y))
                    gall_rms_x.append(grms_x)
                    gall_rms_y.append(grms_y)

        #        if (ispw > 0) and (ispw < nspw-1):
        #            f2string = ('%s %6.3f %6.3f '% (f1string,grms_x,grms_y))
        #            gall_rms_x.append(grms_x)
        #            gall_rms_y.append(grms_y)
        #            f1string = f2string

        #        if ispw == (nspw-1):
        #            f3string = ('%s %6.3f %6.3f \n'% (f2string,grms_x,grms_y))
        #            gall_rms_x.append(grms_x)
        #            gall_rms_y.append(grms_y)

        #        if ispw == (nspw-1):
        #            f3string = ('%s %6.3f %6.3f \n'% (f2string,grms_x,grms_y))

                if ispw > 0:
                    f2string = ('%s %6.3f %6.3f '% (f1string,grms_x,grms_y))
                    gall_rms_x.append(grms_x)
                    gall_rms_y.append(grms_y)
                    f1string = f2string

#                if ispw == (nspw-1):
                if ispw == spw_un[-1]:
                    f3string = ('%s \n'% (f1string))

            f.write(f3string)


        rms_med = numpy.median(rms_med)
        f.write('\n\n    BANDPASS RMS MEDIAN VALUE = %6.3f \n' % (rms_med))
        if rms_med > 0.05:
            f.write ('Consider using BPOLY, or B with channel smoothing (e.g. solint="20ch")\n')


        #  Get outliers in each spw
        gx = gall_rms_x
        gy = gall_rms_y
        gx = numpy.reshape(gx,(nant,nspw))
        gy = numpy.reshape(gy,(nant,nspw))
        gx = numpy.transpose(gx)
        gy = numpy.transpose(gy)
#        print "shape(gx) = ", np.shape(gx)
#        print "shape(gy) = ", np.shape(gy)
        tsigma = 3.0
        pbad = []
        antbad = []
        spwbad = []
        f.write('\n\n       RMS OUTLIERS >%3.1f SIGMA\n\n' % (tsigma))
        f.write(' SPW     Xpol           Ypol\n')
        f.write('      mean    rms    mean   rms     OUTLIERS \n\n')
#        print "spw_un = ", spw_un
        for i in range(nspw):
            ispw = spw_un[i]
            nout = 0; noutstr = 'No Outliers'
#            print "shape(gx[%d]) = " % (i), np.shape(gx[i])
#            print "shape(gy[%d]) = " % (i), np.shape(gy[i])
            xavg = numpy.median(gx[i])
            xeavg = numpy.sqrt(numpy.var(gx[i]))
            yavg = numpy.median(gy[i])
            yeavg = numpy.sqrt(numpy.var(gy[i]))
            f.write('%3d  %6.4f %6.4f  %6.4f %6.4f'% (ispw, xavg, xeavg, yavg, yeavg))
            for iant in ant_un:
                xoff = (gx[i][iant]-xavg)/xeavg
                cpol = 'X'
                if (numpy.abs(xoff) > tsigma):
                    if (nout == 0):
                        f.write('  %s  ant=%2d  sigma=%4.1f \n'% (cpol, iant, xoff))
                    else:
                        f.write('%36s  ant=%2d  sigma=%4.1f \n'% (cpol, iant, xoff))
                    nout=nout+1
                    pbad.append(cpol)
                    antbad.append(iant)
                    spwbad.append(ispw)

                yoff = (gy[i][iant]-yavg)/yeavg
                cpol = 'Y'
                if (numpy.abs(yoff) > tsigma):
                    if (nout == 0):
                        f.write('  %s  ant=%2d  sigma=%4.1f \n'% (cpol, iant, yoff))
                    else:
                        f.write('%36s  ant=%2d  sigma=%4.1f \n'% (cpol, iant, yoff))
                    nout=nout+1
                    pbad.append(cpol)
                    antbad.append(iant)
                    spwbad.append(ispw)
            if nout == 0: f.write('  %s \n'% (noutstr))


        f.close()
        os.system('cat '+zfileRes)

        #  Plot band bandpasses

        nobad = len(pbad)
        if nobad > 0:
            print '******* see plot in bandpass_bad.png ******'
            pl.close()
            nsub1 = nobad/2 + 1
            nsub2 = 2; nsub3 = 0
            tb.open (caltable)
            for i in range(0,len(pbad)):
                nsub3 = nsub3 + 1
                if (calFormat == 33):
                    tb1 = tb.query('CAL_DESC_ID=='+str(spwbad[i])+' and ANTENNA1=='+str(antbad[i]))
                    if pbad[i] == 'X': g = tb1.getcol('GAIN')[0]
                    if pbad[i] == 'Y': g = tb1.getcol('GAIN')[1]
                else:
                    tb1 = tb.query('SPECTRAL_WINDOW_ID=='+str(spwbad[i])+' and ANTENNA1=='+str(antbad[i]))
                    if pbad[i] == 'X':
                        g = tb1.getcol('CPARAM')[0]
                    if pbad[i] == 'Y':
                        g = tb1.getcol('CPARAM')[1]

                gg = numpy.transpose(g)[0]
                chan = range(0,len(gg))
                pl.subplot(nsub1, nsub2, nsub3)
                pl.plot(chan,gg,'b,')
                pl.title('Bandpass: spw '+str(spwbad[i])+'; ant '+str(antbad[i])+'; pol '+pbad[i])
                pl.xticks([])
            pl.savefig(qa2_output_dir+'bandpass_bad.png')
            tb.close()

    def flag_calc(self, in_ms):
        # Create the local instance of the flag tool and open it
        if (casadef.casa_version >= '4.0.0'):
            fgLoc = fgtool()   
        else:
            fgLoc = fgtool.create()
        fgLoc.open( in_ms )

        # Get the flagging statistics
        fgLoc.setdata()
        fgLoc.setflagsummary()
        flag_stats_dict = fgLoc.run()

        # Close and delete the local flag tool
        fgLoc.done()
        del fgLoc

        # Return the dictionary containing the flagging statistics
        return flag_stats_dict

    def flag_stats(self, ms2='', qa2_output_dir=''):

        """
        flag_stats.py

        This is an experimental python script that determines the distribution
        of flags in the calibrated data base.  It only includes flags from
        shadowing and anomalous bad data.

        INPUTS NEEDED:

           None.  assumes visibility data set is ms2

        OUTPUTS:

        The ascii output file lists the spw and antenna percentage of
        flagged data.

        qa2/flag_stat.txt'

        USEAGE: assumes ms2 as the visibility data set

        execfile (flag_stats.py)

        """

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        flagStats = self.flag_calc(ms2)

        zfileRes = qa2_output_dir+'flag_stat.txt'
        os.system('rm -f '+zfileRes)
        f = open (zfileRes, 'w')
        print 'opening file '+zfileRes

        f.write('\n\n\n    FLAGGING STATISTICS \n\n')
        f.write( 'Overall -> %.2f' %(100.0*flagStats['flagged']/flagStats['total'])+'\n')
        f.write('\n')
        f.write('Per spw (over total of dataset):\n')
        for i in flagStats['spw']:
            f.write(i+' -> %.2f' %(100.0*flagStats['spw'][i]['flagged']/flagStats['total'])+'\n')

        f.write('')
        f.write('Per antenna (over total of dataset):\n')
        for i in flagStats['antenna']:
            f.write( i+' -> %.2f' %(100.0*flagStats['antenna'][i]['flagged']/flagStats['total'])+'\n')

        f.close()

    def flux_values(self, ms2='', qa2_output_dir=''):

        """
        flux_values.py

        This program reads the log file obtained with flux scale, and puts
        the output in a better format.

        execfile ('flux_values.py')

        INPUTS NEEDED:

           None.  assumes table is in ms2+'.fluxscale'

        OUTPUTS:

        The ascii output  is put in

        ms2+'.flux.txt'

        USEAGE:

        execfile ('qa2_flux_values.txt')

        """

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        caltable = ms2+'.fluxscale'
        if os.path.isfile(caltable) == False: return 0
        caltable2 = qa2_output_dir+'flux.txt'
        f1 = open(caltable, 'r')
        f2 = open(caltable2, 'w')

        f2.write('**********************************************************\n\n')
        f2.write('                    Flux Density Determinations \n\n')

        lines = f1.readlines()
        for line in lines:
            x = line.find('Found reference')
            if x!=-1:
                line_out = line[x+26:x+42]
                f2.write('   Reference source %s\n' %(line_out))

            x = line.find('Flux density')
            if x!=-1:
                line_out = line[x+17:]
                f2.write('     Flux densities %s' %(line_out))


        f1.close()
        caltable_band9 = caltable[:-9] + 'cal_fluxfile'
        if (os.path.isfile(caltable_band9)):
            print "Appending results from extra file = ", caltable_band9
            f1 = open(caltable_band9, 'r')
            lines = f1.readlines()
            for line in lines:
                x = line.find('Found reference')
                if x!=-1:
                    line_out = line[x+26:x+42]
                    f2.write('   Reference source %s\n' %(line_out))

                x = line.find('Flux density')
                if x!=-1:
                    line_out = line[x+17:]
                    f2.write('     Flux densities %s' %(line_out))
            f1.close()
        
        f2.close()
        os.system('cat '+caltable2)

    def addTrailingSlashIfNecessary(self, qa2_output_dir):
        """
        If name is not null, and does not end in a '/', then append a '/'.
        Also, create the directory if it does not exist, so that qa2 functions
        can be called independently, and before generating the full qa2 report.
        """
        if (len(qa2_output_dir) > 0):
            if (os.path.exists(qa2_output_dir) == False):
                print "Creating directory ", qa2_output_dir
                os.mkdir(qa2_output_dir)
            if (qa2_output_dir[-1] != '/'):
                qa2_output_dir += '/'
        return(qa2_output_dir)

    def listobs2(self, ms2='', makeplot=True, qa2_output_dir='', 
                 plotAntennasActualSize=False, xlim=None, ylim=None):

        """
        This is an experimental qa2 python script that produces a more
        readable listobs and plotants than the casapy version.


        INPUTS NEEDED:

           ms2 = visibility data set.  inputset to desired ms.
           makeplot  T = make antenna array plot, F = do not ...
           plotAntennaActualSize: will behave similar to plotants, but without 
                                  the problems that plotants has:
                  1. It will work on measurement sets that are read-only.
                  2. The title will not include the directory.
           xlim, ylim: plotrange (in meters), used only if plotAntennaActualSize is True 

        OUTPUTS:

        The ascii listobs output file is placed in

        qa2_output_dir+'NewListobs.txt'

        The antenna plot file is placed in

        qa2_output_dir+'antenna_config.png'

        USEAGE:

        ms2 = <data set ms>
        qa2_output_dir = <output directory path>
        makeplot = T
        execfile (listobs.py)

        """
        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        ms.open(ms2)
        scanInfo = ms.getscansummary()
        ms.close()
        if (casadef.casa_version < '4.1.0'):
            vm = ValueMapping(ms2)
            msname = vm.inputMs
            spw_info=vm.spwInfo
            conditions = listconditions(vis=ms2,byscan=True,scan='',antenna='0',verbose=False,vm=vm)
        else:
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(ms2)
            msname = ms2
            conditions = listconditions(vis=ms2,byscan=True,scan='',antenna='0',verbose=False)
        try:
            scanInfoSummary = scanInfo['summary']  # CASA 3.4
        except:
            scanInfoSummary = scanInfo  # CASA 4.0.0
        scan_list = scanInfoSummary.keys() 
        #  Sort scans
        scan_num = []
        for sc in scan_list:
            scan_num.append(int(sc))

        scan_srt = np.sort(scan_num)

        nscans = len(scan_srt)

        #   Get experiment time range
        if (casadef.casa_version < '4.1.0'):
            ttemp = vm.getTimesForScan(scan_srt[0])
            int_time = scanInfoSummary[str(scan_srt[0])]['0']['IntegrationTime']
            ttemp = ((ttemp/86400.0)+2400000.5-2440587.5)*86400.0 - int_time/2.0
            scan_begin = np.min(ttemp)
            ttemp = vm.getTimesForScan(scan_srt[nscans-1])
            ttemp = ((ttemp/86400.0)+2400000.5-2440587.5)*86400.0 + int_time/2.0
            scan_end = np.max(ttemp)
        else:
            ttemp = mymsmd.timesforscans(mymsmd.scannumbers())
            ttemp = ((ttemp/86400.0)+2400000.5-2440587.5)*86400.0
            scan_begin = np.min(ttemp)
            scan_end = np.max(ttemp)
        exp_start=timeUtilities.strftime('%Y/%m/%d/%H:%M:%S', timeUtilities.gmtime(scan_begin))
        exp_end=timeUtilities.strftime('%Y/%m/%d/%H:%M:%S', timeUtilities.gmtime(scan_end))

        scan_list = []
        field_list = []
        time_on_field = []

        #   Open file for writing
        #   Split data set?
        zfileRes = qa2_output_dir+'NewListObs.txt'
        print "removing file = ", zfileRes
        os.system('rm -f '+zfileRes)
        f = open (zfileRes, 'w')
        print 'opening file '+zfileRes
        #
        f.write( '\n')
        f.write( '* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n')
        f.write( '\n')
        f.write( '          SUMMARY INFORMATION FOR  %s '% (os.path.basename(msname))+'\n')
        f.write( '\n')
        f.write( '   Experiment Duration:  %19s to'%  (exp_start)+'\n')
        f.write( '                         %19s'%  (exp_end)+'\n')
        f.write( '\n')
        f.write( '   Processed from ms: '+ms2+'\n')
        f.write( '   Written to file:   NewListobs.txt\n')
        f.write( '\n')
        f.write( '                                   SCAN LISTING \n')
        f.write( '\n')
        f.write( '  Scan FdId srcId FieldName         StartTime    StopTime     Int(s) Elev  ScanIntent\n')
        for isc in scan_srt:
        #    print 'scan ', isc
            iscstr = str(isc)
            subscan = []
            nk = scanInfoSummary[iscstr].keys()
            for sc in nk:
                subscan.append(int(sc))

            sub_scan = np.sort(subscan)
            sfid = []
            sstart = []
            sstop = []
            nrows = []
            for isubsc in sub_scan:
                j = str(isubsc)
                fid = scanInfoSummary[iscstr][j]['FieldId']
                start_time = scanInfoSummary[iscstr][j]['BeginTime']
                stop_time = scanInfoSummary[iscstr][j]['EndTime']
                integration_time = scanInfoSummary[iscstr][j]['IntegrationTime']
                sfid.append(fid)
                sstart.append(start_time)
                sstop.append(stop_time)

        #   Integration time addition
            int_time = integration_time / 2.0 / 3600.0 / 24.0
        #   Combine consecutive fieldids
            nslots = len(sfid)
            ib = []
            ie = []
            ib.append(0)
            for i in range(1,nslots):
                if sfid[i] != sfid[i-1]:
                    ie.append(i-1)
                    ib.append(i)

            ie.append(nslots-1)
            nsources = len(ie)
            for i in range (0,nsources):
                ibeg = ib[i]
                iend = ie[i]
                field = sfid[ibeg]
                if (casadef.casa_version < '4.1.0'):
                    field_name = vm.getFieldNamesForFieldId(field)
                    source_id = vm.getFieldIdsForFieldName(field_name)[0]
                else:
                    field_name = mymsmd.namesforfields(field)[0]
                    source_id = mymsmd.fieldsforname(field_name)[0]
                if len(field_name) > 12: field_name = field_name[0:12]+'*'

                mjd_start = sstart[ibeg] - int_time
                mjd_stop = sstop[iend] + int_time
                q_start = qa.quantity(mjd_start, unitname='d')
                q_stop  = qa.quantity(mjd_stop, unitname='d')
                scan_list.append(isc)
                field_list.append(field)
                time_on_field.append((mjd_stop-mjd_start)* 1440.0)
                elev = conditions[isc]['elevation']
        #        pwv = conditions[isc]['pwv']
                if (casadef.casa_version < '4.1.0'):
                    intent = vm.getIntentsForScan(isc)
                else:
                    intent = mymsmd.intentsforscan(isc)
                jintent = string.join(intent, '')
                scan_intent = []
                if jintent.find('POINTING')!=-1: scan_intent.append('Cal Pointing')

                if jintent.find('FOCUS')!=-1: scan_intent.append('Cal Focus')

                if jintent.find('ATMOSPHERE')!=-1: scan_intent.append('Cal atmos=Tsys')

                if jintent.find('BANDPASS')!=-1: scan_intent.append('Cal Bandpass')

                if jintent.find('PHASE')!=-1: scan_intent.append('Cal Phase')

                if jintent.find('AMPLI')!=-1: scan_intent.append('Cal Flux')

                if jintent.find('SIDEBAND')!=-1: scan_intent.append('Cal Sideband')

                if jintent.find('TARGET')!=-1: scan_intent.append('Obs Target')

                f.write (' %4d %4d %4d   %13s  %s - %s  %5.2f %6.1f  %s\n' % (isc, field, source_id, field_name.ljust(16), call_qa_time(q_start,prec=7), call_qa_time(q_stop,prec=7), integration_time, elev, string.join(scan_intent,', ')))
        #
        #
        #
        #      Get source information
        f.write( '\n')
        f.write( '\n')
        f.write( '                               FIELD INFORMATION \n')
        f.write( '\n')
        f.write( ' Fid  Srd  Field                       RA  (J2000)    DEC       Fld Time  #Scans\n')
        f.write( '                                                                  (min)\n')
        temp = timeOnSource(ms=ms2,verbose=False)
        tb.open(ms2+'/FIELD')
        name = tb.getcol('NAME')
        sid = tb.getcol('SOURCE_ID')
        pos = tb.getcol('PHASE_DIR')
        tb.close()
        nfld = len(name)
        n_of_scans = len(field_list)
        for i in range(0,nfld):
            ra=str(pos[0][0][i])+'rad'
            rra=call_qa_time(ra,prec=11)
            dec=str(pos[1][0][i])+'rad'
            rdec=call_qa_angle(dec,prec=10)
            total_time = 0.0
            num_scans = 0
            for ix in range(0,n_of_scans):
                if field_list[ix] == i:
                    total_time = total_time + time_on_field[ix]
                    num_scans = num_scans + 1

            f.write( '%4d %4d  %22s %14s %1s%12s  %5.2f    %3d\n' % (i,sid[i],name[i].ljust(22), rra, rdec[0:1],rdec[2:],total_time, num_scans))
        #       print '%4d %4d  %22s %14s %1s%12s  %5.2f    %3d\n' % (i,sid[i],name[i].ljust(22), rra, rdec[0:1],rdec[2:],total_time, num_scans)



        #      Get spectral window information
        f.write( '\n')
        f.write( '\n')
        f.write( '                        FREQUENCY INFORMATION \n')
        f.write( '\n')
        f.write( 'spw  nchan      -----Frequencies (GHz)-------     --Channel Width-- \n')
        f.write( '               First         Last     Bandwidth     MHz     km/s     POLN \n')
        f.write( '\n')
        if (casadef.casa_version < '4.1.0'):
            spw_size = len(spw_info)
        else:
            spw_size = mymsmd.nspw()

        #  Getting polarizations
        polId = []
        tb.open(ms2+'/DATA_DESCRIPTION')
        for spwId in range(0,spw_size):
            if (casadef.casa_version >= '4.1.0'):
                # msmd reports all the high-numbered WVR spws which we want to avoid
                if (spwId in mymsmd.wvrspws() and spwId>0):
                    spw_size = spwId
                    break
            polId.append(tb.query('SPECTRAL_WINDOW_ID == '+str(spwId)).getcell('POLARIZATION_ID', 0))

        tb.close()

        polId = sorted(dict.fromkeys(polId).keys())[0]

        tb.open(ms2 +'/POLARIZATION')
        corrProdRow = tb.selectrows(polId)
        corrProd = corrProdRow.getcell('CORR_PRODUCT', 0)
        corrType = corrProdRow.getcell('CORR_TYPE', 0)
        tb.close()
        corrProd = corrProd.transpose()

        numCorr = corrProd.shape[0]

        if numCorr == 2:
            polProdNames = ['XX', 'YY']
        elif numCorr == 4:
            polProdNames = ['XX', 'XY', 'YX', 'YY']
        elif numCorr == 1:
            if (corrType == 9):
                polProdNames = ['XX']
            elif (corrType == 12):
                polProdNames = ['YY']
        else:
            sys.exit("Number of correlations not supported")

        #  Does spw0 have wvr?

        if (casadef.casa_version >= '4.1.0'):
            Nwvr = len(mymsmd.wvrspws())
        else:
            if spw_info.keys()[0] == 0:
                Nwvr = 0
            else:
                Nwvr = 1
        if (Nwvr > 0):
            f.write ("  0     4   184.550       189.550     7.500                       ['I'] \n")

        if (casadef.casa_version >= '4.1.0'):
            # remove this once CAS-5450 is resolved
            mytb = createCasaTool(tbtool)
            mytb.open(msname+'/SPECTRAL_WINDOW')
        for i in range(Nwvr,spw_size):
            if (casadef.casa_version < '4.1.0'):
                bandwidth = spw_info[i]['bandwidth']/1.0E9
                num_chan = spw_info[i]['numChannels']
                chan_width = spw_info[i]['chanWidth']/1.0E6
                chan_1_freq = spw_info[i]['chanFreqs'][0]/1.0E9
                chan_L_freq = spw_info[i]['chanFreqs'][num_chan-1]/1.0E9
            else:
                # replace the next two lines when CAS-5450 is resolved
                chan_width = mytb.getcell("CHAN_WIDTH",i)[0]/1.0E6
                bandwidth = mytb.getcell('TOTAL_BANDWIDTH',i)/1.0E9
                num_chan = mymsmd.nchan(i)
                chan_1_freq = mymsmd.chanfreqs(i)[0]/1.0E9
                chan_L_freq = mymsmd.chanfreqs(i)[num_chan-1]/1.0E9
                
            vel_res = chan_width / chan_1_freq * 299.7
            f.write( '%3d %5d %12.6f %12.6f %7.3f %11.3f %8.2f  %s \n' % (i,num_chan,chan_1_freq,chan_L_freq,bandwidth,chan_width,vel_res,polProdNames))
        if (casadef.casa_version >= '4.1.0'):
            # remove this once CAS-5450 is resolved
            mytb.close()

        #      Get antenna information
        f.write( '\n')
        f.write( '\n')
        f.write( '                      ANTENNA INFORMATION \n')
        f.write( '\n')
        f.write(  ' ID  Name    Pad   Size     Longitude   Latitude      E-off   N-off  Elev \n')
        f.write( '                    (m)                                 (m)     (m)   (m) \n')
        tb.open(ms2+'/ANTENNA')
        position = tb.getcol('POSITION')
        diam = tb.getcol('DISH_DIAMETER')
        station = tb.getcol('STATION')
        antenna = tb.getcol('NAME')
        nant = len(antenna)
        tb.close()
        lon0 = -1.1825470
        lat0 = -0.3994900
        plotx = []
        ploty = []
        for i in range (0,nant):
            xx = position[0][i]
            yy = position[1][i]
            zz = position[2][i]
            elev = sqrt(xx**2+yy**2+zz**2)-6379960.0
            lat = math.asin(zz/sqrt(xx**2+yy**2+zz**2))
            lon = math.atan2(yy, xx)
            zlat = str(lat)+'rad'
            zlon = str(lon)+'rad'
            qlat = call_qa_angle(zlat,prec=8)
            qlon = call_qa_angle(zlon,prec=8)
            qqlat = qlat[0]+qlat[2:]
            qqlon=qlon[0]+qlon[2:]
            n_off = (lat - lat0)*6379960.0 +215.0
            e_off = (lon - lon0)*6379960.0 * cos(lat) - 3.0
            f.write( '%3d  %4s %6s %6.1f  %12s %12s  %7.1f %7.1f %5.1f \n' %(i,antenna[i],station[i],diam[i],qqlon,qqlat,e_off,n_off,elev))
            plotx.append (e_off)
            ploty.append (n_off)
        #
        if makeplot:
            pngname = 'antenna_config.png'
            plotfile = qa2_output_dir + pngname
            if (xlim != None or ylim != None):
                plotfile = qa2_output_dir + 'antenna_config_zoom.png'
            plotAntennaPositionList(plotx, ploty, antenna, diam, os.path.basename(ms2),
                                    plotfile, plotAntennasActualSize, xlim, ylim)

        f.close()
        os.system('cat '+zfileRes)
        # end of listobs2

    def mosaic_plot(self, ms2='', qa2_output_dir=''):

        """
        mosaic_plot.py

        This program plots the mosaic region.

        INPUTS NEEDED:

           vis = desired ms

        OUTPUTS:

        The mosaic plot is put in 'qa2_mosaic_plot.png'


        USEAGE:

        execfile ('qa2_mosaic_plot_.py')

        """

        # Is this a mosaic?

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        a=self.getIntentsAndSourceNames(ms2)
        idstr = a['OBSERVE_TARGET']['idstring']
        sid =   a['OBSERVE_TARGET']['sourceid']
        if idstr != sid:
            plotmosaic(vis=ms2, sourceid=sid[0], figfile = qa2_output_dir+'mosaic_plot.png')

    def phase_cal_check(self, ms2='', phase_cal='', qa2_output_dir=''):

        """
        qa2_phase_cal_check.py

        This script plots the phase calibration
          amp and phase versus uvdist for each spw
          amp and phase versys frequency for each spw

        INPUTS NEEDED:

           Assumes data base is ms2
           Needs field number, phase_cal


        OUTPUTS:

        The calibrated and model amplitudes for the selected field
        number is placed in

            qa2_output_dir+'phase_cal_uvdist.png'
            qa2_output_dir+'phase_cal_freq.png'


        USEAGE: assumes ms2 as the visibility data set.

        phase_cal = '2'
        execfile ('phase_cal_check.py')

        """

        from vishead_cli import vishead_cli as vishead

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        pols = self.findNumberOfPolarizations(ms2)

        #  Get number of spw

        a = vishead(vis=ms2, mode = 'get',hdkey = 'spw_name')
        nspw = len(a[0])

        #  Plot amp, phase versus uvdist for calibrator

        nsubplot = 100*nspw+20
        if (pols < 2 or casadef.casa_version >= '4.0.0'):
            # plotxy fails in this case, so make separate plotms plots and montage them together
            # It also cannot overplot a model created with usescratch=False, so we will
            # likely use this work-around in all cases when we switch to casa 4.0.0. - T. Hunter
            plotfiles = ''
            for i in range(0,nspw):
                myplotfile = qa2_output_dir + 'phase_cal_ampuvdist%d.png' % i
                plotfiles += myplotfile + ' '
                print "Running plotms(vis='%s', title='spw %d amplitude', xaxis='uvdist', yaxis='amp', ydatacolumn='corrected', spw=str(%d), averagedata=True, avgchannel='8000', field='%s', avgtime='60', plotfile='%s',coloraxis='corr', overwrite=True)" % (ms2,i,i,phase_cal,myplotfile)
                plotms(vis=ms2, title='spw %d amplitude' % (i), xaxis = 'uvdist', yaxis = 'amp',
                       ydatacolumn = 'corrected', spw=str(i), averagedata = True, avgchannel = '8000', 
                       field = phase_cal, avgtime= '60', plotfile=myplotfile,coloraxis='corr', overwrite=True)
                myplotfile = qa2_output_dir+'phase_cal_phaseuvdist%d.png' % i
                plotfiles += myplotfile + ' '
                print "Running plotms(vis='%s', title='spw %d phase', xaxis='uvdist', yaxis='phase', ydatacolumn='corrected', spw=str(%d), averagedata=True, avgchannel='8000', field='%s', avgtime='60', plotfile='%s',coloraxis='corr', overwrite=True)" % (ms2,i,i,phase_cal,myplotfile)
                plotms(vis=ms2, title='spw %d phase' % (i), xaxis = 'uvdist', yaxis = 'phase',
                       ydatacolumn = 'corrected', spw=str(i), averagedata = True, avgchannel = '8000', 
                       field = phase_cal, avgtime= '60', plotfile=myplotfile,coloraxis='corr', overwrite=True)
            cmd = "montage -tile 2X%d -geometry 1000x1000+0+0  %s %sphase_cal_uvdist.png"%(nspw,plotfiles,qa2_output_dir)
            print "Running %s" % (cmd)
            os.system(cmd)
            os.system('rm -f %s' % plotfiles)
        else:
            for i in range(0,nspw):
                nsubplot = nsubplot+1
                print "Running plotxy(vis='%s', xaxis = 'uvdist', yaxis = 'amp', datacolumn = 'corrected', spw=str(%d), averagemode = 'vector', width = '8000', plotsymbol = ',', field = '%s', timebin = '60',subplot=%d)" % (ms2,i,phase_cal,nsubplot)
                plotxy(vis=ms2, xaxis = 'uvdist', yaxis = 'amp', datacolumn = 'corrected', spw=str(i),
                       averagemode = 'vector', width = '8000', plotsymbol = ',',
                       field = phase_cal, timebin = '60',subplot=nsubplot)
                nsubplot = nsubplot+1
                if (i != nspw-1):
                    figfile = ''
                else:
                    figfile = qa2_output_dir+'phase_cal_uvdist.png'
                print "Running plotxy(vis='%s', xaxis = 'uvdist', yaxis = 'phase', datacolumn = 'corrected', spw=str(%d), averagemode = 'vector', width = '8000', plotsymbol = ',', field = '%s', timebin = '60',subplot=%d, figfile='%s')" % (ms2,i,phase_cal,nsubplot,figfile)
                plotxy(vis=ms2, xaxis = 'uvdist', yaxis = 'phase',
                       datacolumn = 'corrected', spw=str(i),
                       averagemode = 'vector', width = '8000', plotsymbol = ',',
                       field = phase_cal, timebin = '60', subplot=nsubplot, figfile = figfile)

        #  Plot amp, phase versus freq for calibrator
        #  Get number of channels
        vm = ValueMapping(ms2)
        spw_Info = vm.spwInfo
        nchan = spw_Info[0]['numChannels']
        nchan = nchan / 128
        if nchan < 2: nchan = 1
        nwidth = str(nchan)

        nsubplot = 100*nspw+20
        if (pols < 2 or casadef.casa_version >= '4.0.0'):
            # plotxy fails in this case, so make separate plotms plots and montage them together.
            # It also cannot overplot a model created with usescratch=False, so we will
            # likely use this work-around in all cases when we switch to casa 4.0.0. - T. Hunter
            plotfiles = ''
            for i in range(0,nspw):
                myplotfile = qa2_output_dir+'phase_cal_ampfreq%d.png' % i
                plotfiles += myplotfile + ' '
                print "Running plotms(vis='%s', title='spw %d amplitude', xaxis='freq', yaxis='amp', ydatacolumn='corrected', spw=str(%d), averagedata=True, avgchannel='%s', avgbaseline=True, field='%s', avgtime='100000', avgscan=True,plotfile='%s',coloraxis='corr', overwrite=True)" % (ms2,i,i,nwidth,phase_cal,myplotfile)
                plotms(vis=ms2, title='spw %d amplitude' % (i), xaxis = 'freq', yaxis = 'amp',
                       ydatacolumn = 'corrected', spw=str(i),
                       averagedata = True, avgchannel = nwidth, avgbaseline=True,
                       field = phase_cal, avgtime= '100000',avgscan=True,
                       plotfile = myplotfile,coloraxis='corr', overwrite=True)
                myplotfile = qa2_output_dir+'phase_cal_phasefreq%d.png' % i
                plotfiles += myplotfile + ' '
                print "Running plotms(vis='%s', title='spw %d phase', xaxis='freq', yaxis='phase', ydatacolumn='corrected', spw=str(%d), averagedata=True, avgchannel='%s', avgbaseline=True, field='%s', avgtime='100000', avgscan=True,plotfile='%s',coloraxis='corr', overwrite=True)" % (ms2,i,i,nwidth,phase_cal,myplotfile)
                plotms(vis=ms2, title='spw %d phase' % (i), xaxis = 'freq', yaxis = 'phase',
                       ydatacolumn = 'corrected', spw=str(i),
                       averagedata = True, avgchannel = nwidth, avgbaseline=True,
                       field = phase_cal, avgtime= '100000', avgscan=True,
                       plotfile=myplotfile,coloraxis='corr', overwrite=True)
            cmd = "montage -tile 2X%d -geometry 1000x1000+0+0  %s %sphase_cal_freq.png"%(nspw,plotfiles,qa2_output_dir)
            print "Running %s" % (cmd)
            os.system(cmd)
            os.system('rm -f %s' % plotfiles)
        else:
            for i in range(0,nspw):
                nsubplot = nsubplot+1
                print "Running plotxy(vis='%s', xaxis='freq', yaxis='amp', datacolumn='corrected', spw='%s', averagemode='vector', width='%s', timebin='100000', crossscans=True, crossbls=True, interactive=False, field='%s', subplot=%d)" % (ms2,str(i),nwidth,phase_cal,nsubplot)
                plotxy(vis=ms2,
                       xaxis = 'freq', yaxis = 'amp',
                       datacolumn = 'corrected', spw=str(i),
                       averagemode = 'vector', width = nwidth, timebin='100000',
                       crossscans = True, crossbls = True, interactive = False,
                       field = phase_cal, subplot=nsubplot)
                nsubplot = nsubplot+1
                if i != nspw-1:
                    figfile = ''
                else:
                    figfile = qa2_output_dir+'phase_cal_freq.png'
                print "Running plotxy(vis='%s', xaxis='freq', yaxis='phase', datacolumn='corrected', spw='%s', averagemode='vector', width='%s', timebin='100000', crossscans=True, crossbls=True, interactive=False, field='%s', subplot=%d, figfile='%s')" % (ms2,str(i),nwidth,phase_cal,nsubplot,figfile)
                plotxy(vis=ms2,
                xaxis = 'freq', yaxis = 'phase',
                datacolumn = 'corrected', spw=str(i),
                averagemode = 'vector', width = nwidth,timebin='100000',
                crossscans = True, crossbls = True, interactive = False,
                field = phase_cal,subplot=nsubplot,
                figfile = figfile)

    def sensitivity_calculator(self, ms1='', ms2='', caltable='', s_id='', tsys_field='', qa2_output_dir=''):
        """
        Sensitivity calculator

        This is an experimental python script that determines
        the expected sensitivity for observations of a science
        target field.

        The default source_id is the first OBSERVE_TARGET.  If a
        mosaic, the sensitivity for one field in the source_id is
        determined.  source_id can be overwritten as an INPUT.


        INPUTS:  vis:            the calibrated measurement set name
                 ctable:         tsys table name
                 s_id:           s_id = ''.  Use first OBSERVE_TARGET and
                                   one field if mosaic.
                                 s_id = 'N'. Use this source number.  Will
                                   include all fields if mosaic.

          Examples:  s_id='';execfile('sensitivity_calculator.py')
                          will determine expected rms for the first target

                     s_id='4';execfile('sensitivity_calculator.py')
                          will determine expected rms for source id 4.


        OUTPUTS:  The expected rms sensitivity for one channel in
                 each spw, plus other derived values

                 obs_spw:                   A numerical list of the spectral windows
                 chan_sensitivity[obs_spw]: The rms sensitivity in mJy for one channel
                                            per spw
                 chan_width[obs_spw]:       The width of one channel (GHz) per spw
                 num_chan[obs_spw]:         The number of channels per spw
                 spw_sensitivity[obs_spw]:  The rms sensitivity in mJy per spw
                 mfs_sensitivity:           The rms sensitivity in mJy for all spw
        """

        import numpy
        if (tsys_field == ''):
            print "es.sensitivity_calculator() requires the tsys_field parameter to be set"
            return
            
        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        # Initialization of normalized values for each band
        # Taken from alma sensitivity calculator

        band_low = [75.0, 200.0, 300.0, 600.0]
        band_high = [120.0, 300.0, 500.0, 1000.0]
        band_name = ['3','6','7','9']
        tsys_nominal = [75.0, 90.0, 150.0, 1200.0]
        sensitivities = [0.20, 0.27, 0.50, 5.32]

        #  Assume apropri sensitivity for band 3,6,7,9
        #  Sensitivity units are in mJy and are normalized to:
        #    16 12-m antennas,
        #    8 GHz banwidth
        #    Dual freq bandwidth
        #    for tsys_nominal given above
        #    Integration time of one minute

        #  Determine the time on first target source field

        tos = self.getIntentsAndSourceNames(ms2)

        if s_id == '':
            tos['OBSERVE_TARGET'].keys()
            source_id = tos['OBSERVE_TARGET']['sourceid'][0]
            field_all = tos['OBSERVE_TARGET']['id']
            nfield = len(field_all)
            time_os = timeOnSource(ms2)
            min_all = time_os[source_id]['minutes_on_source']
            min_per_field = min_all / nfield
        else:
            time_os = timeOnSource(ms2)
            all_scans = numpy.unique(time_os['source_ids'])
            source_id = int(s_id)
            if source_id in all_scans:
                min_per_field = time_os[source_id]['minutes_on_source']
            else:
                print '*************************************************'
                print '******* source_id =', source_id, ' NOT FOUND'
                print '*************************************************'
                print "You may need to run es.fixForCSV2555() on this dataset."
                return(None)


        #  Determine the number of antennas

        tb.open(ms2+'/ANTENNA')
        antenna = tb.getcol('NAME')
        tb.close()
        nant = len(numpy.unique(antenna))

        #  Get frequency information

        vm = ValueMapping(ms2)

        npol = vm.nPolarizations
        d_pol = 'single_pol'
        if npol >= 2: d_pol = 'dual_pol'

        spw_info = vm.spwInfo
        obs_spw = spw_info.keys()
        n_spw = len(obs_spw)
        chan_width = []
        mean_freq = []
        band_index = []
        num_chan = []
        for dspw in obs_spw:
            chan_width.append(spw_info[dspw]['chanWidth']/1.0E9)
            num_chan.append(spw_info[dspw]['numChannels'])
            freq = spw_info[dspw]['meanFreq']/1.0E9
            mean_freq.append(freq)
            for i in range(0,4):
                if (freq>band_low[i]) and (freq<band_high[i]):
                    band_index.append(i)
                    break



        #  Get tsys for each spw
        if (caltable == ''):
            caltable = ms1+'.tsys'
        tb.open(caltable)
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
            spw = tb.getcol('SPECTRAL_WINDOW_ID')
        else:
            calFormat = 33  # <= casa 3.3
            spw = tb.getcol('CAL_DESC_ID')
        original_spw = np.unique(spw)
        ss = tsys_field
        tsys_spw = []
        for dspw in obs_spw:
            if (calFormat == 33):
                tb1 = tb.query('FIELD_ID=='+ss+' and CAL_DESC_ID=='+str(original_spw[dspw]))
                gain = numpy.real(tb1.getcol('GAIN'))
            else:
                tb1 = tb.query('FIELD_ID=='+ss+' and SPECTRAL_WINDOW_ID=='+str(original_spw[dspw]))
                gain = numpy.real(tb1.getcol('FPARAM'))
            xsum = sum(sum(gain[0]))
            ysum = sum(sum(gain[1]))
            if (xsum > 0 and ysum > 0):
                tsys_spw.append(numpy.median(gain))
            elif (xsum > 0):
                tsys_spw.append(numpy.median(gain[0]))
            else:
                tsys_spw.append(numpy.median(gain[1]))
#            print "spw %d: median tsys=%f" % (dspw, numpy.median(gain))

        tb.close()

        #  Determine expected sensitivities for each spw for each channel

        chan_sensitivity = []
        spw_sensitivity = []
        for dspw in obs_spw:
            rel_tsys = tsys_spw[dspw] / tsys_nominal[band_index[dspw]]
            s_temp = sensitivities[band_index[dspw]] * rel_tsys            #  scale by tsys
            s_temp = s_temp / numpy.sqrt(min_per_field)                    #  scale by inverse sqrt time
#            print "nant = %d" % nant
            s_temp = s_temp * 16.0 / nant                                  #  scale by antenna number
            s_temp = s_temp / numpy.sqrt(abs(chan_width[dspw]) / 8.0)           #  scale by chan bandwidth
            if d_pol != 'dual_pol': s_temp = s_temp * 1.414                #  not dual frequency?
            chan_sensitivity.append(s_temp)
            spw_sensitivity.append(s_temp / numpy.sqrt(num_chan[dspw]))

        #  Results

        print '\n SENSITIVITY CALCULATION:\n     Number of spw             %2d\n     Polarization               %s \n     Number of Antennas        %3d \n     Source_Id             %6d \n     Field Integration Time   %7.2f min \n' % (n_spw, d_pol, nant, source_id, min_per_field)

        print '\n spw   mean freq      T_sys avg  chan width    channel rms     # chan    spw rms\n'

        mfs_rms = 0.0
        for dspw in obs_spw:
            mfs_rms = mfs_rms + 1.0 / spw_sensitivity[dspw]**2
            print ' %2d   %7.3f GHz    %6.1f K   %+8.4f MHz   %7.2f mJy     %5d    %6.2f mJy' %  (dspw, mean_freq[dspw], tsys_spw[dspw],chan_width[dspw]*1.0E3, chan_sensitivity[dspw], num_chan[dspw], spw_sensitivity[dspw])

        mfs_sensitivity = numpy.sqrt(1.0/mfs_rms)
        print ' ALL    %70.2f mJy ' % (mfs_sensitivity)

        return {'min_per_field': min_per_field, 'mfs_sensitivity': mfs_sensitivity}

    def shadowed_ant(self, ms2='', qa2_output_dir=''):

        """
        shadowed_ant.py

        This is an experimental qa2 python script that determines the antenna
        and time range the were flagged because of shadowing.

        Must be run just after the shadowing flag command

        INPUTS NEEDED:

           ms2 = visibility data set (usual default)
           Assumes flag file of ms2+flagversions/flags.BeforeBandpassCalibration'

        OUTPUTS:

        The ascii output file is placed in

        qa2_output_dir+'shadowed_ant.txt'


        USEAGE:

        execfile (shadowed_ant.py)

        HISTORY

        29 Apr - wrapping issue patched

        """

        import pylab as pl

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        tb.open(ms2)
        time=tb.getcol('TIME')
        ant1 = tb.getcol('ANTENNA1')
        ant2 = tb.getcol('ANTENNA2')
        flag=tb.getcol('FLAG_ROW')
        tb.done()

        #  Get saved flagcolumn after shadowing only
        fg_ver = ms2+'.flagversions/flags.BeforeBandpassCalibration'
        tb.open(fg_ver)
        flag = tb.getcol('FLAG_ROW')
        tb.done()

        # DERIVE THE UNIQUE TIME STAMPS
        uniqt = np.unique(time)
        uniqt.sort()
        n_time = uniqt.shape[0]

        # DERIVE THE UNIQUE ANTENNAS
        uniqa = np.unique(np.append(ant1,ant2))
        n_ant = uniqa.shape[0]
        max_ant = np.max(uniqa)  # 9/10/2012

        #   Open file for writing
        zfileRes = qa2_output_dir+'shadowed_ant.txt'
        if os.path.exists: os.system('rm -f '+zfileRes)

        f = open (zfileRes, 'w')
        print 'opening file '+zfileRes
        #
        f.write( '\n\n')
        f.write( '* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n')
        f.write( '\n')
        f.write( '              SHADOWING OF ANTENNAS\n')

        # -------------------------------------------------------------------
        # PROBLEM 1 ... EXTRACT "ANTENNA" FLAGS
        # -------------------------------------------------------------------

        # ... so this is easy if we have an array that is n_time x n_ant x
        # n_ant in shape. We just collapse along the second axis and look for
        # where the number of flags at a timestep equals (n_ant-1). That is,
        # just look for the unique time stamps where baselines with all other
        # antennas are flagged. The problem is that constructing this array is
        # painful because (at least as I set it up here) you have to
        # constantly requery the array. Still, for a small dataset this is
        # pretty fast in numpy. Here goes.

        # (1) Build a flags-by-baseline 3-d array (time, ant1, ant2)

        flag_base = np.zeros([n_time, max_ant+1, max_ant+1],dtype=np.bool)    # 9/10/2012

        if (len(flag) != len(time)):
            print "WARNING: There is a mismatch between the number of rows in %s (%d) and %s (%d)." % (ms2,len(time), fg_ver, len(flag))
            print "You may need to 'rm -rf %s*' and re-run your script starting from the split step." % (ms2)
        for i in np.arange(n_time):
            # ... find rows with this timestamp and a flag
#            print "shape(time) = ", np.shape(time)
#            print "shape(uniqt) = ", np.shape(uniqt)
#            print "flag = ", np.shape(flag)
            ind = ((time == uniqt[i])*(flag == 1)).nonzero()

            # ... continue if no flags
            if ind[0].shape[0] == 0: continue
            # ... note each flagged row in our new array
            for row in ind[0]:
                flag_base[i,ant1[row],ant2[row]] = True
                flag_base[i,ant2[row],ant1[row]] = True

        # (2) Collapse this to a flags-by-antenna array. Sum along one of the
        # antenna axes and then not where all baselines show a flag.

        flag_ant =  np.sum(flag_base, axis=2) >= (n_ant-1)

        # we now have antenna flags in this data set!

        # To look at this visually do this:
        # pl.imshow(np.transpose(flag_ant), aspect='auto')
        # ... this is time on x and antenna on y

        # -------------------------------------------------------------------
        # PROBLEM 2 ... EXTRACT TIME RANGES
        # -------------------------------------------------------------------

        # This is also pretty easy in principle once we have the previous
        # array. We have the unique time stamps and for each antenna. We
        # consider each antenna in turn and step through our array of True
        # (flagged) and False (unflagged) vs time. When flags flip from True
        # to False (or vice verse) in contiguous elements we want to include
        # that in our output.

        didshadow = 0
        for ant in uniqa:
            # this is flagged (True/False) vs. time
#            print "np.shape(flag_ant) = ", np.shape(flag_ant)
#            print "len(flag_ant[0]) = ", len(flag_ant[0])
#            print "ant = ", ant

            # Todd added the following line to prevent a crash on
            # uid___A002_X436934_X48c.ms
            if (ant >= len(flag_ant[0])): break

            flag_v_time = flag_ant[:,ant]

            if np.sum(flag_v_time) == 0:
        #        print "No flags for antenna "+str(ant)
                continue

            # Note where flags start
            flag_started = (flag_v_time == False)* \
                (np.roll(flag_v_time, shift=-1,axis=0) == True)

            # Take care of first time stamp
            if flag_v_time[0] == True:
                flag_started[0] = True

            # Take care of last time stamp (the roll wraps)
            if flag_v_time[0] == True and flag_v_time[-1] == False:
                flag_started[-1] = False

            # Note where flags stop
            flag_stopped = (flag_v_time == True)* \
                (np.roll(flag_v_time, shift=-1,axis=0) == False)

            # Take care of last time stamp
            if flag_v_time[-1] == True:
                flag_stopped[-1] = True

            if np.sum(flag_started) != np.sum(flag_stopped):
                print "Something weird is happening."
                print np.sum(flag_started), np.sum(flag_stopped)

            # Use our "starts" and "stops" to report time ranges
            start_ind = (flag_started).nonzero()
            start_times = uniqt[start_ind]
            for start_time in start_times:
                stop_ind = (flag_stopped*(uniqt >= start_time)).nonzero()
                stop_time = np.min(uniqt[stop_ind[0]])
                mjd_start = start_time / 3600. / 24.
                mjd_stop = stop_time / 3600. / 24.
                q_start = qa.quantity(mjd_start, unitname='d')
                q_stop = qa.quantity(mjd_stop, unitname='d')
                didshadow = 1
                f.write("     antenna: "+str(ant)+" shadowed "+call_qa_time(q_start)+" to "+call_qa_time(q_stop))
                f.write('\n')

        if didshadow == 0:
            f.write('\n           No shadowed antennas\n')

        f.close()
        #os.system('cat '+zfileRes)

    def target_check(self, ms1='', ms2='', target='', target_source='', tsys_caltable='',
                     tsys_field='', qa2_output_dir='', fdmSpwsToImage=''):
        """
        One target is chosen.  A full bandwidth image is made
        and the peak and rms of the image is determined.  Assuming ALMA
        parameters and valid tsys observations, the expected sensitivity is
        determined and compared with the image sensitivity.  The psf and
        the uv-coverage are also made.


        INPUTS NEEDED:

           ms2 is the assumed data set
           target = 'xx'  is the field number of the target
           tsys_field = 'yy' is the field number with the relevant tsys
              if tsys_field = '', tsys_field = target.


        OUTPUTS:

        The calibrated and model amplitudes for the selected field
        number is placed in

            qa2_output_dir+'sensitivity.txt'    contains information about the image
            qa2_output_dir+'target.image.png' is a display of the target image (done by hand)
            qa2_output_dir+'target.psf.png'   is a display of the target psf (done by hand)
            qa2_output_dir+'target.uvcov.png'  is a display of the target uv coverage



        USEAGE: assumes ms2 as the visibility data set.

        target = '4'
        execfile ('target_check.py')




        """


        import numpy
        from clean import clean
        from imstat import imstat
        from imhead import imhead

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        #  Image on target and check on sensitivity
        #
        # Initializations

        vm = ValueMapping(ms2)
        spw_info=vm.spwInfo

        #  Get a frequency
        if (0 not in spw_info.keys()):
            print "Are you sure that ms2 was set to the name of the split ms?"
            return(None)
        freq = spw_info[0]['meanFreq'] / 1.0E9

        image_sizes = [216,256,360,432,640,800,1000,1296,1600,2048]

        tb.open(ms2+'/ANTENNA')
        antenna = tb.getcol('NAME')
        tb.close()
        nant = len(numpy.unique(antenna))

        #  Get band

        zfileRes = qa2_output_dir+'sensitivity.txt'
        os.system('rm -f '+zfileRes)
        f = open (zfileRes, 'w')
        print 'opening file '+zfileRes

        #  Get image parameters

        print 'getting imaging parameters'

        #  Find longest baseline

        baselines = getBaselineLengths(ms2)
        ll = baselines[len(baselines)-1]
        baseline_max = ll[1]
        print 'longest baselines is ',ll[0] ,'with length ', baseline_max
        b = 15000.0 / baseline_max / freq
        print 'theoretical pixel separation ', b

        #  Round to nearest unit
        if b > 0.20:
            b = numpy.int(b*20)/20.0
        else:
            b = numpy.int(b*100.0)/100.0

        zcell = str(b)+'arcsec'

        #  Field of view
        pbsize = 6000.0 / (spw_info[0]['chanFreqs'][0]*1.0E-9)

        #  Find best image size that is >1.5*pbsize/cellsize.
        #  Note: 1.5*pbsize corresponds to the 20% level for a Gaussian beam
        possible_size = 1.5*pbsize/b

        for zimsize in image_sizes:
            if zimsize > possible_size: break

        f.write('\n\n')
        f.write('************************************************************* \n')
        f.write('\n')
        f.write('        CHECK OF A TARGET IMAGE AND SENSITIVITY\n\n')
        f.write('    longest baseline       = %7.1f (meters)\n'% (baseline_max))
        f.write('    recommended cellsize   = %6.2f (arcsec)\n'% (b))
        f.write('    primary beam FWHM      = %6.2f (arcsec)\n'% (pbsize))
        f.write('    recommended image size = %5d\n\n'  % (zimsize))
        print "Running es.sensitivity_calculator(ms1='%s', ms2='%s', caltable='%s', s_id='%s', tsys_field='%s', qa2_output_dir='%s')" % (ms1,ms2,tsys_caltable,target_source,tsys_field,qa2_output_dir)
        tmp1 = self.sensitivity_calculator(ms1=ms1, ms2=ms2, caltable=tsys_caltable, s_id=target_source, tsys_field=tsys_field, qa2_output_dir=qa2_output_dir)
        if tmp1 == None:
            return(None)

        #  Make the image of selected target

        newWidths = []
        doSplit = False
        for s in range(len(spw_info)):
            if (spw_info[s]['numChannels'] > 256):
                if (str(s) in fdmSpwsToImage or fdmSpwsToImage==''):
                    newWidths.append(int(spw_info[s]['numChannels']/64))
                    doSplit = True
            else:
                newWidths.append(1)
        if (doSplit):
            ms3 = ms2+'.chanavg'
            os.system('rm -rf '+ms3)
            print 'Due to the presence of 1 or more FDM windows, splitting target field with channel averaging: ', newWidths
            print "Running split(vis='%s', outputvis='%s', width=%s, field='%s', datacolumn='corrected', spw='%s')" % (ms2, ms3, newWidths, target, fdmSpwsToImage)
            split(vis=ms2, outputvis=ms3, width=newWidths, field=target, datacolumn='corrected', spw=fdmSpwsToImage)
            cleanvis = ms3
            cleanfield = '0'
        else:
            print 'This is a TDM dataset, so no need to average channels prior to imaging'
            cleanvis = ms2
            cleanfield = target

        print 'making mfs image of selected target'
        os.system('rm -rf '+qa2_output_dir+'target_check*')
        print "Running clean(vis='%s', field='%s', imagename='%starget_check', imsize=%d, cell='%s', threshold='%fmJy', interactive=False, niter=100)" % (cleanvis, cleanfield, qa2_output_dir, zimsize, zcell, 3.0*tmp1['mfs_sensitivity'])
        clean(vis=cleanvis,
              field = cleanfield,
              imagename = qa2_output_dir+'target_check',
              imsize = zimsize, cell = zcell,
              threshold = '%fmJy'%(3.0*tmp1['mfs_sensitivity']), # Added 9/7/2012
              interactive = False, niter=100)

        #  Get rms and peak box information

        zbox1 = str(int(0.1*zimsize)); zbox2 = str(int(0.9*zimsize))

        a=imstat(imagename=qa2_output_dir+'target_check.image',
               box = zbox1+','+zbox1+','+zbox2+','+zbox2)

        amax = a['max'][0]

        zbox1 = str(int(0.1*zimsize)); zbox2 = str(int(0.3*zimsize))

        a=imstat(imagename=qa2_output_dir+'target_check.image',
               box = zbox1+','+zbox1+','+zbox2+','+zbox2)
        arms = a['rms'][0]

        clev = float(arms*2.5)

        #  Make plot of object and store

        imview(raster = {'file':qa2_output_dir+'target_check.image'},
               contour = {'file':qa2_output_dir+'target_check.image',
                          'levels':[-1,1,2,4,6,8,10,12,16,20,30,50],
                          'unit':clev},
               zoom = 1,
               out = qa2_output_dir+'target_image.png')

        imview(raster = {'file':qa2_output_dir+'target_check.psf'},
               contour = {'file':qa2_output_dir+'target_check.psf',
                          'levels':[-3,-2,-1,1,2,3,5,7,9,9.5],
                          'unit':0.1},
               zoom = 1,
               out = qa2_output_dir+'target_psf.png')
        if (plotxyAvailable):
            plotxy(vis = ms2,
                   xaxis = 'u', yaxis = 'v',
                   spw = '0:100~100',
                   field = target,
                   interactive = False,
                   figfile = qa2_output_dir+'target_uv.png')
        else:
            plotuv(vis = ms2,
                   spw = '0:100~100',
                   field = target,
                   figfile = qa2_output_dir+'target_uv.png')
            


        #  Get image parameters

        a = imhead(imagename = qa2_output_dir+'target_check.image',
                   mode = 'list')
        freq = a['crval4']*1.0E-9
        bwidth = a['cdelt4']*1.0E-9
        bmaj = a['beammajor']
        bmin = a['beamminor']
        bpa = a['beampa']
        if (type(bmaj) == dict):
            # casa >= 4.1.0  (previously these were floats)
            bmaj = bmaj['value']
            bmin = bmin['value']
            bpa = bpa['value']

        #  Get expected Sensitivities of mfs image

        #vis=ms2
        #s_id = ''
        #execfile(qa2_scripts_dir+'sensitivity_calculator.py')
        print "Calling: es.sensitivity_calculator(ms2='%s', caltable='%s', s_id='%s', tsys_field='%s', qa2_output_dir='%s')" % (ms2,tsys_caltable,str(target_source),str(tsys_field),qa2_output_dir)

#        tmp1 = self.sensitivity_calculator(ms1=ms1, ms2=ms2, caltable=tsys_caltable, s_id=target_source, tsys_field=tsys_field, qa2_output_dir=qa2_output_dir)

        f.write('    target                 = %2s \n' % (target))
        f.write('    resolution             = %5.2f x%5.2f in pa %6.1f\n' % (bmaj, bmin, bpa))
        f.write('    time on target         = %6.2f (min)\n'  % (tmp1['min_per_field']))
        f.write('    peak on image          = %6.2f (mJy)\n'  % (amax*1000.0))
        f.write('    rms on image           = %6.2f (mJy)\n'  % (arms*1000.0))
        f.write('    expected sensitivity   = %6.2f (mJy)\n'  % (tmp1['mfs_sensitivity']))


        f.close()
        os.system('cat '+zfileRes)
        return(0)

    def target_spectrum(self, ms2='', target='', dospw='', qa2_output_dir='',
                        uvrange='0~30m', avgchannel=5, correlation=''):

        """
        target_spectrum.py

        One target is chosen.  The spectrum for the short spacings
        is made for all spw's.


        INPUTS NEEDED:

           ms2 is the assumed data set
           target = 'xx'  is the field number of the target
           dospw = '0'    put in spw's and channel range needed



        OUTPUTS:

        The source spectrum is placed in

            qa2_output_dir+'target_spectrum.png' 



        USEAGE: assumes ms2 as the visibility data set.

        target = '7'
        dospw = '0'
        execfile ('target_spectrum.py')


        """
        pols = self.findNumberOfPolarizations(ms2)
        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)

        (longestLength,shortestLength,longestBaseline,shortestBaseline) = getBaselineExtrema(ms2)
        if (uvrange.find('~') >= 0):
            uvrangeMax = float(uvrange.split('~')[1].split('m')[0])
            if (shortestLength > uvrangeMax):
                baselineStats = getBaselineStats(ms2)
                print "WARNING: No data found for uvrange=%s, increasing max baseline to %.0fm (20th percentile)" % (uvrange, baselineStats[6])
                uvrange = uvrange.split('~')[0] + '~%.0fm' % (baselineStats[6])
                print "new uvrange = ", uvrange
        sep_spw = dospw.split(',')
        n_spw = len(sep_spw)
        subplot = 100*n_spw + 10
        if casadef.casa_version >= '4.2.0':
            plotmsparm="showgui=False,"
        else:
            plotmsparm=""
        if (pols < 2 or casadef.casa_version >= '4.0.0'):
            # plotxy fails in this case, so make separate plotms plots and montage them together.
            # It also cannot overplot a model created with usescratch=False, so we will
            # likely use this work-around in all cases when we switch to casa 4.0.0. - T. Hunter
            plotfiles = ''
            for spw in sep_spw:
                myplotfile = '%starget_spectrum_spw%s.png' % (qa2_output_dir,spw)
                plotfiles += myplotfile + ' '
                cmd="plotms("+plotmsparm+"vis='%s', xaxis='freq', yaxis='amp', ydatacolumn='corrected', field='%s', averagedata=True, avgtime = '100000', avgscan=True, avgbaseline=True, coloraxis='corr', avgchannel='%d', uvrange='%s', spw='%s', plotfile='%s', overwrite=True, title='spw %s (%s)', correlation='%s')" % (ms2,target,avgchannel,uvrange,spw,myplotfile,spw,uvrange,correlation)
                print "es.target_spectrum() is Running "+cmd
                exec cmd
                #print "es.target_spectrum() is Running plotms(vis='%s', xaxis='freq', yaxis='amp', ydatacolumn='corrected', field='%s', averagedata=True, avgtime = '100000', avgscan=True, avgbaseline=True, coloraxis='corr', avgchannel='%d', uvrange='%s', spw='%s', plotfile='%s', overwrite=True, title='spw %s (%s)', correlation='%s')" % (ms2,target,avgchannel,uvrange,spw,myplotfile,spw,uvrange,correlation)
                #plotms(showgui=False,vis=ms2, xaxis='freq', yaxis='amp', ydatacolumn='corrected', field=target,
                #       averagedata=True, avgtime = '100000', avgscan=True, avgbaseline=True, coloraxis='corr',
                #       avgchannel=str(avgchannel), uvrange=uvrange, spw=spw, plotfile=myplotfile,
                #       overwrite=True,title='spw '+spw+' (%s)'%uvrange, correlation=correlation)
                if casadef.casa_version < '4.2.0': waitForPlotms()
            # Here we assume a maximum of 4 spws
            cmd = "montage -tile 2X2 -geometry 1000x1000+0+0  %s %starget_spectrum.png"%(plotfiles,qa2_output_dir)
            print "Running %s" % (cmd)
            os.system(cmd)
            os.system('rm -f %s' % plotfiles)
        else:
          for spw in sep_spw:
            subplot = subplot + 1
            print "Running plotxy(vis='%s', xaxis='freq', yaxis='amp', datacolumn='corrected', field='%s', plotsymbol='o', averagemode='vector', timebin='100000', crossscans=True, crossbls=True, width='5', uvrange='%s', spw='%s', subplot=%d, figfile='%s', interactive=False)" % (ms2,target,uvrange,spw,subplot,qa2_output_dir+'target_spectrum.png')
            os.system('rm -rf plotxy.log')
            mylogfile = casalog.logfile()
            casalog.setlogfile('plotxy.log')
            plotxy(vis = ms2,
                   xaxis = 'freq', yaxis = 'amp', datacolumn = 'corrected',
                   field = target, plotsymbol = 'o',
                   averagemode = 'vector', timebin = '100000',
                   crossscans = True, crossbls = True, width = '5',
                   uvrange = uvrange,
                   spw = spw, subplot = subplot,
                   figfile = qa2_output_dir+'target_spectrum.png', interactive = False)
            casalog.setlogfile(mylogfile)
            logtext = open('plotxy.log','r')
            if 'SEVERE' in logtext.read():
                print "WARNING: Blank plot!"
                print "Did you flag the short spacings for spw %s on field %s?  If so, then you could try increasing the uvrange." % (spw,target)
            logtext.close()
            os.system('rm -rf plotxy.log')
    
    def tsys_stat(self, ms1='', tsys_field='', makeplot=True, qa2_output_dir=''):

        """
        tsys_stat.py

        This is an experimental python script that determines the statistics,
        the average and outliers for the tsys.  Plots are made of the TDM
        tsys determination.

        INPUTS NEEDED:

           None.  assumes visibility data set is ms1 and the tdm tsys in
                  in ms1+.tsys.png'

        OUTPUTS:

        The ascii output file lists the scans for each tsys observation, and
        any outliers for each antenna/spw.

        <qa2_output_dir>+'tsys_stat.txt'
        <qa2_output_dir>+'tsys_plot.png'


        USEAGE: assumes ms1 as the visibility data set and the TDM tsys
                is in ms1+'.tsys'.
                makeplot = T for plots, makeplot = F for no plots

        makeplot = T
        execfile ('qa2_scripts/tsys_stat.py')

        """

        #######################################

        import numpy

        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)

        #  Determines rms and average value of Tsys (TDM)

        #  Get antenna paramters

        tb.open(ms1+'/ANTENNA')
        ant_names=tb.getcol('NAME')
        ant_pos=tb.getcol('POSITION')
        nant = len(ant_names)
        tb.close()

        #  Get amplitude and other information

        caltable = ms1+'.tsys'               #  Put in caltable name

        tb.open(caltable)
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
        else:
            calFormat = 33  # <= casa 3.3

        time=tb.getcol('TIME')
        time = time-time[0]+5.0
        antenna1 = tb.getcol('ANTENNA1')
        if (calFormat == 33):
            gain = tb.getcol('GAIN')
            spw = tb.getcol('CAL_DESC_ID')
        else:
            gain = tb.getcol('FPARAM')
            spw = tb.getcol('SPECTRAL_WINDOW_ID')
        nchan = gain.shape[1]
        gain_amp = numpy.abs(gain)
        fldid = tb.getcol('FIELD_ID')
        scanno = tb.getcol('SCAN_NUMBER')
        spw_un = numpy.unique(spw)
        nspw = len(spw_un)
        tb.close()
        nstream = len(antenna1)
        ntimes = 0
        dotime = 1
        fld_un = numpy.unique(fldid)

        zfileRes = qa2_output_dir+'tsys_stat.txt'
        if os.path.exists (zfileRes): os.system('rm -f '+zfileRes)

        f = open (zfileRes, 'w')
        print 'opening file '+zfileRes

        #  Get average tsys per each scan/elevation

        vm = ValueMapping(ms1)
        scans = unique(scanno)
        nscans = len(scans)
        #   Loop over each scan
        TX_save = []
        TY_save = []
        elev_save = []
        conditions = listconditions(vis=ms1,byscan=True,scan='',antenna='0',verbose=False,vm=vm)
        for isc in range (0,nscans):
            tsys_x = []
            tsys_y = []
            for ist in range (0,nstream):
                if scans[isc] == scanno[ist]:
                    ncrange = range(int(0.2*nchan), int(0.8*nchan))
                    for nc in ncrange:
                        tsys_x.append(gain_amp[0,nc,ist])
                        tsys_y.append(gain_amp[1,nc,ist])


            T_x = numpy.median(tsys_x)
            T_y = numpy.median(tsys_y)
            Tmin = numpy.min(tsys_x+tsys_y)*0.7
            Tmax = numpy.max(tsys_x+tsys_y)*1.00
            TX_save.append(T_x)
            TY_save.append(T_y)
            elev_save.append(conditions[scans[isc]]['elevation'])
        #    sfield = vm.getFieldsForScan(scans[isc])

        nscans = len(elev_save)
        scan_tsys=[]
        f.write('\n\n')
        f.write('*********************************************************** \n')
        f.write('\n')
        f.write('              MEDIAN TSYS WITH SOURCE/ELEVATION \n')
        f.write('                  (see plots for details) \n')
        f.write('Scan   Fid                Source      Elev    Median T_x  Median T_y \n')
        TXs = []
        TYs = []
        for isc in range (0,nscans):
            sfield = vm.getFieldsForScan(scans[isc])
            fid = vm.getFieldIdsForFieldName(sfield)
            f.write('%4d  %4d %24s %6.1f   %7d     %7d\n'% (scans[isc], fid[0], sfield[0], elev_save[isc], TX_save[isc], TY_save[isc]))
        #    print '%4d  %4d %24s %6.1f   %7d     %7d \n'% (scans[isc], sfield[0], elev_save[isc], TX_save[isc], TY_save[isc])
            scan_tsys.append(sfield[0])
            TXs.append(TX_save[isc])
            TYs.append(TY_save[isc])


        #  Find outlier Tsys's

        #  Set up averages

        max_spw = []
        for ispw in range(len(spw_un)):
            varx = []
            avgx = []
            vary = []
            avgy = []
            for iant in range(0,nant):
                ggx = []
                ggy = []
                for id in range(0,nstream):
#                    print "%d vs. %d,  %d vs. %d" % (antenna1[id],iant,spw[id],ispw)
                    if ((antenna1[id] == iant) and (spw[id] == spw_un[ispw])):
                        ncrange = range(int(0.2*nchan), int(0.8*nchan))
                        for ic in ncrange:
                            ggx.append(gain_amp[0][ic][id])
                            ggy.append(gain_amp[1][ic][id])

                varx.append(numpy.var(ggx))
                avgx.append(numpy.average(ggx))
                vary.append(numpy.var(ggy))
                avgy.append(numpy.average(ggy))

            medavgx = numpy.median(avgx)
            medavgy = numpy.median(avgy)
            medvarx = 0.0
            medvary = 0.0
            nx = 0
            ny = 0
            for iant in range(0,nant):
                difx = numpy.abs(avgx[iant]-medavgx)
                dify = numpy.abs(avgy[iant]-medavgy)
                if (difx < 5.0*medavgx):
                    medvarx = medvarx + numpy.abs(avgx[iant]-medavgx)
                    nx = nx + 1

                if (dify < 5.0*medavgy):
                    medvary = medvary + numpy.abs(avgy[iant]-medavgy)
                    ny = ny + 1


            medvarx = medvarx / numpy.sqrt(float(nx))
            medvary = medvary / numpy.sqrt(float(ny))
            max_spw.append(0.5*(medavgx+medavgy)+2.5*(medvarx+medvary))
            if ispw == 0:
                f.write('\n\n\n')
                f.write('            MEDIAN TSYS versus ANTENNA/SPW and OUTLIERS \n\n')
                f.write('              TSYS MEDIAN                >3-sigma OUTLIERS \n')
                f.write('       XPOL              YPOL                OUTLIERS \n')
                f.write(' SPW    T   rms        T   rms      antenna  Pol  tsys  n-sigma \n\n')

            f.write('%3d  %5.0f %4.0f     %5.0f %4.0f ' %(ispw, medavgx, medvarx, medavgy, medvary))
            nout = 0
            for iant in range(0,nant):
                offx = numpy.abs(avgx[iant]-medavgx)/medvarx
                offy = numpy.abs(avgy[iant]-medavgy)/medvarx
                if offx > 3.0:
                    if (nout == 0):
                        f.write('  %3d %4s   X %5d  %5.1f \n'%(iant, ant_names[iant],avgx[iant], offx))
                    else:
                        f.write('%36d %4s   X %5d  %5.1f \n'%(iant, ant_names[iant],avgx[iant], offx))
                    nout += 1
                if offy > 3.0:
                    if (nout == 0):
                        f.write('  %3d %4s   Y %5d  %5.1f \n'%(iant, ant_names[iant],avgy[iant], offy))
                    else:
                        f.write('%36d %4s   Y %5d  %5.1f \n'%(iant, ant_names[iant],avgy[iant], offy))
                    nout += 1
            if (nout == 0): f.write('  No outliers \n')

        f.close()

        os.system('cat '+zfileRes)

        if makeplot == True:
            showgui = False
            lchan = int(0.1*nchan); hchan = int(0.9*nchan); chanstr = str(lchan)+'~'+str(hchan)
            tsys_spw = self.getSpwInfo(ms1,intent='CALIBRATE_ATMOSPHERE').keys()
            numspw = len(tsys_spw)
            for i in range (0,numspw):
                if (np.isnan(max_spw[i])):
                    # Take care of the single-polarization case, where max_spw will be NaN
                    if (np.sum(TXs) > 0):
                        max_spw[i] = np.median(TXs) * 2
                    elif (np.sum(TYs) > 0):
                        max_spw[i] = np.median(TYs) * 2
                if i != numspw-1:
                    print "Running plotcal(caltable='%s', xaxis='freq', yaxis='amp', field='%s', spw='%s', showgui=%s, plotsymbol=',', plotrange=[0,0,0,%f], subplot=%d)" % (caltable,tsys_field,str(tsys_spw[i])+':'+chanstr,showgui,max_spw[i],221+i)
                    plotcal(caltable = caltable, xaxis = 'freq', yaxis = 'amp', field = tsys_field,
                        spw = str(tsys_spw[i])+':'+chanstr, showgui = showgui, plotsymbol = ',',
                        plotrange = [0,0,0,max_spw[i]], subplot=221 + i)
                else:
                    print "Running plotcal(caltable='%s', xaxis='freq', yaxis='amp', field='%s', spw='%s', showgui=%s, plotsymbol=',', plotrange=[0,0,0,%f], subplot=%d, figfile='%s')" % (caltable,tsys_field,str(tsys_spw[i])+':'+chanstr,showgui,max_spw[i],221+i, qa2_output_dir+'tsys_plot.png')
                    plotcal(caltable = caltable, xaxis = 'freq', yaxis = 'amp', field = tsys_field,
                        spw = str(tsys_spw[i])+':'+chanstr, showgui = showgui, plotsymbol = ',',
                        plotrange = [0,0,0,max_spw[i]], subplot=221 + i,
                        figfile = qa2_output_dir+'tsys_plot.png')

    def wvr_stat(self, ms1='', refAnt='',qa2_output_dir='', autoscale_yaxis=True, wvr_gaintable='',
                 scanintent='BANDPASS', solint='int', spw='', pol='', plotfile='wvr_plot.png',
                 nsigma_coherence=5, unwrap_phase=True):

        """
        wvr_stat.py

        This is an experimental qa2 python script that analyzes the
        bandpass calibrator data to determine the phase rms before and
        after application of wvr.  This is useful to determine if the
        the wvr corrections are reasonable, and to suggests flags or
        averaging of any bad antenna wvrgcals.  Uses spw 0, 'XX' only.

        INPUTS NEEDED:

           assumes visibility data set is ms1
           refAnt can be defined before entry, otherwise uses '0'
           makeplot can be defined before use, otherwise = T
           wvr_gaintable should be left as '' for manual reduction.
              Alternatively, it is set when called from analyzemscal.py which passes
              in the name of the wvr table created by the pipeline.

        OUTPUTS:

        The ascii output file contains the statistics for each antenna (wrt
        to refAnt) and the output from wvrgcal in:

        <qa2_output_dir>/wvr_stat.txt'

        The corrected (green) and uncorrected (blue) phases are
        shown for each antenna in

        <qa2_output_dir>/wvr_plot.png'

        USEAGE: assumes ms1 as the visibility data set
                assumes refAnt='0', if not defined

        execfile (wvr_stat.py)

        """

        import numpy
        import pylab as pl
        from clearplot import clearplot
        from gaincal import gaincal

        if (autoscale_yaxis != True and autoscale_yaxis != False):
            autoscale_yaxis_range = autoscale_yaxis
            autoscale_yaxis = False
        else:
            autoscale_yaxis_range = [-200,200]
        qa2_output_dir = self.addTrailingSlashIfNecessary(qa2_output_dir)
        if (refAnt == ''):
            refAnt = '0'
            refAntID = '0'
        else:
            refAntID = getAntennaIndex(ms1,refAnt)


        makeplot = True

        print "Running ValueMapping"
        vm = ValueMapping(ms1)
        print "Completed ValueMapping"

        #  Get antenna parameters

        tb.open(ms1+'/ANTENNA')
        ant_names=tb.getcol('NAME')
        ant_pos=tb.getcol('POSITION')
        nant = len(ant_names)
        tb.close()


        #    Get bandpass scan

        scan_list = vm.uniqueScans
        cscan = None
        sfield = ''
        for isc in scan_list:
            intent = vm.getIntentsForScan(isc)
            jintent = string.join(intent, '')
            if jintent.find(scanintent)!=-1:
                if (scanintent.find('PHASE')>=0):
                    # skip the amplitude and bandpass calibrator scans if they also have PHASE intent
                    if (jintent.find('BANDPASS')>=0 or jintent.find('AMPLI')>=0 or
                        jintent.find('FLUX')>=0):
                        continue
                sfield = vm.getFieldsForScan(isc)[0]
                if (scanintent.find('BANDPASS')>=0):
                    cscan = str(isc)
                    break
                else:
                    # use all scans, not just the first scan
                    if (cscan == None):
                        cscan = str(isc)
                    else:
                        cscan += ',' + str(isc)

        if (cscan == None):
            print "No %s intent found." % (scanintent)
            for isc in scan_list:
                intent = vm.getIntentsForScan(isc)
                jintent = string.join(intent, '')
                if jintent.find('PHASE')!=-1:
                    print "Using first PHASE calibrator"
                    cscan = str(isc)
                    sfield = vm.getFieldsForScan(isc)[0]
                    break
        if (cscan == None):
            print "No %s nor PHASE calibrator scans found!" % (scanintent)
            return

        #    Get a science spw
        if (spw == ''):
            a = self.getSpwInfo(ms1); jspw = a.keys()[0]
            cspw = str(jspw)  # should apply a channel selection here to avoid edges
        else:
            cspw = str(spw)
        if (pol == ''):
            cpol = 'X'
        else:
            cpol = pol


        #   Remove previous phase gain solutions:
        os.system('rm -rf '+qa2_output_dir+'wvr_before')
        os.system('rm -rf '+qa2_output_dir+'wvr_after')

        if makeplot == True:
            clearplot()


        #   Open file for writing
        if (plotfile != 'wvr_plot.png'):
            zfileRes = qa2_output_dir + 'wvr_stat_%s.txt' % (os.path.basename(plotfile).strip('.png'))
        else:
            zfileRes = qa2_output_dir+'wvr_stat.txt'
        if os.path.exists (zfileRes): os.system('rm -f '+zfileRes)

        f = open (zfileRes, 'w')
        print 'opening file '+zfileRes

        #   Make phase gain solution with and without wvr correction
        print "Running gaincals with spw = ", cspw
        print "Running gaincal(vis='%s', refant='%s', calmode='p', selectdata=True, scan='%s',spw='%s',solint='%s', caltable='%swvr_before')" % (ms1,refAnt,cscan,cspw,solint,qa2_output_dir)
        gaincal(vis=ms1,
                refant=refAnt,calmode='p', selectdata=True,
                scan=cscan,spw=cspw,solint=solint,
                caltable=qa2_output_dir+'wvr_before')

#        print "Done the gaincal on the 'without' wvr correction"

        #   Which gain table.  Smoothed or not?
        if (wvr_gaintable == ''):
            wvr_gaintable = ms1+'.wvr.smooth'
            if not os.path.exists(wvr_gaintable): wvr_gaintable = ms1+'.wvr'

        print "Running gaincal(vis='%s', refant='%s', calmode='p', selectdata=True, scan='%s',spw='%s',solint='%s', caltable='%swvr_after', gaintable='%s')" % (ms1,refAnt,cscan,cspw,solint,qa2_output_dir,wvr_gaintable)
        gaincal(vis=ms1,
                refant=refAnt,calmode='p',selectdata=True,
                scan=cscan,spw=cspw,solint=solint,
                caltable=qa2_output_dir+'wvr_after',gaintable = wvr_gaintable)

#        print "Done the gaincal on the 'with' wvr correction"
        f.write('number of antennas=%3d  refAnt=%4s   \n' % (nant, refAnt))


        #  Get antenna separations

        ant_sep=[]
        for i in range(0,nant):
            temp = (ant_pos[0,i]-ant_pos[0,refAntID])**2 + (ant_pos[1,i]-ant_pos[1,refAntID])**2 +(ant_pos[2,i]-ant_pos[2,refAntID])**2
            ant_sep.append(numpy.sqrt(temp))

        #  Get phases before wvrgcal

        tb.open(qa2_output_dir+'wvr_before')
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
        else:
            calFormat = 33  # <= casa 3.3

        time=tb.getcol('TIME')
        time = time-time[0]+0.0
        antenna1 = tb.getcol('ANTENNA1')
        if (calFormat == 33):
            gain = tb.getcol('GAIN')
        else:
            gain = tb.getcol('CPARAM')
        p_1 = numpy.arctan2(numpy.imag(gain),numpy.real(gain))*180.0 / numpy.pi
        np1=len(antenna1)
        #print 'number of phases ', np1
        tb.close()

        #  Get phases after wvrgcal

        tb.open(qa2_output_dir+'wvr_after')
        time = tb.getcol('TIME')
#        time = time-time[0]+0.0
        antenna1 = tb.getcol('ANTENNA1')
        if (calFormat == 33):
            gain = tb.getcol('GAIN')
        else:
            gain = tb.getcol('CPARAM')
        p_2 = numpy.arctan2(numpy.imag(gain),numpy.real(gain))*180.0 / numpy.pi
        np2=len(antenna1)
        #print 'number of phases ', np2
        tb.close()

        #  get a phase stream for each antenna

        var_1=[]
        var_2=[]
        if makeplot: pl.close()


        #  Formatting of plots
        nsub3 = 0
        nsub1, nsub2 = self.pickSubplotGrid(nant)

        for iant in range(0,nant):            
            if cpol == 'X':
                pa_1 = p_1[0][0]
                pa_2 = p_2[0][0]
            else:
                pa_1 = p_1[1][0]
                pa_2 = p_2[1][0]

            np1 = len(pa_1)
            pb_1 = []
            pb_2 = []
            tt = []

            for j in range(0,np1):
                if iant == antenna1[j]:
                    pb_1.append(pa_1[j])
                    pb_2.append(pa_2[j])
                    tt.append(time[j])
            #
        #
            npc = len(pb_1)
            pc_1 = pb_1
            pc_2 = pb_2
            if (unwrap_phase==False):
                # Make an independent copy of the list to ensure that raw
                # phases get plotted, even after the unwrapping for statistics.
                pc_1_plot = list(pc_1)
                pc_2_plot = list(pc_2)
            # Remove lobe ambiguities before computing statistics
            for i in range(1,npc):
                pdiff = pc_1[i]-pc_1[i-1]
                pdiff = numpy.mod(pdiff+900.0,360.0)-180.0
                pc_1[i] = pc_1[i-1] + pdiff
                pdiff = pc_2[i]-pc_2[i-1]
                pdiff = numpy.mod(pdiff+900.0,360.0)-180.0
                pc_2[i] = pc_2[i-1] + pdiff
            if (unwrap_phase):
                pc_1_plot = pc_1
                pc_2_plot = pc_2

        #     plot phases
            if makeplot == True:
                nsub3 = nsub3 + 1
                desc = pl.subplot(nsub1,nsub2,nsub3)
                pl.subplots_adjust(hspace=0.40, wspace=0.40)
                pl.hold(True)
                tt = pb.date2num(mjdSecondsListToDateTime(tt))
                if (autoscale_yaxis):
                    pmax = numpy.max([numpy.max(pc_1), numpy.max(pc_2)])
                    pmin = numpy.min([numpy.min(pc_1), numpy.min(pc_2)])
                    pdiff = pmax-pmin
                    if pdiff <10: pdiff = 10
                    pmax = pmax + 0.25*pdiff
                    pmin = pmin - 0.25*pdiff
                pl.plot_date(tt, pc_1_plot, 'b.', markeredgecolor='b')
                pl.title('WVR '+ant_names[iant], size=10)
                if (autoscale_yaxis):
                    pl.plot_date(tt,pc_2_plot,'g.', markeredgecolor='g')
                else:
                    pl.plot_date(tt,pc_2_plot,'g.', markeredgecolor='g')
                # tt is in units of days
                ttrange = tt[-1] - tt[0]
                if (ttrange < 3.5/1440.):
                    ttmajor = 1
                    ttminor = 1
                elif (ttrange < 10/1440.):
                    ttmajor = 2
                    ttminor = 1
                elif (ttrange < 60/1440.):
                    ttmajor = 10
                    ttminor = 2
                else:
                    ttmajor = 20
                    ttminor = 10
                desc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,300,ttmajor)))
                desc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,300,ttminor)))
                desc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
                desc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
                if (iant != nant-1):
                    desc.set_xticklabels([])
                else:
                    pl.xlabel('UT (HH:MM)', size=10)
                pl.yticks(range(-540,541,90))
                if (autoscale_yaxis):
                    pl.ylim (pmin,pmax)
                else:
                    pl.ylim(autoscale_yaxis_range)
                pl.setp(plt.gca().get_xmajorticklabels(), size=7)
                pl.setp(plt.gca().get_ymajorticklabels(), size=8)
                if (iant == 0):
                    pb.text(0.0, 1.3, 'before',color='b', transform=desc.transAxes,size=9)
                    pb.text(0.75, 1.3, 'after',color='g', transform=desc.transAxes,size=9)
                if (iant == 1):
                    pb.text(0.0, 1.3, 'SPW '+cspw+', Pol '+cpol,color='k', transform=desc.transAxes,size=10)
                if (iant == 2):
                    pb.text(0.25, 1.3, 'Scan '+cscan,color='k', transform=desc.transAxes,size=10)
                if (iant == 3):
                    pb.text(0.25, 1.3, sfield,color='k', transform=desc.transAxes,size=10)

            var_1.append(numpy.var(pc_1))
            var_2.append(numpy.var(pc_2))

        if makeplot: pl.savefig(qa2_output_dir + plotfile)

        f.write('\n****************************************************************** \n\n')
        scan_string = '      '+scanintent+' scan='+cscan+'; spw='+cspw+'; pol='+cpol+' \n\n'
        f.write(scan_string)
        f.write('\n          PHASE FLUCTUATIONS OVER %s SCAN\n' % (scanintent))
        f.write('          BEFORE AND AFTER WVR CORRECTION: '+wvr_gaintable+'\n\n')
        f.write('Column Header Key:\n')
        f.write('A: Antenna Name\n')
        f.write('B: Spacing (m)\n')
        f.write('C: Phase RMS Before (deg)\n')
        f.write('D: Phase RMS After (deg)\n')
        f.write('E: D/C (%)\n')
        f.write('F: Coherence Before (%)\n')
        f.write('G: Coherence After (%)\n')
        f.write('H: Not Improved?\n\n')
        f.write('A          B       C       D      E    F    G  H\n')
        coherList = []
        for i in range(0,nant):
            coherAfter = cos(sqrt(var_2[i])*pi/180.0)**2
            coherBefore = cos(sqrt(var_1[i])*pi/180.0)**2
            with numpy.errstate(invalid='print'):
                coherList.append(100.0*sqrt(var_2[i]/var_1[i]))
            improved_string = '            '
            if var_1[i]<var_2[i]: improved_string = 'NI'
            if var_1[i] > 0.1:
                f.write( '%4s  %7.1f  %6.1f  %6.1f  %4.0f  %3.0f  %3.0f  %2s\n' %(ant_names[i], ant_sep[i], sqrt(var_1[i]),sqrt(var_2[i]),100.0*sqrt(var_2[i]/var_1[i]),100.0*coherBefore,100.0*coherAfter,improved_string))
        #
        medianCoherenceRatio = np.median(coherList)
        madCoherenceRatio = plotbp3.mad(coherList)
        madCoherenceOutliers = 0
        f.write('\nOutliers in "rms_after/rms_before" [>%g*MAD (>%.2f%%) above median (%.2f%%)]:' % (nsigma_coherence,nsigma_coherence*madCoherenceRatio,medianCoherenceRatio))
        for i in range(0,nant):
            if (coherList[i] - medianCoherenceRatio > nsigma_coherence*madCoherenceRatio):
                f.write(' '+ant_names[i])
                madCoherenceOutliers += 1
        if (madCoherenceOutliers == 0): f.write(' none')
        #  Add log output from wvrgcal
        f.write ('\n\n  wvrgcal output of average wvr for each antenna\n\n')
        zwvrgcal_log = ms1+'.wvrgcal'
        if (os.path.exists(zwvrgcal_log)):
            f1 = open (zwvrgcal_log, 'r')
            fc = f1.readlines()
            f1.close
            for i in range(len(fc)):
                if (re.findall('Flag?',fc[i])):
                    f.write(fc[i]);break


            for j in range(i+1,len(fc)):
                f.write(fc[j])
        else:
            f.write("Could not find %s.\n"%(zwvrgcal_log))
        f.close()
        return
        #os.system('cat '+zfileRes)
        # end of wvr_stat()

    def glue_qa2(self, qa2_output_dir='',target='',pols=2):

        cwd1 = os.getcwd()
        os.chdir(qa2_output_dir)

        os.system("rm -f qa2.pdf textfile.txt textfile.ps")

        os.system("cat wvr_stat.txt   tsys_stat.txt  NewListObs.txt   ant_gain_check.txt   bandpass_rms.txt  flux.txt   flag_stat.txt   sensitivity.txt  >  textfile.txt")

        os.system("enscript -Bc -fCourier5 --columns=2 -ptextfile.ps textfile.txt")

        os.system("ps2pdf textfile.ps qa2.pdf")

        #  combine all plots

        os.system("rm -f *part*png")

        #  CONVERT IS USED TO ADD IN LABELS

        os.system("convert obs_display.png -font Utopia-Regular -pointsize 48 label:'Observing Schedule' -gravity Center -append obs_display_labeled.png")
        os.system("convert mosaic_plot.png -font Utopia-Regular -pointsize 48 label:'Mosaic Pointing Configuration' -gravity Center -append mosaic_plot_labeled.png")
        os.system("convert antenna_config.png -font Utopia-Regular -pointsize 48 label:'Antenna Configuration' -gravity Center -append antenna_config_labeled.png")
        os.system("convert wvr_plot.png -font Utopia-Regular -pointsize 48 label:'Phase: before/after WVR' -gravity Center -append wvr_plot_labeled.png")
        os.system("convert ant_amp_temporal.png -font Utopia-Regular -pointsize 48 label:'Temporal gain calibration' -gravity Center -append ant_amp_temporal_labeled.png")
        os.system("convert ant_phase_temporal.png -font Utopia-Regular -pointsize 48 label:'Temporal phase calibration' -gravity Center -append ant_phase_temporal_labeled.png")

        os.system("convert bandpass_avg.png -font Utopia-Regular -pointsize 48 label:'Average Bandpass for each spw' -gravity Center -append bandpass_avg_labeled.png")
        if (os.path.exists('bandpass_bad.png')):
            os.system("convert bandpass_bad.png -font Utopia-Regular -pointsize 48 label:'Poor Bandpass' -gravity Center -append bandpass_bad_labeled.png")
        os.system("convert tsys_plot.png -font Utopia-Regular -pointsize 48 label:'Composite Tsys for each spw' -gravity Center -append tsys_plot_labeled.png")
        if (os.path.exists('ampcal_uvdist.png')):
            # we used plotxy
            os.system("convert ampcal_uvdist.png -font Utopia-Regular -pointsize 48 label:'Flux calibration model and data' -gravity Center -append ampcal_uvdist_labeled.png")
        else:
            # we used plotms - this might be obsoleted now by the montage command in ampcal_uvdist()
            os.system("convert ampcal_uvdist_model.png -font Utopia-Regular -pointsize 48 label:'Flux calibration model' -gravity Center -append ampcal_uvdist_model_labeled.png")
            os.system("convert ampcal_uvdist_corrected.png -font Utopia-Regular -pointsize 48 label:'Flux calibration data' -gravity Center -append ampcal_uvdist_corrected_labeled.png")

        if (pols < 2):
            uvdist_pointsize = 96
        else:
            uvdist_pointsize = 48
        os.system("convert target_spectrum.png -font Utopia-Regular -pointsize %d label:'Target Spectrum for each spw' -gravity Center -append target_spectrum_labeled.png" % uvdist_pointsize)

        os.system("convert phase_cal_uvdist.png -font Utopia-Regular -pointsize %d label:'Phase Calibrator amp/phase vs uvdist' -gravity Center -append phase_cal_uvdist_labeled.png" % uvdist_pointsize)
        os.system("convert phase_cal_freq.png -font Utopia-Regular -pointsize %d label:'Phase Calibrator amp/phase vs freq' -gravity Center -append phase_cal_freq_labeled.png" % uvdist_pointsize)
        os.system("convert target_uv.png -font Utopia-Regular -pointsize 48 label:'Target (Field_ID=%s) u-v coverage' -gravity Center -append target_uv_labeled.png" % (target))
        os.system("convert target_image.png -font Utopia-Regular -pointsize 48 label:'Target Image (Field_ID=%s)' -gravity Center -append target_image_labeled.png" % (target))
        os.system("convert target_psf.png -font Utopia-Regular -pointsize 48 label:'Target psf' -gravity Center -append target_psf_labeled.png")

        os.system("montage -tile 2X3 -geometry 1000x1000+0+0   obs_display_labeled.png   mosaic_plot_labeled.png   antenna_config_labeled.png   wvr_plot_labeled.png  ant_amp_temporal_labeled.png  ant_phase_temporal_labeled.png   qa2_part1.png")

        if (os.path.exists('ampcal_uvdist_labeled.png')):
            # We used plotxy
            os.system("montage -tile 2X3 -geometry 1000x1000+0+0   bandpass_avg_labeled.png   tsys_plot_labeled.png  target_spectrum_labeled.png  qa2_part2.png")
            os.system("montage -tile 2x3 -geometry 1000x1000+0+0  ampcal_uvdist_labeled.png  phase_cal_uvdist_labeled.png  phase_cal_freq_labeled.png    target_uv_labeled.png   target_image_labeled.png  target_psf_labeled.png   qa2_part3.png")
        else:
            # We used plotms rather than plotxy (e.g. for single-polarization data)
            # Put uv-coverage plot on part2 to avoid 7 panels on part3.
            os.system("montage -tile 2X3 -geometry 1000x1000+0+0   bandpass_avg_labeled.png   tsys_plot_labeled.png  target_spectrum_labeled.png  target_uv_labeled.png qa2_part2.png")
            os.system("montage -tile 2x3 -geometry 1000x1000+0+0  ampcal_uvdist_model_labeled.png  ampcal_uvdist_corrected_labeled.png  phase_cal_uvdist_labeled.png  phase_cal_freq_labeled.png target_image_labeled.png  target_psf_labeled.png   qa2_part3.png")

        #os.system("display *qa2_part*png &")

        os.chdir(cwd1)

    def generateQA2Report(self, ms1='', ms2='', phase_cal='', target='', target_source='',
                          tsys_field='', dospw='', refAnt='', qa2_output_dir='', uvrange='0~30m',
                          autoscale_yaxis=True, fdmSpwsToImage='', ant_gain_check_caltable=None,
                          ant_amp_temporal_caltable=None, ant_phase_temporal_caltable=None):

        """

        QA2 Package to interface with Eric's latest scripts.  Older scripts will
        work, but some names of calibration files may be different.

        Version 2.1:  Ed Fomalont, Feb 27, 2012
        Version 2.2:  streamlined, Amy Kimball, May 1, 2012
        updated instructions, Feb 2014  (Todd Hunter)

        INPUTS:
        ms1: the name of the parent ms (any trailing '/' will be removed)

        OPTIONAL INPUTS:
        ms2: the name of the split ms (the default is to add ".split" to ms1)
        phase_cal: the source ID of the phase calibrator as a string (e.g. '3')
        target_source: the source ID of the science target as a string (e.g. '3')
                       It is used by es.sensitivity_calculator.
                       The default is the first source with OBSERVE_TARGET intent.
        target: the field ID of the science target as a string (e.g. '3')
                It is used by es.target_spectrum, and for cleaning and plotuv.  
                The default is the ID of the target_source.
        tsys_field: the field ID to use for Tsys stats as a string (e.g. '3')
        dospw: a list of spws to use in target_spectrum (e.g. '0,1')
        refAnt: the reference antenna name to use in wvr_stat (e.g. 'DV05')
        qa2_output_dir: the directory to write the output files
        uvrange: the uv range to use in target_spectrum (e.g. '0~30m')
        autoscale_yaxis: passed to wvr_stat: either True, False or a range (i.e. [-180,180])
        fdmSpwsToImage: a list of spws to image in target_check (e.g. ['2','3'])
        ant_gain_check_caltable: the caltable to use in ant_gain_check
        ant_amp_check_caltable: the caltable to use in ant_amp_temporal
        ant_phase_check_caltable: the caltable to use in ant_phase_temporal

        INSTRUCTIONS

        1. Run Eric's latest reduction script in an appropriate directory.

        2. Run es.generateQA2Report('msname')
        where msname is the name of the (unsplit) ms
        This creates the qa2_output directory, and runs all the qa2 scripts below.


        SUMMARY OF CAL TABLES NEEDED:
        1. tsys_stat() expects                    uid___Axxxxxx_xxxx.ms.tsys

        2. ant_gain_check() expects               uid___Axxxxxx_xxxx.ms.split.ap_pre_bandpass
              but you can specify it via the optional ant_gain_check_caltable argument
           
        3. bandpass_rms() expects                 uid___Axxxxxx_xxxx.ms.split.bandpass
        
        4. bandpass_plot() expects original table uid___Axxxxxx_xxxx.ms.split.bandpass
                and also looks for smoothed table uid___Axxxxxx_xxxx.ms.split.bandpass_smooth20ch
                                               or uid___Axxxxxx_xxxx.ms.split.bandpass_bpoly

        5. ant_amp_temporal() expects             uid___Axxxxxx_xxxx.ms.split.flux_inf
           if it doesn't find it, it looks for    uid___Axxxxxx_xxxx.ms.split.cal_amp
              but you can specify it via the optional ant_amp_temporal_caltable argument

        6. ant_phase_temporal() expects           uid___Axxxxxx_xxxx.ms.split.phase_inf
           if it doesn't find it, it looks for    uid___Axxxxxx_xxxx.ms.split.cal_phase
              but you can specify it via the optional ant_phase_temporal_caltable argument

        7. flux_values() expects                  uid___Axxxxxx_xxxx.ms.split.fluxscale
        """

        #  qa2 plots and text Generating script
        #  Any initialization stuff
        ####  Point to data directories
        ## PreCalibration directory should contain .ms, .ms.wvr table, .ms.tsys table
        #PreCal_dir = '../reduction_X69/'
        ## Calibration directory should contain .ms.split,
        #Cal_dir = '../reduction_X69/'
        ## output directory
        #qa2_output_dir = '../reduction_X69/qa2/'

        ####  Global parameters specific to data set:
        #asdmName = 'uid___A002_X383b50_X69'  #  base name of data
        #phase_cal = '3'                       #  Need field number of main phase cal
        #target = '4'                          #  Target field for quick image check
        #tsys_field = '4'                      #  field with tsys.  needed for sensit.
        #refAnt = 'DV05'                       #  reference antenna by name
        #dospw = '0,1' # for target_spectrum.py (put each spw separately)
        #### End of needed parameters

        #ms1 = PreCal_dir+asdmName+'.ms'
        #ms2 = Cal_dir+asdmName+'.ms.split'

        #-------------

        ms1 = ms1.rstrip('/')
        if (ms2 == ''):
            ms2 = ms1 + '.split'
        else:
            ms2 = ms2.rstrip('/')
        if (os.path.exists(ms1) == False):
            print "could not find ms1 = ", ms1
            return
        if (os.path.exists(ms2) == False):
            print "could not find the split dataset: ms2 = ", ms2
            return
        # Check CASA version
        casaVersionString = casalog.version()
        casaMajorVersion = int(casalog.version().split()[2].split('.')[0])
        casaMinorVersion = int(casalog.version().split()[2].split('.')[1])
        casaVersion = casaMajorVersion*10 + casaMinorVersion
        caltable = ms1+'.tsys'
        tb.open(caltable)
        names = tb.colnames()
        if ('CAL_DESC_ID' not in names):
            calFormat = 34  # >= casa 3.4
            if (casaVersion < calFormat):
                print "Fatal error: You are trying to run QA2 in %s on a dataset that was reduced in casa >= %.1f" % (casaVersionString,calFormat*0.1)
                print "Please restart casa in version >= %.1f" % (calFormat*0.1)
                return
        else:
            calFormat = 33  # <= casa 3.3
            if (casaVersion > calFormat):
                print "Fatal error: You are trying to run QA2 in %s on a dataset that was reduced in casa <= %.1f" % (casaVersionString,calFormat*0.1)
                print "Please restart casa in version %.1f" % (calFormat*0.1)
                return


        phaseCalInfo = self.getPhaseCal(ms1)

        intentsAndSourcesInfo = self.getIntentsAndSourceNames(ms1)
        if len(intentsAndSourcesInfo['OBSERVE_TARGET']['sourceid']) > 1:
            print "# Note: there are more than one science target: i'm picking the first one."
        if (target_source == ''):
            target_source = str(intentsAndSourcesInfo['OBSERVE_TARGET']['sourceid'][0])  # ID as string
        target_source_name = intentsAndSourcesInfo['OBSERVE_TARGET']['name'][0]      # name as string
        if (tsys_field == ''):
          if target_source_name in intentsAndSourcesInfo['CALIBRATE_ATMOSPHERE']['name']:
            ij = intentsAndSourcesInfo['CALIBRATE_ATMOSPHERE']['name'].index(target_source_name)
            tsys_field = intentsAndSourcesInfo['CALIBRATE_ATMOSPHERE']['idstring'][ij]
          else:
            print "Note: no Tsys measurement on science target: using phase calibrator."
            if phaseCalInfo[target_source_name]['phaseCalName'] not in intentsAndSourcesInfo['CALIBRATE_ATMOSPHERE']['name']: sys.exit('Error')
            ij = intentsAndSourcesInfo['CALIBRATE_ATMOSPHERE']['name'].index(phaseCalInfo[target_source_name]['phaseCalName'])
            tsys_field = intentsAndSourcesInfo['CALIBRATE_ATMOSPHERE']['idstring'][ij]

        if (phase_cal==''):
            phase_cal = str(phaseCalInfo[target_source_name]['phaseCalId'])
        if (target == ''):
            target = str(phaseCalInfo[target_source_name]['sciFieldIds'][0])   # ID as string

        spwInfo = self.getSpwInfo(ms1).keys()
        spwInfo = range(len(spwInfo))
        dospw = ','.join([str(k) for k in spwInfo])

        if refAnt == '': refAnt = self.getRefAntenna(ms1)

        if qa2_output_dir == '':
            msdir = os.path.dirname(os.path.abspath(ms1))
            if os.path.exists(msdir+'/qa2') == False:
                os.makedirs(msdir+'/qa2')
            qa2_output_dir = msdir+'/qa2/'
        else:
            qa2_output_dir += '/'
            if os.path.exists(qa2_output_dir) == False:
                os.makedirs(qa2_output_dir)

        pols = self.findNumberOfPolarizations(ms2)
        #-------------

        print '# Get Colorful Diagram of Observations'
        self.listobs3(msName=ms1,figfile=qa2_output_dir+'obs_display.png')

        print '# Get listings of experiment and antenna-config plot'
        print "# If mosaic, make this plot"
        self.mosaic_plot(ms2=ms2, qa2_output_dir=qa2_output_dir)

        if (sevenMeterAntennasOnly(ms2) == False):
            print '# Determine wvr correction from bandpass obs'
            print "Running es.wvr_stat(ms1='%s', refAnt='%s', qa2_output_dir='%s', autoscale_yaxis='%s')" % (ms1,refAnt,qa2_output_dir,autoscale_yaxis)
            self.wvr_stat(ms1=ms1, refAnt=refAnt, qa2_output_dir=qa2_output_dir, autoscale_yaxis=autoscale_yaxis)

            # Produce a fixed-scale plot for display in analyzemscal
            print "Running es.wvr_stat(ms1='%s', refAnt='%s', qa2_output_dir='%s', autoscale_yaxis=False, unwrap_phase=False)" % (ms1,refAnt,qa2_output_dir)
            self.wvr_stat(ms1=ms1, refAnt=refAnt, qa2_output_dir=qa2_output_dir, autoscale_yaxis=False,
                          plotfile='wvr_plot_fixedscale.png', unwrap_phase=False)

        print '# Tsys statistics and plots'
        print "Calling es.tsys_stat(ms1='%s', tsys_field='%s', makeplot=True, qa2_output_dir='%s')" % (ms1,tsys_field,qa2_output_dir)
        self.tsys_stat(ms1=ms1, tsys_field=tsys_field, makeplot=True, qa2_output_dir=qa2_output_dir)

        print '# listing of split data set'
        print "Running es.listobs2(ms2='%s', makeplot=True, qa2_output_dir='%s', plotAntennasActualSize=True)" % (ms2, qa2_output_dir)
        self.listobs2(ms2=ms2, makeplot=True, qa2_output_dir=qa2_output_dir, plotAntennasActualSize=True)

        print '# Any antennas shadowed?'
        print "Calling es.shadowed_ant(ms2='%s', qa2_output_dir='%s')" % (ms2,qa2_output_dir)
        self.shadowed_ant(ms2=ms2, qa2_output_dir=qa2_output_dir)

        print '# Check antenna amp of bandpass scan'
        print "Running es.ant_gain_check(ms2='%s', qa2_output_dir='%s')" % (ms2, qa2_output_dir)
        self.ant_gain_check(ms2=ms2, qa2_output_dir=qa2_output_dir, caltable=ant_gain_check_caltable)

        print '# Check channel to channel rms of bandpass scan and plot outliers'
        print "Running es.bandpass_rms(ms2='%s', refAnt='%s', qa2_output_dir='%s')" % (ms2,refAnt,qa2_output_dir)
        self.bandpass_rms(ms2=ms2, refAnt=refAnt, qa2_output_dir=qa2_output_dir)

        print '# Make an spw average bandpass plots for atmosphere effects'
        print "Running es.bandpass_plot(ms2='%s', qa2_output_dir='%s')" % (ms2, qa2_output_dir)
        self.bandpass_plot(ms2=ms2, qa2_output_dir=qa2_output_dir)

        print '# Printout of flux density determinations'
        print "Running es.flux_values(ms2='%s', qa2_output_dir='%s')" % (ms2, qa2_output_dir)
        self.flux_values(ms2=ms2, qa2_output_dir=qa2_output_dir)

        print '# Plot temporal antenna amp calibration of phase cal'
        if (ant_amp_temporal_caltable == None):
            caltable = ms2+'.flux_inf'
        else:
            caltable = ant_amp_temporal_caltable
        if (os.path.exists(caltable) == False):
            caltable = ms2+'.cal_amp' # alternative Band 9 calibration path

        print "Running es.ant_amp_temporal(ms2='%s', phase_cal='%s', caltable='%s', qa2_output_dir='%s')" % (ms2, phase_cal, caltable, qa2_output_dir)
        self.ant_amp_temporal(ms2=ms2, phase_cal=phase_cal, caltable=caltable, qa2_output_dir=qa2_output_dir)

        print '# Plot temporal antenna phase calibration of phase cal'
        if (ant_phase_temporal_caltable == None):
            caltable = ms2+'.phase_inf'
        else:
            caltable = ant_phase_temporal_caltable
        if (os.path.exists(caltable) == False):
            caltable = ms2+'.cal_phase'  # alternative Band 9 calibration path
        print "Running es.ant_phase_temporal(ms2='%s', phase_cal='%s', caltable='%s', qa2_output_dir='%s')" % (ms2, phase_cal, caltable, qa2_output_dir)
        self.ant_phase_temporal(ms2=ms2, caltable=caltable, phase_cal=phase_cal, qa2_output_dir=qa2_output_dir)

        print '# Plot fluxcal object model and calibrated data'
        self.ampcal_uvdist(ms2=ms2, qa2_output_dir=qa2_output_dir)

        print '# Check uvdist and freq response of uv calibration phase cal'
        print "Running es.phase_cal_check(ms2='%s', phase_cal='%s', qa2_output_dir='%s')" % (ms2,phase_cal,qa2_output_dir)
        self.phase_cal_check(ms2=ms2, phase_cal=phase_cal, qa2_output_dir=qa2_output_dir)

        print '# Obtain flagging statistics'
        print "Running es.flag_stats(ms2='%s', qa2_output_dir='%s')" % (ms2, qa2_output_dir)
        self.flag_stats(ms2=ms2, qa2_output_dir=qa2_output_dir)

        print '#  Check target properties'
        print "Running es.target_check(ms1='%s', ms2='%s', target='%s', target_source='%s', tsys_caltable='%s.tsys', tsys_field='%s', qa2_output_dir='%s', fdmSpwsToImage='%s')" % (ms1, ms2, target, target_source, ms1, tsys_field, qa2_output_dir, fdmSpwsToImage)
        tcresult = self.target_check(ms1=ms1, ms2=ms2, target=target, target_source=target_source,
                          tsys_caltable=ms1+'.tsys', tsys_field=tsys_field,
                          qa2_output_dir=qa2_output_dir, fdmSpwsToImage=fdmSpwsToImage)
        if (tcresult == None):
            print "Aborting"
            return
        print '#  Get a spectrum on the target'
        print "Running es.target_spectrum(ms2='%s',target='%s',dospw='%s',qa2_output_dir='%s',uvrange='%s')" %  (ms2,target,dospw,qa2_output_dir,uvrange)
        self.target_spectrum(ms2=ms2, target=target, dospw=dospw,
                             qa2_output_dir=qa2_output_dir, uvrange=uvrange)

        #  Make overall pdf file of text file and the three qa png files.
        print "Running es.glue_qa2(qa2_output_dir='%s', target='%s')" % (qa2_output_dir, target)
        self.glue_qa2(qa2_output_dir=qa2_output_dir, target=target, pols=pols)

    def generateScriptForPI(self, fname=''):

        f = open(fname, 'r')
        fc = f.read()
        f.close()

        casaCmd = re.findall('^ *(?:split|applycal) *\( *vis.*?\)', fc, re.DOTALL|re.MULTILINE|re.IGNORECASE)

        name1, ext1 = os.path.splitext(fname)
        fname1 = name1 + '_forPI' + ext1

        f = open(fname1, 'w')
        for i in casaCmd:
            print >> f, i
            print >> f, ''
        f.close()

    def SDfillTsysSolutions(self, asapName, msName='', spwIds='', tsysmap='', iHaveSplitMyScienceSpw=False, doplot=False):

        # spwIds must be specified as a string, e.g. spwIds = '1,3,5,7'

        if re.search('^3.3', casadef.casa_version) != None: sys.exit('ERROR: Your version of CASA is too old.')

        if msName == '':
            if spwIds == '' and tsysmap == '': sys.exit('ERROR: you have not specified neither msName, or spwIds and tsysmap.')
            if doplot == True: sys.exit('ERROR: you have not specified msName, so I cannot do any plot.')

        if type(asapName).__name__ == 'str': asapName = [asapName]

        casaCmd = ''

        calTableName1 = msName + '.tsys'

        casaCmd = casaCmd + "os.system('rm -Rf "+calTableName1+"')\n\n"
        casaCmd = casaCmd + "gencal(vis = '"+msName+"',\n"
        casaCmd = casaCmd + "  caltable = '"+calTableName1+"',\n"
        casaCmd = casaCmd + "  caltype = 'tsys')\n\n"

        if tsysmap == '':
            casaCmd = casaCmd + "from recipes.almahelpers import tsysspwmap\n"
            casaCmd = casaCmd + "tsysmap = tsysspwmap(vis = '"+msName+"', tsystable = '"+calTableName1+"')\n\n"
        else:
            casaCmd = casaCmd + "tsysmap = "+str(tsysmap)+"\n\n"

        if msName != '':
            spwInfo = self.getSpwInfo(msName)
            spwIds1 = sorted(spwInfo.keys())
            spwIds1 = [int(i) for i in spwIds1]
            if iHaveSplitMyScienceSpw == True: spwIds1 = range(len(spwIds1))
        else:
            spwIds1 = spwIds.split(',')
            spwIds1 = [int(i) for i in spwIds1]

        for i in asapName:
            casaCmd = casaCmd + "for i in "+str(spwIds1)+":\n"
            casaCmd = casaCmd + "  filltsys.fillTsys('"+i+"',\n"
            casaCmd = casaCmd + "    specif = i,\n"
            casaCmd = casaCmd + "    tsysif = tsysmap[i],\n"
            casaCmd = casaCmd + "    mode = 'linear',\n"
            casaCmd = casaCmd + "    extrap = True)\n\n"

        if doplot == True:

            tsysNumChans = []
            tsysSpwInfo = self.getSpwInfo(msName, intent='CALIBRATE_ATMOSPHERE')
            for i in tsysSpwInfo: tsysNumChans.append(tsysSpwInfo[i]['numChans'])
            tsysNumChans = sorted(dict.fromkeys(tsysNumChans).keys())
            if len(tsysNumChans) != 1:
                print "WARNING: the Tsys spws do not all have the same number of channels ("+str(tsysNumChans)+"), I am using the smallest number for the plotting."
            tsysNumChans = tsysNumChans[0]

            chanEdge = 0.0390625
            startChan = int(tsysNumChans * chanEdge)
            endChan = int(tsysNumChans * (1-chanEdge))
            chanrange = str(startChan)+'~'+str(endChan)

            casaCmd = casaCmd + "plotbandpass(caltable='%s', overlay='time', \n" %(calTableName1)
            casaCmd = casaCmd + "  xaxis='freq', yaxis='amp', subplot=22, buildpdf=False, interactive=False,\n"
            casaCmd = casaCmd + "  showatm=True,pwv='auto',chanrange='"+chanrange+"',showfdm=True, \n"
            casaCmd = casaCmd + "  field='', figfile='%s') \n" %(calTableName1+'.plots.overlayTime/'+calTableName1.split('/')[-1])

            casaCmd = casaCmd + "\nes.checkCalTable('"+calTableName1+"', msName='"+msName+"', interactive=False)\n"

        return casaCmd

    def SDdoBaselineSubtraction(self, asapName, msName='', spwIds='', iHaveSplitMyScienceSpw=False, doplot=True):

        # spwIds must be specified as a string, e.g. spwIds = '1,3,5,7'

        if re.search('^3.3', casadef.casa_version) != None: sys.exit('ERROR: Your version of CASA is too old.')

        if msName == '' and spwIds == '': sys.exit('ERROR: you have not specified neither msName, or spwIds.')

        if type(asapName).__name__ == 'str': asapName = [asapName]

        if msName != '':
            spwInfo = self.getSpwInfo(msName)
            spwIds1 = sorted(spwInfo.keys())
            spwIds1 = [int(i) for i in spwIds1]
            if iHaveSplitMyScienceSpw == True: spwIds1 = range(len(spwIds1))
            spwIds = ','.join([str(i) for i in spwIds1])
        else:
            spwIds1 = spwIds.split(',')
            spwIds1 = [int(i) for i in spwIds1]

        casaCmd = ''

        for i in asapName:

            casaCmd = casaCmd + "os.system('rm -Rf "+i+".bl')\n\n"
            if (casadef.casa_version >= '4.2.2'):
                casaCmd = casaCmd + "sdbaseline(infile = '"+i+"',\n"
                casaCmd = casaCmd + "  spw = '"+','.join([str(j) for j in spwIds1])+"',\n"
                casaCmd = casaCmd + "  maskmode = 'auto',\n"
                casaCmd = casaCmd + "  thresh = 5.0,\n"
                casaCmd = casaCmd + "  avg_limit = 4,\n"
    #            casaCmd = casaCmd + "  edge = [120],\n"
                casaCmd = casaCmd + "  blfunc = 'poly',\n"
                casaCmd = casaCmd + "  order = 1,\n"
                casaCmd = casaCmd + "  outfile = '"+i+".bl',\n"
                casaCmd = casaCmd + "  overwrite = True)\n\n"
            else:
                casaCmd = casaCmd + "sdbaseline(infile = '"+i+"',\n"
                casaCmd = casaCmd + "  iflist = "+str(spwIds1)+",\n"
                casaCmd = casaCmd + "  maskmode = 'auto',\n"
                casaCmd = casaCmd + "  thresh = 5.0,\n"
                casaCmd = casaCmd + "  avg_limit = 4,\n"
    #            casaCmd = casaCmd + "  edge = [120],\n"
                casaCmd = casaCmd + "  blfunc = 'poly',\n"
                casaCmd = casaCmd + "  order = 1,\n"
                casaCmd = casaCmd + "  outfile = '"+i+".bl',\n"
                casaCmd = casaCmd + "  overwrite = True)\n\n"

            if doplot == True:
                casaCmd = casaCmd + "es.SDcheckSpectra('"+i+".bl', spwIds='"+spwIds+"', interactive=False)\n\n"

        return casaCmd

    def SDdoCalibration(self, asapName, msName='', spwIds='', calmode='ps', iHaveSplitMyScienceSpw=False, doplot=True):

        # spwIds must be specified as a string, e.g. spwIds = '1,3,5,7'

        if re.search('^3.3', casadef.casa_version) != None: sys.exit('ERROR: Your version of CASA is too old.')

        if msName == '' and spwIds == '': sys.exit('ERROR: you have not specified neither msName, or spwIds.')

        if type(asapName).__name__ == 'str': asapName = [asapName]

        if msName != '':
            spwInfo = self.getSpwInfo(msName)
            spwIds1 = sorted(spwInfo.keys())
            spwIds1 = [int(i) for i in spwIds1]
            if iHaveSplitMyScienceSpw == True: spwIds1 = range(len(spwIds1))
            spwIds = ','.join([str(i) for i in spwIds1])
        else:
            spwIds1 = spwIds.split(',')
            spwIds1 = [int(i) for i in spwIds1]

        casaCmd = ''

        for i in asapName:

            casaCmd = casaCmd + "os.system('rm -Rf "+i+".cal')\n\n"
            if (casadef.casa_version >= '4.2.2'):
                casaCmd = casaCmd + "sdcal(infile = '"+i+"',\n"
                casaCmd = casaCmd + "  calmode = '"+calmode+"',\n"
                casaCmd = casaCmd + "  spw = '"+','.join([str(j) for j in spwIds1])+"',\n"
                casaCmd = casaCmd + "  outfile = '"+i+".cal',\n"
                casaCmd = casaCmd + "  overwrite = True)\n\n"
            else:
                casaCmd = casaCmd + "sdcal(infile = '"+i+"',\n"
                casaCmd = casaCmd + "  calmode = '"+calmode+"',\n"
                casaCmd = casaCmd + "  iflist = "+str(spwIds1)+",\n"
                casaCmd = casaCmd + "  scanaverage = False,\n"
                casaCmd = casaCmd + "  timeaverage = False,\n"
                casaCmd = casaCmd + "  polaverage = False,\n"
                casaCmd = casaCmd + "  outfile = '"+i+".cal',\n"
                casaCmd = casaCmd + "  overwrite = True)\n\n"

            if doplot == True:
                casaCmd = casaCmd + "es.SDcheckSpectra('"+i+".cal', spwIds='"+spwIds+"', interactive=False)\n\n"

        return casaCmd

    def SDcheckSpectra(self, asapName, msName='', spwIds='', specunit='channel', panel='scan', iHaveSplitMyScienceSpw=False, interactive=True):

        # spwIds must be specified as a string, e.g. spwIds = '1,3,5,7'

        if re.search('^3.3', casadef.casa_version) != None: sys.exit('ERROR: Your version of CASA is too old.')

        if msName == '' and spwIds == '': sys.exit('ERROR: you have not specified neither msName, or spwIds.')

        if os.path.isdir(asapName+'.plots') == True:
            if (interactive == True):
                raw_input("Directory for plots already exists. It will be removed. Press Enter to continue...")
            os.system('rm -Rf '+asapName+'.plots')
        os.system('mkdir '+asapName+'.plots')

        if msName != '':
            spwInfo = self.getSpwInfo(msName)
            spwIds1 = sorted(spwInfo.keys())
            spwIds1 = [int(i) for i in spwIds1]
            if iHaveSplitMyScienceSpw == True: spwIds1 = range(len(spwIds1))
        else:
            spwIds1 = spwIds.split(',')
            spwIds1 = [int(i) for i in spwIds1]

        if (casadef.casa_version >= '4.2.2'):
            for i in spwIds1:
                sdplot(infile=asapName, spw=str(i), plottype='spectra', specunit=specunit, timeaverage=True, scanaverage=True, stack='p', panel=panel, outfile=asapName+'.plots/'+asapName+'.spectra.spw'+str(i)+'.png', overwrite = True)
                if interactive == True:
                    userRawInput = raw_input("Press Enter to continue, or n to go non-interactive. ")
                    if userRawInput.lower() == 'n': interactive = False

            print "# This is what SDcheckSpectra executed:\n"
            print "# for i in "+str(spwIds1)+":"
            print "#   sdplot(infile='"+asapName+"', spw=str(i), plottype='spectra', specunit='"+specunit+"', timeaverage=True, scanaverage=True, stack='p', panel='"+panel\
                +"', outfile='"+asapName+".plots/"+asapName+".spectra.spw'+str(i)+'.png', overwrite = True)"
        else:
            for i in spwIds1:
                sdplot(infile=asapName, iflist=[i], plottype='spectra', specunit=specunit, scanaverage=True, stack='pol', panel=panel, outfile=asapName+'.plots/'+asapName+'.spectra.spw'+str(i)+'.png', overwrite = True)
                if interactive == True:
                    userRawInput = raw_input("Press Enter to continue, or n to go non-interactive. ")
                    if userRawInput.lower() == 'n': interactive = False

            print "# This is what SDcheckSpectra executed:\n"
            print "# for i in "+str(spwIds1)+":"
            print "#   sdplot(infile='"+asapName+"', iflist=[i], plottype='spectra', specunit='"+specunit+"', scanaverage=True, stack='pol', panel='"+panel\
                +"', outfile='"+asapName+".plots/"+asapName+".spectra.spw'+str(i)+'.png', overwrite = True)"

    def detectOutliers(self, values, threshold=10., edgetrim=5):
        """
        Detect outlying samples from an array of values.

        threshold: if a value is deviated from the mean by more than
                   threshold*sigma, it is identified as an outlier,
                   where mean and sigma are not "raw" ones but
                   "robust" ones (see below)
        edgetrim: minimum and maximum 1/edgetrim samples are ignored
                  to determine robust (trimmed) mean and sigma
        """
        n_samples = len(values)
        subsample = pb.sort(values)[n_samples/edgetrim:-n_samples/edgetrim]
        std = subsample.std()
        mean = subsample.mean()
        return (pb.fabs(values-mean) > threshold*std)

    def detectDelayJumps(self, msname='', spw='', scan='', solint='int', refant=0, intent='CALIBRATE_PHASE#ON_SOURCE'):
        """
        Detect delay jumps using bandpass(bandtype=BPOLY).

        Outliers in the amplitude and phase slopes of the bandpass solution
        are identified as delay jumps.
        spw: spws to be analyzed (can be a comma-separated list)
        scan: scans to be analyzed (can be a comma-separated list)
        solint: time interval for solving bandpass
        refant: reference antenna ID (integer) for bandpass solution

        If spw and/or scan are left blank and CASA version is >= 4.1.0,
        they were set according to the given intent parameter.
        """

        tb.open('%s/ANTENNA' % msname)
        antnames = tb.getcol('NAME')
        tb.close()
        nants = len(antnames)

        if spw == '':
            if casadef.casa_version >= '4.1.0':
                #mymsmd = createCasaTool(msmdtool)
                msmd.open(msname)
                phase_spw = msmd.spwsforintent(intent)
                wvrspws = msmd.wvrspws()
                spw = []
                for s in phase_spw:
                    if len(msmd.chanfreqs(s)) > 4 and s not in wvrspws:
                        spw.append(s)
                if len(spw) < 1:
                    print 'Found no non-wvr, multi-channel spws for intent=%s' \
                        % intent
                    return
                print 'Found %d non-wvr, multi-channel spws for intent=%s: %s' \
                    % (len(spw), intent, str(spw))
                spw = ','.join([str(i) for i in spw])
                msmd.close()
            else:
                print 'You must specify 1 or more spws via the spw parameter.'
                return

        if scan == '' and casadef.casa_version >= '4.1.0':
            msmd.open(msname)
            scans = msmd.scansforintent(intent)
            if len(scans) > 1:
                scan = ','.join([str(i) for i in scans])
            msmd.close()

        bpcaltable = '%s.bpcal' % msname
        os.system('rm -rf %s' % bpcaltable)
        bandpass(vis = msname,
            caltable = bpcaltable,
            spw = spw,
            scan = scan,
            solint = solint,
            refant = '%s' % refant,
            bandtype = 'BPOLY',
            degamp = 1,
            degphase = 1,
            visnorm = True,
            maskedge = 10)

    ###

        #coeffs = readCoeffs(bpcaltable, spw)

        # Read polynomial coeffs and timestamps of bandpass table.

        # obtain CAL_DESC_IDs corresponding to spws.
        # should be [0, 1, ...] ...
        spws = [int(item) for item in spw.split(',')]
        tb.open('%s/CAL_DESC' % bpcaltable)
        spwin = tb.getcol('SPECTRAL_WINDOW_ID').squeeze()
        tb.close()
        caldescs = [pb.arange(len(spwin))[spwin==s][0] for s in spws]

        coeffs = {}
        tb.open(bpcaltable)
        nants1 = len(pb.unique(tb.getcol('ANTENNA1')))
        for i in range(nants1):
            coeffs[i] = {}
            for j in range(len(spws)):
                q = tb.query('ANTENNA1==%d && CAL_DESC_ID==%d' % (i, caldescs[j]))
                coeffs[i][spws[j]] = {'timestamp': q.getcol('TIME').squeeze(),
                    'acoeff': q.getcol('POLY_COEFF_AMP').squeeze(),
                    'pcoeff': q.getcol('POLY_COEFF_PHASE').squeeze()}
        tb.close()

    ###

        #spws = [int(item) for item in spw.split(',')]
        timestamp = coeffs[0][spws[0]]['timestamp']
        outliers = []
        # hereafter 2-pol spws are assumed
        for i in range(nants):
            for j in range(len(spws)):
                outX = (self.detectOutliers(coeffs[i][spws[j]]['acoeff'][1, :]) | \
                        self.detectOutliers(coeffs[i][spws[j]]['pcoeff'][1, :]))
                outY = (self.detectOutliers(coeffs[i][spws[j]]['acoeff'][3, :]) | \
                        self.detectOutliers(coeffs[i][spws[j]]['pcoeff'][3, :]))
                outliers.append(outX)
                outliers.append(outY)
        outliers = pb.array(outliers)
        olexist = outliers.sum(0, dtype=bool)
        antspwpol = pb.array([('%sspw%dpol%d' % (a, s, p)) \
            for a in antnames for s in spws for p in [0, 1]])
        if olexist.sum(dtype=bool):
            ts = timestamp[olexist]
            ol = outliers[:, olexist]
            for i in range(len(ts)):
                #print mjd2iso8601(ts[i]), ', '.join(antspwpol[ol[:, i]])
                print qa.time('%fs' % ts[i], form='fits')[0], \
                    ', '.join(antspwpol[ol[:, i]])
        else:
            print 'no delay jumps were detected.'

# end of class definition for stuffForScienceDataReduction

def getIntegrationTime(vis, spw=None, intent='OBSERVE_TARGET#ON_SOURCE', scan=None,
                       method='first', verbose=True, pointingTable=False):
    """
    Uses the ms and msmd tools to get the integration time (in seconds).  If nothing
    is specified, then it will use the first scan that has the OBSERVE_TARGET intent
    (or otherwise specified intent).  Alternatively, the scan can be specified. If
    the spw is not specified, then the first spw that has the OBSERVE_TARGET intent
    is used.
    spw: integer or string
    scan: integer or string
    method: 'first', 'median', 'mean' or 'stdev' (for standard deviation)
    pointingTable: also compute the median of the INTERVAL column in the pointing table
    Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not find measurement set."
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    methods = ['median','mean','first','stdev']
    if (method not in methods):
        print "invalid method.  available methods are %s" % (str(methods))
        return
    myms = createCasaTool(mstool)
    myms.open(vis)
    scanInfo = myms.getscansummary()  # this is keyed by scan number, then integration within it
    myms.close()
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    if (intent != ''):
        noData = True
        intents = intent.split(',')
        intent = ''
        for myIntent in intents:
            if (myIntent != intents[0]):
                intent += ','
            intent += myIntent
            if (myIntent.find('#') < 0):
                intent += '#ON_SOURCE'
        intents = intent.split(',')
        for myIntent in intents:
            if (myIntent in mymsmd.intents()):
                noData = False
        if (noData):
            print "getIntegrationTime(): %s is not an intent in this dataset.  Available intents: %s" % (intent,mymsmd.intents())
            mymsmd.close()
            return
        scans = []
        for myIntent in intents:
            scans += list(mymsmd.scansforintent(myIntent))
    else:
        scans = mymsmd.scannumbers()
    if (scan != None and scan != ''):
        scan = str(scan)
        if (int(scan) not in scans):
            if (int(scan) not in mymsmd.scannumbers()):
                print "Scan %s is not in the data." % (scan)
            else:
                print "Scan %s does not have intent=%s." % (scan, intent)
            print "The available scans with this intent are %s" % (str(scans))
            return
    else:
        if (len(scans) < 0):
            print "No scans have intent = %s" % (intent)
            return
        scan = str(scans[0])
        print "Picking scan %s, which is the first with intent=%s" % (scan,intent)
    if (intent != ''):
        spws = []
        for myIntent in intent.split(','):
            spws += list(mymsmd.spwsforintent(myIntent))
        spws = np.array(spws)
    else:
        spws = mymsmd.almaspws(fdm=True,tdm=True)
    # The following line is necessary for spectral-scan SBs.
    spws = np.intersect1d(spws,mymsmd.spwsforscan(int(scan)))

    if (spw==None or spw==''):
        integration = '0'
        if (casadef.subversion_revision >= casaRevisionWithAlmaspws):
            spws = np.intersect1d(spws,mymsmd.almaspws(tdm=True,fdm=True,chavg=True,sqld=True))
        else:
            spws = np.setdiff1d(spws,mymsmd.wvrspws())
        if (len(spws) < 1):
            print "There are no spws with intent = %s" % (intent)
            return
        spws = [spws[0]]
    else:
        if (int(spw) not in spws):
            if (int(spw) >= mymsmd.nspw()):
                print "spw %s is not in the dataset" % (str(spw))
            else:
                print "spw %s does not have intent=%s." % (str(spw), intent)
            print "Available spws with this intent = %s" % (str(spws))
            return
        spws = [int(spw)]
    integrationTime = []
    for s in range(len(spws)):
        spw = spws[s]
        for integration in sorted(scanInfo[scan].keys()):
            if (spw in scanInfo[scan][integration]['SpwIds']):
                integrationTime.append(scanInfo[scan][integration]['IntegrationTime'])
                if (method=='first'):
                    break
        if (integrationTime != [] and method=='first'):
            break
    if (integrationTime == []):
        print "No spw with intent = %s is in any integrations of scan %s" % (intent, scan)
        return
    elif (verbose):
        print "Picking spw %d (with %d channels) to determine integration time" % (spw,mymsmd.nchan(spw))
    mymsmd.close()
    if (method == 'median'):
        print "Taking median of %d integrations" % (len(integrationTime))
        seconds = np.median(integrationTime)
    elif (method == 'mean'):
        print "Taking mean of %d integrations" % (len(integrationTime))
        seconds = np.mean(integrationTime)
    elif (method == 'stdev'):
        print "Taking standard deviation of %d integrations" % (len(integrationTime))
        seconds = np.std(integrationTime)
    else:
#        print "Reporting length of first integration. Use method parameter to compute mean/median/stdev."
        seconds = integrationTime[0]
    if (pointingTable):
        mytb = createCasaTool(tbtool)
        mytb.open(vis+'/POINTING')
        interval = mytb.getcol('INTERVAL')
        direction = mytb.getcol('DIRECTION')
        diffdirectionRA = (direction[0][0][1:] - direction[0][0][:-1])*206264.8*np.cos(direction[1][0][1:])
        diffdirectionDec = (direction[1][0][1:] - direction[1][0][:-1])*206264.8
        print "Median separation of points = %f,%f arcsec" % (np.median(diffdirectionRA),np.median(diffdirectionDec))
        print "Median INTERVAL in pointing table = ", np.median(interval)
        mytb.close()
    return seconds
    
def spectralindex(filename='',yfilename='',source='',verbose=False,
                  maxpoints=0,trials=0,spw='',plotdir='',
                  labelspw=False,referenceFrame='TOPO',
                  plaintext=False, lineNumbers=None,columns=None,
                  yscale=1.0, plotunits='linear',freqs=[],fluxes=[],
                  errors=[],plotfile='',showplot=True,xaxis=[]):
    """
    This is a wrapper for the spectralindex method of the linfit class.
    For help, see help au.linfit().spectralindex.
    """
    return(linfit().spectralindex(filename,yfilename,source,verbose,
                                  maxpoints,trials,spw,plotdir,
                                  labelspw,referenceFrame,plaintext,
                                  lineNumbers,columns,yscale,plotunits,
                                  freqs,fluxes,errors,plotfile,showplot,xaxis))

def coGradient(x, trials=10000):
    """
    Milam et al. 2005
    """
    return(computeStdDevMonteCarlo(slope=5.41, slopeSigma=1.07, intercept=19.03, interceptSigma=7.9, x=x, trials=trials))

def computeStdDevMonteCarlo(slope, slopeSigma, intercept, interceptSigma, x, trials=10000):
    """
    This is a wrapper for the computeStdDevMonteCarlo method of the linfit class.
    Computes Y and its uncertainty given uncertainties on a fitted slope
    and intercept, and a value of X.
    - Todd Hunter
    """
    return(linfit().computeStdDevMonteCarlo(slope, slopeSigma, intercept, interceptSigma, x, trials))
    
class linfit:
  """
  Todd Hunter
  """
  def computeMultivariateNormalStats(self, slope, intercept, covar, x, trials=10000,
                                     logfit=False, meanOfLogX=0):
      y = []
      # If the slope and intercept are correlated, then this will pick correlated
      # random variables, which reduces the spread of the result.
      mymean = [intercept,slope]
      random_intercept, random_slope = np.random.multivariate_normal(mymean,covar,trials).T
      if (logfit):
          for t in range(trials):
              y.append(10**(random_slope[t]*(np.log10(x)-meanOfLogX) + random_intercept[t]))
      else:
          for t in range(trials):
              y.append(10**(random_slope[t]*x + random_intercept[t]))
      rms = np.std(y,axis=0)
      ymin = np.min(y,axis=0)
      ymax = np.max(y,axis=0)
      ymean = np.mean(y,axis=0)
      return(rms, ymin, ymax, ymean)

  def computeStdDevMonteCarlo(self, slope, slopeSigma, intercept, interceptSigma, x, trials=10000,
                              logfit=False, meanOfLogX=0, covar=None):
      """
      Computes Y and its uncertainty given a fitted slope and intercept, uncertainies on them,
      and a value of X.  Returns the uncertainty.
      """
      y = []
      if (covar != None):
          # If the slope and intercept are correlated, then this will pick correlated
          # random variables, which reduces the spread of the result.
          mymean = [intercept,slope]
          random_intercept, random_slope = np.random.multivariate_normal(mymean,covar,trials).T
      if (logfit):
          for t in range(trials):
              if (covar == None):
                  y.append(10**((slope+slopeSigma*pickRandomError())*(np.log10(x)-meanOfLogX) + intercept + interceptSigma*pickRandomError()))
              else:
                  y.append(10**(random_slope[t]*(np.log10(x)-meanOfLogX) + random_intercept[t]))
      else:
          for t in range(trials):
              if (covar == None):
                  y.append((slope+slopeSigma*pickRandomError())*x + intercept + interceptSigma*pickRandomError())
              else:
                  y.append(10**(random_slope[t]*x + random_intercept[t]))
      rms = np.std(y)
      print "Median Monte-Carlo result at %f = %f +- %f (scaled MAD = %f)" % (x, np.median(y), rms, MAD(y))
      return(rms)
  
  def readFluxscaleResult(self,xfilename, yfilename, source, verbose=False,
                          maxpoints=0,spwlist=[],referenceFrame='TOPO',debug=False):
    """
    Specific function to read CASA output files from listobs and fluxscale.
    It returns the log10() of the frequency and flux densities read. The
    flux density uncertainties returned are scaled by the flux density values
    (but the ratios are not logged).
    """
    fx = open(xfilename,'r')
    fy = open(yfilename,'r')
    lines = fy.readlines()
    fy.close()
    x = []
    y = []
    yerror = []
    skiplist = ''
    trueSource = ''
    sourcesFound = []
    ignoreSpw = []  # This will be a list of spws with "Insufficient data"
    for line in lines:
        if (line.find('Flux')>=0 and (source=='' or line.find(source)>=0)):
            tokens = line.split()
            for t in range(len(tokens)):
                if (tokens[t].find('SpW')>=0):
                    #  We have specified the spws to include
                    spw = int(tokens[t].split('=')[1])
                    if (line.find('INSUFFICIENT DATA')>=0):
                        ignoreSpw.append(spw)
                        print "Skipping spw %d due to INSUFFICIENT DATA result from fluxscale." % (spw)
                        break
                if (tokens[t]=='is:'):
                    if (spw not in spwlist and spwlist != []):
                        skiplist += str(spw) + ','
                    else:
                        # print "Using spw %d" % spw
                        if (tokens[t-4] != 'for'):
                            # there is a blank in the name
                            trueSource = tokens[t-4] + ' ' + tokens[t-3]
                        else:
                            trueSource = tokens[t-3]  # no blanks were found in the name
                        sourcesFound.append(trueSource)
                        if (debug):
                            print "parsing flux from %s" % (tokens[t+1])
                        y.append(float(tokens[t+1]))
                        if (debug):
                            print "parsing flux uncertainty from %s" % (tokens[t+3])
                        yerror.append(float(tokens[t+3]))
                        break
            if (len(y) == maxpoints and maxpoints>0): break
    if (len(y) == 0):
        if (trueSource == ''):
          print "Did not find any flux densities for source = %s" % (source)
        else:
          print "Did not find any flux densities for source = %s" % (trueSource)
        return([],[],[],[],[])
    if (len(skiplist) > 0):
      print "Skipping spw ", skiplist[0:-1]
    lines = fx.readlines()
    fx.close()
    bw = []
    freqUnits = ''
    spwsKept = []
    for line in lines:
        loc=line.find('Ch1(')
        if (loc>=0):
            freqUnits = line[loc+4:loc+7]
            if (verbose):
                print "Read frequency units = ", freqUnits
        if (line.find(referenceFrame)>=0):
            tokens = line.split()
            for t in range(len(tokens)):
                    if (tokens[t]==referenceFrame):
                        try:
                            spw = int(tokens[t-2])
                        except:
                            spw = int(tokens[t-3])
                            
                        if ((spw not in spwlist and spwlist != []) or spw in ignoreSpw):
#                            print "Skipping spw %d" % spw
                            continue
                        else:
                            spwsKept.append(spw)
                            bw.append(float(tokens[t+3]))
                            x.append(float(tokens[t+1])+bw[-1]*0.5*0.001)
                        break
                    if (len(x) == maxpoints and maxpoints>0):
                        print "Stopping after readings %d points ---------------" % (maxpoints)
                        break
    if (len(y) != len(x)):
        print "There is a mismatch between the number of spws in the %s frame (%d" % (referenceFrame,len(x))
        print "and the number of valid flux densities (%d)." % (len(y))
        if (len(np.unique(sourcesFound)) > 1):
            print "Please limit the fit to one source using the 'source' paramter: ", np.unique(sourcesFound)
        return([],[],[],[],[],[])
    if (verbose):
        print "Read %d x values for %s = " % (len(x),trueSource), x
        print "Read %d y values for %s = " % (len(y),trueSource), y
    else:
        print "Read %d x values for %s (avg=%.3f)" % (len(x),trueSource,np.mean(x))
        print "Read %d y values for %s (avg=%.3f)" % (len(y),trueSource,np.mean(y))
    if (freqUnits.find('MHz') >= 0):
        x = np.array(x)*0.001
        freqUnits = 'GHz'
    logx = np.log10(x)
    logyerror = list(np.array(yerror) / np.array(y))
    logy = np.log10(y)
    return (logx,logy,logyerror,trueSource,freqUnits,spwsKept)
# end of readFluxscaleResult

  def parse_spw_argument(self,spw):
    """
    # returns an integer list of spws based on a string entered by the user
    #  e.g.  '1~7,9~15' yields [1,2,3,4,5,6,7,9,10,11,12,13,14,15]
    #        [1,2,3] yields [1,2,3]
    #        1 yields [1]
    """
    if (type(spw) == list):
        return(spw)
    elif (type(spw) == int):
        return([spw])
    sublists = spw.split(',')
    spwlist = []
    for s in sublists:
        spwrange = s.split('~')
        if (len(spwrange) > 1):
            try:
                firstSpw = int(spwrange[0])
                try:
                    secondSpw = int(spwrange[1])
                    for w in range(int(spwrange[0]),int(spwrange[1])+1):
                        spwlist.append(w)
                except:
                    print "Unrecognized element in spw string: %s" % (spwrange[1])
            except:
                print "Unrecognized element in spw string: %s" % (spwrange[0])
        else:
            try:
                spwlist.append(int(spwrange[0]))
            except:
                print "Unrecognized element in spw string: %s" % (spwrange[0])
    return spwlist

  def spectralIndexFitterMonteCarlo(self,filename,yfilename='',degree=1,source='',
                                    verbose=False,maxpoints=0,trials=2000,spw='',
                                    referenceFrame='TOPO', plaintext=False,
                                    lineNumbers=None, columns=None, yscale=1.0,
                                    freqs=[],fluxes=[], errors=[]):
    """
    If error bars are included with the data, then the return values are:
        p, covar contain the results of the weighted fit
        p2 contains the results of the unweighted fit
    If no error bars are included, then
        p contains the results of the unweighted fit
    lineNumbers: which lines to read, where 1 is the first line in the file
    columns: which columns to read for freq, flux, error (starting at 1)
    """
    spwlist = []
    nullReturn = ([],[],[],[],[], [],[],[],[],[], [])
    if (spw != [] and spw != ''):
      spwlist = self.parse_spw_argument(spw)
      if (len(spwlist) < 2):
          print "I need more than 1 spws to fit a spectral index."
          return(nullReturn)
      else:
          print "Will use spw = ", spwlist
    if (filename == ''):
        x = np.array(freqs, dtype=np.float)
        y = np.array(fluxes, dtype=np.float)
        yerror = np.array(errors, dtype=np.float)
        if (len(x) != len(y) or len(x) != len(yerror)):
            print "Inconsistent array lengths of freqs, fluxes, errors"
            return
        freqUnits = 'GHz'
        spwsKept = 0
        if (type(x[0]) == str):
            newx = []
            for xf in x:
                newx.append(parseFrequencyArgument(xf)*1e-9)
            x = newx
        elif (x[0] > 2000):
            x *= 1e-9
        yerror = list(yerror/y)
        x = np.log10(x)
        y = np.log10(y)
    elif (plaintext == False):
        (x,y,yerror,source,freqUnits,spwsKept) = self.readFluxscaleResult(filename,yfilename,source,verbose,maxpoints,spwlist,referenceFrame=referenceFrame)
    else:
        result = self.readPlaintextFile(filename,lineNumbers,columns)
        if (result == None): return
        (x,y,yerror) = result
        source = 'source'
        freqUnits = 'GHz'
        spwsKept = 0
    y = np.array(y)*yscale
    if (len(x) == 0 or len(y) == 0):
        return(nullReturn)

    # normalize the X values about 0 such that the uncertainties between slope
    # and intercept will be uncorrelated
    meanOfLogX = np.mean(x)
    x = x-meanOfLogX

    if (len(yerror)>0):
        fitfunc = lambda p, x: p[0]*x + p[1]
        errfunc = lambda p,x,y,err: (y-fitfunc(p,x))/err
        pinit = [1.0,-1.0]
        slope = []
        yoffset = []
        errors = np.zeros(len(y))
        # first trial is with no errors
        for t in range(trials):
            ytrial = list(np.array(y) + np.array(yerror)*np.array(errors))
            out = optimize.leastsq(errfunc, pinit, args=(x,ytrial,yerror),full_output=1)
            p = out[0]
            if (t==0):
                covar = out[1]
            slope.append(p[0])
            yoffset.append(p[1])
            errors = []
            for e in range(len(y)):
                errors.append(pickRandomError())
        p = [slope[0], yoffset[0]]
        pmedian = [np.median(slope), np.median(yoffset)]
        perror = [np.std(slope), np.std(yoffset)]
        p2 = np.polyfit(x,y,degree)
    else:
        p = np.polyfit(x,y,degree)
        covar = []
        p2 = []
        perror = []
        pmedian = []

    return(p,covar,x,y,yerror,p2,source,freqUnits, pmedian, perror, spwsKept, meanOfLogX)
  # end of spectralIndexFitterMonteCarlo

  def readPlaintextFile(self,filename,lineNumbers=None,columns=None):
      """
      Reads a file of the format:   Freq(GHz)   Flux   Error
      and returns the 3 columns as three arrays.
      lineNumbers: which lines to read, where 1 is the first line in the file
      columns: which columns to read for freq, flux, error (starting at 1)
      """
      f = open(filename,'r')
      lines = f.readlines()
      f.close()
      freq = []
      flux = []
      error = []
      linectr = 0
      for line in lines:
          linectr += 1
          if (line[0] != '#'):
              if (lineNumbers==None or linectr in lineNumbers):
                  if (columns==None):
                      a,b,c = line.split()
                      freq.append(float(a))
                      flux.append(float(b))
                      error.append(float(c))
                  else:
                      mycolumns = line.split()
                      n_mycolumns = len(mycolumns)
                      if (len(columns) < 3):
                          print "invalid column list: need to specify at least 3"
                          return
                      if (np.max(columns) >= n_mycolumns):
                          print "invalid column list: %d exceeds %d" % (np.max(columns),n_mycolumns)
                          return
#                      print "parsing %s" % (mycolumns[columns[0]-1])
                      freq.append( float(mycolumns[columns[0]-1]))
                      flux.append( float(mycolumns[columns[1]-1]))
                      error.append(float(mycolumns[columns[2]-1]))
#      print "Read %d lines" % (len(freq))
      logx = np.log10(freq)
      logyerror = list(np.array(error) / np.array(flux))
      logy = np.log10(flux)
      return(logx, logy, logyerror)
      
  def spectralIndexFitterCovarMatrix(self,filename='',yfilename='',degree=1,source='',
                                     verbose=False,maxpoints=0,spw='',
                                     referenceFrame='TOPO',plaintext=False,
                                     lineNumbers=None, columns=None, yscale=1.0,
                                     freqs=[],fluxes=[], errors=[]):
    """
    If error bars are included with the data, then the return values are:
        p, covar contain the results of the weighted fit
        p2 contains the results of the unweighted fit
    If no error bars are included, then
        p contains the results of the unweighted fit
    lineNumbers: which lines to read, where 1 is the first line in the file
    columns: which columns to read for freq, flux, error (starting at 1)
    """
    spwlist = []
    nullReturn = ([],[],[],[],[], [],[],[],[],[], [])
    if (spw != [] and spw != ''):
      spwlist = self.parse_spw_argument(spw)
      if (len(spwlist) < 2):
          print "I need more than 1 spws to fit a spectral index."
          return(nullReturn)
      else:
          print "Will use spw = ", spwlist
    if (filename == ''):
        x = np.array(freqs,dtype=float)
        y = np.array(fluxes,dtype=float)
        yerror = np.array(errors,dtype=float)
        if (len(x) != len(y) or len(x) != len(yerror)):
            print "Inconsistent array lengths of freqs, fluxes, errors"
            return
        freqUnits = 'GHz'
        spwsKept = 0
        if (type(x[0]) == str):
            newx = []
            for xf in x:
                newx.append(parseFrequencyArgument(xf)*1e-9)
            x = newx
        elif (x[0] > 2000):
            x *= 1e-9
        yerror = list(yerror/y)
        x = np.log10(x)
        y = np.log10(y)
    elif (plaintext == False):
        # yerror returned by readFluxscaleResult = y_uncertainty / y
        (x,y,yerror,source,freqUnits,spwsKept) = self.readFluxscaleResult(filename,yfilename,source,
                                         verbose,maxpoints,spwlist,referenceFrame=referenceFrame)
    else:
        result = self.readPlaintextFile(filename,lineNumbers,columns)
        if (result == None): return
        (x,y,yerror) = result
        source = 'source'
        freqUnits = 'GHz'
        spwsKept = 0
    if (len(x) == 0 or len(y) == 0):
        return(nullReturn)
    y = np.log10(np.array(10**y)*yscale)
    
    # normalize the X values about 0 such that the uncertainties between slope
    # and intercept will be uncorrelated
    meanOfLogX = np.mean(x)
    x = x-meanOfLogX

    # simple fit with no errors
    p2 = np.polyfit(x,y,degree)

    x = 10**x
    y = 10**y

    if (len(yerror)>0):
        fitfunc = lambda p, x: p[0] + p[1]*np.log10(x)
        errfunc = lambda p,x,y,err: (np.log10(y)-fitfunc(p,x))/err
        pinit = [1.0,-1.0]
        out = optimize.leastsq(errfunc, pinit, args=(x,y,yerror),full_output=1)
        p = out[0]
        covar = out[1]
    else:
        print "No uncertainties were found for the flux density measurements."

    return(p,x,y,yerror,covar,source,freqUnits,spwsKept,p2,meanOfLogX)
  # end of spectralIndexFitterCovarMatrix

  def round_to_n(self, x, n):
      ''' 
      http://stackoverflow.com/questions/3410976/how-to-round-a-number-to-significant-figures-in-python 
      '''
      return np.round(x, -int(floor(log10(abs(x)))) + (n - 1))

  def calc_ticks(self, domain, tick_count, equidistant):
      if equidistant:
          ticks = np.logspace(np.log10(domain[0]), np.log10(domain[1]), num = tick_count, base = 10)
      else:
          ticks = np.linspace(domain[0], domain[1], num = tick_count)
      for n in range(1, 6):
          if len(set(self.round_to_n(tick, n) for tick in ticks)) == tick_count:
              break    
      return list(self.round_to_n(tick, n) for tick in ticks)

  def spectralIndexCovarMatrix(self,filename='',yfilename='',source='',verbose=False,
                               maxpoints=0,spw='',plotdir='',
                               labelspw=False,referenceFrame='TOPO',plaintext=False,
                               lineNumbers=None, columns=None, yscale=1.0,plotunits='linear',
                               freqs=[],fluxes=[],errors=[],plotfile='',showplot=True,
                               xaxis=[], dashedCurvePoints=40):
    """
    This function is designed to fit the spectral index to the results
    output from casa's fluxscale task, and make a summary plot. Currently,
    it requires the output from the casa listobs task to determine the center
    frequencies of each spectral window.  It calls scipy.optimize.leastsq()
    and uses the fractional covariance matrix that it returns to determine the
    uncertainty on the fitted slope on the basis of the error bars on each flux
    density, as long as there are more than 2 points.  This is the formula that
    Bryan Butler sent me in Feb 2013. However, for the case of only 2 points,
    the denominator becomes zero in his formula, so it instead uses the
    sqrt(covariance matrix) which seems to agree well with the Monte-Carlo
    method.             
    -- Todd Hunter

    filename: contains a listobs output file
    yfilename: contains a fluxscale output file
    source: sourcename to choose from the (possibly) multi-source fluxscale file
    maxpoints: the maximum number of spws to select for the fit (0=no max)
    spw: the spws to use, e.g. ''=all, '1~3,5,6~8'=[1,2,3,5,6,7,8]
    plotdir: the directory in which to write the plotfile
    labelspw: draw spw numeric labels adjacent to each point
    referenceFrame: the frequency reference frame, if not 'TOPO'
    plaintext: if True, then read the freqs, flux densities and uncertainties
               from a single plain text file, specified by filename
    lineNumbers: which lines to read, where 1 is the first line in the file
    columns: which columns to read for freq, flux, error (starting at 1)
    freqs,fluxes,errors: alternative to using filename
    showplot: if True, produce a plot showing error bars and model
    xaxis: a list of points for which to compute model y values
    dashedCurvePoints: number of points to define the min/max/rms model lines
    """
    # x & y are returned in linear units of frequency (normalized about 1.0 MHz)
    # and flux density (usually Jy)
    # yerror is the (uncertainty in y) divided by y
    result = self.spectralIndexFitterCovarMatrix(filename,yfilename,degree=1,source=source,
                                  verbose=verbose,maxpoints=maxpoints,
                                  spw=spw, referenceFrame=referenceFrame,
                                  plaintext=plaintext,lineNumbers=lineNumbers,
                                  columns=columns, yscale=yscale,freqs=freqs,fluxes=fluxes,errors=errors)
    if (result == None): return
    if (result[0] == []): return
    (p,x,y,yerror,covar,source,freqUnits,spwsKept,p2,meanOfLogX) = result
    if (plotdir == ''):
        plotdir = './'
    if (plotdir[-1] != '/'):
        plotdir += '/'
    if (p == []):
        # If the data import failed, then the fit will be blank, so return.
        return(p)

    # Get the result of the fit
    yoffset = p[0]
    slope = p[1]
    freq = x[0]
    freqUnNormalized = 10**(np.log10(freq) + meanOfLogX)
    amp = 10**(yoffset + np.log10(freq)*slope)

    # from Bryan Butler email on Feb 15/16, 2013
    summed_error = 0
    for ii in range(len(x)):
        model = yoffset + slope*x[ii]
        residual = (model - y[ii])**2 / (yerror[ii]**2)
        summed_error += residual
    if (len(x) > 2):
        residual_variance = summed_error / (len(x) - 2)
        slopeFitError = fabs(slope) / np.sqrt(covar[1][1]*residual_variance)
        yoffsetError = fabs(yoffset) / np.sqrt(covar[0][0]*residual_variance)
    else:
        # residual variance cannot be calculated due to divide by zero
        # but the following formula seem to agree with the Monte Carlo approach
        slopeFitError = fabs(slope) * np.sqrt(covar[1][1])
        yoffsetError = fabs(yoffset) * np.sqrt(covar[0][0]) 
    ampError = self.computeStdDevMonteCarlo(slope,slopeFitError,yoffset,yoffsetError,freqUnNormalized,
                                            logfit=True,meanOfLogX=meanOfLogX,covar=covar)
    mydict = {'spectralIndex': slope, 'spectralIndexUncertainty':slopeFitError,
              'intercept': yoffset, 'interceptUncertainty': yoffsetError,
              'meanOfLogX': meanOfLogX, 'yaxis': [], 'yaxisUncertainty': [], 'covar': covar}
    amp2 = (10.0**p2[1]) * (freq**p2[0])
    if (verbose):
        print "yoffset=%f, covar = " % (yoffset), covar
    if (amp < 0.01):
        print "Error-weighted fit: Slope: %.3f+-%.3f  Flux D. @ %.3f%s: %.3f+-%.3f mJy" % (slope,
                                 slopeFitError, freqUnNormalized, freqUnits, amp*1000, ampError*1000)
        print "   Un-weighted fit: Slope: %.3f         Flux D. @ %.3f%s: %.3f mJy" % (p2[0], freqUnNormalized, freqUnits, amp2*1000)
    else:
        print "Error-weighted fit: Slope: %.3f+-%.3f  Flux D. @ %.3f%s: %.3f+-%.3f Jy" % (slope,
                                 slopeFitError, freqUnNormalized, freqUnits, amp, ampError)
        print "   Un-weighted fit: Slope: %.3f         Flux D. @ %.3f%s: %.3f Jy" % (p2[0], freqUnNormalized, freqUnits, amp2)
    
    if (distutils.spawn.find_executable('dvipng')):
        rc('text',usetex=True)
    if (showplot):
        pb.clf()
        desc = pb.subplot(111)
    logx = np.log10(x)
    logy = np.log10(y)
    logxsorted = np.sort(logx)
    yfit = yoffset + logx*slope
    for myx in xaxis:
        yaxis = 10**(yoffset+(np.log10(myx)-meanOfLogX)*slope)
        mydict['yaxis'].append(yaxis)
        mydict['yaxisUncertainty'].append(self.computeStdDevMonteCarlo(slope,slopeFitError,yoffset,yoffsetError,myx,
                                                                       logfit=True,meanOfLogX=meanOfLogX,covar=covar))
    dashedCurveX = 10**np.linspace(np.log10(np.min(x)),np.log10(np.max(x)),dashedCurvePoints)
    dashedCurveRms,dashedCurveMin,dashedCurveMax,dashedCurveMean = \
        self.computeMultivariateNormalStats(slope, yoffset, covar, dashedCurveX, trials=10000,
                                                logfit=True, meanOfLogX=0)
    minvalue = np.log10(dashedCurveMin)
    maxvalue = np.log10(dashedCurveMax)
    logxsorted = np.log10(dashedCurveX)
    
    if (showplot):
      if (plotunits == 'linear'):
        if (verbose):   
            print "Using linear plot units"
        lower = y*yerror
        upper = y*yerror
        x = 10**(logx+meanOfLogX)
        pb.errorbar(x,y,yerr=[lower,upper],color='k',ls='None')
        pb.loglog(x,y,'ko',
                  x,10**yfit,'r-',
#                  10**(logxsorted+meanOfLogX),10**minvalue,'r--',
#                  10**(logxsorted+meanOfLogX),10**maxvalue,'r--',
                  10**(logxsorted+meanOfLogX),dashedCurveMean-dashedCurveRms,'r:',
                  10**(logxsorted+meanOfLogX),dashedCurveMean+dashedCurveRms,'r:'
                  )
        desc.set_xscale("log",subsx=range(10))
        desc.set_yscale("log",subsy=range(10))
        if (freqUnits != ''):
            pb.xlabel('Frequency (%s)'%freqUnits)
        else:
            pb.xlabel('Frequency')
        pb.ylabel('Flux Density (Jy)')
        x0 = np.min(x)
        x1 = np.max(x)
        xr = x1 - x0
        y0 = np.min(y-lower)
        y1 = np.max(y+upper)
        yr = y1-y0
        pb.xlim([x0-xr*0.1, x1+xr*0.1])
        pb.ylim([y0-yr*0.1, y1+yr*0.1])
        if (labelspw):
            for i in range(len(x)):
                pb.text(x[i], y[i],'%d'%(spwsKept[i]),size=10)
      else:
          logx += meanOfLogX
          logxsorted += meanOfLogX
          pb.plot(logx,logy,'ko',logx,yfit,'r-',  
                  logxsorted, minvalue,'r--',logxsorted,maxvalue,'r--')
          lower = np.log10(y) - np.log10(y-y*yerror) 
          upper = np.log10(y+y*yerror) - np.log10(y)
          pb.errorbar(logx,logy,yerr=[lower,upper],color='k',ls='None')
          if (freqUnits != ''):
              pb.xlabel('Log10(Frequency(%s))'%freqUnits)
          else:
              pb.xlabel('Log10(Frequency)')
          pb.ylabel('Log10(FluxDensity(Jy))')
          pb.axis('equal')
          if (labelspw):
              for i in range(len(x)):
                  pb.text(logx[i], logy[i],'%d'%(spwsKept[i]),size=10)
      if (amp < 0.01):
          pb.title(source+'  spectral index=%+.3f+-%.3f, F(%.2f%s)=%.3f+-%.3f mJy'%(slope,slopeFitError,freqUnNormalized,freqUnits,amp*1000,ampError*1000),size=14)
      else:
          pb.title(source+'  spectral index=%+.3f+-%.3f, F(%.2f%s)=%.3f+-%.3f Jy'%(slope,slopeFitError,freqUnNormalized,freqUnits,amp,ampError),size=14)
      desc.xaxis.grid(which='major')
      desc.yaxis.grid(which='major')
      desc.xaxis.set_major_formatter(matplotlib.ticker.ScalarFormatter(useOffset=False))
      desc.yaxis.set_major_formatter(matplotlib.ticker.ScalarFormatter(useOffset=False))
      desc.set_xticks(self.calc_ticks(pb.xlim(),tick_count=4,equidistant=True))
      desc.set_yticks(self.calc_ticks(pb.ylim(),tick_count=4,equidistant=True))
      if (plaintext):
          yfilename = filename
      if (yfilename != ''):
          ytext = self.replaceUnderscores(yfilename)
          pb.text(0.01, 0.01, 'data from %s'%(ytext), transform=desc.transAxes,size=10)
      if (plotfile == True):
        if (plaintext):
            pngname = '%s%s.png' % (plotdir,yfilename)
        else:
            pngname = '%s%s.%s.png' % (plotdir,yfilename,source)
      elif (plotfile != ''):
        pngname = plotfile
      if (plotfile != ''):
        if (os.access('./',os.W_OK) == False):
            fileWriteMessage = "Cannot write plot to current directory, therefore will write to /tmp."
            pngname = '/tmp/' + os.path.basename(pngname)
        pb.savefig(pngname)
        print "Plot saved in %s" % (pngname)
      pb.draw()
    return(mydict)
# end of spectralIndexCovarMatrix()    text

  def spectralindex(self,filename='',yfilename='',source='',verbose=False,
                    maxpoints=0,trials=0,spw='',plotdir='',
                    labelspw=False,referenceFrame='TOPO',plaintext=False,
                    lineNumbers=None, columns=None, yscale=1.0, plotunits='linear',
                    freqs=[],fluxes=[],errors=[],plotfile='',showplot=True,xaxis=[]):
    """
    This function is designed to fit the spectral index to the results
    output from casa's fluxscale task. Currently, it requires the output
    from the listobs task to determine the center frequencies of each spw.
    Usage: spectralIndex(filename='',yfilename='',source='',verbose=False,
                         maxpoints=0,trials=0,spw='',plotdir='',plaintext=False)
    filename: contains a listobs output file
    yfilename: contains a fluxscale output file
    source: sourcename to choose from the (possibly) multi-source fluxscale file
    maxpoints: the maximum number of spws to select for the fit (0=no max)
    trials: if > 0, use a Monte-Carlo technique estimate the fit uncertainties,
       otherwise, use the sqrt(covar_matrix) from scipy.optimize.leastsq (default).
       There is a minimum number of 100 trials, and ~1000 is recommended.
    spw: the spws to use, e.g. ''=all, '1~3,5,6~8'=[1,2,3,5,6,7,8]
    plotdir: the directory in which to write the plotfile
    labelspw: draw spw numeric labels adjacent to each point
    referenceFrame: the frequency reference frame, if not 'TOPO'
    plaintext: if True, then read the freqs, flux densities and uncertainties
               from a single plain text file, specified by filename
    lineNumbers: which lines to read, where 1 is the first line in the file
    columns: which columns to read for freq, flux, error (starting at 1)
    yscale: factor to scale the y values after reading from the file
    plotunits: 'linear' or 'log' (only used if trials==0)
    freqs,fluxes,errors: alternative to using filename
    xaxis: a list of points for which to compute model y values
    """
    if (plaintext==False and yfilename=='' and (freqs==[] or fluxes==[] or errors==[])):
        print "When plaintext=False, you must also specify yfilename which is the output file from fluxscale."
        return
    if (plotunits not in ['linear','log']):
        print "plotunits must be either 'linear' or 'log'"
        return
    if (len(errors) == 2):
        # report the exact fit, and 1-sigma extrema fits
        si = np.log(fluxes[1]/fluxes[0]) / np.log(freqs[1]/freqs[0])
        si1 = np.log((fluxes[1]+errors[1])/(fluxes[0]-errors[0])) / np.log(freqs[1]/freqs[0])
        si2 = np.log((fluxes[1]-errors[1])/(fluxes[0]+errors[0])) / np.log(freqs[1]/freqs[0])
        print "exact value: %f,  1-sigma extrema: %f, %f,  mean unc=%f" % (si,si1,si2,0.5*abs(si2-si1))
    if (trials > 0):
        if (trials < 100):
            trials = 100
        return(self.spectralIndexMonteCarlo(filename,yfilename,source,verbose,maxpoints,
                                            trials,spw,plotdir,labelspw,referenceFrame,plaintext,
                                            lineNumbers,columns,yscale,plotunits,freqs,fluxes,
                                            errors,plotfile,showplot,xaxis))
    else:
        return(self.spectralIndexCovarMatrix(filename,yfilename,source,verbose,maxpoints,
                                      spw,plotdir,labelspw,referenceFrame,
                                      plaintext,lineNumbers,columns,yscale,plotunits,
                                      freqs,fluxes,errors,plotfile,showplot,xaxis))
          
  def spectralIndexMonteCarlo(self,filename='',yfilename='',source='',verbose=False,
                              maxpoints=0,trials=2000,spw='',plotdir='',
                              labelspw=False,referenceFrame='TOPO',
                              plaintext=False,lineNumbers=None,columns=None,yscale=1.0,
                              plotunits='linear',freqs=[],fluxes=[],errors=[],plotfile='',
                              showplot=True, xaxis=[]):
      """
      This function is designed to fit the spectral index to the results
      output from casa's fluxscale task. Currently, it requires the output
      from the listobs task to determine the center frequencies of each
      spectral window.  It runs a brief Monte-Carlo series of fits to
      determine the uncertainty on the fitted slope on the basis of the
      error bars on each flux density.    -- Todd Hunter

      filename: contains a listobs output file
      yfilename: contains a fluxscale output file
      source: sourcename to choose from the (possibly) multi-source fluxscale file
      maxpoints: the maximum number of spws to select for the fit (0=no max)
      trials: number of Monte-Carlo fits to run to estimate the fit uncertainties
      spw: the spws to use, e.g. ''=all, '1~3,5,6~8'=[1,2,3,5,6,7,8]
      plotdir: the directory in which to write the plotfile
      labelspw: draw spw numeric labels adjacent to each point
      referenceFrame: the frequency reference frame, if not 'TOPO'
      lineNumbers: which lines to read, where 1 is the first line in the file
      columns: which columns to read for freq, flux, error (starting at 1)
      xaxis: a list of points for which to compute model y values
      """
      (p,covar,x,y,yerror,p2,source,freqUnits,pmedian,perror,spwsKept,meanOfLogX) = \
          self.spectralIndexFitterMonteCarlo(filename,yfilename,degree=1,source=source,
                                             verbose=verbose,maxpoints=maxpoints,
                                             trials=trials,spw=spw,
                                             referenceFrame=referenceFrame, plaintext=plaintext,
                                             lineNumbers=lineNumbers, columns=columns,yscale=yscale,
                                             freqs=freqs,fluxes=fluxes,errors=errors)
      if (plotdir == ''):
          plotdir = './'
      if (plotdir[-1] != '/'):
          plotdir += '/'
      if (p == []):
          return(p)
      if (p2 != []):
          # Then we have two solutions, where the first one is the error-weighted fit.
          slope = p[0]
          yoffset = p[1]
          if (verbose):
              print "Completed %d Monte-Carlo error trials." % (trials)
          slopeErr = perror[0]
          yoffsetErr = perror[1]
          freq = 10**x[0]
          amp = 10**(p[1] + x[0]*slope)
          ampError = amp * perror[1]
          mydict = {'spectralIndex': slope, 'spectralIndexUncertainty':slopeErr,
                    'intercept': yoffset, 'interceptUncertainty': yoffsetErr,
                    'meanOfLogX': meanOfLogX, 'yaxis': [], 'yaxisUncertainty': []}
          freqUnNormalized = 10**(x[0] + meanOfLogX)
          print "Error-weighted fit: Slope: %.3f+-%.3f  Flux D. @ %.3f%s: %.3f+-%.3f" % (slope, slopeErr, freqUnNormalized, freqUnits, amp, ampError)
          if (verbose):
              yfit = x*pmedian[0] + pmedian[1]
              print "Predicted values = ", yfit
      else:
          # We only have one solution, so put it into p2.
          p2 = p
      amp2 = 10.0**p2[1]
      amp2 *= freq**p2[0]
      print "   Un-weighted fit: Slope: %.3f         Flux D. @ %.3f%s: %.3f" % (p2[0], freqUnNormalized, freqUnits, amp2)
      if (distutils.spawn.find_executable('dvipng')):
          rc('text',usetex=True)
      yfit = x*p[0]+p[1]  # the fit result with zero Monte-Carlo errors added to the data
      for myx in xaxis:
          mydict['yaxis'].append(10**(p[1] + (np.log10(myx)-meanOfLogX)*p[0]))
          mydict['yaxisUncertainty'].append(self.computeStdDevMonteCarlo(slope,slopeErr,yoffset,yoffsetErr,myx,
                                                                         logfit=True,meanOfLogX=meanOfLogX,covar=covar))
      if (showplot):
        pb.clf()
        desc = pb.subplot(111)
        desc.xaxis.grid(which='major')
        desc.yaxis.grid(which='major')
        if (pmedian != []):
          minslope = x*(pmedian[0]-perror[0]) + pmedian[1]
          maxslope = x*(pmedian[0]+perror[0]) + pmedian[1]
  
          # Now apply the scaled error in the yoffset
          minslope2 = np.log10(10**minslope - ampError)
          minslope3 = np.log10(10**minslope + ampError)
          maxslope2 = np.log10(10**maxslope - ampError)
          maxslope3 = np.log10(10**maxslope + ampError)
          minvalue = np.minimum(np.minimum(minslope2,minslope3),np.minimum(maxslope2,maxslope3))
          maxvalue = np.maximum(np.maximum(minslope2,minslope3),np.maximum(maxslope2,maxslope3))
          # sort into ascending order (in case they are not given in this order)
          xsorted = np.sort(x)
          minvalue = minvalue[np.argsort(x)]
          maxvalue = maxvalue[np.argsort(x)]
  
          x += meanOfLogX
          xsorted += meanOfLogX
          pb.plot(x,y,'ko',x,yfit,'r-', xsorted,minvalue,'r--',xsorted,maxvalue,'r--')
          pb.title(source+'  spectral index=%+.3f+-%.3f, F(%.2f%s)=%.3f+-%.3f Jy'%(slope,slopeErr,freqUnNormalized,freqUnits,amp,ampError),size=14)
        else:
          pb.plot(x,y,'ko', x,yfit,'r-')
          pb.title(source+' index=%.3f, F(%.2f%s)=%.3f' % (slope,freqUnNormalized,freqUnits,amp))
        if (labelspw):
          for i in range(len(x)):
              pb.text(x[i],y[i],'%d'%(spwsKept[i]),size=10)
        originalYerror = yerror*(10**y)
        lower = y-np.log10(10**y-originalYerror)
        upper = np.log10(10**y+originalYerror)-y
        pb.errorbar(x,y,yerr=[lower,upper],color='k',ls='None')
        if (freqUnits != ''):
            pb.xlabel('Log10(Frequency(%s))'%freqUnits)
        else:
            pb.xlabel('Log10(Frequency)')
        pb.ylabel('Log10(FluxDensity(Jy))')
        pb.axis('equal')
        if (plaintext):
            yfilename = filename
        if (yfilename != ''):
            ytext = self.replaceUnderscores(yfilename)
            pb.text(0.01, 0.01, 'data from %s'%(ytext), transform=desc.transAxes,size=10)
        if (plotfile == True):
            pngname = '%s%s.%s.png' % (plotdir,yfilename,source)
        elif (plotfile != ''):
            pngname = plotfile
        if (plotfile != ''):
            if (os.access('./',os.W_OK) == False):
                fileWriteMessage = "Cannot write plot to current directory, therefore will write to /tmp."
                pngname = '/tmp/' + os.path.basename(pngname)
            pb.savefig(pngname)
            print "Plot saved in %s" % (pngname)
        pb.draw()
      return(mydict)
  # end of spectralIndexMonteCarlo

  def replaceUnderscores(self,y):
    """
    Replaced underscores with \_ to avoid strange effects when plotting text with pylab.text()
    """
    newy = ''
    for i in range(len(y)):
        if (y[i]=='_'):
            newy += '\_'
        else:
            newy += y[i]
    return(newy)

  def linfitFromFile(self, filename, xcol, ycol, yerrorcol=None, pinit=[0,0],
                     plot=False, plotfile=None, xlabel=None, ylabel=None, 
                     title=None,delimiter=None, residual=False):
      """
      Performs linear fit to data from the specified file, and data columns.
      xcol, ycol: columns to use from the file (starting at 0)
      yerrorcol: column to use for uncertainties (None -> 1% of ycol)
      pinit: contains the initial guess of [slope, intercept]
      plot: whether to generate a plot window
      plotfile: whether to generate a png file
      xlabel, ylabel, title: labels for the plot
      delimiter: column delimitier in your file
      residual: if True, show the residual of the fit in second panel
      """
      x,y = getxyFromFile(filename,xcol,ycol,delimiter)
      if (yerrorcol == None):
          yerror = y*0.01
      elif (type(yerrorcol) == np.float or type(yerrorcol) == float):
          yerror = y*yerrorcol
      else:
          yerror = y*0.01
      self.linfit(x,y,yerror,pinit,plot,plotfile,xlabel,ylabel,title,residual)

  def linfit(self, x, y, yerror, pinit=[0.57,3.4], plot=False, plotfile=None,
             xlabel=None, ylabel=None, title=None, residual=False):
      """
      Basic linear function fitter with error bars in y-axis data points.
      Uses scipy.optimize.leastsq().  Accepts either lists or arrays.
      Example:
           lf = au.linfit()
           lf.linfit(x, y, yerror, pinit)
      Input:
           x, y: x and y axis values
           yerror: uncertainty in the y-axis values
           pinit contains the initial guess of [slope, intercept]
           residual: if True, show the residual of the fit in second panel
      Output:
         The fit result as: [slope, y-intercept]
      - Todd Hunter
      """
      x = np.array(x)
      y = np.array(y)
      yerror = np.array(yerror)
      fitfunc = lambda p, x: p[1] + p[0]*x
      errfunc = lambda p,x,y,err: (y-fitfunc(p,x))/(err**2)
      out = optimize.leastsq(errfunc, pinit, args=(x,y,yerror/y), full_output=1)
      p = out[0]
      covar = out[1]
      if (plot):
          pb.clf()
          if (residual):
              desc = pb.subplot(211)
          else:
              desc = pb.subplot(111)
          pb.errorbar(x,y,yerr=yerror,fmt='o',color='b',ecolor='b')
          xline = np.array(pb.xlim())
          yline = p[0]*xline + p[1]
          pb.plot(xline, yline, 'k-')
          if (title == None):
              pb.title('y = (%g)x %+g' % (p[0], p[1]))
          else:
              pb.title(title)
              pb.text(0.4,0.92,'y = (%g)x %+g' % (p[0], p[1]), transform=desc.transAxes)
          if (xlabel != None):
              pb.xlabel(xlabel)
          if (ylabel != None):
              pb.ylabel(ylabel)
          if (plotfile == None): 
              plotfile = 'linfit.png'
          if (residual):
              pb.subplot(212)
              pb.plot(x,y-(p[0]*x+p[1]),'b.')
              pb.ylabel('Residuals')
              if (xlabel != None):
                  pb.xlabel(xlabel)
          pb.savefig(plotfile)
          pb.draw()
      return(p)

#  def linfitplot(self)
    
# end of definition of class     linfit

def sevenMeterAntennasOnly(msWithPath):
    """
    Checks for 'CM' in antenna names, and returns False if at least one
    antenna is not a CM antenna.
    """
    antnames = getAntennaNames(msWithPath)
    for name in antnames:
        if ('CM' not in name):
            return(False)
    return(True)


def replace_bpsol(intable,replacetable,antennas,outtable):
    """
    This function will read in two bandpass solution tables and write out
    a new table in which the solutions for the specified antennas in the
    the first table are replaced by the solutions in the second table.
    Currently, this only works for casa 3.3 format tables.
    -Remy Indebetouw
    """
    print "replacing solution for antennas ",antennas
    print "in "+intable
    print "with solutions from "+replacetable
    print "output to "+outtable

    if os.path.exists(outtable):
        print outtable+" exists - delete or choose another name"
        return 1

    # unsafe to filename chaff like trailing slashes
    os.system("cp -r "+intable+" "+outtable)
    
    if not tb.open(replacetable):
        print "can't find "+replacetable
        return 1

    # antennas should be a list of integers
    replaceantcol=tb.getcol("ANTENNA1")
    replacerowids=[]
    for ant in antennas:
        for i in range(len(replaceantcol)):
            if replaceantcol[i] == ant:
                replacerowids.append(i)
    replacerows=tb.selectrows(replacerowids)
    replaceants=replacerows.getcol("ANTENNA1")
    print "antenna numbers in replacement table: ",replaceants

    tb.done()
    
    if not tb.open(outtable,nomodify=False):
        print "can't find "+outtable
        return 1

    origantcol=tb.getcol("ANTENNA1")
    origrowids=[]
    for ant in antennas:
        for i in range(len(origantcol)):
            if origantcol[i] == ant:
                origrowids.append(i)

    oldrows=tb.selectrows(origrowids)
    oldants=oldrows.getcol("ANTENNA1")
    print "antenna numbers in original table: ",oldants
    
    if not pl.all( replaceants==oldants ):
        print "antenna row mismatch"
        return 1

    tb.removerows(antennas)    
    tb.done()
    replacerows.copyrows(outtable)
    replacerows.done()
    return 0

def uvplot(msfile, field='', plotrange=[0,0,0,0], figfile=False, markersize=2, 
           density=144, units='m', mirrorPoints=True):
    """
    A simple function to make u vs. v plot with points mirrored about the
    origin, similar to AIPS.  This functionality is not yet in casa's plotms,
    but it *is* in plotuv. For further help and examples, see
    https://safe.nrao.edu/wiki/bin/view/ALMA/Uvplt
    field: restrict to single field name or field ID
    units: 'm' or 'km'
    -Todd Hunter
    """
    fieldid = field
    if (os.path.exists(msfile) == False):
        print "Could not find ms = %s." % (msfile)
        return
    try:
        mytb = createCasaTool(tbtool)
        mytb.open(msfile)
        mytb.close()
    except:
        print "Could not open ms = %s." % (msfile)
        return
    if (type(fieldid) == str):
        if (fieldid == ''):
            print "Showing points for all fields"
            mytb.open(msfile)
            tb1 = mytb
        elif (len(fieldid) == sum([m in [str(m) for m in range(10)] for m in fieldid])):
            fieldid = int(fieldid)
            vm = ValueMapping(msfile)
            fieldname = vm.getFieldNamesForFieldId(fieldid)
            if (fieldname == None):
                print "No such field in the ms."
                return
            print "Showing field id = %d = %s" % (fieldid, fieldname)
            mytb.open(msfile)
            tb1 = mytb.query('FIELD_ID == '+str(fieldid))
        else:
            # convert from name to ID
            fieldname = fieldid
            vm = ValueMapping(msfile)
            fieldid = vm.getFieldIdsForFieldName(fieldname)[0]
            mytb.open(msfile)
            tb1 = mytb.query('FIELD_ID == '+str(fieldid))
            print "Showing field id = %d = %s" % (fieldid, fieldname)
    elif (type(fieldid) == int):
        tb1 = mytb.query('FIELD_ID == '+str(fieldid))
        vm = ValueMapping(msfile)
        fieldname = vm.getFieldNamesForFieldId(fieldid)
        if (fieldname == None):
            print "No such field in the ms."
            return
        print "Showing field id = %d = %s" % (fieldid, fieldname)
    else:
        print "unsupported field id type"
        return
          
    rawdata = tb1.getcol("UVW")
    if (len(rawdata) < 1):
        print "No data found for this field"
        return
    mytb.close()
    pb.clf()
    adesc = pb.subplot(111)
    if (units == 'km'):
        rawdata *= 0.001
    maxbase = max([max(rawdata[0,]),max(rawdata[1,])])  # in m
        
    pb.plot(rawdata[0,],rawdata[1,],'b.',markersize=markersize)
    if (mirrorPoints):
        pb.plot(-rawdata[0,],-rawdata[1,],'b.',markersize=markersize)
    if (plotrange[0] != 0 or plotrange[1] != 0):
        pb.xlim([plotrange[0],plotrange[1]])
    if (plotrange[2] != 0 or plotrange[3] != 0):
        pb.ylim([plotrange[2],plotrange[3]])
    pb.gca().set_aspect(aspect='equal')
    if (units == 'km'):
        pb.xlabel('u (km)',fontsize='medium')
        pb.ylabel('v (km)',fontsize='medium')
    else:
        pb.xlabel('u (meter)',fontsize='medium')
        pb.ylabel('v (meter)',fontsize='medium')
    if (fieldid==''):
        pb.title(os.path.basename(msfile) + '  all fields')
    else:
        pb.title(os.path.basename(msfile) + '  field %d = %s' % (fieldid,fieldname),fontsize=12)
    yFormatter = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.yaxis.set_major_formatter(yFormatter)
    adesc.yaxis.grid(True,which='major')
    xFormatter = matplotlib.ticker.ScalarFormatter(useOffset=False)
    adesc.xaxis.set_major_formatter(xFormatter)
    adesc.xaxis.grid(True,which='major')
    if (figfile == True):
        if (msfile.find('/')==len(msfile)-1):
            msfile = msfile[0:len(msfile)-1]
        myfigfile = msfile + '.uvplot.png'
        pb.savefig(myfigfile,format='png',density=density)
    elif (figfile != False):
        myfigfile = figfile
        pb.savefig(myfigfile,format='png',density=density)
    else:
        print "To generate a .png file, re-run with: figfile=T or figfile='my.png'"
        return
    pb.draw()
    print "Plot left in = %s" % (myfigfile)

def modifyAntenna(vis, newantenna1, row=0):
    """
    Change the antenna ID in one row of the ms, as a test for listobs behavior.
    -Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not open measurement set = ", vis
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mytb = createCasaTool(tbtool)
    mytb.open(vis,nomodify=False)
    c1 = 'ANTENNA1'
    c2 = 'ANTENNA2'
    uniqueAntennas = np.unique(list(mytb.getcol(c1)) + list(mytb.getcol(c2)))
    print "Antennas initially present in column %s or %s = %s" % (c1, c2, str(uniqueAntennas))
    antenna1 = mytb.getcell(c1,row)
    mytb.putcell(c1,row,newantenna1)
    print "Changed %s in row %d from %d to %d" % (c1, row, antenna1, newantenna1)
    uniqueAntennas = np.unique(list(mytb.getcol(c1)) + list(mytb.getcol(c2)))
    print "Antennas now present in column %s or %s = %s" % (c1, c2, str(uniqueAntennas))
    mytb.close()
    
def modifyIntents(vis='', oldintent='', newintent=''):
    """
    Change all appearances of an intent to be a different intent.
    - Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not open measurement set = ", vis
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mytb = createCasaTool(tbtool)
    mytb.open(vis + '/STATE', nomodify=False)
    intentcol = mytb.getcol('OBS_MODE')
    for i in range(len(intentcol)):
        intentcol[i] = intentcol[i].replace(oldintent,newintent)
    mytb.putcol('OBS_MODE',intentcol)
    mytb.close()
    mytb.done()

def getIntentsFromASDM(asdm, stripPrefix=False):
    """
    Makes dictionary with field name as key and intents as the value
    Required parameters:
    asdm: the name of the ASDM
    -- Todd Hunter
    """
    if (os.path.exists(asdm) == False):
        print "Could not open ASDM = ", asdm
        return
    if (asdm[-1] != '/'):
        asdm = asdm + '/'
    xmlscans = minidom.parse(asdm+'/Scan.xml')
    scandict = {}
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    mydict = {}
    for rownode in rowlist:
        rowpwv = rownode.getElementsByTagName("fieldName")
        # The following is necessary for the case that the SB was terminated
        # early, in which case the final entry of the Scan.xml might not have a <fieldName>
        if (rowpwv == []): continue
        names = rowpwv[0].childNodes[0].nodeValue.split()
        fieldname = str(names[2]).strip('"')
        if (fieldname not in mydict.keys()):
            mydict[fieldname] = []
        rowintent = rownode.getElementsByTagName("scanIntent")
        tokens = rowintent[0].childNodes[0].nodeValue.split()
        numIntents = int(tokens[1])
        for i in range(numIntents):
            intent = str(tokens[i+2])
            if stripPrefix:
                intent = intent[intent.find('_')+1:]
            if (intent not in mydict[fieldname]):
                mydict[fieldname].append(intent)
    return(mydict)

def editFieldname(asdm, field, newname):
    """
    Changes a field name in the ASDM (in 4 files: Source.xml, Scan.xml,
    Subscan.xml and Field.xml')
    -- Todd Hunter
    Required parameters:
    asdm: the name of the ASDM
    field: the old field name
    newname: the new field name
    """
    if (os.path.exists(asdm) == False):
        print "Could not open ASDM = ", asdm
        return
    if (asdm[-1] != '/'):
        asdm = asdm + '/'
    files = ['Source.xml', 'Scan.xml', 'Subscan.xml', 'Field.xml']
    for f in files:
        replaced = 0
        with open(asdm+f+'.new', "w") as out:
            for line in open(asdm+f):
                if (line.find(field) >= 0):
                    line = line.replace(field, newname)
                    replaced += 1
                out.write(line)
        os.rename(asdm+f+'.new', asdm+f)
        print "Replaced %d lines in %s" % (replaced,f)

def editIntents(msName='', field='', scan='', newintents='', help=False,
                append=False):
    """
    Change the observation intents for a specified field.  Adapted from
    John Lightfoot's interactive function for the ALMA pipeline.
    For further help and examples, run editIntents(help=True) or
    see http://casaguides.nrao.edu/index.php?title=EditIntents
    - T. Hunter
    """
    validIntents = ['AMPLITUDE','ATMOSPHERE','BANDPASS','DELAY','FLUX','PHASE',
                    'SIDEBAND_RATIO', 'TARGET','WVR', 'CALIBRATE_AMPLI',
                    'CALIBRATE_ATMOSPHERE','CALIBRATE_BANDPASS',
                    'CALIBRATE_DELAY', 'CALIBRATE_FLUX','CALIBRATE_PHASE',
                    'CALIBRATE_SIDEBAND_RATIO','OBSERVE_TARGET',
                    'CALIBRATE_WVR']
    if (help == True):
        print "Usage: editIntents(msName='', field='', scan='', newintents='', help=False, append=False)"
        print "valid intents = ", validIntents
        print "  Note: the first 9 are simply a shorthand way to specify the latter 9."
        print "  Enter as a list like above, or as single comma-delimited string."
        print "field is a required argument, while scan is optional."
        print "scan can be a single integer, integer list, or comma-delimited string list"
        print "Set append=True to add the specified intent to the existing intents."
        return
    if (msName == ''):
        print "You must specify a measurement set."
        return
    if (field == ''):
        print "You must specify a field ID or name."
        return
    mytb = createCasaTool(tbtool)
    mytb.open(msName + '/FIELD')
    fieldnames = mytb.getcol('NAME')
    print "Found fieldnames = ", fieldnames
    mytb.close()

    mytb.open(msName + '/STATE')
    intentcol = mytb.getcol('OBS_MODE')
    intentcol = intentcol
    mytb.close()

    mytb.open(msName, nomodify=False)
    naddedrows = 0
    if (type(newintents)==list):
        desiredintents = ''
        for n in newintents:
            desiredintents += n
            if (n != newintents[-1]):
                desiredintents += ','
    else:
        desiredintents = newintents
    desiredintentsList = desiredintents.split(',')
        
    for intent in desiredintentsList:
        if ((intent in validIntents)==False):
            print "Invalid intent = %s.  Valid intents = %s" % (intent,validIntents)
            mytb.close()
            return
    foundField = False
    if (type(scan) != list):
        scan = str(scan)
    for id,name in enumerate(fieldnames):
      if (name == field or id == field):
        foundField = True
        print 'FIELD_ID %s has name %s' % (id, name)
        if scan == '': 
            s = mytb.query('FIELD_ID==%s' % id)
            print "Got %d rows in the ms matching field=%s" % (s.nrows(),id)
        else:
            if (type(scan) == str):
                scans = [int(x) for x in scan.split(',')]
            elif (type(scan) != list):
                scans = [scan]
            else:
                scans = scan
#            s = mytb.query('FIELD_ID==%s AND SCAN_NUMBER==%s' % (id, scan))
            print "Querying: 'FIELD_ID==%s AND SCAN_NUMBER in %s'" % (id, str(scans))
            s = mytb.query('FIELD_ID==%s AND SCAN_NUMBER in %s' % (id, str(scans)))
#            print "Got %d rows in the ms matching field=%s and scan=%s" % (s.nrows(),id,scan)
            print "Got %d rows in the ms matching field=%s and scan in %s" % (s.nrows(),id,str(scans))
        if (s.nrows() == 0):
            mytb.close()
            print "Found zero rows for this field (and/or scan). Stopping."
            return
        state_ids = s.getcol('STATE_ID')
        # original code from J. Lightfoot, can probably be replaced
        # by the np.unique() above
        states = []
        for state_id in state_ids:
            if state_id not in states:
                states.append(state_id)
#        print "states = ", states
        for ij in range(len(states)):
            states[ij] = intentcol[states[ij]]
        print 'current intents are:'
        for state in states:
            print state

        if append == False: states = []
        for desiredintent in desiredintentsList:
            if desiredintent.find('TARGET')>=0:
                states.append('OBSERVE_TARGET#ON_SOURCE')
            elif desiredintent.find('BANDPASS')>=0:
                states.append('CALIBRATE_BANDPASS#ON_SOURCE')
            elif desiredintent.find('PHASE')>=0:
                states.append('CALIBRATE_PHASE#ON_SOURCE')
            elif desiredintent.find('AMPLI')>=0:
                states.append('CALIBRATE_AMPLI#ON_SOURCE')
            elif desiredintent.find('FLUX')>=0:
                states.append('CALIBRATE_FLUX#ON_SOURCE')
            elif desiredintent.find('ATMOSPHERE')>=0:
                states.append('CALIBRATE_ATMOSPHERE#ON_SOURCE')
            elif desiredintent.find('WVR')>=0:
                states.append('CALIBRATE_WVR#ON_SOURCE')
            elif desiredintent.find('SIDEBAND_RATIO')>=0:
                states.append('CALIBRATE_SIDEBAND_RATIO#ON_SOURCE')
            elif desiredintent.find('DELAY')>=0:
                states.append('CALIBRATE_DELAY#ON_SOURCE')
            else:
                print "Unrecognized intent = %s" % desiredintent
                continue
            print 'setting %s' % (states[-1])

        if states != []:
            state = reduce(lambda x,y: '%s,%s' % (x,y), states)
            if state not in intentcol:
                print 'adding intent to state table'
                intentcol = list(intentcol)
                intentcol.append(state)
                intentcol = np.array(intentcol)
                state_id = len(intentcol) - 1
                naddedrows += 1
                print 'state_id is', state_id
                state_ids[:] = state_id
            else:
                print 'intent already in state table'
                state_id = np.arange(len(intentcol))[intentcol==state]
                print 'state_id is', state_id
                if (type(state_id) == list or type(state_id)==np.ndarray):
                    # ms can have identical combinations of INTENT, so just
                    # pick the row for the first appearance - T. Hunter
                    state_ids[:] = state_id[0]
                else:
                    state_ids[:] = state_id
            s.putcol('STATE_ID', state_ids)
    if (foundField == False):
        print "Field not found"
        return
    mytb.close()

    print 'writing new STATE table'
    mytb.open(msName + '/STATE', nomodify=False)
    if naddedrows > 0:
        mytb.addrows(naddedrows)
    mytb.putcol('OBS_MODE', intentcol)
    mytb.close()

def strDate2MJD(d, use_metool=True):
    """
    Converts date in string format 20110809 or 2011x08x09 to MJD
    where 'x' can be any non-numeric character, like '-' or '/'
    """
#    print "strDate2MJD received: ", d
    hr = 0
    mn = 0
    sc = 0
    if ((d[4]==d[7]) and (d[4]<'0' or d[4]>'9') and (d[7]<'0' or d[7]>'9')):
        # a delimiter is present
        year = d[0:4]
        month = d[5:7]
        day = d[8:10]
        if (len(d) > 11):
            tokens = len(d[11:].split(':'))
            hr = d[11:].split(':')[0]
            if (tokens > 1):
                mn =  d[11:].split(':')[1]
            if (tokens > 2):
                sc = d[11:].split(':')[2]
    else:
        year = d[0:4]
        month = d[4:6]
        day = d[6:8]
        if (len(d) > 9):
            tokens = len(d[9:].split(':'))
            hr = d[9:].split(':')[0]
            if (tokens > 1):
                mn =  d[9:].split(':')[1]
            if (tokens > 2):
                sc = d[9:].split(':')[2]
    date='%s-%s-%sT%s:%s:%s'%(year,month,day,hr,mn,sc)
    if (os.getenv('CASAPATH') == None and use_metool):
        use_metool = False
    if (use_metool):
        myme = createCasaTool(metool)
        mjd = myme.epoch('utc',date)['m0']['value']
        myme.done()
    else:
        year = int(year)
        month = int(month)
        day = int(day)
        hr = int(hr)
        mn = int(mn)
        sc = float(sc)
        mjd = ymdhmsToMJD(year,month,day, hr,mn,sc)
    return mjd

def tunnel(server='pomona.osf.alma.cl', port=8080, gateway='tatio.aiv.alma.cl', user=''):
    """
    Open an ssh tunnel to a server in Chile, e.g. for accessing the calibrator catalog
    web tool. You need to have an account on a gateway machine in Chile for this to
    work, i.e. either on tatio.aiv.alma.cl or login.alma.cl.
    In the future, the calibrator catalog might become openly available to everyone
    at http://asa.alma.cl/sourcecatweb/sourcecat (but currently it is not).
    - Todd Hunter
    """
    response = os.popen('ps ax | grep ssh | grep %s' % (port)).read()
    if (user == ''):
        user = os.getenv('USER')
    command = 'ssh -N -f -L %d:%s:%d %s@%s' % (port,server,port,user,gateway)
    loc = response.find(command)
    if (loc >= 0):
        process = response[:loc].split('\n')[-1].split()[0]
        print "You already have this tunnel open (with process ID %s)" % (process)
        return
    if (response.find('ssh -N -f -L %d'%port) >= 0):
        process = response[:loc].split('\n')[-1].split()[0]
        print "You already have a tunnel open with port %d. You need to kill this process ID (%s) first" % (port,process)
        return
    print "Creating tunnel: %s" % (command)
    os.system(command)
    print "Now you can access the calibrator web tool at http://localhost:%d/sourcecatweb/sourcecat/" % (port)
    return

def computeFlaggedFraction(flagarray):
    """
    Called by timeOnSourceSD
    """
    flags = 0
    npoints = 0
    for row in flagarray:
        flags += np.sum(flagarray.flatten())
        npoints += len(flagarray.flatten())
    return(flags/(1.0*npoints))

def gridSourceReport(nsources=None):
    """
    See: help au.calDatabaseQuery.CalibratorCatalogUpdate.gridSourceReport
    """
    return(calDatabaseQuery.CalibratorCatalogUpdate().gridSourceReport(nsources))

def getALMAFluxForMS(vis, field=None, frequency=None, verbose=False, 
                     searchAdjacentNames=False, server='', dayWindow=0,
                     showplot=False, plotfile=''):
    """
    Calls getALMAFlux for sources in a measurement set, and returns a dictionary
    keyed by field name.
    field: list of field IDs or names (default = all)
    frequency: the frequency to use (default = mean freq of first TDM or FDM spw)
    searchAdjacentNames: pass this flag to au.searchFlux
    server: pass this string to au.searchFlux (name of xmlrpc database URL)
            can be 'internal', 'external' or full URL
    dayWindow: if non-negative, then process all measurements within this
               many days of the first measurement found (per band)
    showplot: if True, then produce a plot with errorbars and model
    plotfile: write the plot to a file
    """
    if  (type(field)==np.string_):
        field = str(field)
    if (os.path.exists(vis) == False):
        print "Could not open MS = %s" % (vis)
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    if (frequency==None or frequency==''):
        if (casadef.subversion_revision >= casaRevisionWithAlmaspws):
            spws = mymsmd.almaspws(tdm=True,fdm=True)
        else:
            spws = np.setdiff1d(np.union1d(mymsmd.fdmspws(),mymsmd.tdmspws()), mymsmd.chanavgspws())
        # if OBSERVE_TARGET is present, only use those spws
        if ('OBSERVE_TARGET#ON_SOURCE' in mymsmd.intents()):
            myspws = np.intersect1d(mymsmd.spwsforintent('OBSERVE_TARGET#ON_SOURCE'),spws)
            if (verbose):
                print "spw interection of %s with %s = %s" % (mymsmd.spwsforintent('OBSERVE_TARGET#ON_SOURCE'),spws,myspws)
            spws = myspws
        frequency = []
        for spw in myspws:
            frequency.append(mymsmd.meanfreq(spw))
        frequency = np.mean(frequency)
        print "Using frequency = ", frequency
    else:
        frequency = parseFrequencyArgument(frequency)
    if (field==None):
        field = mymsmd.fieldsforintent('CALIBRATE_PHASE*')  # get all the fields
        field = np.append(field,mymsmd.fieldsforintent('CALIBRATE_BANDPASS*'))
        field = np.append(field,mymsmd.fieldsforintent('CALIBRATE_AMPLI*'))
        field = np.append(field,mymsmd.fieldsforintent('CALIBRATE_FLUX*'))
        field = sorted(list(np.unique(field)))
    elif (type(field)==int):
        field = [field]
    elif (type(field)==str):
        fieldlist = []
        for f in field.split(','):
            fieldlist.append(mymsmd.fieldsforname(f))
        field = fieldlist

    date = getObservationStartDate(vis).split()[0]
    sources = {}
    print "fields = ", field
    for i,f in enumerate(field):
        print "\nWorking on field %d of %d: %d = %s" % (i+1, len(field), f, mymsmd.namesforfields(f)[0])
        if (f == ''):
            print "Error in field ID.  Not found in MS"
            return
        mydict = getALMAFlux(mymsmd.namesforfields(f)[0], frequency, 
                             verbose=verbose, date=date,
                             searchAdjacentNames=searchAdjacentNames, 
                             server=server, dayWindow=dayWindow, 
                             showplot=showplot, plotfile=plotfile)
        if (mydict != None):
            sources[mymsmd.namesforfields(f)[0]] = {'fluxDensity': mydict['fluxDensity'], 'fluxDensityUncertainty': mydict['fluxDensityUncertainty'], 'frequency': frequency}
    mymsmd.close()
    return(sources)

def computeFutureDate(dateString, age):
    """
    Takes a date string (returned by the ALMA calibrator database, i.e. YYYY-MM-DD)
    and age in days and computes a future date string to use that is the same number
    of days into the future from the original date.
    """
    dateString = dateString.replace('/','-')
    if (dateString.find('-') < 0):
        dateString = dateString[:4]+'-'+dateString[4:6]+'-'+dateString[6:]
    mydate = datetime.datetime.strptime(dateString,"%Y-%m-%d") + datetime.timedelta(days=age)
    futureDateString = mydate.strftime('%Y-%m-%d')
    return(futureDateString)

def getALMAFlux(sourcename, frequency, lowband=3, highband=7, ignoreLowBand=False,
                ignoreHighBand=False, simulateLowBand=False, simulateHighBand=False,
                defaultSpectralIndex=-0.7, defaultSpectralIndexUncertainty=0.2,
                verbose=False, trials=10000,date='',searchAdjacentNames=False, 
                server='', dayWindow=0, showplot=False, plotfile=''): 
    """
    Queries the ALMA calibrator catalog for flux density measurements in two bands.
    It first computes the spectral index, then interpolates or extrapolates to the
    desired frequency.  It then performs a Monte-Carlo simulation to obtain the flux
    density uncertainty.  If the date is not specified, it simply gets the most recent
    measurements.  If the date is specified, then it finds the measurements in each
    band that are closest to that date, either in the past or future.
    
    frequency: floating point value in Hz or GHz, or string with units (Hz, kHz, MHz, GHz)
    lowband: the ALMA band to use for the low frequency measurement
    highband: the ALMA band to use for the high frequency measurement
    ignoreLowBand: ignore any measurements in the low frequency band
    ignoreHighBand: ignore any measurements in the high frequency band
    simulateLowBand: set to 3.0 Jy (meant only for allow testing)
    simulateHighBand: set to 1.0 Jy (meant only for testing)
    defaultSpectralIndex: spectral index to use if only one band measurement is available
    defaultSpectralIndexUncertainty:  uncertainty to use
    trials: the number of trials to run in the Monte-Carlo simulation of the uncertainty
    date: the date in the past to begin looking for earlier measurements (default=today)
          formats accepted: '20120101' or '2012-01-01' or '2012/01/01'  where the
                             delimiter can be any non-integer character
    searchAdjacentNames: pass this flag to au.searchFlux
    server: pass this string to au.searchFlux (name of xmlrpc database URL)
            can be 'internal', 'external' or full URL
    dayWindow: if non-negative, then process all measurements within this
               many days of the first measurement found (per band)
    showplot: if True, then produce a plot with errorbars and model
    plotfile: write the plot to a file
    """
    if (type(frequency) == str):
        frequency = parseFrequencyArgument(frequency)
    if (frequency < 2000):
        frequency *= 1e9
    allresults = {}
    noLowBandMeasurement = True
    noHighBandMeasurement = True
    if (ignoreLowBand and ignoreHighBand):
        print "No measurements available."
        return
    for band in [lowband,highband]:
        if (band == lowband and ignoreLowBand): continue
        if (band == highband and ignoreHighBand): continue
        if (verbose):
            print "Calling searchFlux('%s', band='%s', date='%s', returnMostRecent=True, verbose=%s, searchAdjacentNames=%s)" % (sourcename, band, date, verbose, searchAdjacentNames)
        results = searchFlux(sourcename, band=band, date=date, returnMostRecent=True,
                             verbose=verbose, searchAdjacentNames=searchAdjacentNames, 
                             server=server, dayWindow=dayWindow)
        if (results == None): return
        if (results == -1): continue  # source not found in catalog
        if (dayWindow < 0):
            results = [results]
        allresults[band] = {} # each key is an array of the same length
        allresults[band]['frequency'] = []
        allresults[band]['flux'] = []
        allresults[band]['uncertainty'] = []
        allresults[band]['age'] = []
        for result in results:
            if (type(result) == NoneType or simulateLowBand or simulateHighBand):
                if (type(result) == NoneType):
                    print "The calibrator database is not currently accessible."
                if (simulateLowBand or simulateHighBand):
                    if (simulateLowBand):
                        allresults[lowband]['frequency'].append(90e9)
                        allresults[lowband]['flux'].append(3)
                        allresults[lowband]['uncertainty'].append(0.3)
                        allresults[lowband]['age'].append(100)
                        noLowBandMeasurement = False
                    if (simulateHighBand):
                        allresults[lowband]['frequency'].append(340e9)
                        allresults[lowband]['flux'].append(1)
                        allresults[lowband]['uncertainty'].append(0.1)
                        allresults[lowband]['age'].append(100)
                        noHighBandMeasurement = False
                else:
                    return None
            elif (type(result) == int):
                print "No Band %d observation in the catalog for this source" % (band)
                if (band == highband):
                    if (noLowBandMeasurement):
                        print "No measurement in either band.  Cannot produce a flux density."
                        return None
            else:
                # Clean up the existing measurement, if necessary
                if (result['uncertainty'] == 0.0):
                    print "No uncertainty in the catalog for this measurement, assuming 10 percent."
                    result['uncertainty'] = 0.1*(result['flux'])
                if (band==lowband):
                    noLowBandMeasurement = False
                else:
                    noHighBandMeasurement = False
                print "Using Band %d measurement: %.3f +- %.3f (age=%d days) %.1f GHz" % (band, result['flux'],
                                                                            result['uncertainty'], result['age'],
                                                                             result['frequency']*1e-9)
                allresults[band]['frequency'].append(result['frequency'])
                allresults[band]['flux'].append(result['flux'])
                allresults[band]['uncertainty'].append(result['uncertainty'])
                allresults[band]['age'].append(result['age'])

        if (date != '' and dayWindow < 0):
            if (type(result) != int):
                futureDate = computeFutureDate(date,result['age'])
            else:
                futureDate = computeFutureDate(date,365*10) # look ahead 10 years
            futureResult = searchFlux(sourcename, band=band, date=futureDate,
                                      returnMostRecent=True, verbose=verbose, server=server)
            if (type(futureResult) != int):
                if (futureResult['date'] != result['date']):
                    # then the measurement after the observation date is closer in time than the one
                    # before, so use it
                    result = python_copy.deepcopy(futureResult)
                    if (result['uncertainty'] == 0.0):
                        print "No uncertainty in the catalog for this measurement, assuming 10 percent."
                        result['uncertainty'] = 0.1*(result['flux'])
                    allresults[band]['frequency'].append(result['frequency'])
                    allresults[band]['flux'].append(result['flux'])
                    allresults[band]['uncertainty'].append(result['uncertainty'])
                    allresults[band]['age'].append(result['age'])
    # end 'for' loop over band
    if (allresults == {}): return None
    spectralIndex = defaultSpectralIndex
    spectralIndexUncertainty = defaultSpectralIndexUncertainty
    if (noLowBandMeasurement or noHighBandMeasurement):
        if (noLowBandMeasurement):
            band = highband
        else:
            band = lowband
#        print "allresults.keys() = ", allresults.keys()
        fluxDensity = allresults[band]['flux'][0] * (frequency/allresults[band]['frequency'][0])**spectralIndex

        # The following does not account for uncertainty in the spectral index, but
        # prevents a crash when defining mydict later.
        fluxDensityUncertainty = fluxDensity * allresults[band]['uncertainty'][0]/allresults[band]['flux'][0]
        
        intercept = np.log10(fluxDensity) 
        # interceptUncertainty should simply be the flux density uncertainty on the log scale
        interceptUncertainty = 0.434*allresults[band]['uncertainty'][0]/allresults[band]['flux'][0]
        meanAge = allresults[band]['age'][0]
        meanOfLogX = np.log10(allresults[band]['frequency'][0]*1e-9) 
        ageDifference = 0
    else:
        meanAge = np.mean([allresults[lowband]['age'] + allresults[highband]['age']])
        ageDifference = fabs(np.mean(allresults[lowband]['age']) - np.mean(allresults[highband]['age']))
        freqs = allresults[lowband]['frequency'] + allresults[highband]['frequency']
        fluxes = allresults[lowband]['flux'] + allresults[highband]['flux']
        errors = allresults[lowband]['uncertainty'] + allresults[highband]['uncertainty']
        if (verbose):
            print "Calling linfit().spectralindex(freqs=%s, fluxes=%s, errors=%s, showplot=%s, plotfile='%s', source='%s')" % (str(freqs),str(fluxes),str(errors),showplot,plotfile,sourcename)
        mydict = linfit().spectralindex(freqs=freqs, fluxes=fluxes, errors=errors, showplot=showplot, plotfile=plotfile, source=sourcename)
        meanOfLogX = mydict['meanOfLogX']
        spectralIndex = mydict['spectralIndex']
        spectralIndexUncertainty = mydict['spectralIndexUncertainty']
        intercept = mydict['intercept']
        interceptUncertainty = mydict['interceptUncertainty']
        fluxDensity = fluxes[0] * (frequency/freqs[0])**spectralIndex
    logfit = True
    if (not noLowBandMeasurement and not noHighBandMeasurement):
        fluxDensityUncertainty = linfit().computeStdDevMonteCarlo(spectralIndex,
                                                        spectralIndexUncertainty,
                                                        intercept,
                                                        interceptUncertainty,
                                                        frequency*1e-9,
                                                        trials,logfit,meanOfLogX,covar=mydict['covar'])
    mydict = {'fluxDensity': fluxDensity, 'spectralIndex': spectralIndex,
              'spectralIndexUncertainty': spectralIndexUncertainty,
              'fluxDensityUncertainty': fluxDensityUncertainty, 'meanAge': meanAge,
              'ageDifference': ageDifference}
    return(mydict)

def searchFlux(sourcename=None, date='', band = None, fLower=1e9, fUpper=1e12,
               tunnel=False, maxrows=10, limit=1000, debug=False,
               server = '', dateCriteria=0, verbose=True, measurements=None,
               returnMostRecent=False, searchAdjacentNames=False,
               showDateReduced=False, dayWindow=-1):
    """
    For main options, see: help au.calDatabaseQuery.CalibratorCatalogUpdate.searchFlux
    Additional options:
    searchAdjacentNames: if True, search nearby names (if given in format: [J]HHMM[+/-]DDM[M])
    server: '', 'external', 'internal', or full URL
    returnMostRecent: if True, return a dictionary describing the most 
             recent measurement
    dayWindow: if non-negative, and returnMostRecent is True, then return a 
          list of matches that are within this many days of the first find
    """
    hostname = socket.gethostname()
    if (server.find('internal')>=0):
        server = 'http://sourcecat.osf.alma.cl/sourcecat/xmlrpc'
    if (server.find('external')>=0):
        server = 'http://asa.alma.cl/sourcecat/xmlrpc'
    if 'alma.cl' in hostname:
        if (server != ''):
            if (debug): print "Using server = ", server
            ccu = calDatabaseQuery.CalibratorCatalogUpdate(server=server)
        else:
            server='http://sourcecat.osf.alma.cl/sourcecat/xmlrpc'
            # There was a time when internal server failed while external kept working, so always use it.
            #server = 'http://asa.alma.cl/sourcecat/xmlrpc'
            ccu = calDatabaseQuery.CalibratorCatalogUpdate(server=server)
    else:
        if (server == ''):
            server = 'http://asa.alma.cl/sourcecat/xmlrpc'
        if (debug):
            print "Calling calDatabaseQuery.CalibratorCatalogUpdate(tunnel=%s,server='%s')" % (tunnel,server)
        ccu = calDatabaseQuery.CalibratorCatalogUpdate(tunnel=tunnel,server=server)
    if (ccu.connectionFailed):
        return(None)
    status = ccu.searchFlux(sourcename,date,band,fLower,fUpper,tunnel,maxrows,
                            limit,debug,server,dateCriteria,verbose,measurements,
                            returnMostRecent,showDateReduced, sourceBandLimit=limit,
                            dayWindow=dayWindow)
    if (status == -1):
        if (searchAdjacentNames):
            names = getAdjacentSourceNames(sourcename)
            if (names == []):
                print "This name is not an allowed format to search for adjacent names.  Must be: [J/B]HHMM+/-DDM[M]"
            else:
                for sourcename in names:
                    status = ccu.searchFlux(sourcename,date,band,fLower,fUpper,
                                            tunnel,maxrows,
                                            limit,debug,server,dateCriteria,
                                            verbose,measurements,
                                            returnMostRecent,showDateReduced,
                                            sourceBandLimit=limit,dayWindow=dayWindow)
                    if (status != -1): break
        elif (verbose):
            print "You could try setting searchAdjacentNames=True"
    return(status)

def getAdjacentSourceNames(sourcename):
    """
    Takes a source name of the format [J/B]1924[+/-]242[9]
    and returns the four adjacent names:  1925+2429, 1923+2429, 1924-2430, 1924-2428
    -Todd Hunter
    """
    mymatch = re.match(r'.?[\d,%]{4}[+-]\d{3}',sourcename)
    sources = []
    if (mymatch != None):
        if (re.match(r'[\d,%]{4}[+-]\d{3}',sourcename) == None):
            epoch = sourcename[0]
            radec = sourcename[1:]
        else:
            epoch = 'J'
            radec = sourcename
        if (len(radec.split('-')) > 1):
            mysign = '-'
        else:
            mysign = '+'
        ra,dec = radec.split(mysign)
        decdigits = len(dec)
        if (ra.find('%') < 0):
            ra2 = int(ra)+1
            # convert 1960 to 2000
            if (ra2%100 == 60): ra2 = (ra2/100 + 1)*100
            if (ra2==2400): ra2=0
            sources.append('%s%04d%c%s' % (epoch,ra2,mysign,dec))
            ra0 = int(ra)-1
            # convert 1999 to 1959
            if (ra0%100 == 99): ra0 = (ra0/100)*100 + 59
            if (ra0 < -1): ra0 = 2359
            sources.append('%s%04d%c%s' % (epoch,ra0,mysign,dec))
        if (dec.find('%') < 0):
            dec2 = int(dec)+1
            # convert 1960 to 2000
            if (dec2%100 == 60):
                dec2 = (dec2/100 + 1)*100
            dec0 = int(dec)-1
            # convert 1999 to 1959
            if (dec0%100 == 99): dec0 = (dec0/100)*100 + 59
            sources.append('%s%s%c%0*d' % (epoch,ra,mysign,decdigits,dec2))
            sources.append('%s%s%c%0*d' % (epoch,ra,mysign,decdigits,dec0))
        if (dec.find('%') < 0 and ra.find('%') < 0):
            sources.append('%s%04d%c%0*d' % (epoch,ra2,mysign,decdigits,dec2))
            sources.append('%s%04d%c%0*d' % (epoch,ra2,mysign,decdigits,dec0))
            sources.append('%s%04d%c%0*d' % (epoch,ra0,mysign,decdigits,dec2))
            sources.append('%s%04d%c%0*d' % (epoch,ra0,mysign,decdigits,dec0))
    return(sources)
         

def timeOnSourceSD(vis, obsid=0, spw=None, debug=False, ignore7m=True):
    """
    Determine the time spent on-source and off-source (per-antenna, and sum)
    for single-dish datasets. Flags are accounted for.
    spw: which spw to use to analyze times.  default=None=first non-WVR science spw
    Returns:
       the total on-source time in minutes
    Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not find the measurement set"
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mytb = createCasaTool(tbtool)
    mytb.open(vis)
    allObsIDs = mytb.getcol('OBSERVATION_ID')
    obsIDs = np.unique(allObsIDs)
    nObsIDs = len(obsIDs)
    print "There are %d rows and %d OBSERVATION_IDs in this dataset = %s" % (len(allObsIDs), nObsIDs, str(obsIDs))
    if (nObsIDs > 1):
        print "Using only OBSERVATION_ID = %d" % (obsid)

    # Find the start and end time of the requested ObsID
    subtable = mytb.query('OBSERVATION_ID == %d' % (obsid))
    antennas = subtable.getcol('ANTENNA1')
    states = subtable.getcol('STATE_ID')
    if (debug):
        print "unique states = ", np.unique(states)
    datadesc = subtable.getcol('DATA_DESC_ID')  # same as spw for now.  See casa ticket on msmd.
    exposures = subtable.getcol('EXPOSURE')
    subtable.close()
    mytb.close()
    mytb.open(vis+'/STATE')
    obsMode = mytb.getcol('OBS_MODE')
    mytb.close()
    offSourceStateIDs = []
    onSourceStateIDs= []
    for o in range(len(obsMode)):
        if (obsMode[o].find('OBSERVE_TARGET#ON_SOURCE') >= 0):
            onSourceStateIDs.append(o)
        elif (obsMode[o].find('OBSERVE_TARGET#OFF_SOURCE') >= 0):
            offSourceStateIDs.append(o)
    offSourceStateIDs = np.array(offSourceStateIDs)
    onSourceStateIDs = np.array(onSourceStateIDs)
    clockTimeMinutes = computeClockTimeOfMS(vis=vis)
    uniqueAntennas = np.unique(antennas)
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    antennaNames = mymsmd.antennanames(uniqueAntennas)
    if (ignore7m):
        uniqueAntennas = []
        for name in antennaNames:
            if (name.find('CM') < 0):
                uniqueAntennas.append(mymsmd.antennaids(name)[0])
    spws = mymsmd.spwsforintent('OBSERVE_TARGET#ON_SOURCE')
    print "spws with observe_target = ", spws
    if (spw == None):
        if (casadef.subversion_revision >= casaRevisionWithAlmaspws):
            spws = np.setdiff1d(spws, mymsmd.almaspws(wvr=True))
        else:
            spws = np.setdiff1d(spws, mymsmd.wvrspws())
        spw = spws[0]
        print "Choosing spw=%d" % (spw)
    if (casadef.subversion_revision >= '26585'):
        try:
            matches1 = np.where(datadesc == mymsmd.datadescids(spw)[0])[0]
        except:
            print "If you see this message, then please email Todd Hunter the full output of this command."
            matches1 = np.where(datadesc == spw)[0]
    else:
        matches1 = np.where(datadesc == spw)[0]
    mymsmd.close()
    if (debug):
        print "%d rows have spw=%d" % (len(matches1),spw)
    allAntsOnSource = 0
    allAntsOffSource = 0
    mytb.open(vis)
    for antenna in uniqueAntennas:
        matches2 = np.where(antennas == antenna)[0]
        spw_ant_matches = np.intersect1d(matches1,matches2)
        if (debug):
            print "%d rows have antenna=%d" % (len(matches2), antenna)
            print "%d rows have both" % (len(spw_ant_matches))
            print "first = %d, state_id=%d" % (spw_ant_matches[0],states[spw_ant_matches[0]])
            print "on source state IDs = ", onSourceStateIDs
            print "off source state IDs = ", offSourceStateIDs
        offSourceMatches = []
        flaggedRowsOffSource = 0
        for o in offSourceStateIDs:
            rows = list(np.where(states == o)[0])
            if (len(rows) > 0):
                subtable = mytb.query('ANTENNA1 == %d AND STATE_ID == %d AND DATA_DESC_ID == %d' % (antenna, o, spw))
                flagcolumn = subtable.getcol('FLAG')
                if (len(flagcolumn) > 0):
                    flaggedFraction = computeFlaggedFraction(flagcolumn)
                else:
                    flaggedFraction = 0
                flaggedRowsOffSource += flaggedFraction*len(flagcolumn)
                subtable.close()
            offSourceMatches += rows
        offSourceMatches = np.array(sorted(offSourceMatches))
        offSourceMatches = np.intersect1d(spw_ant_matches,offSourceMatches)
        if (len(offSourceMatches) > 0):
            if (debug):
                print "%s: %d rows have spw=%d and an off_source state id (percent flagged=%.3f)" % (antennaNames[antenna],
                                                                                 len(offSourceMatches), spw,
                                                                                 flaggedRowsOffSource*100/len(offSourceMatches))
        if (debug):
            if (len(offSourceMatches) > 0):
                print "first = %d with id=%d" % (offSourceMatches[0], states[offSourceMatches[0]])
        onSourceMatches = []
        flaggedRowsOnSource = 0
        for o in onSourceStateIDs:
            rows = list(np.where(states == o)[0])
            if (len(rows) > 0):
                subtable = mytb.query('ANTENNA1 == %d AND STATE_ID == %d AND DATA_DESC_ID == %d' % (antenna, o, spw))
                flagcolumn = subtable.getcol('FLAG')
                if (len(flagcolumn) > 0):
                    flaggedFraction = computeFlaggedFraction(flagcolumn)
                else:
                    flaggedFraction = 0
                flaggedRowsOnSource += flaggedFraction*len(flagcolumn)
                subtable.close()
            onSourceMatches += rows
        onSourceMatches = np.array(sorted(onSourceMatches))
        onSourceMatches = np.intersect1d(spw_ant_matches,onSourceMatches)
        if (debug):
            print "%s: %d rows have spw=%d and an on_source  state id (percent flagged=%.3f)" % (antennaNames[antenna],
                                                                                       len(offSourceMatches), spw,
                                                                                       flaggedRowsOnSource*100/len(onSourceMatches))
        if (debug):
            print "first = %d with id=%d" % (onSourceMatches[0], states[onSourceMatches[0]])
            print "of total %d rows:  on-source=%d,  off-source=%d" % (len(exposures), len(onSourceMatches), len(offSourceMatches))
        if (len(offSourceMatches) > 0):
            offSourceExposures = exposures[offSourceMatches]
        else:
            offSourceExposures = []
        onSourceExposures = exposures[onSourceMatches]
        if (len(offSourceExposures) > 0):
            totalOffSource = np.sum(offSourceExposures) * (1-flaggedRowsOffSource/len(offSourceMatches))
        else:
            totalOffSource = 0
        totalOnSource = np.sum(onSourceExposures) * (1-flaggedRowsOnSource/len(onSourceMatches))
        print "%s:  on source time = %.1f sec = %.1f min" % (antennaNames[antenna],totalOnSource,
                                                             totalOnSource/60.)
        print "%s: off source time = %.1f sec = %.1f min" % (antennaNames[antenna],totalOffSource,
                                                             totalOffSource/60.)
        allAntsOnSource += totalOnSource
        allAntsOffSource += totalOffSource
    mytb.close()
    if (len(uniqueAntennas) > 1):
        print "sum of %d antennas:" % (len(uniqueAntennas))
        print " on source time = %.1f sec = %.1f min" % (allAntsOnSource, allAntsOnSource/60.)
        print "off source time = %.1f sec = %.1f min" % (allAntsOffSource, allAntsOffSource/60.)
        print "on-source efficiency = %.1f%%" % (100*allAntsOnSource/(60.*len(uniqueAntennas))/clockTimeMinutes)
    return(allAntsOnSource/60.)

def plotPointingTable(vis, timerange='', antennaId=0):
    """
    Plots the timestamps of the entries in the POINTING table corresponding to one antenna.
    - Todd Hunter
    """
    if (timerange != ''):
        timerange = parseTimerangeArgument(timerange,vis)
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/POINTING')
    myt = mytb.query("ANTENNA_ID == %s" % antennaId)
    alltimes = myt.getcol('TIME')
    tSuccessiveDifferences = alltimes[1:] - alltimes[:-1]
    print "median sampling interval in POINTING table = %f sec" % (np.median(tSuccessiveDifferences))
    print "min interval= %f" % (np.min(tSuccessiveDifferences))
    print "max interval = %f" % (np.max(tSuccessiveDifferences))
    myt.close()
    mytb.close()
    pb.clf()
    adesc = pb.subplot(111)
    pb.plot_date(pb.date2num(mjdSecondsListToDateTime(alltimes)),np.zeros(len(alltimes)), 'b.',
                 markersize=2.0)
    pb.xlabel('Universal Time on %s' % (mjdsecToUT(alltimes[0]).split()[0]))
    if (timerange != ''):
        pb.xlim(pb.date2num(mjdSecondsListToDateTime(timerange)))
        x0 = timerange[0]
        x1 = timerange[1]
    else:
        x0 = np.min(alltimes)
        x1 = np.max(alltimes)
    setXaxisTimeTicks(adesc, x0, x1)
    adesc.xaxis.grid(True,which='major')
    pb.title(vis)
    pb.draw()
    pb.savefig(vis+'.pointingTable.png')

def getMapBasis(vis):
    """
    Reads the mapping coordinate system from the POINTING table.
    -Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/POINTING')
    coordSys = mytb.getcolkeyword('DIRECTION',1)['Ref']
    mytb.close()
    return(coordSys)
    
def getOffSourceTimes(vis):
    """
    Get the timestamps when observing the OFF_SOURCE position.
    -Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/STATE')
    obsMode = mytb.getcol('OBS_MODE')
    offSourceStateIds = []
    for i,o in enumerate(obsMode):
        if ('OBSERVE_TARGET#OFF_SOURCE' in o):
            offSourceStateIds.append(i)
#    print "State_IDs with OBSERVE_TARGET#OFF_SOURCE: ", offSourceStateIds
    mytb.close()
    mytb.open(vis)
    stateId = mytb.getcol('STATE_ID')
    indices = np.array([],dtype=int)
    for o in range(len(offSourceStateIds)):
        indices = np.append(indices,np.where(stateId == offSourceStateIds[o]))
    print "Found %d/%d rows in the MS corresponding to OBSERVE_TARGET#OFF_SOURCE" % (len(indices),len(stateId))
    times = mytb.getcol('TIME')[indices]
    mytb.close()
    return(times)

def scansforfields(mymsmd, calAtmFields):
    scans = []
    for f in calAtmFields:
        scans += list(mymsmd.scansforfield(f))
    return(np.array(scans))

def getTPSampling(vis, obsid=0, showplot=False, plotfile='', debug=False,
                  labelFirstNSamples=0, labelIncrement=1, convert=True,
                  field='auto', plotrange=[0,0,0,0], antenna=0, scan=None,
                  refractionCorrection=False, nutationCorrection=False, 
                  timerange=None, trimPointingData=True, showComponents=False,
                  pickFirstRaster=False,
                  useApparentPositionForPlanets=False, connectDots=False,
                  intent='OBSERVE_TARGET', findSubscans=False):
    """
    This function reads the main table of the ms, finds the
    start and end time of the specified observation ID, then
    read the POINTING table and extracts the pointing directions
    within that timerange.  It computes successive differences
    on both axes to determine which is the scan direction and
    what the sampling is in each axes, which it returns in
    units of arcseconds on-the-sky, i.e. corrected for the
    right ascension axis by multiplying by cos(declination).
    It also generates a png file showing the observed points
    in relative coordinates in units of arc seconds.

    vis: the name of the measurement set
    obsid: the number of the OBSERVATION_ID to analyze
    showplot: set to True to generate an interactive plot of sampled positions
    plotfile: default='' -->  '<vis>.obsid0.sampling.png'
    labelFirstNSamples: put labels on the first N samples
    labelIncrement: the number of samples between labels
    convert: if True, convert AZELGEO coords to RA Dec in the plot
    field: plot the offset coordinates relative to this field ID (or name)
           default = 'auto' == the first field with OBSERVE_TARGET intent
    plotrange: set the plot axes ranges [x0,x1,y0,y1]
    pickFirstRaster: automatically set to True for major planets
        This avoids confusion due to the slowly changing source position.
    antenna: which antenna ID (or name) to use to determine the scan parameters
    scan: default: use all scans on the first target with OBSERVE_TARGET intent
    timerange: limit the data to this timerange,  e.g. '05:00:00 06:00:00'
            or  '05:00~06:00' or '2011/10/15-05:00:00 2011/10/15-06:00:00'
    trimPointingData: if False, then don't exclude data outside of scan times
    showComponents: if True, then also show X and Y vs. time on upper plot
    intent: the intent for which to pick the scans to use
    findSubscans: if True, then run class Atmcal to find subscan times
    
    Returns:
    xSampling, ySampling, largestDimension (all in units of arcsec)
    
    -Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "The ms does not exist."
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (field==''): field = None
    mytb = createCasaTool(tbtool)
    mytb.open(vis)
    allObsIDs = mytb.getcol('OBSERVATION_ID')
    obsIDs = np.unique(allObsIDs)
    nObsIDs = len(obsIDs)
    print "There are %d rows and %d OBSERVATION_IDs in this dataset = %s" % (len(allObsIDs), nObsIDs, str(obsIDs))

    subtable = mytb.query('OBSERVATION_ID == %d' % (obsid))
    mytb.close()
    times = subtable.getcol('TIME')
    subtable.close()
    if (len(times) < 1):
        print "No rows found for OBSERVATION_ID=%d" % (obsid)
        return

    startTime = np.min(times)
    stopTime = np.max(times)
    if (casadef.casa_version < '4.1.0'):
        print "This function requires casa >= 4.1.0."
        return
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    timeranges = {}
    timecenters = []
    intent = intent.split('#')[0]
    if (intent+'#ON_SOURCE' not in mymsmd.intents()):
        if ('MAP_ANTENNA_SURFACE#ON_SOURCE' in mymsmd.intents()):
            intent = 'MAP_ANTENNA_SURFACE'
        else:
            print "%s#ON_SOURCE is not an intent in this measurement set." % (intent)
            print "Available intents = ", mymsmd.intents()
            return
    scansOnSource = list(mymsmd.scansforintent(intent+'#ON_SOURCE'))
    if (intent+'#OFF_SOURCE' in mymsmd.intents()):
        scansOnSource += list(mymsmd.scansforintent(intent+'#OFF_SOURCE'))
    scansOnSource = np.unique(scansOnSource)
    if (scan != None and scan != ''):
        scansToUse = [int(s) for s in str(scan).split(',')]
        for scan in scansToUse:
            if (scan not in scansOnSource):
                print "Scan %d is not an %s scan.  Available scans = %s" % (scan,intent,str(scansOnSource))
                return
        print "Using only the specified scans: %s" % (str(scansToUse))
    else:
        # should default to the first scan with specified intent
        if (len(scansOnSource) == 0):
            print "There are no scans on the with intent=%s to use." % (intent)
            print "Available intents = ", mymsmd.intents()
            print "Use the intent parameter to select one."
            return
        myfield = mymsmd.fieldsforscan(scansOnSource[0])[0]
        scansToUse = scansOnSource # mymsmd.scansforfield(myfield)
        print "Using only the %s scans on the science target: %s" % (intent,str(scansToUse))

    calAtmTimes = []
    firstCalAtmScan = -1
    if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' in mymsmd.intents()):
        calAtmFields = mymsmd.fieldsforname(mymsmd.namesforfields(mymsmd.fieldsforintent(intent+'#ON_SOURCE')[0])[0])
#        print "calAtmFields = ", calAtmFields
        scans1 = mymsmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
#        print "scans1 = ", scans1
        scans2 = scansforfields(mymsmd,calAtmFields)
#        print "scans2 = ", scans2
        calAtmScans = np.intersect1d(scans1,scans2)
#        print "calAtmScans = ", calAtmScans
        if (len(calAtmScans) > 0):
            firstCalAtmScan = calAtmScans[0]
            firstCalAtmScanMeanMJD = np.mean(mymsmd.timesforscan(firstCalAtmScan))/86400.
            calAtmField = mymsmd.fieldsforscan(firstCalAtmScan)[0]
            calAtmTimes = mymsmd.timesforscan(firstCalAtmScan)
            calAtmTimesMax = np.max(calAtmTimes)
            calAtmTimesMin = np.min(calAtmTimes)
            print "first AtmCal scan on target = %d has %d times (%s-%s)" % (firstCalAtmScan,len(calAtmTimes),
                                                                             plotbp3.utstring(calAtmTimesMin,3),
                                                                             plotbp3.utstring(calAtmTimesMax,3))
            if (findSubscans):
                ac = Atmcal(vis)
                skyTimes = ac.timestamps[firstCalAtmScan][ac.skysubscan]
                print "sky subscan has times (%s-%s)" % (plotbp3.utstring(np.min(skyTimes),3),
                                                         plotbp3.utstring(np.max(skyTimes),3))
        else:
            print "No AtmCals were done on a field with intent %s (%s)" % (intent,calAtmField)
            print "scans1 = ", scans1
            print "scans2 = ", scans2
    else:
        print "No AtmCals in this dataset."

    timesforscan = {}
    if (timerange != None and timerange != ''):
        timerange = parseTimerangeArgument(timerange,vis)
        if (debug):
            print "timerange[0] = ", str(timerange[0])
            print "timerange[1] = ", str(timerange[1])
    for i in scansToUse:
        mytimes = mymsmd.timesforscan(i)
        if (timerange != None and timerange != ''):
            idx1 = np.where(mytimes > timerange[0])[0]
            idx2 = np.where(mytimes < timerange[1])[0]
            mytimes = mytimes[np.intersect1d(idx1,idx2)]
        if (len(mytimes) > 0):
            timesforscan[i] = {'begin': np.min(mytimes), 'end': np.max(mytimes)}
            timeranges[i] = [np.min(mytimes),np.max(mytimes)]
            timecenters += list(mytimes)
        else:
            scansToUse = np.delete(scansToUse,list(scansToUse).index(i))
            if (debug):
                print "No times found for scan %d" % (i)
    timecenters = np.array(timecenters)
    tSuccessiveDifferences = timecenters[1:] - timecenters[:-1]
    medianSamplingIntervalDataTable = np.median(tSuccessiveDifferences)
    print "median sampling interval in data table with OBSERVE_TARGET#ON_SOURCE (scans=%s) = %f sec" % (str(scansOnSource), medianSamplingIntervalDataTable)
    if (casadef.casa_version >= '4.2.0'):
        try:
            spw = np.intersect1d(mymsmd.spwsforintent(intent+'#ON_SOURCE'), mymsmd.almaspws(fdm=True,tdm=True))[0]
            pol = 0
            exposureTime = mymsmd.exposuretime(scan=scansToUse[0], spwid=spw, polid=pol)['value']
            print "Exposure time = %g in spw %d, pol %d" % (exposureTime,spw,pol)
            medianSamplingIntervalDataTable = exposureTime
        except:
            pass

    # find the name of the science field, and (if present) the scan numbers on it
    fieldName = None
    if (field == 'auto'):
        intent = intent + '#ON_SOURCE'
        if (intent not in mymsmd.intents()):
            print "No science target found.  Checking for amplitude or flux calibrator"
            if ('CALIBRATE_FLUX#ON_SOURCE' in mymsmd.intents()):
                intent = 'CALIBRATE_FLUX#ON_SOURCE'
            elif ('CALIBRATE_AMPLI#ON_SOURCE' in mymsmd.intents()):
                intent = 'CALIBRATE_AMPLI#ON_SOURCE'
            else:
                field = None
        if (field != None):
            field = mymsmd.fieldsforintent(intent)
            if (len(field) < 1):
                field = None
            else:
                field = field[0]
                fieldName = mymsmd.namesforfields(field)[0]
                print "Found first source with %s = %d = %s" % (intent.split('#')[0], field, fieldName)
    elif (field != None):
        if (field in mymsmd.namesforfields(range(mymsmd.nfields()))):
            fieldName = field
            field = mymsmd.fieldsforname(fieldName)[0]
        elif (str(field) in [str(a) for a in range(mymsmd.nfields())]):
            fieldName = mymsmd.namesforfields(int(field))[0]
        else:
            print "Field %s is not in this dataset.  Available fields = %s" % (field,str(mymsmd.namesforfields(range(mymsmd.nfields()))))
            return
    if (field != None):
        scansforfield = mymsmd.scansforfield(field)
    nantennas = mymsmd.nantennas()
    antennanames = mymsmd.antennanames(range(nantennas))
    
    mytb.open(vis+'/POINTING')
    coordSys = mytb.getcolkeyword('DIRECTION',1)['Ref']
    originalCoordSys = coordSys
    print "Map coordinate system from the POINTING table = ", coordSys
    alltimes = mytb.getcol('TIME')
    direction = mytb.getcol('DIRECTION')
    antenna_ids = mytb.getcol('ANTENNA_ID')
    uniqueAntennas = len(np.unique(antenna_ids))
    mytb.close()
    if (antenna not in antenna_ids):
        if (antenna not in antennanames):
            print "Antenna %s is not in the POINTING table" % (str(antenna))
            return
        else:
            antenna = mymsmd.antennaids(antenna)
    mymsmd.close()
    matches = np.where(antenna_ids == antenna)[0]
    print "Picked %d/%d rows, which correspond to antenna %d=%s (of %d)" % (len(matches), len(antenna_ids), antenna, antennanames[antenna], uniqueAntennas)
    times = alltimes[matches]
    xdirection = direction[0][0][matches]
    ydirection = direction[1][0][matches]
    
    uniqueTimes, uniqueTimesIndices = np.unique(times, return_index=True)
    if (debug):
        print "Mean time: %f, MJD = %f =  %s" % (np.mean(uniqueTimes),np.mean(uniqueTimes)/86400.,
                                                 mjdSecondsToMJDandUT(np.mean(uniqueTimes))[1])
    timeSortedIndices = np.argsort(uniqueTimes)

    # single-antenna times (sorted by time)
    pointingTime = times[uniqueTimesIndices[timeSortedIndices]]
    xdirection = xdirection[uniqueTimesIndices[timeSortedIndices]]
    ydirection = ydirection[uniqueTimesIndices[timeSortedIndices]]
    tdirection = times[uniqueTimesIndices[timeSortedIndices]]

    totalTimes = len(pointingTime)

    # Keep only the points from the requested ObsID
    matches1 = np.where(pointingTime >= startTime)[0]
    matches2 = np.where(pointingTime <= stopTime)[0]
    matches = np.intersect1d(matches1,matches2)
    matchesObsID = matches[:]
    myTimes = len(matches)
    if (debug):
        print "Selected %d of %d unique times (i.e. from one spw) matching OBSERVATION_ID=%d" % (myTimes, totalTimes, obsid)
    if (myTimes == 0):
        return

    if (trimPointingData):
      # Trim off any pointing table entries not associated with an integration in the selected scan(s)
        scanmatches = []
        scanfieldmatches = []
        pointingTime = np.array(pointingTime)
        for match in matches:
          for i in timeranges.keys():
              if (pointingTime[match] > timeranges[i][0] and  pointingTime[match] < timeranges[i][1]):
                  scanmatches.append(match)
                  if (field != None):
                      if (i in scansforfield):
                          scanfieldmatches.append(match)
                  break
        matches = np.array(scanmatches)  # times within any scan
        scanfieldmatches = np.array(scanfieldmatches)  # times within scans on the field
        myTimes = len(matches)
        if (debug):
            print "Selected %d times as being within a data scan (%s)" % (myTimes, scansToUse)
        if (myTimes == 0):
            return
        x = xdirection[matches]  # These are the longitude values in the pointing table for the selected scan
        y = ydirection[matches]  # These are the latitude values in the pointing table for the selected scan
        times = tdirection[matches]  # These are the timestamps in the pointing table for the selected scan
        if (firstCalAtmScan != -1):
            scanmatches = []
            for match in matchesObsID:
                if (pointingTime[match] > calAtmTimesMin and  pointingTime[match] < calAtmTimesMax):
                    scanmatches.append(match)
            matches = np.array(scanmatches)  
            xCalAtm = xdirection[matches]
            yCalAtm = ydirection[matches]
            timesCalAtmPointing = tdirection[matches]
            if (findSubscans):
                scanmatches = []
                for match in matchesObsID:
                    if (pointingTime[match] > np.min(skyTimes) and pointingTime[match] < np.max(skyTimes)):
                        scanmatches.append(match)
                matches = np.array(scanmatches)
                xCalAtmSky = xdirection[matches]
                yCalAtmSky = ydirection[matches]
                timesCalAtmSkyPointing = tdirection[matches]
    else:
        x = xdirection
        y = ydirection
        times = tdirection
    tSuccessiveDifferences = times[1:] - times[:-1]
    medianSamplingIntervalPointingTable = np.median(tSuccessiveDifferences)
    print "median sampling interval in POINTING table = %f sec" % (medianSamplingIntervalPointingTable)

    

    if (False):
        # Try to speed up the calculation by reducing the number of points.
        # Group the pointing table values into the correlator data time bins.
        # Does not yet work right.
        pointsPerIntegration = {}
        print "Assigning %d pointing table values to %d integrations" % (len(times),len(timecenters))
        for t in range(len(times)):
            mindiff = 1e30
            for integration in range(len(timecenters)):
                absdiff = abs(times[t]-timecenters[integration])
                if (absdiff < mindiff):
                    mindiff = absdiff
                    whichIntegration = integration
            if (whichIntegration not in pointsPerIntegration.keys()):
                pointsPerIntegration[whichIntegration] = {}
                pointsPerIntegration[whichIntegration]['x'] = []
                pointsPerIntegration[whichIntegration]['y'] = []
            pointsPerIntegration[whichIntegration]['x'].append(x[t])
            pointsPerIntegration[whichIntegration]['y'].append(y[t])
        xnew = []
        ynew = []
        times = timecenters
        for key in pointsPerIntegration.keys():
            xnew.append(np.median(pointsPerIntegration[key]['x']))
            ynew.append(np.median(pointsPerIntegration[key]['y']))
        x = np.array(xnew[:])
        y = np.array(ynew[:])
    
    # Keep a copy of the original values in radians
    xrad = x[:]
    yrad = y[:]

    # make sure RA/azimuth is in positive units
    if (np.median(x) < 0):
        if (debug):
            print "Adding 2*pi to the horizontal axis"
        x += 2*np.pi
    if (field==None):
        rightAscension = np.median(x)
        declination = np.median(y)
        if (debug):
            print "Median coordinates = ", rightAscension, declination
    else:
        rightAscension, declination = getRADecForField(vis, field, forcePositiveRA=True)
        if (debug):
            print "field coordinates in radians = %f, %f = %s" % (rightAscension, declination,
                                                                  rad2radec(rightAscension, declination))
        if (coordSys.find('AZEL') >= 0 and convert==False):
            rightAscension, declination = computeAzElFromRADecMJD([rightAscension,declination],
                                                                  mjd=np.median(times)/86400.,verbose=False)
            if (debug):
                print "field coordinates in az/el = ", rightAscension, declination

    apparentCoordinates = False
    offSourceTimes = getOffSourceTimes(vis)
    if (len(offSourceTimes) < 1):
        print "No off source intent found in the MS."

    offSourceRA = []
    offSourceDec = []
    calAtmRA = []
    calAtmDec = []
    if (coordSys.find('AZEL') >= 0 and convert):
        coordSys = 'J2000'
        print "Converting %d coordinates from AZELGEO to J2000..." % (len(x))
        my_metool = createCasaTool(metool)
        for i in range(len(x)):
            if ((i+1) % 10000 == 0): print "%d/%d" % (i+1,len(x))
            ra,dec = computeRADecFromAzElMJD([xrad[i],yrad[i]], mjd=times[i]/86400.,
                                             verbose=False,my_metool=my_metool,
                                             refractionCorrection=refractionCorrection,
                                             nutationCorrection=nutationCorrection)
            x[i] = ra
            y[i] = dec
            if (times[i] in offSourceTimes):
                offSourceRA.append(ra)
                offSourceDec.append(dec)
        if (len(offSourceRA) > 0):
            xOffSource = np.median(offSourceRA)
            yOffSource = np.median(offSourceDec)
            print "     Field source position = %s" % (rad2radec(rightAscension, declination,verbose=False))
            print "Median off source position = %s" % (rad2radec(xOffSource, yOffSource, verbose=False))
        elif (len(offSourceTimes) > 0):
            print "No times in the POINTING table match the times of off source integrations."


        medianRA = np.median(x)
        medianDec = np.median(y)
        separation = []
        for i in range(len(x)):
            separation.append(angularSeparationRadians(medianRA,medianDec,x[i],y[i]))
        madSeparation = MAD(separation)
        if (debug):
            print "MAD of the separation of points from median (%s) = %f arcsec" % (rad2radec(medianRA,medianDec),madSeparation*180*3600/np.pi)

        if (firstCalAtmScan != -1):
            print "Converting %d coordinates (for AtmCal scan %d) from AZELGEO to J2000..." % (len(xCalAtm),firstCalAtmScan)
            for i in range(len(xCalAtm)):
                if ((i+1) % 10000 == 0): print "%d/%d" % (i+1,len(x))
                ra,dec = computeRADecFromAzElMJD([xCalAtm[i],yCalAtm[i]], mjd=timesCalAtmPointing[i]/86400.,
                                                 verbose=False,my_metool=my_metool,
                                                 refractionCorrection=refractionCorrection,
                                                 nutationCorrection=nutationCorrection)
                calAtmRA.append(ra)
                calAtmDec.append(dec)
            if (len(calAtmRA) > 0):
                xCalAtm = np.median(calAtmRA)
                yCalAtm = np.median(calAtmDec)
                print "Median atm calib. position = %s" % (rad2radec(xCalAtm, yCalAtm, verbose=False))
                xCalAtm = np.mean(calAtmRA)
                yCalAtm = np.mean(calAtmDec)
                print "  Mean atm calib. position = %s" % (rad2radec(xCalAtm, yCalAtm, verbose=False))
            elif (len(calAtmTimes) > 0):
                print "No times in the POINTING table match the times of AtmCal integrations."
            else:
                print "There are no times found on AtmCal scans."
            if (findSubscans):
                calAtmSkyRA = []
                calAtmSkyDec = []
                for i in range(len(xCalAtmSky)):
                    if ((i+1) % 10000 == 0): print "%d/%d" % (i+1,len(x))
                    ra,dec = computeRADecFromAzElMJD([xCalAtmSky[i],yCalAtmSky[i]], mjd=timesCalAtmSkyPointing[i]/86400.,
                                                     verbose=False,my_metool=my_metool,
                                                     refractionCorrection=refractionCorrection,
                                                     nutationCorrection=nutationCorrection)
                    calAtmSkyRA.append(ra)
                    calAtmSkyDec.append(dec)
                if (len(calAtmSkyRA) > 0):
                    xCalAtmSky = np.median(calAtmSkyRA)
                    yCalAtmSky = np.median(calAtmSkyDec)
                    print "Median atmcal sky position = %s" % (rad2radec(xCalAtmSky, yCalAtmSky, verbose=False))
                    xCalAtmSky = np.mean(calAtmSkyRA)
                    yCalAtmSky = np.mean(calAtmSkyDec)
                    print "  Mean atmcal sky position = %s" % (rad2radec(xCalAtmSky, yCalAtmSky, verbose=False))
                


#        offSources = []
#        threshold = 65
#        thresholdMinimum = 5
#        thresholdIncrement = 10
#        while (len(offSources) < 1 and threshold >= thresholdMinimum):
#            if (debug):
#                print "Searching for off-source field with threshold of %d sigma" % (threshold)
#            for i in range(len(x)):
#                if (separation[i] > threshold*madSeparation):
#                    offSources.append(i)
#            threshold -= thresholdIncrement
#        xOffSource = np.median(np.array(x)[offSources])
#        yOffSource = np.median(np.array(y)[offSources])
#        if (xOffSource == xOffSource and yOffSource == yOffSource):
#            print "median off source position = %s" % (rad2radec(xOffSource,yOffSource,verbose=False))
#        else:
#            if (xOffSource != xOffSource): print "xOffSource = NaN"
#            if (yOffSource != yOffSource): print "xOffSource = NaN"
            
        my_metool.done()
        if (field == None):
            rightAscension = np.median(x)
            declination = np.median(y)
        else:
            if (useApparentPositionForPlanets==False and fieldName.upper() in majorPlanets):
                try:
                    rightAscension, declination = planet(fieldName,mjd=times[0]/86400.)['directionRadians']
                    if (firstCalAtmScan != -1):
                        rightAscensionCalAtm, declinationCalAtm = planet(fieldName,mjd=firstCalAtmScanMeanMJD)['directionRadians']
                except:
                    if (casadef.casa_version >= '4.0.0'):
                        print "Failed to contact JPL, reverting to using CASA ephemerides to get the J2000 position."
                        rightAscension, declination = planet(fieldName,mjd=times[0]/86400.,useJPL=False)['directionRadians']
                        if (firstCalAtmScan != -1):
                            rightAscensionCalAtm, declinationCalAtm = planet(fieldName,mjd=firstCalAtmScanMeanMJD, useJPL=False)['directionRadians']
                    else:
                        print "Failed to contact JPL, reverting to showing apparent position (from the ms)."
                        rightAscension, declination = getRADecForField(vis, field, forcePositiveRA=True)
                        apparentCoordinates = True
                        if (firstCalAtmScan != -1):
                            rightAscensionCalAtm, declinationCalAtm = getRADecForField(vis, calAtmField, forcePositiveRA=True)
            else:
                rightAscension, declination = getRADecForField(vis, field, forcePositiveRA=True)
                apparentCoordinates = True
                if (firstCalAtmScan != -1):
                    rightAscensionCalAtm, declinationCalAtm = getRADecForField(vis, calAtmField, forcePositiveRA=True)
        if (len(offSourceRA) > 0):
            separation, deltaRaRadians, deltaDecRadians, ignore = angularSeparationRadians(xOffSource, yOffSource,
                                                                                       rightAscension, declination,
                                                                                       returnComponents=True)
            print "Separation from the off source position in relative coordinates = %+.1f, %+.1f arcsec" % (deltaRaRadians*3600*180/np.pi,
                                                                        deltaDecRadians*3600*180/np.pi)
        if (len(calAtmRA) > 0):
            separation, deltaRaRadians, deltaDecRadians, ignore = angularSeparationRadians(xCalAtm, yCalAtm,
                                                                                       rightAscensionCalAtm, declinationCalAtm,
                                                                                       returnComponents=True)
            print "Separation from mean atm calib position in relative coordinates = %+.1f, %+.1f arcsec" % (deltaRaRadians*3600*180/np.pi,
                                                                        deltaDecRadians*3600*180/np.pi)
            if (findSubscans):
                separation, deltaRaRadians, deltaDecRadians, ignore = angularSeparationRadians(xCalAtmSky, yCalAtmSky,
                                                                                       rightAscensionCalAtm, declinationCalAtm,
                                                                                       returnComponents=True)
                print "Separation from mean atmcal sky position in relative coordinates = %+.1f, %+.1f arcsec" % (deltaRaRadians*3600*180/np.pi,
                                                                        deltaDecRadians*3600*180/np.pi)
                
            
    # convert absolute coordinates to relative arcsec on-the-sky
    for i in range(len(x)):
        separation, dx, dy, ignore = angularSeparationRadians(x[i],y[i],rightAscension,declination,True)
        x[i] = dx*180*3600/np.pi
        y[i] = dy*180*3600/np.pi

    # determine largest dimension of the map
    ymaxloc = y.argmax()
    yminloc = y.argmin()
    xmaxloc = x.argmax()
    xminloc = x.argmin()
    locs = [xminloc,xmaxloc,yminloc,ymaxloc]
    distances = []
    for l in range(3): # 0; 1; 2
        for i in range(l+1,4): # 1,2,3;  2,3;  3
            distance = ((x[locs[l]]-x[locs[i]])**2 + (y[locs[l]]-y[locs[i]])**2)**0.5
            distances.append(distance)
    largestDimension = round(np.max(distances))
    
    # determine the scan direction and sampling
    xSuccessiveDifferences = x[1:] - x[:-1]
    ySuccessiveDifferences = y[1:] - y[:-1]
    successiveDifferences = (xSuccessiveDifferences**2 + ySuccessiveDifferences**2)**0.5

    # define x as the axis with most rapidly changing values
    xSampling = np.median(successiveDifferences)

    # correct for the ratio of pointing table data interval (0.048s) to correlator data rate (0.144s)
    xSampling *= medianSamplingIntervalDataTable / medianSamplingIntervalPointingTable

    # Find where the scan reverses direction
    magnification = 0.3
    xReversalPoints = (np.diff(np.sign(np.round(magnification*xSuccessiveDifferences)/magnification)) != 0)*1
    yReversalPoints = (np.diff(np.sign(np.round(magnification*ySuccessiveDifferences)/magnification)) != 0)*1
    reversalPoints = xReversalPoints + yReversalPoints
    indices = np.where(reversalPoints > 0)[0]
    rowChanges = indices[1::2]
    if (debug):
        print "%d xReversalPoints = %s" % (len(np.where(xReversalPoints>0)[0]), str(xReversalPoints))
        print "%d yReversalPoints = %s" % (len(np.where(yReversalPoints>0)[0]), str(yReversalPoints))
        print "Found %d row changes = %s" % (len(rowChanges), str(rowChanges))

    successiveRowDifferences = (xSuccessiveDifferences[rowChanges]**2 + ySuccessiveDifferences[rowChanges]**2)**0.5
    ySampling = np.median(successiveRowDifferences)
    xAtRowChanges = x[rowChanges]
    yAtRowChanges = y[rowChanges]
    if (originalCoordSys.find('AZEL') >= 0):
        ymedian = np.median(yAtRowChanges)
        if (debug):
            print "ymedian = ", ymedian
        keeprows = np.where(abs(yAtRowChanges - ymedian) > 1)[0]
        if (debug):
            print "yAtRowChanges = ", str(yAtRowChanges)
        yAtRowChanges = yAtRowChanges[keeprows]
        xAtRowChanges = xAtRowChanges[keeprows]
        if (debug):
            print "yAtRowChanges = ", str(yAtRowChanges)
        successiveRowDifferences = abs(yAtRowChanges[1:] - yAtRowChanges[:-1])
        ySampling = np.median(successiveRowDifferences)
#        ySampling = np.median(successiveRowDifferences[:len(successiveRowDifferences)/4])

    if (fieldName != None):  # comment this block out for Crystal's temporary usage
        if (fieldName.upper() in majorPlanets):
            if (pickFirstRaster == False):
                print "Setting pickFirstRaster=True"
            pickFirstRaster = True

    if (pickFirstRaster):
        # Recalculate the y Sampling for major planets
        medianYoffset = np.median(y)
        maxYoffset = np.max(y)
        minYoffset = np.min(y)
        yrange = maxYoffset-minYoffset
        idx1 = np.where(y > maxYoffset-0.1*yrange)[0]
        if (debug):
            print "idx1=%s" % (str(idx1))
        idx2 = np.where(y < minYoffset+0.1*yrange)[0]
        if (debug):
            print "idx2=%s" % (str(idx2))
        idx3 = np.where(idx2>idx1[0])[0]
        if (debug):
            print "idx3=%s" % (str(idx3))
            print "idx2[idx3[0]] = ", idx2[idx3[0]]
        myx = x
        myy = y
        mytimes = times
        if (len(idx3) > 0):
            if (len(idx2)>idx3[0]):
                endOfFirstRaster = idx2[idx3[0]]
                myx = x[:endOfFirstRaster]
                myy = y[:endOfFirstRaster]
                mytimes = times[:endOfFirstRaster]
    
        # determine the scan direction and sampling
        xSuccessiveDifferences = myx[1:] - myx[:-1]
        ySuccessiveDifferences = myy[1:] - myy[:-1]
        successiveDifferences = (xSuccessiveDifferences**2 + ySuccessiveDifferences**2)**0.5
    
        # Find where the scan reverses direction
        xReversalPoints = (np.diff(np.sign(np.round(magnification*xSuccessiveDifferences)/magnification)) != 0)*1
        yReversalPoints = (np.diff(np.sign(np.round(magnification*ySuccessiveDifferences)/magnification)) != 0)*1
        reversalPoints = xReversalPoints + yReversalPoints
        indices = np.where(reversalPoints > 0)[0]
        rowChanges = indices[1::2]
        if (debug):
            print "%d xReversalPoints = %s" % (len(np.where(xReversalPoints>0)[0]), str(xReversalPoints))
            print "%d yReversalPoints = %s" % (len(np.where(yReversalPoints>0)[0]), str(yReversalPoints))
            print "Found %d row changes = %s" % (len(rowChanges), str(rowChanges))
    
        successiveRowDifferences = (xSuccessiveDifferences[rowChanges]**2 + ySuccessiveDifferences[rowChanges]**2)**0.5
        ySampling = np.median(successiveRowDifferences)
        myxAtRowChanges = myx[rowChanges]
        myyAtRowChanges = myy[rowChanges]
        if (originalCoordSys.find('AZEL') >= 0):
            ymedian = np.median(myyAtRowChanges)
            if (debug):
                print "ymedian = ", ymedian
            keeprows = np.where(abs(myyAtRowChanges - ymedian) > 1)[0]
            if (debug):
                print "yAtRowChanges = ", str(myyAtRowChanges)
            myyAtRowChanges = np.array(sorted(myyAtRowChanges[keeprows]))  # note the sorted() which is essential
            myxAtRowChanges = myxAtRowChanges[keeprows]
            if (debug):
                print "yAtRowChanges = ", str(myyAtRowChanges)
            successiveRowDifferences = abs(myyAtRowChanges[1:] - myyAtRowChanges[:-1])
            ySampling = np.median(successiveRowDifferences)
    mybeam = primaryBeamArcsec(vis, showEquation=False)
    print "xSampling = %.3f arcsec (%.3f points per beam)" % (xSampling, mybeam/xSampling)
    print "ySampling = %.3f arcsec (%.3f points per beam)" % (ySampling, mybeam/ySampling)

    if (showplot or plotfile!=''):
        if (showplot == False):
            pb.ioff()
        mjdsec = getObservationStart(vis)
        obsdateString = mjdToUT(mjdsec/86400.)
        pb.clf()
        adesc = pb.subplot(211)
        lineStyleUpperPlot = '.'
        if (connectDots):
            lineStyle = '-'
        else:
            lineStyle = '.'
        pb.plot_date(pb.date2num(mjdSecondsListToDateTime(times)),(x**2+y**2)**0.5,
                     'k'+lineStyleUpperPlot,
                     markeredgecolor='k',markerfacecolor='k',markersize=2.0)
        pb.hold(True)
        if (showComponents):
            pb.plot_date(pb.date2num(mjdSecondsListToDateTime(times)),x,'r-')
            pb.plot_date(pb.date2num(mjdSecondsListToDateTime(times)),y,'g-')
        pb.xlabel('Universal Time on %s' % (mjdsecToUT(times[0]).split()[0]))
        pb.ylabel('Angle from origin (arcsec)')
        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M:%S'))
        setXaxisTimeTicks(adesc, np.min(times), np.max(times))
        y0,y1 = pb.ylim()
        for s in timesforscan.keys():
            b = timesforscan[s]['begin']
            pb.plot_date(pb.date2num(mjdSecondsListToDateTime([b,b])), [y0,y1], 'k-')
            e = timesforscan[s]['end']
            pb.plot_date(pb.date2num(mjdSecondsListToDateTime([e,e])), [y0,y1], 'k--')
            pb.text(pb.date2num(mjdSecondsListToDateTime([0.5*(b+e)]))[0], 0.8*(y1-y0)+y0,
                    'Scan '+str(s),size=8,rotation='vertical')
        if (timerange == None or timerange == ''):
            newStartTime = timesforscan[scansToUse[0]]['begin'] - 20
            newEndTime = timesforscan[scansToUse[-1]]['end'] + 20
            newlimits = pb.date2num(mjdSecondsListToDateTime([newStartTime, newEndTime]))
            pb.xlim(newlimits)
            setXaxisTimeTicks(adesc, newStartTime, newEndTime)
        else:
            pb.xlim(pb.date2num(mjdSecondsListToDateTime(timerange)))
            setXaxisTimeTicks(adesc, timerange[0], timerange[1])
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        if (field != None):
            fieldString = "  (0,0)=%s" % (fieldName)
        else:
            fieldString = ""
        pb.title(os.path.basename(vis) + ', ' + antennanames[antenna] + ', ' + obsdateString +  ', OBS_ID=%d,  %s' % (obsid,fieldString), fontsize=10)
        if (debug):
            print "subplot 211 : xlim=%s, ylim=%s" % (str(pb.xlim()),str(pb.ylim()))
        
        adesc = pb.subplot(212)
        pb.plot(x,y,'b.')
        pb.plot(x,y,'b'+lineStyle)
        xlimits = pb.xlim()
        ylimits = pb.ylim()
        pb.hold(True)
        pb.plot(xAtRowChanges, yAtRowChanges, 'r.', x[0], y[0], 'ro')
        pb.xlim(xlimits)
        pb.ylim(ylimits)
        if (plotrange != [0,0,0,0]):
            if (plotrange[0] != 0 or plotrange[1] != 0):
                pb.xlim([plotrange[0],plotrange[1]])
            if (plotrange[2] != 0 or plotrange[3] != 0):
                pb.ylim([plotrange[2],plotrange[3]])
        else:
            pb.xlim([np.max(x), np.min(x)])
            pb.axis('equal')
        for i in range(np.min([labelFirstNSamples, len(x)/labelIncrement])):
            sample = i*labelIncrement
            pb.text(x[sample],y[sample],str(sample),size=8)
        if (coordSys.find('AZEL') >= 0):
            azimString = qa.formxxx('%frad'%(rightAscension), format='deg', prec=5)
            elevString = qa.formxxx('%frad'%(declination), format='deg', prec=5)
            pb.xlabel('Azimuth offset (arcsec) from %s deg' % azimString)
            pb.ylabel('Elevation offset (arcsec) from %s deg' % elevString)
            pb.xlim([np.min(x), np.max(x)])
        else:
            raString = qa.formxxx('%frad'%(rightAscension), format='hms', prec=2)
            decString = qa.formxxx('%frad'%(declination), format='dms', prec=0).replace('.',':',2).replace('-0','-').replace('+0','+')
            if (apparentCoordinates):
                basis = '(apparent)'
            else:
                basis = '(J2000)'
            pb.ylabel('Dec offset (arcsec) from %s' % (decString))
            if (convert):
                pb.xlabel('Right Ascension offset (arcsec) from %s %s' % (raString,basis))
        adesc.xaxis.grid(True,which='major')
        adesc.yaxis.grid(True,which='major')
        pb.plot([0.025], [0.96], 'ro', transform=adesc.transAxes)
        pb.plot([0.025], [0.91], 'r.', transform=adesc.transAxes)
        pb.text(0.05, 0.93, 'start point', transform=adesc.transAxes)
        pb.text(0.05, 0.86, 'end stroke', transform=adesc.transAxes)
        if (debug):
            print "subplot 212 : xlim=%s, ylim=%s" % (str(pb.xlim()),str(pb.ylim()))
        if (showplot):
            pb.draw()
        if (plotfile != ''):
            if (plotfile == True):
                plotfile = vis+'.obsid%d.sampling.png' % (obsid)
            if (os.path.exists(plotfile)):
                if (os.access(plotfile, os.W_OK) == False):
                    plotfile = '/tmp/' + os.path.basename(plotfile)
            else:
                mydir = os.path.dirname(plotfile)
                if (mydir == ''):
                    mydir = os.getcwd()
                if (os.access(mydir, os.W_OK) == False):
                    plotfile = '/tmp/' + os.path.basename(plotfile)
            pb.savefig(plotfile)
            print "Saved plot in %s" % (plotfile)
        if (showplot == False):
            pb.ion()
    else:
        print "To show a plot, re-run with parameter showplot=True"
    if (convert==False and coordSys.find('AZEL')>=0):
        print "To determine the reference position, re-run with convert=True"
    return xSampling, ySampling, largestDimension
    # end of getTPSampling
    
def imshift(img, rashift, decshift, copyimage=True):
    """
    Uses imhead to shift a CASA image in RA/Dec.
    rashift: value in arcsec to subtract from CRPIX1
    decshift: value in arcsec to subtract from CRPIX2
    copyimage: if True, then first copy the image to *.imshift
    -Todd Hunter
    """
    if (not os.path.exists(img)):
        print "Could not find image: %s" % (img)
        return
    if (not os.path.isdir(img)):
        print "This is not a CASA image."
        return
    if (copyimage):
        os.system('cp -r %s %s.imshift'%(img,img))
        img = img+'.imshift'
        print "Copied image to ", img
    cdelt1 = headerToArcsec(imhead(img, mode='get', hdkey='CDELT1'))
    cdelt2 = headerToArcsec(imhead(img, mode='get', hdkey='CDELT2'))
    rapix = rashift/cdelt1
    decpix = decshift/cdelt2
    crpix1 = imhead(img, mode='get', hdkey='CRPIX1')
    crpix2 = imhead(img, mode='get', hdkey='CRPIX2')
    print "Shifting RA  by %+f arcsec = %+f pixels" % (rashift,rapix)
    imhead(img, mode='put', hdkey='CRPIX1', hdvalue=crpix1-rapix)
    print "Shifting Dec by %+f arcsec = %+f pixels" % (decshift,decpix)
    imhead(img, mode='put', hdkey='CRPIX2', hdvalue=crpix2-decpix)

def readNonStandardHeader(image):
    """
    If restfreq is missing, then imhead(mode='list') will bomb (CAS-5901).
    This workaround function reads the other major items individually 
    and builds a dictionary for getFitsBeam.
    -Todd Hunter
    """
    a = {}
    a['beammajor'] = imhead(image,mode='get',hdkey='beammajor')
    if (type(a['beammajor']) == type(None)):
        a['beammajor'] = 0
        a['beamminor'] = 0
        a['beampa'] = 0
    else:
        a['beamminor'] = imhead(image,mode='get',hdkey='beamminor')
        a['beampa'] = imhead(image,mode='get',hdkey='beampa')
    a['shape'] = imhead(image,mode='get',hdkey='shape')
    for key in ['cdelt','cunit','crpix','ctype']:
        for i in range(len(a['shape'])):
            keyn = key+str(i+1)
            a[keyn] = imhead(image,mode='get',hdkey=keyn)
            if (type(a[keyn]) == dict):
                arcsec = a[keyn]['value']
                if (a[keyn]['unit'].find('min') >= 0):
                    arcsec *= 60
                if (a[keyn]['unit'].find('deg') >= 0):
                    arcsec *= 3600
                if (a[keyn]['unit'].find('rad') >= 0):
                    arcsec *= 180*3600/np.pi
                a[keyn] = arcsec
    return(a)
    
def getFitsDate(image):
    """
    Extracts and prints the date information from a FITS image.
    Todd Hunter
    """
    if (os.path.exists(image) == False):
        print "image not found"
        return
    if (pyfitsPresent == False):
        print "pyfits is not present"
        return
    if (os.path.isdir(image)):
        # Assume this is a CASA image
        a = imhead(image,mode = 'list')
        if (a == None):
            if (os.access(".",os.W_OK) == False):
                print "Change to a directory where you have write permission and try again."
                print "e.g. au.getFitsDate('%s/%s')" % (os.getcwd(),image)
                return
            else:
                try:
                    restfreq = imhead(image,mode='get',hdkey='restfreq')
                    if (restfreq['value'] <= 0.0):
                        a = readNonStandardHeader(image)
                        print "Reading non-standard header: ", a
                    else:
                        print "restfreq = ", restfreq
                except:
                    print "imhead returned NoneType."
                    print "This image header is not sufficiently standard."
                    return
        foundDate = 0
        for datekey in a.keys():
            if (datekey.lower().find('date') >= 0):
                foundDate += 1
                print "%s = %s" % (datekey, a[datekey])
        if (foundDate == 0): print "No date keys found in the header."
    else:
        f = pyfits.open(image)
        hdr = f[0].header
        bmaj = -1
        try:
            keys = hdr.ascardlist().keys()
        except:
            keys = hdr.keys()
        for datekey in ['DATE-OBS', 'DATE_OBS', 'DATE-END', 'DATE_END']:
            if (datekey in keys):
                print "%s = %s" % (datekey, hdr[datekey])
        f.close()

def kelvinPerJansky(img):
    """
    Compute the Kelvin per Jansky conversion factor of a FITS or CASA 
    interferometric image using the beam size and frequency.
    -Todd Hunter
    """
    bmaj,bmin,bpa,cdelt1,cdelt2,naxis1,naxis2,imgfreq = getFitsBeam(img)
    # imgfreq is in GHz, bmaj and bmin are in arcsec
    bdict = brightness(1, imgfreq, bmaj, bmin)
    print bdict
    return(bdict['temperature'])

def getFitsBeam(image):
    """
    Extract the beam information from a FITS image, or a CASA image.
    Returns: bmaj, bmin, bpa, cdelt1, cdelt2, naxis1, naxis2, frequency
             angles are in arcseconds (bpa in degrees)
             frequency is in GHz and is the central frequency
    -Todd Hunter
    """
    if (os.path.exists(image) == False):
        print "image not found"
        return
    if (os.path.isdir(image)):
        # Assume this is a CASA image
        a = imhead(image,mode = 'list')
        if (a == None):
            if (os.access(".",os.W_OK) == False):
                print "Change to a directory where you have write permission and try again."
                print "e.g. au.getFitsBeam('%s/%s')" % (os.getcwd(),image)
                return
            else:
                try:
                    restfreq = imhead(image,mode='get',hdkey='restfreq')
                    if (restfreq['value'] <= 0.0):
                        a = readNonStandardHeader(image)
                        print "Reading non-standard header: ", a
                    else:
                        print "restfreq = ", restfreq
                except:
                    print "imhead returned NoneType."
                    print "This image header is not sufficiently standard."
                    return
        if ('beammajor' in a.keys()):
            bmaj = a['beammajor']
            bmin = a['beamminor']
            bpa = a['beampa']
        elif ('perplanebeams' in a.keys()):
            beammajor = []
            beamminor = []
            beampa = []
            for beamchan in range(a['perplanebeams']['nChannels']):
                beamdict = a['perplanebeams']['*'+str(beamchan)]
                beammajor.append(beamdict['major']['value'])
                beamminor.append(beamdict['minor']['value'])
                beampa.append(beamdict['positionangle']['value'])
            bmaj = np.median(beammajor)
            bmin = np.median(beamminor)
            sinbpa = np.sin(np.radians(np.array(beampa)))
            cosbpa = np.cos(np.radians(np.array(beampa)))
            bpa = degrees(np.median(np.arctan2(np.median(sinbpa), np.median(cosbpa))))
        else:
            bmaj = 0
            bmin = 0
            bpa = 0
        naxis1 = a['shape'][0]
        naxis2 = a['shape'][1]
        cdelt1 = a['cdelt1']
        cdelt2 = a['cdelt2']
        if (a['cunit1'].find('rad') >= 0):
            # convert from rad to arcsec
            cdelt1 *= 3600*180/np.pi
        elif (a['cunit1'].find('deg') >= 0):
            # convert from deg to arcsec
            cdelt1 *= 3600
        if (a['cunit2'].find('rad') >= 0):
            cdelt2 *= 3600*180/np.pi
            # convert from rad to arcsec
        elif (a['cunit2'].find('deg') >= 0):
            # convert from deg to arcsec
            cdelt2 *= 3600
        if (type(bmaj) == dict):
            # casa >= 4.1.0  (previously these were floats)
            bmaj = headerToArcsec(bmaj)
            bmin = headerToArcsec(bmin)
            bpa = headerToArcsec(bpa)/3600.
        ghz = 0
        if ('ctype4' in a.keys()):
            if (a['ctype4'] == 'Frequency'):
                imgfreq = a['crval4']
                cdelt = a['cdelt4']
                crpix = a['crpix4']
                npix = a['shape'][3]
                imgfreq += cdelt*(npix/2.)
                ghz = imgfreq*1e-9
        if (ghz == 0):
            if ('ctype3' in a.keys()):
                if (a['ctype3'] == 'Frequency'):
                    imgfreq = a['crval3']
                    cdelt = a['cdelt3']
                    crpix = a['crpix3']
                    npix = a['shape'][2]
                    imgfreq += cdelt*(npix/2.)
                    ghz = imgfreq*1e-9
        return([bmaj,bmin,bpa,cdelt1,cdelt2,naxis1,naxis2,ghz])
    # This is a FITS image.
    if (pyfitsPresent == False):
        print "pyfits is not present"
        return
    f = pyfits.open(image)
    imghdr = 0
    for hdctr in range(len(f)): # support Herschel images (where the image is an extension)
        hdr = f[hdctr].header
        bmaj = -1
        if ('BMAJ' not in hdr.keys()):
            if ('HISTORY' not in hdr.keys()):
                if (hdctr == len(f)-1):
                    print "Did not find BMAJ in header, and there are no HISTORY keys."
                    hdr = f[imghdr].header
                    bmin = 0
                    bmaj = 0
                    bpa = 0
                    break
                else:
                    if 'CDELT1' in hdr.keys():
                        # Take note of the image header, when you encounter it
                        imghdr = hdctr
                    continue
            try:
                keys = hdr.ascardlist().keys()
            except:
                keys = hdr.keys()
            for key in range(len(keys)):
                if ('HISTORY' == keys[key]):
                    try:
                        value = hdr.ascardlist().values()[key]
                    except:
                        value = hdr.values()[key]
                    if (value.find('BMAJ') >= 0):
                        # Assume all are in one record.  If not, be careful of
                        # BPA being confused with BPASS.
                        tokens = value.split()
                        for t in range(len(tokens)):
                            if (tokens[t].find('BMAJ') == 0):
                                bmaj = float(tokens[t+1])*3600
                                break
                        for t in range(len(tokens)):
                            if (tokens[t].find('BMIN') == 0):
                                bmin = float(tokens[t+1])*3600
                                break
                        for t in range(len(tokens)):
                            if (tokens[t].find('BPA') == 0):
                                bpa = float(tokens[t+1].split('/')[0])
                                break
            if (bmaj < 0):
                print "Did not find BMAJ in header, nor in the HISTORY keys."
                return
        else:            
            bmaj = hdr['BMAJ']*3600
            bmin = hdr['BMIN']*3600
            bpa = hdr['BPA']
        print "%g'' x %g'' at %+g deg" % (bmaj, bmin, bpa)
    naxis1 = hdr['NAXIS1']
    naxis2 = hdr['NAXIS2']
    cdelt1 = hdr['CDELT1']*3600
    cdelt2 = hdr['CDELT2']*3600
    ctype1 = hdr['CTYPE1'].split('-')[0]
    ctype2 = hdr['CTYPE2'].split('-')[0]
    print "Pixel size = %f by %f (%s by %s)" % (cdelt1,cdelt2,ctype1,ctype2)
    imgfreq = 0
    if ('CTYPE3' in hdr.keys()):
        ctype3 = hdr['CTYPE3']
        if (ctype3.find('FREQ')>=0):
            crval3 = hdr['CRVAL3']
            crpix3 = hdr['CRPIX3']
            cdelt3 = hdr['CDELT3']
            npix3 = hdr['NAXIS3']
            print "CRVAL3 = %g Hz at CRPIX = %g" % (crval3,crpix3)
            imgfreq = crval3 + cdelt3*(npix3/2.)
            print "central freq = %g Hz" % (imgfreq)
            imgfreq *= 1e-9
    if ('RESTFREQ' in hdr.keys()):
        print "RESTFREQ = %g Hz" % (hdr['RESTFREQ'])
        if (imgfreq == 0): imgfreq = hdr['RESTFREQ']
    return(bmaj, bmin, bpa, cdelt1, cdelt2, naxis1, naxis2, imgfreq)
                                                                
def gjincBeam(frequency, pixelsize=10, diameter=12.0, xSamplesPerBeam=5.0,
              ySamplesPerBeam=None, xSamplingArcsec=None, ySamplingArcsec=None,
              makeplot=False, taper=10, geometricMean=False, obscuration=0.75,
              widthMultiplier=1.0, useCasaJinc=False, testOption=False, 
              minlevels=[0], truncate=False, img=None, row=None, column=None, 
              stokes='XX',plotfile='',verbose=False, fwhmfactor=None,
              excludeBand3=True,excludeBand3Below=109.0):
    """
    This function calls the griddedBeam class to compute the effective restoring
    beam obtained from the casa command sd_imaging when using the GJINC
    gridding kernel assuming the GJINC specific parameters are left at
    their default values.
        
    frequency: floating point number in GHz (no units) or a string with units
    pixelsize: floating point number in arcseconds (no units)
    diameter: the diameter of the single dish antenna in meters (no units)
    xSamplesPerBeam: the number of sampled points per telescope FWHM beam
                     along the X axis
    ySamplesPerBeam: the number of sampled points per telescope FWHM beam
                     along the Y axis
    xSamplingArcsec: if not None, then use this value instead of xSamplesPerBeam
    ySamplingArcsec: if not None, then use this value instead of ySamplesPerBeam
    taper: the illumination taper in dB to pass to au.primaryBeamArcsec
               if zero, then it uses an Airy function as the antenna beam,
               otherwise it uses a Gaussian
    fwhmfactor: if specified, pass this to primaryBeamArcsec, overriding taper
    obscuration: diameter in m to pass to au.primaryBeamArcsec
    geometricMean: if True, return only the mean beamsize and mean
             Gaussian-fitted beamsize; otherwise, return:
             minorAxis,majorAxis,geometricMean,geometricMeanFit (if the
             sampling is provided in both axes)
    widthMultiplier: the value by which to multiply the default values of
                     gwidth/jwidth
    minlevels: a list of values above which to perform 1D Gaussian fits
    truncate: if taper=0, sets whether to truncate the Airy at the first null
        if taper>0, sets the intensity level at which to truncate the Gaussian
    img: if != None, then use a row or column from this image as the beam model
         if 'ticraDA', 'ticraDV' or 'ticraPM' is specified, it will automatically use 
         the TICRA models distributed with au
    row: the row of img to use as the starting beam profile model
    column: the column of img to use as the starting beam profile model
    stokes: 'XX','YY' which Stokes to use in the img
    excludeBand3: if True, do not allow the Band 3 models to be chosen below
                  the frequency specified in excludeBand3Below
    excludeBand3Below: frequency in GHz below which to not use Band 3 patterns

    Returns:
       If only the X-axis sampling is given:
          the FWHM of the restoring beam
          the FWHM of a Gaussian fit to the restoring beam
       If both X and Y-axis sampling is given:
        If geometricMean=True:
          the FWHM of the restoring beam
          the FWHM of a Gaussian fit to the restoring beam
        If geometricMean=False:
          the minor axis of the restoring beam
          the major axis of the restoring beam
          the geometric mean of the restoring beam computed using findFWHM()
          the geometric mean of the FWHM of a Gaussian fit to the restoring beam
    - Todd Hunter
    """
    if (pyfits.__version__ < '2.1.1'):
        print "Your pyfits version (%s) is old."
        print "Check that your PYTHONPATH is not overriding the version of pyfits distributed with casa."
        return
    if (fwhmfactor != None):
        if (fwhmfactor < 1.02 or fwhmfactor > 1.22):
            print "Invalid fwhmfactor (1.02<fwhmfactor<1.22)"
            return
    if (img != None):
        if (img.lower().find('ticra') == 0):
            ticraDir = os.getenv("CASAPATH").split()[0]+"/data/alma/responses/"
            ticraImage = ticraDir + "ALMA_0_DA__0_0_360_0_45_90_602_602_631.5_GHz_ticra2007_EFP.im.square.normalized"
            if (not os.path.exists(ticraImage)):
                ticraDir = os.path.dirname(__file__) + '/TicraImages/'
                if (os.path.exists(ticraDir) == False):
                    print "The Ticra model images (squared) are not present in the analysisUtils area nor CASA."
                    return
            img = pickTicraImage(frequency,img,ticraDir,excludeBand3,
                                 excludeBand3Below)
            if (img == None): return
            if (verbose):
                print "Using TICRA image: %s" % (os.path.basename(img))
        if (os.path.exists(img) == False):
            print "Could not find image = ", img
            return
    if (plotfile != ''): makeplot = True
    if (ySamplesPerBeam == None and ySamplingArcsec == None):
        return(griddedBeam().gjincBeamOneAxis(frequency, pixelsize, diameter,
                                      xSamplesPerBeam, xSamplingArcsec,
                                      makeplot, taper, obscuration=obscuration,
                                      widthMultiplier=widthMultiplier,
                                      useCasaJinc=useCasaJinc,
                                      testOption=testOption,minlevels=minlevels,
                                      truncate=truncate, img=img, row=row,
                                      column=column, stokes=stokes,
                                      plotfile=plotfile,fwhmfactor=fwhmfactor))
    else:
        return(griddedBeam().gjincBeamTwoAxes(frequency, pixelsize, diameter,
                                        xSamplesPerBeam, ySamplesPerBeam,
                                        xSamplingArcsec, ySamplingArcsec,
                                        makeplot, taper, geometricMean,
                                        obscuration=obscuration,
                                        widthMultiplier=widthMultiplier,
                                        useCasaJinc=useCasaJinc,
                                        testOption=testOption,
                                        minlevels=minlevels, truncate=truncate,
                                        img=img, row=row, column=column,
                                        stokes=stokes,plotfile=plotfile,
                                        fwhmfactor=fwhmfactor))

def sfBeamRatio(frequency, pixelsizeMax=10, diameter=12.0, xSamplesPerBeam=None,
                ySamplesPerBeam=None, xSamplingArcsecMax=None, 
                convsupport=-1,makeplot=False,m=0,taper=10,geometricMean=False,
                obscuration=0.75, cmult=1.0,coffset=0.0,xmult=1.0,alpha=1.0,
                testOption=False, minlevels=[0], truncate=False, img=None,
                row=None, column=None, stokes='both', datafile='sfBeamRatio'):
    """
    Computes the ratio of predicted beam sizes for a grid of pixel sizes and 
    sampling sizes.
    """
    f = open(datafile+'.'+stokes+'.txt','w')
    for pixelsize in np.linspace(2,pixelsizeMax,1+(pixelsizeMax-2)/2):
        for xSamplingArcsec in np.linspace(2,xSamplingArcsecMax,1+(xSamplingArcsecMax-2)/2):
            result = sfBeam(frequency,pixelsize,diameter,xSamplesPerBeam,ySamplesPerBeam,
                            xSamplingArcsec,xSamplingArcsec,convsupport,
                            makeplot,m,taper,geometricMean,obscuration,cmult,coffset,xmult,alpha,
                            testOption,minlevels,truncate,None,row,column,stokes)
            resultImg = sfBeam(frequency,pixelsize,diameter,xSamplesPerBeam,ySamplesPerBeam,
                               xSamplingArcsec,xSamplingArcsec,convsupport,
                               makeplot,m,taper,geometricMean,obscuration,cmult,coffset,xmult,alpha,
                               testOption,minlevels,truncate,img,row,column,stokes)
            f.write('%d %d %f %f\n' % (pixelsize,xSamplingArcsec,result[1]/resultImg[1], result[3]/resultImg[3]))
            f.flush()
    f.close()
    print "Results left in %s" % (datafile)

def pickPixelSize(frequency, convsupport=5, sfratio=0.5):
    """
    Returns the best pixel size to use with the specified convsupport parameter
    for the SF option of sdimaging.
    frequency: string with units, or a floating point number in GHz
    sfratio: the desired ratio between the FWHM of the SF and the telescope beam
    - Todd Hunter
    """
    # Freq convsupport  pixelsize  SF FWHM  SF FWZI
    # 100    3          10        22.29       60
    # 100    4          10        29.72       80
    # 100    4           5        14.86       40
    # pixelsize = (best SF FWHM) * 1.34589 / convsupport
    # pixelsize = (beam * sfratio) * 1.34589 / convsupport
    beam = primaryBeamArcsec(frequency=frequency, showEquation=False)
    pixelsize = beam * sfratio * 1.34589/float(convsupport)
    return(pixelsize)

def antennaEfficiency(frequency, surfaceRms, R0=0.72):
    """
    frequency: GHz or Hz, or string with units
    surfaceRms: in microns
    R0: initial efficiency factor (other than Ruze)
        default value is for ALMA based on technical handbook p. 114
    returns: telescope efficiency (from 0..1)
    -Todd Hunter
    """
    frequency = parseFrequencyArgumentToHz(frequency)
    efficiency= R0*np.exp(-16*(np.pi**2)*(surfaceRms*1e-4)**2*(frequency/c)**2)
    return(efficiency)

def janskyPerKelvin(frequency, beamsize=None, diameter=12, obscuration=0.75,
                    surfaceRms=25):
    """
    Computes the theoretical Jy/K for an ALMA single dish image based on its
    measured beamsize.
    frequency: GHz
    beamsize: arcsec, if not specified, then the theoretical beam will be used
    diameter: m
    obscuration: m
    surfaceRms: micron
    """
    frequency = parseFrequencyArgumentToHz(frequency)
    efficiency = antennaEfficiency(frequency, surfaceRms)
    print "efficiency = ", efficiency
    area = np.pi*(diameter*50)**2*efficiency
#    print "effective area = ", area
    jyPerK = (2*k/area) * 1e23
#    print "Jy/K of raw antenna beam = ", jyPerK
    if (beamsize != None):
        jyPerK *= (beamsize/primaryBeamArcsec(frequency=frequency,diameter=diameter,obscuration=obscuration,showEquation=False))**2
    return(jyPerK)
    
def sfBeamWeightVariation(frequency=None, pixelsize=None, diameter=12.0, samplesPerBeam=5.0,
           samplingArcsec=None, convsupport=-1, m=0, taper=10, 
           obscuration=0.75, cmult=1.0, coffset=0.0,xmult=1.0,alpha=1.0,testOption=False,
           minlevels=[0], truncate=False, img=None, row=None, column=None, stokes='XX',
           plotfile='', tpdata=None, spw=None, pixelsPerBeam=None):
    """
    Makes a plot of the gridded beamsize and weight variation vs. the pixelsize chosen
    for the image to be created by sdimaging with the SF gridding function.
    pixelsize: None -> default = 0.5 to 15 by 0.5 arcsec
    tpdata: if not None, then run getTPSampling on this dataset to find samplingArcsec
            (the maximum value of the two axes)
    taper: the illumination taper in dB to pass to au.primaryBeamArcsec
               if zero, then it uses an Airy function as the antenna beam,
               otherwise it uses a Gaussian
    truncate: if taper=0, sets whether to truncate the Airy at first null
              if taper > 0, and not False, sets intensity level to truncate Gaussian
    img: if not none, then use a row or column from this image as the beam model
    row: the row of img to use as the starting beam profile model
    column: the column of img to use as the starting beam profile model
    stokes: 'XX','YY' which Stokes to use in the img
    pixelsPerBeam: default=None --> np.arange(3.8,13.21,0.2)
    -Todd Hunter
    """
    if (type(frequency) == str):
        frequency = parseFrequencyArgument(frequency) * 1e-9
    makeplot = False
    if (frequency == None and (tpdata == None or spw == None)):
        print "You must specify either frequency or (tpdata and spw)"
        return
    if (tpdata != None):
        if (os.path.exists(tpdata) == False):
            print "Dataset not found: %s" % (tpdata)
            return
        xSampling, ySampling, maxsize = getTPSampling(tpdata)
        samplingArcsec = max(xSampling,ySampling)
        if (frequency == None):
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(tpdata)
            frequency = mymsmd.meanfreq(int(spw))*1e-9
            mymsmd.close()
    beamfwhm = primaryBeamArcsec(frequency=frequency, showEquation=False)
    if (samplingArcsec == None):
        samplingArcsec = beamfwhm / float(samplesPerBeam)
    if (pixelsize==None):
        if (pixelsPerBeam == None):
            pixelsPerBeam = np.arange(3.8,13.21,0.2)
        pixelsize = beamfwhm/pixelsPerBeam
    pixelsPerBeam = beamfwhm / pixelsize
    if (convsupport == -1):
        convsupports = [3,4,5,6]
    elif (type(convsupport) == list):
        convsupports = convsupport
    else:
        convsupports = [convsupport]
    pb.clf()
    col = ['k','b','r','g']
    for convsupport in convsupports:
        ratios = []
        fwhms = []
        for p in pixelsize:
            ratio, fwhm = sfWeightVariation(frequency, p, diameter, samplesPerBeam,
                                            samplingArcsec, convsupport, makeplot, m, taper, 
                                            obscuration, cmult, coffset,xmult,alpha,testOption,
                                            minlevels, truncate, img, row, column, stokes)
            ratios.append(ratio)
            fwhms.append(fwhm)
        pb.subplot(211)
        ratios = np.array(ratios)*100
        pb.plot(pixelsPerBeam,ratios,'k-',color=col[convsupport-3])
        pb.subplot(212)
        pb.plot(pixelsPerBeam,fwhms,'k-',color=col[convsupport-3])
    desc = pb.subplot(211)
    pb.ylim([-3,30])
    pb.xlim([np.min(pixelsPerBeam), np.max(pixelsPerBeam)])
    pb.ylabel('Weight variation (%)')
    pb.title('%g GHz, beam=%.2f", sampling=%.2f", convsupport =     ' % (frequency, beamfwhm, samplingArcsec),size=12)
    if (tpdata != None):
        if (spw == None):
            pb.text(0.1,1.10,'%s' % (os.path.basename(tpdata)),transform=desc.transAxes)
        else:
            pb.text(0.1,1.10,'%s, spw=%d' % (os.path.basename(tpdata),spw),transform=desc.transAxes)
    majorLocator = MultipleLocator(1)
    desc.xaxis.set_major_locator(majorLocator)
    for convsupport in convsupports:
        pb.text(0.90+0.03*(convsupport-3), 1.03, str(convsupport), color=col[convsupport-3], transform=desc.transAxes, size=12)
    desc = pb.subplot(212)
    beamgrowths = [1.1, 1.2, 1.3]
    for beamgrowth in beamgrowths:
        pb.text(np.mean([np.mean(pb.xlim()),np.max(pb.xlim())]), (beamgrowth+0.01)*beamfwhm, '%.1f * beam' % (beamgrowth))
        pb.plot(pb.xlim(), [beamgrowth*beamfwhm]*2,'k--')
    pb.ylabel('FWHM (arcsec)')
    pb.xlabel('Pixels per beam')
    pb.xlim([np.min(pixelsPerBeam), np.max(pixelsPerBeam)])
    majorLocator = MultipleLocator(1)
    desc.xaxis.set_major_locator(majorLocator)
    pb.draw()
    if (plotfile != ''):
        if (plotfile == True):
            if (tpdata == None):
                plotfile = 'sfBeamWeightVariation.png'
            else:
                plotfile = tpdata + '.sfBeamWeightVariation.png'
        pb.savefig(plotfile) #, bbox_inches='tight')  # This cuts off line above title
        print "Plot left in %s" % (plotfile)
                      
def sfWeightVariation(frequency, pixelsize, diameter=12.0, samplesPerBeam=5.0,
           samplingArcsec=None, convsupport=-1, makeplot=False, m=0, taper=10, 
           obscuration=0.75,cmult=1.0,coffset=0.0,xmult=1.0,alpha=1.0,testOption=False,
           minlevels=[0], truncate=False, img=None, row=None, column=None, stokes='XX',
           plotfile=''):
    """
    Returns two numbers:
    1) the ratio of the standard deviation to the mean of the pixel weights
    predicted along one axis of an image that will be created by sdimaging using
    the specified parameters with the SF gridding function.
    2) the predicted FWHM of the gridded beam
    
    - Todd Hunter
    """
    return(griddedBeam().sfComb(frequency, pixelsize, diameter, samplesPerBeam,
                                samplingArcsec, convsupport, makeplot, m, taper, 
                                obscuration, cmult, coffset, xmult, alpha, testOption,
                                minlevels, truncate, img, row, column, stokes,
                                plotfile))

def gjincBeamWeightVariation(frequency=None, pixelsize=None, diameter=12.0, 
                             samplesPerBeam=5.0, samplingArcsec=None, 
                             useCasaJinc=False, taper=10, widthMultiplier=[],
                             obscuration=0.75, testOption=False,
                             minlevels=[0], truncate=False, img=None, row=None,
                             column=None, stokes='XX', plotfile='', 
                             tpdata=None, spw=None, pixelsPerBeam = None):
    """
    Makes a plot of the gridded beamsize and weight variation vs. the pixelsize
    chosen for the image to be created by sdimaging with the GJINC gridding 
    function.
    widthMultiplier: a list of values to use for the widthMultiplier parameter 
                     of gjincBeam
    pixelsize: None -> default = 0.5 to 15 by 0.5 arcsec
    tpdata: if not None, then run getTPSampling on this dataset to find 
            samplingArcsec (i.e. the maximum value of the two axes)
    pixelsPerBeam: default=None --> np.arange(3.8,13.21,0.2)
    -Todd Hunter
    """
    if (type(frequency) == str):
        frequency = parseFrequencyArgument(frequency) * 1e-9
    makeplot = False
    if (frequency == None and (tpdata == None or spw == None)):
        print "You must specify either frequency or (tpdata and spw)"
        return
    if (tpdata != None):
        if (os.path.exists(tpdata) == False):
            print "Dataset not found: %s" % (tpdata)
            return
        xSampling, ySampling, maxsize = getTPSampling(tpdata)
        samplingArcsec = max(xSampling,ySampling)
        if (frequency == None):
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(tpdata)
            frequency = mymsmd.meanfreq(int(spw))*1e-9
            mymsmd.close()
    beamfwhm = primaryBeamArcsec(frequency=frequency, showEquation=False)
    if (samplingArcsec == None):
        samplingArcsec = beamfwhm / float(samplesPerBeam)
    if (pixelsize==None):
        if (pixelsPerBeam == None):
            pixelsPerBeam = np.arange(3.8,13.21,0.2)
        pixelsize = beamfwhm/pixelsPerBeam
    pixelsPerBeam = beamfwhm / pixelsize
    if (widthMultiplier == []):
        widthMultipliers = [1, 1.5, 2, 2.5]
    elif (type(widthMultplier) == list):
        widthMultipliers = widthMultiplier
    else:
        widthMultipliers = [widthMultiplier]
    pb.clf()
    col = ['k','b','r','g']
    for i, widthMultiplier in enumerate(widthMultipliers):
        ratios = []
        fwhms = []
        for p in pixelsize:
            ratio, fwhm = \
                gjincWeightVariation(frequency, p, diameter, samplesPerBeam,
                                     samplingArcsec, widthMultiplier, makeplot,
                                     taper, obscuration, useCasaJinc,testOption,
                                     minlevels, truncate, img, row, column, 
                                     stokes)
            ratios.append(ratio)
            fwhms.append(fwhm)
        pb.subplot(211)
        ratios = np.array(ratios)*100
        pb.plot(pixelsPerBeam,ratios,'k-',color=col[i])
        pb.subplot(212)
        pb.plot(pixelsPerBeam,fwhms,'k-',color=col[i])
    desc = pb.subplot(211)
    pb.ylim([-3,30])
    pb.xlim([np.min(pixelsPerBeam), np.max(pixelsPerBeam)])
    pb.ylabel('Weight variation (%)')
    pb.text(0.05,1.04,'%g GHz, beam=%.2f", sampling=%.2f", widthMultiplier =     ' % (frequency, beamfwhm, samplingArcsec),size=12,transform=desc.transAxes)
    if (tpdata != None):
        if (spw == None):
            pb.text(0.1,1.10,'%s' % (os.path.basename(tpdata)),transform=desc.transAxes)
        else:
            pb.text(0.1,1.10,'%s, spw=%d' % (os.path.basename(tpdata),spw),transform=desc.transAxes)
    majorLocator = MultipleLocator(1)
    desc.xaxis.set_major_locator(majorLocator)
    for i,widthMultiplier in enumerate(widthMultipliers):
        pb.text(0.85+0.05*(i), 1.03, '%g'%(widthMultiplier), color=col[i], transform=desc.transAxes, size=12)
    desc = pb.subplot(212)
    beamgrowths = [1.1, 1.2, 1.3]
    for beamgrowth in beamgrowths:
        pb.text(np.mean([np.mean(pb.xlim()),np.max(pb.xlim())]), (beamgrowth+0.01)*beamfwhm, '%.1f * beam' % (beamgrowth))
        pb.plot(pb.xlim(), [beamgrowth*beamfwhm]*2,'k--')
    pb.ylabel('FWHM (arcsec)')
    pb.xlabel('Pixels per beam')
    pb.xlim([np.min(pixelsPerBeam), np.max(pixelsPerBeam)])
    majorLocator = MultipleLocator(1)
    desc.xaxis.set_major_locator(majorLocator)
    pb.draw()
    if (plotfile != ''):
        if (plotfile == True):
            if (tpdata == None):
                plotfile = 'gjincBeamWeightVariation.png'
            else:
                plotfile = tpdata + '.gjincBeamWeightVariation.png'
        pb.savefig(plotfile) #, bbox_inches='tight')  # This cuts off line above title
        print "Plot left in %s" % (plotfile)
                      
def gjincWeightVariation(frequency,pixelsize, diameter=12.0, samplesPerBeam=5.0,
                         samplingArcsec=None, widthMultiplier=-1, 
                         makeplot=False, taper=10, obscuration=0.75,
                         useCasaJinc=False,testOption=False, minlevels=[0], 
                         truncate=False, img=None, row=None, column=None,
                         stokes='XX', plotfile=''):
    """
    Returns two numbers:
    1) the ratio of the standard deviation to the mean of the pixel weights
    predicted along one axis of an image that will be created by sdimaging using
    the specified parameters with the GJinc gridding function.
    2) the predicted FWHM of the gridded beam
    
    - Todd Hunter
    """
    return(griddedBeam().gjincComb(frequency, pixelsize, diameter, samplesPerBeam,
                                   samplingArcsec, widthMultiplier, makeplot, taper, 
                                   obscuration, useCasaJinc, testOption,
                                   minlevels, truncate, img, row, column, stokes,
                                   plotfile))

def setImageUnits(img, value='deg'):
    """
    Read a CASA image, and set the units of the first two axes using imhead put.
    img: name of a CASA image.  If a wildcard (*) is included, then process 
         all matching files.
    value: the value to which to normalize the peak
    -Todd Hunter
    """
    if (img.find('*') >= 0):
        images = glob.glob(img)
    else:
        images = [img]
    for img in images:    
        if (os.path.exists(img) == False):
            print "Could not find image = ", img
            return
        imhead(img, mode='put', hdkey='cunit1', hdvalue=value)
        imhead(img, mode='put', hdkey='cunit2', hdvalue=value)

def subtractGaussianFromImage(img, peak, x, y, major, minor, pa):
    """
    Subtract a 2D Gaussian from an image and create a difference image.
    peak: peak intensity in image brightness units (set to None for value at xpeak,ypeak)
    xpeak: x pixel of the peak of the Gaussian (set to None for image peak)
    ypeak: y pixel of the peak of the Gaussian
    major: FWHM of major axis in pixels
    minor: FWHM minor axis in pixels
    pa: position angle of major axis in degrees
    -Todd Hunter
    """
    if (os.path.exists(img) == False):
        print "Could not find image = ", img
        return
    gimg = makeGaussianForImage(img, peak, x, y, major, minor, pa)
    outfile = 'difference.image'
    if (os.path.exists(outfile)):
        print "Removing existing image"
        shutil.rmtree(outfile)
    print "Running immath(['%s','%s'], outfile='%s', expr='IM0-IM1')" % (img,gimg,outfile)
    immath([img,gimg], outfile=outfile, expr='IM0-IM1')
    print "Created new image = ", outfile

def makeGaussianForImage(img, peak, xpeak, ypeak, major, minor, pa):
    """
    Take an image as a template, and build an image with a single Gaussian
    component at the specified location and width.
    peak: peak intensity in image brightness units (set to None for value at xpeak,ypeak)
    xpeak: x pixel of the peak of the Gaussian (set to None for image peak)
    ypeak: y pixel of the peak of the Gaussian
    major: FWHM of major axis in pixels
    minor: FWHM minor axis in pixels
    pa: position angle of major axis in degrees
    -Todd Hunter
    """
    if (os.path.exists(img) == False):
        print "Could not find image = ", img
        return
    newimage = img + '.gaussian'
    if (os.path.exists(newimage)):
        print "Removing existing image"
        shutil.rmtree(newimage)
    os.system('cp -r %s %s' % (img,newimage))
    myia = createCasaTool(iatool)
    myia.open(newimage)
    pixels = myia.getregion()
    xpixels = np.shape(pixels)[0]
    ypixels = np.shape(pixels)[1]
    if (xpeak == None):
        xpeak, ypeak = np.unravel_index(np.argmax(pixels), np.shape(pixels))
        print "Peak pixel found at %d,%d" % (xpeak,ypeak)
    if (peak == None):
        peak = pixels[xpeak][ypeak]
        print "Using peak intensity found at %d,%d = %f" % (xpeak,ypeak,peak)
    myia.putregion(pixels=build2DGaussian(peak, xpeak, ypeak, major, minor, pa, xpixels, ypixels, pixels))
    myia.close()
    print "New image created = ", newimage
    return(newimage)

def build2DGaussian(peak, xpeak, ypeak, major, minor, pa, xpixels, ypixels, pixels):
    """
    peak: peak intensity in image brightness units
    xpeak: x pixel of the peak of the Gaussian
    ypeak: y pixel of the peak of the Gaussian
    major: FWHM of major axis in pixels
    minor: FWHM of minor axis in pixels
    pa: position angle of major axis in degrees
    xpixels: number of pixels in the x axis of the image
    ypixels: number of pixels in the y axis of the image
    pixels: a 2D array of image pixel values
    -Todd Hunter
    """
    par = np.radians(90-pa)
    major /= (8*np.log(2))**0.5
    minor /= (8*np.log(2))**0.5
    a = np.cos(par)**2/(2*major**2) + np.sin(par)**2/(2*minor**2)
    b = np.sin(2*par)/(4*major**2) + np.sin(2*par)/(4*minor**2)
    c = np.sin(par)**2/(2*major**2) + np.cos(par)**2/(2*minor**2)
    for x in range(xpixels):
        for y in range(ypixels):
            pixels[x][y] = peak*np.exp(-(a*(xpeak-x)**2 + 2*b*(ypeak-y)*(xpeak-x) + c*(ypeak-y)**2))
    return pixels

def normalizeImage(img, value=1.0, regrid=False):
    """
    Read a CASA image, and normalize the intensity scale to a specified value 
    (default=1.0).
    img: name of a CASA image.  If a wildcard (*) is included, then process 
         all matching files.
    value: the value to which to normalize the peak
    regrid: calls convertImageToDirectionType after normalizing
    -Todd Hunter
    """
    if (img.find('*') >= 0):
        images = glob.glob(img)
    else:
        images = [img]
    for img in images:    
        if (os.path.exists(img) == False):
            print "Could not find image = ", img
            return
        newimage = img + '.normalized'
        if (os.path.exists(newimage)):
            shutil.rmtree(newimage)
        os.system('cp -r %s %s' % (img,newimage))
        myia = createCasaTool(iatool)
        myia.open(newimage)
        pixels = myia.getregion()
        peak = np.max(pixels)
        print "Peak = ", peak
        pixels *= value/peak
        myia.putregion(pixels=pixels)
        peak = np.max(pixels)
        print "New Peak = ", peak
        myia.close()
        print "New image = ", newimage
        if (regrid):
            convertImageToDirectionType(newimage,overwrite=True)
    return(newimage)

def complexToReal(filelist, regrid=False, outdir='', normalize=False):
    """
    Converts a complex image (or a list of images) into its square 
    (amplitude**2).  Useful for holography and TICRA model images.  
    normalize: if True, then normalize the peak to 1.0
    outdir: the output directory to write the new image
    regrid: if True, then rewrite the header with Direction coordinates (to allow imfit)
    - Todd Hunter
    """
    return(complexToOther(filelist,regrid,restfreq,stokes,outdir,suffix='real',
                          expression='real()', normalize=normalize))

def complexToImaginary(filelist, regrid=False, outdir='', normalize=False):
    """
    Converts a complex image (or a list of images) into its imaginary 
    component.  Useful for holography and TICRA model images.  
    normalize: if True, then normalize the peak to 1.0
    outdir: the output directory to write the new image
    regrid: if True, then rewrite the header with Direction coordinates (to allow imfit)
    - Todd Hunter
    """
    return(complexToOther(filelist,regrid,restfreq,stokes,outdir,
                          suffix='imaginary', expression='imag()',
                          normalize=normalize))

def complexToAmplitude(filelist, regrid=False, outdir='',normalize=False):
    """
    Converts a complex image (or a list of images) into its amplitude.
    Useful for holography and TICRA model images.  - Todd Hunter
    normalize: if True, then normalize the peak to 1.0
    outdir: the output directory to write the new image
    regrid: if True, then rewrite the header with Direction coordinates (to allow imfit)
    """
    return(complexToOther(filelist,regrid,restfreq,stokes,outdir,
                          suffix='amplitude', expression='amplitude()',
                          normalize=normalize))

def complexToSquare(filelist, regrid=False, outdir='',normalize=False):
    """
    Converts a complex image (or a list of images) into its square 
    (i.e. amplitude**2).  Useful for holography and TICRA model images.  
    normalize: if True, then normalize the peak to 1.0
    outdir: the output directory to write the new image
    regrid: if True, then rewrite the header with Direction coordinates (to allow imfit)
    - Todd Hunter
    """
    return(complexToOther(filelist,regrid,outdir,
                          suffix='square', expression='pow(amplitude(),2)',
                          normalize=normalize))
        
def complexToOther(filelist, regrid=False, outdir='',
                   suffix='square', expression='pow(amplitude(),2)', normalize=False):
    """
    Converts a complex-valued image (or a list of images) into a different 
    format. Useful for holography and TICRA model images.  - Todd Hunter
    normalize: if True, then normalize the peak to 1.0
    outdir: the output directory to write the new image
    suffix: the suffix to add to the input image name to name the new image
    regrid: if True, then rewrite the header with Direction coordinates (to allow imfit)
    """
    if (filelist.find('*') >= 0):
        filelist = glob.glob(filelist)
    elif (type(filelist) == str):
        filelist = [filelist]
    for f in filelist:
        f = f.rstrip('/')
        if (os.path.exists(f)==False):
            print "Image does not exist: ", f
            return
        myexpr = expression.replace("()","('%s')"%f)
        if (f.find('complex') >= 0):
            outfile = f.replace('complex',suffix)
        else:
            outfile = f+'.'+suffix
        if (outdir != ''):
            outfile = outdir + '/' + os.path.basename(outfile)
        print "Running immath(imagename='%s',expr=\"%s\", outfile='%s')" % (f,myexpr,outfile)
        if (os.path.exists(outfile)):
            shutil.rmtree(outfile)
        immath(imagename=f, expr="%s"%(myexpr), outfile=outfile)
        if (normalize):
            outfile = normalizeImage(outfile)
        if (regrid):
            convertImageToDirectionType(outfile,overwrite=True)

def convertImageToDirectionType(img, overwrite=False, outputimage=''):
    """
    Converts an image with Linear coordinate system type to Direction.
    Useful for ALMA astroholography images output by CLIC.
    img: the input image
    overwrite: if True, then modify the input image
    outputimage: the name of the file to produce if overwrite==False
                 (the default is to append ".dirtype")
    -Todd Hunter
    """
    cdelt1 = imhead(img,mode='get',hdkey='cdelt1')
    cdelt2 = imhead(img,mode='get',hdkey='cdelt2')
    cunit1 = imhead(img,mode='get',hdkey='cunit1')
    cunit2 = imhead(img,mode='get',hdkey='cunit2')
    crpix1 = imhead(img,mode='get',hdkey='crpix1')
    crpix2 = imhead(img,mode='get',hdkey='crpix2')
    hol = createCasaTool(iatool)
    hol.open(img)
    myia = createCasaTool(iatool)
    if (outputimage == ''):
        outputimage = img+'.dirtype'
    if (os.path.exists(outputimage)):
        shutil.rmtree(outputimage)
    myia.fromshape(outputimage, hol.shape())
    myia.putchunk(hol.getchunk())
    hol.done()
    myia.done()
    if (overwrite):
        shutil.rmtree(img)
        os.rename(outputimage,img)
        outputimage = img
    imhead(outputimage,mode='put',hdkey='cdelt1',hdvalue=cdelt1)
    imhead(outputimage,mode='put',hdkey='cdelt2',hdvalue=cdelt2)
    imhead(outputimage,mode='put',hdkey='cunit1',hdvalue=cunit1)
    imhead(outputimage,mode='put',hdkey='cunit2',hdvalue=cunit2)
    imhead(outputimage,mode='put',hdkey='crpix1',hdvalue=crpix1)
    imhead(outputimage,mode='put',hdkey='crpix2',hdvalue=crpix2)

def headerToArcsec(mydict, unit=None):
    if (unit == None):
        value = mydict['value']
    else:
        value = mydict
        mydict = {'value': mydict, 'unit': unit}
    if (mydict['unit'].find('rad') >= 0):
        value *= (180*3600)/np.pi
    elif (mydict['unit'].find('deg') >= 0):
        value *= 3600
    return(value)

def headerToRad(mydict, unit=None):
    if (unit == None):
        print "mydict = ", mydict
        value = mydict['value']
    else:
        value = mydict
        mydict = {'value': mydict, 'unit': unit}
    if (mydict['unit'] == 'arcsec'):
        value /= np.pi/(180*3600.)
    elif (mydict['unit'].find('deg') >= 0):
        value /= np.pi/(180)
    return(value)
    
def pickTicraImage(frequency, antennaType, 
                   ticraDir=os.path.dirname(__file__)+'/TicraImages/', 
                   excludeBand3=True,excludeBand3Below=109.0):
    """
    Pick the appropriate TICRA image (the squared and normalized version) to 
    use for ALMA beamsize simulations as a function of frequency and antenna 
    type.
    frequency: floating point number in GHz (no units) or a string with units
    antennaType: string containing either 'DV', 'PM', or 'DA'
    ticraDir: the directory containing the *EFP.im.square.normalized images
    excludeBand3: if True, do not allow the Band 3 models to be chosen below
                  the frequency specified in excludeBand3Below
    excludeBand3Below: frequency in GHz below which to not use Band 3 patterns
    -Todd Hunter
    """
    antType = None
    for a in ['DV','DA','PM']:
        if (antennaType.upper().find(a) >= 0):
            antType = a
            if (antType == 'PM'): antType = 'DV'
    if (antType == None):
        print "Antenna type was not specified after '%s'" % (antennaType)
        return(None)
    ghz = parseFrequencyArgumentToGHz(frequency)
    upperBounds = [92,108,116, 134.5,153.5,163, 227,259,275, 299.5,348.5,373,
                   631.5,690.5,720]
    if (excludeBand3==True):
        upperBounds = upperBounds[3:]
    elif (excludeBand3 != False):
        upperBounds = list(np.array(upperBounds)[np.where(np.array(upperBounds) >= excludeBand3)])
#        print "upperBounds = ", upperBounds
    pick = None
    for u in upperBounds:
        if (ghz < u):
            if (ghz > excludeBand3Below and ghz < 120):
                if (ghz > 108 or excludeBand3Below>100):
                    ticraUpperFreq = 116
                elif (ghz > 92 or excludeBand3Below>84):
                    ticraUpperFreq = 108
                else:
                    ticraUpperFreq = 92
                pick = antType + '*' + '%d'%(ticraUpperFreq) + '_GHz_ticra2007_EFP.im.square.normalized'
            else:
                pick = antType + '*' + '%g'%(u) + '_GHz_ticra2007_EFP.im.square.normalized'
            break
    if (pick == None or (ghz < 70) or (ghz > 163 and ghz < 211)):
        # bands 1,2,5 not supported, set low bound to 70 for Crystal's Jy/K plot
        print "Frequency out of range of TICRA models"
        return
    dadv = glob.glob(ticraDir+'/*'+pick)
    if (len(dadv) < 1):
        print "TICRA image not found (%s/*%s)" % (ticraDir,pick)
        return
    pick = dadv[0]
    if (antType == 'DV' or antType == 'PM'):
        pick.replace('DA','DV')
    else:
        pick.replace('DV','DA')
    return(pick)

def sfBeam(frequency, pixelsize=10, diameter=12.0, xSamplesPerBeam=5.0,
           ySamplesPerBeam=None, xSamplingArcsec=None, ySamplingArcsec=None,
           convsupport=-1, makeplot=False, m=0, taper=10, geometricMean=False,
           obscuration=0.75,cmult=1.0,coffset=0.0,xmult=1.0,alpha=1.0,
           testOption=False, minlevels=[0], truncate=False, img=None, row=None,
           column=None, stokes='XX', plotfile='',verbose=False,fwhmfactor=None,
           excludeBand3=True, excludeBand3Below=109.0):
    """
    This function calls the griddedBeam class in order to compute the
    effective restoring beam obtained from the casa command sd_imaging
    when using the SF gridding kernel.
        
    frequency: floating point number in GHz (no units) or a string with units
    pixelsize: floating point number in arcseconds (no units)
    diameter: the diameter of the single dish antenna in meters (no units)
    xSamplesPerBeam: the number of sampled points per telescope FWHM beam
                     along the X axis
    ySamplesPerBeam: the number of sampled points per telescope FWHM beam
                     along the Y axis
    xSamplingArcsec: if not None, then use this value instead of xSamplesPerBeam
    ySamplingArcsec: if not None, then use this value instead of ySamplesPerBeam
    convsupport: radius in pixels, default=-1 --> 3 pixels: a support width of
                  7 points
    m: The value to pass as m & n to scipy.special.pro_ang1
    taper: the illumination taper in dB to pass to au.primaryBeamArcsec
               if zero, then it uses an Airy function as the antenna beam,
               otherwise it uses a Gaussian
    fwhmfactor: if specified, pass this to primaryBeamArcsec, overriding taper
    geometricMean: if True, return only the mean beamsize; otherwise, return
             minorAxis,majorAxis,geometricMean (if the sampling is provided in
             both axes)
    obscuration: diameter in m to pass to au.primaryBeamArcsec
    alpha: the exponent of the weighting function: (1-nu**2)**alpha
    testOption: if True, use CASA's method of building the convFunc
    minlevels: a list of values above which to perform 1D Gaussian fits
    truncate: if taper=0, sets whether to truncate the Airy at first null
              if taper > 0, and not False, sets intensity level to truncate 
                 the Gaussian
    img: if not none, then use a row or column from this image as the beam model
         if 'ticraDA', 'ticraDV' or 'ticraPM' is specified, it will 
            automatically use the TICRA models distributed with au
    row: the row of img to use as the starting beam profile model
    column: the column of img to use as the starting beam profile model
    stokes: 'XX','YY' which Stokes to use in the img
    excludeBand3: if True, then don't use Band 3 TICRA patterns below
                  excludeBand3Below'
    excludeBand3Below: frequency in GHz below which to not use Band 3 patterns
    Returns:
       If only the X-axis sampling is given:
          the FWHM of the restoring beam
          the FWHM of a Gaussian fit to the restoring beam
       If both X and Y-axis sampling is given:
       * If geometricMean=True:
          the FWHM of the predicted restoring beam
          the FWHM of a Gaussian fit to the predicted restoring beam
       * If geometricMean=False:
          the minor axis of the restoring beam
          the major axis of the restoring beam
          the geometric mean of the restoring beam computed using findFWHM()
          the geometric mean of the FWHM of a Gaussian fit to the restoring beam
       
    - Todd Hunter
    """
    if (fwhmfactor != None):
        if (fwhmfactor < 1.02 or fwhmfactor > 1.22):
            print "Invalid fwhmfactor (1.02<fwhmfactor<1.22)"
            return
    if (img != None):
        if (img.lower().find('ticra') == 0):
            ticraDir = os.getenv("CASAPATH").split()[0]+"/data/alma/responses/"
            ticraImage = ticraDir + "ALMA_0_DA__0_0_360_0_45_90_602_602_631.5_GHz_ticra2007_EFP.im.square.normalized"
            if (not os.path.exists(ticraImage)):
                ticraDir = os.path.dirname(__file__) + '/TicraImages/'
                if (os.path.exists(ticraDir) == False):
                    print "The Ticra model images (squared) are not present in the analysisUtils area nor CASA."
                    return
            img = pickTicraImage(frequency,img,ticraDir,excludeBand3,
                                 excludeBand3Below)
            if (img == None):
                return
            if (verbose):
                print "Using TICRA image: %s" % (os.path.basename(img))
        if (os.path.exists(img) == False):
            print "Could not find image = ", img
            return
    if (plotfile != ''): makeplot = True
    if (ySamplesPerBeam == None and ySamplingArcsec == None):
        return(griddedBeam().sfBeamOneAxis(frequency, pixelsize, diameter,
                                     xSamplesPerBeam, xSamplingArcsec,
                                     convsupport, makeplot, m, taper,
                                     obscuration=obscuration,cmult=cmult,
                                     coffset=coffset,xmult=xmult,alpha=alpha,
                                     testOption=testOption,minlevels=minlevels,
                                     truncate=truncate,img=img,row=row,
                                     column=column,stokes=stokes,
                                     plotfile=plotfile,fwhmfactor=fwhmfactor))
    else:
        return(griddedBeam().sfBeamTwoAxes(frequency, pixelsize, diameter,
                                     xSamplesPerBeam, ySamplesPerBeam,
                                     xSamplingArcsec, ySamplingArcsec,
                                     convsupport, makeplot, m, taper,
                                     geometricMean,obscuration=obscuration,
                                     cmult=cmult,coffset=coffset,xmult=xmult,
                                     alpha=alpha,testOption=testOption,
                                     minlevels=minlevels,truncate=truncate,
                                     img=img,row=row,column=column,
                                     stokes=stokes,plotfile=plotfile,fwhmfactor=fwhmfactor))
    
class griddedBeam:
    """
    This class contains functions to compute the effective restoring beam
    obtained from the casa sd_imaging task when using either the GJINC
    gridding kernel (assuming the GJINC specific parameters are left at
    their default values), or the SF gridding kernel.
    - Todd Hunter
    """
    def gjinc(self, x, gwidth, jwidth, useCasaJinc=False, normalize=False):
        if (useCasaJinc):
            result = self.grdjinc1(x,jwidth,normalize) * self.gjincGauss(x, gwidth)
        else:
            result = self.jinc(x,jwidth) * self.gjincGauss(x, gwidth)
        return result

    def sfComb(self, frequency, pixelsize, diameter=12.0, samplesPerBeam=5.0,
               samplingArcsec=None, convsupport=-1, makeplot=False, m=0, 
               taper=10, obscuration=0.75,cmult=1.0,coffset=0.0,xmult=1.0,
               alpha=1.0,testOption=False, minlevels=[0], truncate=False, 
               img=None, row=None, column=None, stokes='XX', plotfile=''):
        convolutionPixelSize = 0.02
        showPrimaryBeamEquation = False
        returnProfile = True
        showplot = makeplot
        makeplot = False
        if (convsupport == -1):
            convsupport = 3
        xaxis, sf, result, samplingArcsec, fwhm = \
            self.sfBeamPredict(frequency, pixelsize,diameter, samplesPerBeam, 
                               samplingArcsec,convsupport, makeplot, m, taper,
                               showPrimaryBeamEquation, obscuration,
                               convolutionPixelSize, cmult, coffset, xmult, 
                               alpha, testOption, minlevels, truncate, img, 
                               row, column, stokes,plotfile,returnProfile)
        pixels = np.arange(np.min(xaxis), np.max(xaxis), pixelsize)
        skyMeasurements= np.arange(np.min(xaxis), np.max(xaxis), samplingArcsec)
        mysf = scipy.interpolate.UnivariateSpline(xaxis, sf, s=0)
        pixelSum = np.zeros(len(pixels))
        for i in range(len(pixels)):
            for s in skyMeasurements:
                distance = abs(s-pixels[i])
                if (distance < convsupport*pixelsize):
                    weight = mysf(distance)
#                    if (len(pixels)/2 == i):
#                        print "weight = ", weight
                    pixelSum[i] += weight
        pixel = range(len(pixels))[convsupport:-convsupport]
        pixelSum = pixelSum[convsupport:-convsupport]
        ratio = np.std(pixelSum)/np.mean(pixelSum)
        print "Pixel weight profile: mean = %f, std = %f,  std/mean = %g" % (np.mean(pixelSum), np.std(pixelSum), ratio)
        if (showplot):
            pb.clf()
            pb.plot(pixel, pixelSum, 'k-')
            pb.draw()
            if (plotfile != ''):
                if (plotfile==True):
                    plotfile = 'sfbeam.png'
                pb.savefig(plotfile)
        return(ratio, fwhm)
    
    def gjincComb(self, frequency, pixelsize, diameter=12.0, samplesPerBeam=5.0,
                  samplingArcsec=None, widthMultiplier=-1, makeplot=False, 
                  taper=10, obscuration=0.75,useCasaJinc=False,testOption=False,
                  minlevels=[0], truncate=False, img=None, row=None, 
                  column=None, stokes='XX', plotfile=''):
        convolutionPixelSize = 0.02
        returnProfile = True
        showplot = makeplot
        xaxis, gjinc, result, samplingArcsec, fwhm, radiusOfFirstNull = \
               self.gjincBeamPredict(frequency, pixelsize,diameter,
                                     samplesPerBeam, 
                                     samplingArcsec, makeplot, taper,
                                     obscuration, widthMultiplier,
                                     convolutionPixelSize, useCasaJinc,
                                     testOption, minlevels, truncate, img, row,
                                     column, stokes,plotfile,returnProfile)
        pixels = np.arange(np.min(xaxis), np.max(xaxis), pixelsize)
        skyMeasurements= np.arange(np.min(xaxis), np.max(xaxis), samplingArcsec)
        mygjinc = scipy.interpolate.UnivariateSpline(xaxis, gjinc, s=0)
        pixelSum = np.zeros(len(pixels))
        for i in range(len(pixels)):
            for s in skyMeasurements:
                distance = abs(s-pixels[i])
                if (distance < radiusOfFirstNull*pixelsize):
                    weight = mygjinc(distance)
                    pixelSum[i] += weight
#        print "radiusOfFirstNull of the GJinc function itself = %f pixels" % (radiusOfFirstNull) # 1.89*widthMultiplier
        pixel = range(len(pixels))[int(radiusOfFirstNull):-int(radiusOfFirstNull)]
        pixelSum = pixelSum[int(radiusOfFirstNull):-int(radiusOfFirstNull)]
        ratio = np.std(pixelSum)/np.mean(pixelSum)
        print "Pixel weight profile: mean = %f, std = %f,  std/mean = %g" % (np.mean(pixelSum), np.std(pixelSum), ratio)
        if (showplot):
            pb.clf()
            pb.plot(pixel, pixelSum, 'k-')
            pb.draw()
            if (plotfile != ''):
                if (plotfile==True):
                    plotfile = 'gjincbeam.png'
                pb.savefig(plotfile)
        if (type(fwhm) == dict):
            fwhm = fwhm[0]
        return(ratio, fwhm)
    
    def testsf(self, alphamax=0,mmax=0,increment=0.01):
        """
        Find the best match to Fred's grdsf function in aips/casa
        """
        xvalues = [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875]
        target = [0.941325231, 0.783323506, 0.571913258, 0.361065385, 0.192065331, 0.0820333956, 0.0253406856]
        minerr = 1e9
        for m in range(mmax+1):
            for alpha in range(1+alphamax):
                for c in np.arange(2,15,increment):
                    v = self.spheroidalWaveFunction(xvalues, m=m, n=m, c=c*pi/2., alpha=alpha)
                    err = np.sum((np.array(v)-np.array(target))**2)
                    if (err < minerr):
                        best = [m,alpha,c]
                        minerr = err
                        bestv = v
#                    print "%d %d %.1f  %f %f %f   ( %f )" % (m,alpha,c, v[0],v[1],v[2], err)
        print "fred=%s" % (str(target))
        print "best=%s, err=%f: m, alpha, c=%s, c*pi/2=%f" % (str(bestv),minerr, str(best),best[2]*pi/2.)

    def plotgrdsf(self, plotfile=''):
        """
        Make a comparison plot of grdsf.f and the closest match in scipy
        """
        y = []
        x = np.arange(0,1,0.001)
        for myx in x:
            y.append(self.grdsf(myx))
        c = 5.356*np.pi/2.0 # value obtained by matching Fred's grdsf.f output with scipy(m=0,n=0)
        swf = self.spheroidalWaveFunction(x, c=c)
        pb.clf()
        pb.subplot(211)
        pb.plot(x,y,'k-', x,swf,'r-')
        pb.ylabel('value')
        pb.title('Black: grdsf.f, red: scipy(c=%f*pi/2)' % (c*2/np.pi))
        pb.subplot(212)
        percent = 100*np.array(y-swf)
        pb.plot(x,percent,'k-')
        pb.ylabel('(grdsf-scipy) difference (%% of peak)')
        pb.xlabel('Radius')
        pb.draw()
        if (plotfile!=''):
            pb.savefig(plotfile)
            
    def plotcasajinc(self, plotfile='', xmax=3):
        """
        Make a comparison plot of the grdjinc1 (the Jinc approximation used in 
        casa), and scipy.
        """
        y = []
        x = np.arange(0,xmax,0.001)
        y = self.gjinc(x,gwidth=1.55,jwidth=2.52*sqrt(np.log(2)), useCasaJinc=True)
        swf = self.gjinc(x, gwidth=1.55,jwidth=2.52*sqrt(np.log(2)), useCasaJinc=False)
        pb.clf()
        pb.subplot(211)
        pb.plot(x,y,'k-', x,swf,'r-')
        pb.ylabel('value')
        pb.title('Black: grdjinc1 (casa), red: scipy  gwidth=1.55, jwidth=2.52sqrt(log(2))')
        pb.ylim([-0.05,0.51])
        pb.subplot(212)
        percent = 100*np.array(y-swf)
        pb.plot(x,percent,'k-')
        pb.ylabel('(grdjinc1-scipy) difference (%% of peak)')
        pb.xlabel('Radius')
        pb.draw()
        if (plotfile!=''):
            pb.savefig(plotfile)
            
    def grdsf(self, NU):
        """
        C Find Spheroidal function with M = 6, alpha = 1 using the rational
        C approximations discussed by Fred Schwab in Indirect Imaging.
        C This routine was checked against Fred's SPHFN routine, and agreed
        C to about the 7th significant digit.
        C The gridding function is (1-NU**2)*GRDSF(NU) where NU is the distance
        C to the edge. The grid correction function is just 1/GRDSF(NU) where NU
        C is now the distance to the edge of the image.
        """
        NP = 4
        NQ = 2
        P  = np.reshape([8.203343e-2, -3.644705e-1, 6.278660e-1, -5.335581e-1, 2.312756e-1,
                         4.028559e-3, -3.697768e-2, 1.021332e-1, -1.201436e-1, 6.412774e-2], (5,2), order="F")
        Q = np.reshape([1.0000000e0, 8.212018e-1, 2.078043e-1,1.0000000e0, 9.599102e-1, 2.918724e-1], (3,2), order="F")
        VAL = 0.0
        if ((NU>=0.0) and (NU<0.75)):
            PART = 1-1
            NUEND = 0.75
        elif ((NU>=0.75) and (NU<=1.00)):
            PART = 2-1
            NUEND = 1.00
        else:
            VAL = 0.0
            return(VAL)
        TOP = P[0][PART]
        DELNUSQ = NU**2 - NUEND**2
        for K in range(1,NP+1):
            TOP += P[K][PART] * DELNUSQ ** K
        BOT = Q[0][PART]
        for K in range(1,NQ+1):
            BOT += Q[K][PART] * DELNUSQ ** K
        if (BOT != 0.0):
            VAL = TOP/BOT
        else:
            VAL = 0.0
        return(VAL)
    
    def spheroidalWaveFunction(self, x, m=0, n=0, c=0, alpha=0):
        if (type(x) != list and type(x) != np.ndarray):
            returnScalar = True
            x = [x]
        else:
            returnScalar = False
        cv = scipy.special.pro_cv(m,n,c)  # get the eigenvalue
        result = scipy.special.pro_ang1_cv(m,n,c,cv,x)[0]
        for i in range(len(x)):
            nu = x[i] # (i-0.5*len(x))/(0.5*len(x))  # only true if x is symmetric about zero
            result[i] *= (1-nu**2)**alpha
        # The peak of this function is about 10000 for m=0,n=0,c=6
        if (returnScalar):
            return result[0]
        else:
            return result
    
    def plotsfBeam(self, m=0, n=0, pixelsize=10, convsupport=-1):
        """
        Plots a basic prolate spheroidal wave function with a
        default support width of 7 (i.e. radius = 3).
        pixelsize: in arcsec
        """
        if (convsupport==-1):
            convsupport = 3
        support = convsupport*2+1
        c = np.pi*support/2.
        inc = 0.001
        x = np.arange(-1+inc,1,inc)
        y = self.spheroidalWaveFunction(x,m,n,c)
        y = y/np.max(y)
        pb.clf()
        x = x*pixelsize*(convsupport)
        pb.plot(x,y,'b')
        pb.title('m=%d, n=%d, c=%f' % (m,n,c))
        pb.xlabel('Offset (arcsec)')
        pb.draw()
        pb.savefig('sfBeam.png')
    
    def grdjinc1(self, val, c, normalize=True):
        # Casa's function
        #// Calculate J_1(x) using approximate formula
        xs = np.pi * val / c
        result = []
        for x in xs:
          x = abs(x)  # I added this to make it symmetric
          ax = abs(x)
          if (ax < 8.0 ):
            y = x * x
            ans1 = x * (72362614232.0 + y * (-7895059235.0 \
                       + y * (242396853.1 + y * (-2972611.439 \
                       + y * (15704.48260 + y * (-30.16036606))))))
            ans2 = 144725228442.0 + y * (2300535178.0 \
                       + y * (18583304.74 + y * (99447.43394 \
                       + y * (376.9991397 + y * 1.0))))
            ans = ans1 / ans2
          else:
            z = 8.0 / ax
            y = z * z
            xx = ax - 2.356194491
            ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 \
                      + y * (0.2457520174e-5 + y * (-0.240337019e-6))))
            ans2 = 0.04687499995 + y * (-0.2002690873e-3 \
                      + y * (0.8449199096e-5 + y * (-0.88228987e-6  \
                      + y * (0.105787412e-6))))
            ans = sqrt(0.636619772 / ax) * (cos(xx) * ans1 - z * sin(xx) * ans2)
          if (x < 0.0):
            ans = -ans
          if (x == 0.0):
            out = 0.5
          else:
            out = ans / x
          if (normalize):
            out = out / 0.5
          result.append(out)
        return(result)

    def jinc(self, x, jwidth):
        """
        The peak of this function is 0.5.
        """
        argument = np.pi*np.abs(x)/jwidth
        np.seterr(invalid='ignore') # prevent warning for central point
        result = scipy.special.j1(argument) / argument 
        np.seterr(invalid='warn')
        for i in range(len(x)):
            if (abs(x[i]) < 1e-8):
                result[i] = 0.5
        return result

    def gjincGauss(self, x, gwidth):
        return (np.exp(-np.log(2)*(x/float(gwidth))**2))  

    def gaussfit_errfunc(self,parameters,x,y):
        return (y - self.gauss(x,parameters))

    def gaussfit(self, x, y, showplot=False, minlevel=0, verbose=False, 
                 title=None, truncate=False):
        """
        Fits a 1D Gaussian assumed to be centered at x=0 with amp=1 to the 
        specified data, with an option to truncate it at some level.   
        Returns the FWHM and truncation point.
        """
        fwhm_guess = findFWHM(x,y)
        if (truncate == False):
            parameters = np.asarray([fwhm_guess], dtype=np.float64)
        else:
            parameters = np.asarray([fwhm_guess,truncate], dtype=np.float64)
        if (verbose): print "Fitting for %d parameters: guesses = %s" % (len(parameters), parameters)
        xx = np.asarray(x, dtype=np.float64)
        yy = np.asarray(y, dtype=np.float64)
        lenx = len(x)
        if (minlevel > 0):
            xwidth = findFWHM(x,y,minlevel)
            xx = x[np.where(np.abs(x) < xwidth*0.5)[0]]
            yy = y[np.where(np.abs(x) < xwidth*0.5)[0]]
            if (verbose):
                print "Keeping %d/%d points, guess = %f arcsec" % (len(x),lenx,fwhm_guess)
        result = optimize.leastsq(self.gaussfit_errfunc, parameters, args=(xx,yy),
                                  full_output=1)
        bestParameters = result[0]
        infodict = result[2]
        numberFunctionCalls = infodict['nfev']
        mesg = result[3]
        ier = result[4]
        if (verbose):
            print "optimize.leastsq: ier=%d, #calls=%d, message = %s" % (ier,numberFunctionCalls,mesg)
        if (type(bestParameters) == list or type(bestParameters) == np.ndarray):
            fwhm = bestParameters[0]
            if verbose: print "fitted FWHM = %f" % (fwhm)
            if (truncate != False):
                truncate = bestParameters[1]
                print "optimized truncation = %f" % (truncate)
        else:
            fwhm = bestParameters
        if (showplot):
            pb.clf()
            xgrid = np.arange(np.min(x), np.max(x), (np.max(x)-np.min(x))/1000.)
            pb.plot(xgrid, self.gauss(xgrid, [fwhm, truncate]), 'r-', x,y,'ko')
            if (title != None):
                pb.title(title, size=12)
            pb.draw()
        return(fwhm,truncate)
    
    def gauss(self, x, parameters):
        """
        Computes the value of the Gaussian function at the specified
        location(s) with respect to the peak (which is assumed to be at x=0).
        truncate: if not None, then set result to zero if below this value.
        -Todd Hunter
        """
        if (type(parameters) != np.ndarray and type(parameters) != list):
            parameters = np.array([parameters])
        if (len(parameters) < 2):
            parameters = np.array([parameters[0],0])
        fwhm = parameters[0]
        x = np.asarray(x, dtype=np.float64)
        sigma = fwhm/2.3548201
        result = np.exp(-(x**2/(2.0*sigma**2)))
        idx = np.where(result < parameters[1])[0]
        result[idx] = 0
        return result
    
    def trunc(self, result):
        """
        Truncates a list at the first null on both sides of the center,
        starting at the center and moving outward in each direction.
        Assumes the list is positive in the center, e.g. a Gaussian beam.
        -Todd Hunter
        """
        # casa default truncate=-1, which means truncate at radius of first null
        mask = np.zeros(len(result))
        truncateBefore = 0
        truncateBeyond = len(mask)
        for r in range(len(result)/2,len(result)):
            if (result[r]<0):
                truncateBeyond = r
                break
        for r in range(len(result)/2,0,-1):
            if (result[r]<0):
                truncateBefore = r
                break
        mask[truncateBefore:truncateBeyond] = 1
#        print "Truncating outside of pixels %d-%d (len=%d)" % (truncateBefore,truncateBeyond-1,len(mask))
        result *= mask
        return result
    
    def findFWHM(self, x, y):
        """
        Measures the FWHM of the specified profile.  This works
        well in a noise-free environment, such as this model.
        -Todd Hunter
        """
        halfmax = np.max(y)*0.5
        spline = scipy.interpolate.UnivariateSpline(x, y-halfmax, s=0)
        x0,x1 = spline.roots()
        return(abs(x1-x0))
    
    def buildBoxcar(self, xaxis, width):
        """
        Returns a box car function.
        width: width of the box car, in the same units as the xaxis
        """
        myboxcar = []
        for x in xaxis:
            if (abs(x) <= width/2.0):
                myboxcar.append(1)
            else:
                myboxcar.append(0)
        return(myboxcar)
        
    def gjincBeamOneAxis(self, frequency, pixelsize, diameter, xSamplesPerBeam,
                         xSamplingArcsec, makeplot, taper=12, obscuration=0.75,
                         widthMultiplier=1.0,useCasaJinc=False,testOption=False,
                         minlevels=[0.0], truncate=False, img=None, row=None,
                         column=None, stokes='XX',plotfile='',fwhmfactor=None):
        """
        This function calls gjincBeam for one axis on the sky.
        frequency: in GHz
        pixelsize: in arcsec
        diameter: in meters
        taper: the illumination taper in dB to pass to au.primaryBeamArcsec
               if zero, then it uses an Airy function truncated at the first
               null as the antenna beam, otherwise it uses a Gaussian.
        widthMultiplier: the value by which to multiply the default values of 
                         gwidth/jwidth
        truncate: if taper=0, sets whether to truncate Airy at the first null
                  if taper>0, sets the intensity at which to truncate Gaussian
        If xSamplingArcsec == None, then use the derived FWHM/xSamplesPerBeam
        Returns:  the FWHM and the FWHM of a Gaussian fit
        """
        if (stokes == 'both' and img  != None):
            fwhmXX,alongScanXX,sampling,fittedFWHMXX,radiusOfNullOnPixels = \
                        self.gjincBeamPredict(frequency,pixelsize,diameter,
                                       xSamplesPerBeam,xSamplingArcsec,makeplot,
                                       taper, obscuration=obscuration,
                                       widthMultiplier=widthMultiplier,
                                       useCasaJinc=useCasaJinc,
                                       testOption=testOption,
                                       minlevels=minlevels,truncate=truncate,
                                       img=img, row=row, column=column,
                                       stokes='XX',plotfile=plotfile,
                                       fwhmfactor=fwhmfactor)
            fwhmYY,alongScanYY,sampling,fittedFWHMYY,radiusOfNullOnPixels = \
                        self.gjincBeamPredict(frequency,pixelsize,diameter,
                                      xSamplesPerBeam,xSamplingArcsec,makeplot,
                                      taper, obscuration=obscuration,
                                      widthMultiplier=widthMultiplier,
                                      useCasaJinc=useCasaJinc,
                                      testOption=testOption,
                                      minlevels=minlevels,truncate=truncate,
                                      img=img, row=row, column=column,
                                      stokes='YY',plotfile=plotfile,
                                      fwhmfactor=fwhmfactor)
            fwhm = np.mean([fwhmXX,fwhmYY])
            alongScan = np.mean([alongScanXX,alongScanYY])
            sampling = np.mean([samplingXX,samplingYY])
            fittedFWHM = {}
            for f in fittedFWHMXX:
                fittedFWHM[f] = np.mean([fittedFWHMXX[f],fittedFWHMYY[f]])
        else:
            fwhm,alongScan,sampling,fittedFWHM,radiusOfNullOnPixels = \
               self.gjincBeamPredict(frequency,pixelsize,diameter,
                                     xSamplesPerBeam,xSamplingArcsec,makeplot,
                                     taper, obscuration=obscuration,
                                     widthMultiplier=widthMultiplier,
                                     useCasaJinc=useCasaJinc,
                                     testOption=testOption,
                                     minlevels=minlevels,truncate=truncate,
                                     img=img, row=row, column=column,
                                     stokes=stokes,plotfile=plotfile, 
                                     fwhmfactor=fwhmfactor)
        if (False):
            print "Theoretical primary beam FWHP = %g arcsec" % (fwhm)
            print "Sampled every %g arcsec (%f points per beam)" % (sampling,fwhm/sampling)
            print "Expected effective restoring beam = %.4f arcsec" % (alongScan)
            for f in fittedFWHM:
                print "Gaussian fit to beam (data>%.3f) = %.4f arcsec" % (f,fittedFWHM[f])
        return(alongScan,fittedFWHM[0.0])

    def gjincBeamTwoAxes(self, frequency, pixelsize, diameter, xSamplesPerBeam,
                         ySamplesPerBeam, xSamplingArcsec, ySamplingArcsec,
                         makeplot, taper=12, geometricMean=False,
                         obscuration=0.75, widthMultiplier=1.0, 
                         useCasaJinc=False, testOption=False, minlevels=[0.0], 
                         truncate=False, img=None, row=None, column=None,
                         stokes='XX',plotfile='', fwhmfactor=None):
        """
        This function calls gjincBeam for each of two axes on the sky.
        frequency: in GHz
        pixelsize: in arcsec
        diameter: in meters
        widthMultiplier: the value by which to multiply the default values of 
                         gwidth/jwidth
        taper: the illumination taper in dB to pass to au.primaryBeamArcsec
               if zero, then it uses an Airy function
               as the antenna beam, otherwise it uses a Gaussian
        fwhmfactor: if specified, pass this to primaryBeamArcsec, overriding taper
        truncate: if taper=0, sets whether to truncate Airy at the first null
                  if taper>0, sets the intensity at which to truncate Gaussian
        If xSamplingArcsec == None, then use the derived FWHM/xSamplesPerBeam
        If ySamplingArcsec == None, then use the derived FWHM/ySamplesPerBeam
        """
        if (img != None and ((row=='auto' and column=='auto') or (row==None and column==None))):
            xrow = 'auto'
            xcolumn = None
            yrow = None
            ycolumn = 'auto'
        else:
            xrow = row
            yrow = row
            xcolumn = column
            ycolumn = column
        if (img != None and stokes == 'both'):
            fwhmXX,alongScanXX,xSamplingXX,fittedXFWHMXX,radiusOfNullOnPixels=\
              self.gjincBeamPredict(frequency,pixelsize,diameter,
                        xSamplesPerBeam, xSamplingArcsec, makeplot, taper,
                        obscuration=obscuration,widthMultiplier=widthMultiplier,
                        useCasaJinc=useCasaJinc, testOption=testOption,
                        minlevels=minlevels,truncate=truncate,
                        img=img, row=xrow, column=xcolumn,stokes='XX',
                        plotfile=plotfile, fwhmfactor=fwhmfactor)
            fwhmXX,betweenRowsXX,ySamplingXX,fittedYFWHMXX,radiusOfNullOnPixels = \
              self.gjincBeamPredict(frequency,pixelsize, diameter, 
                                 ySamplesPerBeam, ySamplingArcsec, makeplot,
                                 taper, obscuration=obscuration,
                                 widthMultiplier=widthMultiplier,
                                 useCasaJinc=useCasaJinc, testOption=testOption,
                                 minlevels=minlevels,truncate=truncate,
                                 img=img, row=yrow, column=ycolumn,stokes='XX',
                                 plotfile=plotfile, fwhmfactor=fwhmfactor)
            fwhmYY,alongScanYY,xSamplingYY,fittedXFWHMYY,radiusOfNullOnPixels=\
              self.gjincBeamPredict(frequency,pixelsize,diameter,
                                 xSamplesPerBeam, xSamplingArcsec, makeplot, 
                                 taper, obscuration=obscuration,
                                 widthMultiplier=widthMultiplier,
                                 useCasaJinc=useCasaJinc, testOption=testOption,
                                 minlevels=minlevels,truncate=truncate,
                                 img=img, row=xrow, column=xcolumn,stokes='YY',
                                 plotfile=plotfile, fwhmfactor=fwhmfactor)
            fwhmYY,betweenRowsYY,ySamplingYY,fittedYFWHMYY,radiusOfNullOnPixels = \
              self.gjincBeamPredict(frequency,pixelsize,diameter, 
                                 ySamplesPerBeam, ySamplingArcsec, makeplot, 
                                 taper, obscuration=obscuration,
                                 widthMultiplier=widthMultiplier,
                                 useCasaJinc=useCasaJinc, testOption=testOption,
                                 minlevels=minlevels,truncate=truncate,
                                 img=img, row=yrow, column=ycolumn, stokes='YY',
                                 plotfile=plotfile, fwhmfactor=fwhmfactor)
            fwhm = np.mean([fwhmXX,fwhmYY])
            alongScan = np.mean([alongScanXX,alongScanYY])
            betweenRows = np.mean([betweenRowsXX,betweenRowsYY])
            xSampling = np.mean([xSamplingXX,xSamplingYY])
            ySampling = np.mean([ySamplingXX,ySamplingYY])
            fittedXFWHM = {}
            for f in fittedXFWHMXX:
                fittedXFWHM[f] = np.mean([fittedXFWHMXX[f],fittedXFWHMYY[f]])
            fittedYFWHM = {}
            for f in fittedYFWHMXX:
                fittedYFWHM[f] = np.mean([fittedYFWHMXX[f],fittedYFWHMYY[f]])
        else:
            fwhm,alongScan,xSampling,fittedXFWHM,radiusOfNullOnPixels = \
              self.gjincBeamPredict(frequency,pixelsize,diameter,
                                    xSamplesPerBeam, xSamplingArcsec, makeplot,
                                    taper, obscuration=obscuration,
                                    widthMultiplier=widthMultiplier,
                                    useCasaJinc=useCasaJinc, 
                                    testOption=testOption, minlevels=minlevels,
                                    truncate=truncate, img=img, row=xrow, 
                                    column=xcolumn, stokes=stokes,
                                    plotfile=plotfile,fwhmfactor=fwhmfactor)
            fwhm,betweenRows,ySampling,fittedYFWHM,radiusOfNullOnPixels = \
              self.gjincBeamPredict(frequency,pixelsize, diameter, 
                                    ySamplesPerBeam, ySamplingArcsec, makeplot,
                                    taper, obscuration=obscuration,
                                    widthMultiplier=widthMultiplier,
                                    useCasaJinc=useCasaJinc, 
                                    testOption=testOption, minlevels=minlevels,
                                    truncate=truncate, img=img, row=yrow, 
                                    column=ycolumn, stokes=stokes,
                                    plotfile=plotfile, fwhmfactor=fwhmfactor)
        if (False):
            print "Theoretical primary beam FWHP = %g arcsec" % (fwhm)
            print "Sampled every %g arcsec (%g points per beam) in X" % (xSampling,fwhm/xSampling)
            print "Sampled every %g arcsec (%g points per beam) in Y" % (ySampling,fwhm/ySampling)
            print "Expected effective restoring beam along X = %.4f arcsec" % (alongScan)
            for f in fittedXFWHM:
                print "Gaussian fit to beam along X (data>%.3f) = %.4f arcsec" % (f,fittedXFWHM[f])
            print "Expected effective restoring beam along Y = %.4f arcsec" % (betweenRows)
            for f in fittedYFWHM:
                print "Gaussian fit to beam along Y (data>%.3f) = %.4f arcsec" % (f,fittedYFWHM[f])
        f = minlevels[0]
        geometricMeanDiameter = (alongScan*betweenRows)**0.5
        geometricMeanFit = (fittedXFWHM[f]*fittedYFWHM[f])**0.5
        if (False):
            print "Geometric mean of expected beam= %g arcsec" % (geometricMeanDiameter)
            print "Geometric mean of Gaussian fit = %g arcsec" % (geometricMeanFit)
        if (geometricMean):
            return(geometricMeanDiameter, geometricMeanFit)
        else:
            return(np.min([alongScan, betweenRows]),
                   np.max([alongScan, betweenRows]), geometricMeanDiameter, geometricMeanFit)

    def sfBeamOneAxis(self, frequency, pixelsize, diameter, xSamplesPerBeam,
                      xSamplingArcsec, convsupport, makeplot, m=0, taper=12,
                      obscuration=0.75, cmult=1.0,coffset=0.0,xmult=1.0,
                      alpha=1, testOption=False, minlevels=[0],truncate=False,
                      img=None,row=None,column=None,
                      stokes='XX',plotfile='',fwhmfactor=None):
        """
        This function calls sfBeam for one axis on the sky.
        frequency: in GHz
        pixelsize: in arcsec
        diameter: in meters
        convsupport: radius in pixels, default=-1 --> 3 pixels: a support width of 7 points
        m: The value to pass as m & n to scipy.special.pro_ang1 (0: alpha=0 in VLA memo 156)
        taper: the illumination taper in dB to pass to au.primaryBeamArcsec
               if zero, then it uses an Airy function truncated at the first null
               as the antenna beam, otherwise it uses a Gaussian.
        fwhmfactor: if specified, pass this to primaryBeamArcsec, overriding taper
        obscuration: diameter in m to pass to au.primaryBeamArcsec
        minlevels: a list of values above which to perform 1D Gaussian fits
        truncate: if taper=0, sets whether to truncate the Airy at the first null
                 if taper>0, sets the intensity level at which to truncate the Gaussian
        img: if not none, then use a row or column from this image as the beam model
        row: the row of img to use as the starting beam profile model
        column: the column of img to use as the starting beam profile model
        If xSamplingArcsec == None, then use the derived FWHM/xSamplesPerBeam
        Returns:
          the FWHM of the predicted restoring beam
          the FWHM of a Gaussian fit to the restoring beam
        """
#        support=6, pixelsPerBeam=4, fittedbeam=24.558
#        support=3, pixelsPerBeam=4, fittedbeam=18.811
        if (stokes == 'both' and img != None):
            fwhmXX,alongScanXX,samplingXX,fittedFWHMXX = \
                self.sfBeamPredict(frequency,pixelsize,diameter,xSamplesPerBeam,
                                   xSamplingArcsec, convsupport, makeplot, m, 
                                   taper, obscuration=obscuration, cmult=cmult,
                                   coffset=coffset,xmult=xmult,alpha=alpha,
                                   testOption=testOption,minlevels=minlevels,
                                   truncate=truncate,img=img,row=row,
                                   column=column, stokes='XX',plotfile=plotfile,
                                   fwhmfactor=fwhmfactor)
            fwhmYY,alongScanYY,samplingYY,fittedFWHMYY = \
                self.sfBeamPredict(frequency,pixelsize,diameter,xSamplesPerBeam,
                                   xSamplingArcsec, convsupport, makeplot, m, 
                                   taper, obscuration=obscuration,cmult=cmult,
                                   coffset=coffset,xmult=xmult,alpha=alpha,
                                   testOption=testOption,minlevels=minlevels,
                                   truncate=truncate,img=img,row=row,
                                   column=column, stokes='YY',plotfile=plotfile,
                                   fwhmfactor=fwhmfactor)
            fwhm = np.mean([fwhmXX,fwhmYY])
#            print "sfBeamOneAxis: shape(alongScanXX) = ", np.shape(alongScanXX)
            alongScan = np.mean([alongScanXX,alongScanYY])
            sampling = np.mean([samplingXX,samplingYY])
            fittedFWHM = {}
            for f in fittedFWHMXX:
                fittedFWHM[f] = np.mean([fittedFWHMXX[f],fittedFWHMYY[f]])
        else:
            fwhm,alongScan,sampling,fittedFWHM = \
                self.sfBeamPredict(frequency,pixelsize,diameter,xSamplesPerBeam,
                                   xSamplingArcsec, convsupport, makeplot, m, 
                                   taper, obscuration=obscuration, cmult=cmult,
                                   coffset=coffset,xmult=xmult,alpha=alpha,
                                   testOption=testOption,minlevels=minlevels,
                                   truncate=truncate,img=img,row=row,
                                   column=column, stokes=stokes,
                                   plotfile=plotfile,fwhmfactor=fwhmfactor)
        if (False):
            print "Theoretical primary beam FWHP = %g arcsec" % (fwhm)
            print "Sampled every %g arcsec (%f points per beam)" % (sampling,fwhm/sampling)
            print "Expected effective restoring beam = %.4f arcsec" % (alongScan)
            for f in fittedFWHM:
                print "Gaussian fit to beam (data>%.3f) = %.4f arcsec" % (f,fittedFWHM[f])
        return(alongScan, fittedFWHM[0.0])

    def sfBeamTwoAxes(self, frequency, pixelsize, diameter, xSamplesPerBeam,
                      ySamplesPerBeam, xSamplingArcsec, ySamplingArcsec,
                      convsupport, makeplot, m=0, taper=12, geometricMean=False,
                      obscuration=0.75,cmult=1.0,coffset=0.0,xmult=1.0,alpha=1,
                      testOption=False,minlevels=[0.0],truncate=False,
                      img=None,row=None,column=None,stokes='XX',plotfile='',
                      fwhmfactor=None):
        """
        This function calls sfBeam for each of two axes on the sky.
        frequency: in GHz
        pixelsize: in arcsec
        diameter: in meters
        convsupport: radius in pixels, default=-1 --> 3 pixels: a support
                     width of 7 points
        m: The value to pass as m & n to scipy.special.pro_ang1 (0: alpha=0
           in VLA memo 156)
        taper: the illumination taper in dB to pass to au.primaryBeamArcsec
               if zero, then it uses an Airy function truncated at the first null
               as the antenna beam, otherwise it uses a Gaussian.
        fwhmfactor: if specified, pass this to primaryBeamArcsec, overriding taper
        obscuration: diameter in m to pass to au.primaryBeamArcsec
        geometricMean: if True, return only the mean beamsize; otherwise, return
             minorAxis,majorAxis,geometricMean (if the sampling is provided in
             both axes)
        truncate: if taper=0, sets whether to truncate the Airy at the first null
                  if taper>0, sets the intensity level at which to truncate the Gaussian

        If xSamplingArcsec == None, then use the derived FWHM/xSamplesPerBeam
        If ySamplingArcsec == None, then use the derived FWHM/ySamplesPerBeam
        Returns:
        If geometricMean=True:
          the FWHM of the restoring beam
          the FWHM of a Gaussian fit to the restoring beam
        If geometricMean=False:
          the minor axis of the restoring beam
          the major axis of the restoring beam
          the geometric mean of the restoring beam
          the geometric mean of the FWHM of a Gaussian fit to the restring beam
        """
        if (img != None and ((row=='auto' and column=='auto') or (row==None and column==None))):
            xrow = 'auto'
            xcolumn = None
            yrow = None
            ycolumn = 'auto'
        else:
            xrow = row
            yrow = row
            xcolumn = column
            ycolumn = column
        if (img != None and stokes == 'both'):
            fwhmXX,alongScanXX,xSamplingXX,fittedXFWHMXX = \
                self.sfBeamPredict(frequency,pixelsize,diameter,
                                   xSamplesPerBeam, xSamplingArcsec,
                                   convsupport, makeplot, m, taper,
                                   obscuration=obscuration,
                                   cmult=cmult,coffset=coffset,xmult=xmult,
                                   alpha=alpha, testOption=testOption,
                                   minlevels=minlevels,truncate=truncate,
                                   img=img,row=xrow,column=xcolumn,stokes='XX',
                                   plotfile=plotfile,fwhmfactor=fwhmfactor)
            fwhmYY,alongScanYY,xSamplingYY,fittedXFWHMYY = \
                self.sfBeamPredict(frequency,pixelsize,diameter,
                                   xSamplesPerBeam, xSamplingArcsec,
                                   convsupport, makeplot, m, taper,
                                   obscuration=obscuration,
                                   cmult=cmult,coffset=coffset,xmult=xmult,
                                   alpha=alpha, testOption=testOption,
                                   minlevels=minlevels,truncate=truncate,
                                   img=img,row=xrow,column=xcolumn,stokes='YY',
                                   plotfile=plotfile,fwhmfactor=fwhmfactor)
            fwhm = np.mean([fwhmXX,fwhmYY])
            alongScan = np.mean([alongScanXX,alongScanYY])
            xSampling = np.mean([xSamplingXX,xSamplingYY])
            fittedXFWHM = {}
            for f in fittedXFWHMXX:
                fittedXFWHM[f] = np.mean([fittedXFWHMXX[f],fittedXFWHMYY[f]])

            fwhmXX,betweenRowsXX,ySamplingXX,fittedYFWHMXX = \
                self.sfBeamPredict(frequency,pixelsize,diameter,
                                   ySamplesPerBeam,ySamplingArcsec,
                                   convsupport, makeplot, m, taper,
                                   showPrimaryBeamEquation=False,
                                   obscuration=obscuration,
                                   cmult=cmult,coffset=coffset,xmult=xmult,
                                   alpha=alpha,testOption=testOption,
                                   minlevels=minlevels,truncate=truncate,
                                   img=img,row=yrow,column=ycolumn,stokes='XX',
                                   plotfile=plotfile,fwhmfactor=fwhmfactor)
            fwhmYY,betweenRowsYY,ySamplingYY,fittedYFWHMYY = \
                self.sfBeamPredict(frequency,pixelsize,diameter,
                                   ySamplesPerBeam,ySamplingArcsec,
                                   convsupport, makeplot, m, taper,
                                   showPrimaryBeamEquation=False,
                                   obscuration=obscuration,
                                   cmult=cmult,coffset=coffset,xmult=xmult,
                                   alpha=alpha,testOption=testOption,
                                   minlevels=minlevels,truncate=truncate,
                                   img=img,row=yrow,column=ycolumn,stokes='YY',
                                   plotfile=plotfile,fwhmfactor=fwhmfactor)
            fwhm = np.mean([fwhmXX,fwhmYY])
            betweenRows = np.mean([betweenRowsXX,betweenRowsYY])
            ySampling = np.mean([ySamplingXX,ySamplingYY])
            fittedYFWHM = {}
            for f in fittedYFWHMXX:
                fittedYFWHM[f] = np.mean([fittedYFWHMXX[f],fittedYFWHMYY[f]])
        else:
            fwhm,alongScan,xSampling,fittedXFWHM = \
                self.sfBeamPredict(frequency,pixelsize,diameter,
                                   xSamplesPerBeam, xSamplingArcsec,
                                   convsupport, makeplot, m, taper,
                                   obscuration=obscuration,cmult=cmult,
                                   coffset=coffset,xmult=xmult,alpha=alpha, 
                                   testOption=testOption, minlevels=minlevels,
                                   truncate=truncate, img=img,row=xrow,
                                   column=xcolumn, stokes=stokes,
                                   plotfile=plotfile,fwhmfactor=fwhmfactor)
            fwhm,betweenRows,ySampling,fittedYFWHM = \
                self.sfBeamPredict(frequency,pixelsize,diameter,
                                   ySamplesPerBeam,ySamplingArcsec,
                                   convsupport, makeplot, m, taper,
                                   showPrimaryBeamEquation=False,
                                   obscuration=obscuration, cmult=cmult,
                                   coffset=coffset,xmult=xmult, alpha=alpha,
                                   testOption=testOption, minlevels=minlevels,
                                   truncate=truncate,img=img,row=yrow,
                                   column=ycolumn, stokes=stokes,
                                   plotfile=plotfile,fwhmfactor=fwhmfactor)
        f = minlevels[0]
        geometricMeanDiameter = (alongScan*betweenRows)**0.5
        geometricMeanFit = (fittedXFWHM[f]*fittedYFWHM[f])**0.5
        if (False):
            print "Theoretical primary beam FWHP = %g arcsec" % (fwhm)
            print "Sampled every %g arcsec (%g points per beam) in X" % (xSampling,fwhm/xSampling)
            print "Sampled every %g arcsec (%g points per beam) in Y" % (ySampling,fwhm/ySampling)
            print "Expected effective restoring beam along X = %.10f arcsec" % (alongScan)
            for f in fittedXFWHM:
                print "Gaussian fit to beam along X (data>%.3f) = %.10f arcsec" % (f,fittedXFWHM[f])
            print "Expected effective restoring beam along Y = %.10f arcsec" % (betweenRows)
            for f in fittedYFWHM:
                print "Gaussian fit to beam along Y (data>%.3f) = %.10f arcsec" % (f,fittedYFWHM[f])
            print "Geometric mean of expected beam= %g arcsec" % (geometricMeanDiameter)
            print "Geometric mean of Gaussian fit = %g arcsec" % (geometricMeanFit)
        if (geometricMean):
            return(geometricMeanDiameter, geometricMeanFit)
        else:
            return(np.min([alongScan, betweenRows]),
                   np.max([alongScan, betweenRows]), geometricMeanDiameter, geometricMeanFit)

    def rootAiryIntensity(self, myxaxis, epsilon=0.0, showplot=False):
        """
        This function computes 2*J1(x)/x, which can be squared to get an Airy disk.
        myxaxis: the x-axis values to use
        epsilon: radius of central hole in units of the dish diameter
        """
        if (epsilon > 0):
            a = (2*scipy.special.j1(myxaxis)/myxaxis - \
                 epsilon**2*2*scipy.special.j1(myxaxis*epsilon)/(epsilon*myxaxis)) / (1-epsilon**2)
        else:
            a = 2*scipy.special.j1(myxaxis)/myxaxis  # simpler formula for epsilon=0
        if (showplot):
            pb.clf()
            pb.plot(myxaxis, a**2, 'b-', myxaxis, simple**2, 'r-')
            pb.xlim([-20,20])
            pb.draw()
        return(a)
    
    def buildAiryDisk(self, fwhm, xaxisLimitInUnitsOfFwhm, convolutionPixelSize, truncate=False,
                      obscuration=0.75,diameter=12.0):
        """
        This function computes the Airy disk (with peak of 1.0) across a grid of points
        specified in units of the FWHM of the disk.
        fwhm: a value in arcsec
        xaxisLimitInUnitsOfFwhm: an integer or floating point unitless value
        """
        epsilon = obscuration/diameter
#        print "Using epsilon = %f" % (epsilon)
        myxaxis = np.arange(-xaxisLimitInUnitsOfFwhm*fwhm,
                            xaxisLimitInUnitsOfFwhm*fwhm+0.5*convolutionPixelSize,
                            convolutionPixelSize)
        a = (self.rootAiryIntensity(myxaxis, epsilon))**2
        # Scale the Airy disk to the desired FWHM, and recompute on finer grid
        airyfwhm = self.findFWHM(myxaxis,a)
        ratio = fwhm/airyfwhm
        myxaxis = np.arange(-xaxisLimitInUnitsOfFwhm*fwhm/ratio,
                            (xaxisLimitInUnitsOfFwhm*fwhm+0.5*convolutionPixelSize)/ratio,
                            convolutionPixelSize/ratio)
        a = self.rootAiryIntensity(myxaxis, epsilon)
        if (truncate):
            a = self.trunc(a)
        a = a**2
        myxaxis *= ratio
        return(myxaxis, a)

    def sfBeamPredict(self, frequency, pixelsize=10, diameter=12.0, 
                      samplingFactor=2.5, samplingArcsec=None, convsupport=-1, 
                      makeplot=False, m=0, taper=10, showPrimaryBeamEquation=False,
                      obscuration=0.75, convolutionPixelSize=0.02, cmult=1.0,
                      coffset=0.0,xmult=1.0,alpha=1, testOption=False,
                      minlevels=[0.0], truncate=False,img=None,row=None,
                      column=None, stokes='XX',plotfile='',returnProfile=False,
                      fwhmfactor=None):
        """
        This function computes the effective restoring beam obtained from
        sd_imaging when using the SF gridding kernel.
        
        frequency: floating point number in GHz (no units) or a string with units
        pixelsize: of image = floating point number in arcseconds (no units)
        diameter: the diameter of the single dish antenna in meters (no units)
        samplingFactor: the number of sampled points per telescope FWHM
        samplingArcsec: if not None, then use this value instead of
               FWHM/samplingFactor
        convsupport: radius in pixels, default=-1 --> 3 pixels: a support
               width of 7 points
        m: The value to pass as m & n to scipy.special.pro_ang1
        taper: the illumination taper in dB to pass to au.primaryBeamArcsec.
               if zero, then it uses an Airy function as the antenna beam,
               otherwise it uses a Gaussian
        fwhmfactor: if specified, pass this to primaryBeamArcsec, overriding taper
        obscuration: diameter in m to pass to au.primaryBeamArcsec
        convolutionPixelSize: size of pixels in the model (should be << samplingArcsec)
        alpha: the exponent of the weighting function: (1-nu**2)**alpha
        minlevels: a list of values above which to perform 1D Gaussian fits
        truncate: if taper=0, sets whether to truncate the Airy at first null
                  if taper > 0, sets the intensity level to truncate Gaussian

        Returns:
        if returnProfile == False, then 4 values (all in arcsec)
           fwhm: the FWHM size of the theoretical beam
           myfwhm: the effective restoring beam
           samplingArcsec: the sampling rate
           fittedFWHM: the Gaussian-fitted restoring beam
        If returnProfile == True, then 5 values:
           myxaxis: x-axis (angle)
           mysf: the spheroidal function used (intensity)
           result: y-axis after convolution with SF and the boxcar (intensity)
           samplingArcsec: the sampling rate
           myfwhm: the effective restoring beam
    
        - Todd Hunter
        """
        c = 5.356*np.pi/2.0 # value obtained by matching Fred's grdsf.f output with scipy(m=0,n=0)
        if (convsupport == -1):
            convsupport = 3
        supportwidth = (convsupport*cmult + coffset)   
        n = m  # For convolution, n=m are the only functions we care about.
        if (type(frequency) == str):
            frequency = parseFrequencyArgument(frequency)*1e-9
        if (img != None):
#            print "Using beam profile from image"
            myxaxis, myfunction, row, column, imgfreq = extractCutFromImage(img,row=row,column=column,stokes=stokes,interpolate=True)
            if (frequency < 2000):
                frequencyHz = frequency*1.0e9
            else:
                frequencyHz = frequency
            if (imgfreq > 0):
                imgScaling = imgfreq/frequencyHz
                myxaxis *= imgScaling
                print "Scaling xaxis by %f/%f=%f" % (imgfreq, frequencyHz, imgScaling)
            fwhm = self.findFWHM(myxaxis,myfunction)
            if (samplingArcsec == None):
                samplingArcsec = fwhm/samplingFactor
#                print "Set samplingArcsec to %f/%f=%f" % (fwhm,samplingFactor,samplingArcsec)
            if (samplingArcsec < 5*convolutionPixelSize and samplingArcsec > 0):
                convolutionPixelSize = samplingArcsec / 5.0
        else:
            fwhm = primaryBeamArcsec(frequency=frequency, diameter=diameter, taper=taper,
                                     showEquation=showPrimaryBeamEquation, 
                                     obscuration=obscuration,fwhmfactor=fwhmfactor)
            if (samplingArcsec == None):
                samplingArcsec = fwhm/samplingFactor
#                print "Set samplingArcsec to %f/%f=%f" % (fwhm,samplingFactor,samplingArcsec)
            if (samplingArcsec < 5*convolutionPixelSize and samplingArcsec > 0):
                convolutionPixelSize = samplingArcsec / 5.0
            if (taper < 0.1):
                print "Using Airy disk truncated at first null instead of Gaussian"
                myxaxis, myfunction = self.buildAiryDisk(fwhm, 3, convolutionPixelSize, truncate=truncate,
                                                         diameter=diameter, obscuration=obscuration)
            else:
                myxaxis = np.arange(-3*fwhm,3*fwhm+0.5*convolutionPixelSize, convolutionPixelSize)
                myfunction = self.gauss(myxaxis,[fwhm,truncate])
        initialFWHM = self.findFWHM(myxaxis,myfunction)
        # find indices of points less than +-35" (for pixelsize=10" and convsupport=3)
        # from VLA scientific memo 129 section 2.  We want function C_m to vanish for
        #  |u| > m delta_u/2,  where m = support width and delta_u = grid size
#        print "myxaxis,supportwidth,pixelsize,xmult = ", myxaxis,supportwidth,pixelsize,xmult
        sfaxis = myxaxis/float(supportwidth*pixelsize*xmult)

        # find indices of points less than +-30" (for pixelsize=10" and convsupport=3)
#        sfaxis = myxaxis/float((supportwidth-1)*pixelsize/2.0)
        indices = np.where(abs(sfaxis)<1)
        centralRegion = sfaxis[indices]
        centralRegionY = self.spheroidalWaveFunction(centralRegion, m=m, n=n, c=c, alpha=alpha)
        mysf = np.zeros(len(myxaxis))
        mysf[indices] += centralRegionY/np.max(centralRegionY)
        if (testOption):
            # emulate SDGrid.cc
            convSampling = 100
            convSize = convSampling*(4*convsupport+2)
            convFunc = np.zeros(convSize)
            nu = np.array(range(convSampling*convsupport)) / float(convsupport*convSampling)
            for i in range(len(nu)):
                convFunc[i] = self.spheroidalWaveFunction(nu[i], m=m, n=n, c=c, alpha=alpha)
            convFuncX = np.array(range(convSize)) / float(convsupport*convSampling)
            if (False):
                pb.clf()
                pb.plot(convFuncX,convFunc,'b-')
            s = 1
            convFuncX = np.append(-convFuncX[::-1],convFuncX[1:])
            convFuncX *= convsupport*pixelsize
            reversed = convFunc[::-1]
            convFunc = np.append(reversed[:-s-1],convFunc[s:])
            convFunc = np.append(np.zeros(s), convFunc)
            convFunc = np.append(convFunc, np.zeros(s))
            centralRegion = convFuncX
            myfunction = self.gauss(convFuncX,[fwhm,truncate])
            if (False):
                pb.plot(convFuncX,convFunc,'g-', convFuncX,myfunction,'k-')
                pb.ylim([-0.1,1.1])
                pb.hold(True)
            myxaxis = convFuncX
            mysf = convFunc
            centralRegionY = convFunc

#        print "max=%g, myxaxis = " % (np.max(myxaxis)), myxaxis
        sfFWHM = self.findFWHM(myxaxis,mysf)
        # convolve beam with SF gridding function
        gridded = spsig.convolve(myfunction, centralRegionY, mode='same')

        # normalize
        gridded = gridded/np.max(gridded)
#        print "FWHM of SF = %f,  SF/sampling=%f,   SF/pixel=%f" % (sfFWHM,sfFWHM/samplingArcsec,sfFWHM/pixelsize)
        griddedFWHM= self.findFWHM(myxaxis,gridded)
        myboxcar = self.buildBoxcar(myxaxis, samplingArcsec)
        boxcarFWHM = self.findFWHM(myxaxis,myboxcar)
        # convolve beam with sampling boxcar
        result = spsig.convolve(gridded, myboxcar, mode='same')
        # normalize
        result /= np.max(result)
        myfwhm = self.findFWHM(myxaxis,result)
        fittedFWHM = {}
        for minlevel in minlevels:
            # Fit a normal Gaussian, not a truncated one!
            fittedFWHM[minlevel], junk = self.gaussfit(myxaxis,result,minlevel=minlevel,truncate=False)
        if (makeplot):
            pb.clf()
            desc = pb.subplot(111)
            halfwidthOfPlot = 2*fwhm
            pb.plot(myxaxis,myfunction,'k',myxaxis,mysf,'b',myxaxis,myboxcar,'g',
                    myxaxis,gridded,'c', myxaxis,result,'r',
                    [-halfwidthOfPlot,halfwidthOfPlot],[0.5,0.5],'k:',
                    myxaxis,self.gauss(myxaxis,fittedFWHM[0.0]),'m')
            pb.xlabel('Offset (arcsec)')
            pb.xlim([-halfwidthOfPlot, halfwidthOfPlot])
            desc.yaxis.set_major_locator(MultipleLocator(0.1))
            desc.xaxis.set_minor_locator(MultipleLocator(2))
            pb.ylim([-0.02,1.02])
            mysize = 11
            if (img != None):
                pb.text(0.5,1.06,os.path.basename(img), color='k', transform=desc.transAxes, ha='center')
                if (row != None):
                    pb.text(0.021,0.95,'using image cut as beam (row=%d)'%(row),color='k', transform=desc.transAxes, size=mysize)
                else:
                    pb.text(0.021,0.95,'using image cut as beam (column=%d)'%(column),color='k', transform=desc.transAxes, size=mysize)
                pb.text(0.021,0.90,'unscaled FWHM of cut = %.3f"' % (initialFWHM/imgScaling), color='k', transform=desc.transAxes,size=mysize) 
            else:
                pb.text(0.021,0.95,'desired PB FWHM = %.2f"'%(fwhm), color='k', transform=desc.transAxes,size=mysize)
                if (truncate != False):
                    pb.text(0.021,0.90,'truncated at %.2f'%(truncate), color='k', transform=desc.transAxes,size=mysize)
                else:
                    pb.text(0.021,0.90,'not truncated', color='k', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.85,'achieved PB FWHM = %.3f"'%(initialFWHM), color='k', transform=desc.transAxes, size=mysize)
            pb.text(0.651,0.95,'pixel spacing = %.2f"'%(pixelsize), transform=desc.transAxes, size=mysize)
            pb.text(0.651,0.90,'frequency = %.2f GHz'%(frequency), transform=desc.transAxes, size=mysize)
            pb.text(0.021,0.80,'SF FWHM = %.2f"'%(sfFWHM), color='b', transform=desc.transAxes, size=mysize)
            pb.text(0.021,0.75,'gridded FWHM = %.2f"'%(griddedFWHM), color='c', transform=desc.transAxes, size=mysize)
            pb.text(0.021,0.70,'desired sampling = %.2f"'%(samplingArcsec), color='g', transform=desc.transAxes, size=mysize)
            pb.text(0.021,0.65,'achieved sampling = %.2f"'%(boxcarFWHM), color='g', transform=desc.transAxes, size=mysize)
            pb.text(0.021,0.60,'final FWHM = %.2f"'%(myfwhm), color='r', transform=desc.transAxes, size=mysize)
            pb.text(0.021,0.55,'Gaussfit FWHM = %.2f"'%(fittedFWHM[0.0]), color='m', transform=desc.transAxes, size=mysize)
            pb.title('SF: m=%d, n=%d, c=%.2f$\pi$/2=%f' % (m,n,c*2/np.pi,c))
            pb.draw()
            if (plotfile == ''):
                png = 'sfBeam.png'
            else:
                png = plotfile
            pb.savefig(png)
            print "Plot left in %s" % (png)
        if (returnProfile):
            return(myxaxis, mysf, result, samplingArcsec, myfwhm)
        else:
            return(fwhm, myfwhm, samplingArcsec, fittedFWHM)
        
    def sfBeamSequence(self, c=7*np.pi/2., nvals=7):
        """
        Plots a sequence of prolate spheroidal wave functions at a given value
        of c for 7 values of m=n, starting at zero.
        """
        inc = 0.001
        x = np.arange(-1+inc,1,inc)
        pb.clf()
        desc = pb.subplot(111)
        pb.hold(True)
        col = ['k','b','c','g','y','r','m']
        col += col
        for m in range(nvals):
            n = m
            y = self.spheroidalWaveFunction(x,m=m,n=m,c=c)
            y = y/np.max(y)
            pb.plot(x,y,col[m])
#  Fred Schwab and I spot-checked values here with his Mathematica code.
#            for i in range(len(x)):
#                print "x[%d]=%f, y[%d]=%f" % (i,x[i],i,y[i])
            pb.text(0.1,0.9-m*0.1,'m=%d'%m,transform=desc.transAxes,color=col[m])
        pb.title('scipy.special.pro_ang1_cv(m=n, c=%.2f)' % (c))
        pb.draw()
        png = 'sfBeamSequence.png'
        pb.savefig(png)
        print "Plot left in %s" % (png)
    
    def gjincBeamPredict(self, frequency, pixelsize=10, diameter=12.0, 
                         samplingFactor=2.5, samplingArcsec=None, 
                         makeplot=False, taper=10, obscuration=0.75,
                         widthMultiplier=1.0, convolutionPixelSize=0.02, 
                         useCasaJinc=False, testOption=False, minlevels=[0],
                         truncate=False, img=None, row=None,
                         column=None, stokes='XX',plotfile='',
                         returnProfile=False, fwhmfactor=None):
        """
        This function computes the effective restoring beam obtained from
        sd_imaging when using the GJINC gridding kernel assuming the GJINC
        specific parameters are left at their default values.
        
        frequency: floating point number in GHz (no units) or string with units
        pixelsize: floating point number in arcseconds (no units)
        diameter: the diameter of the single dish antenna in meters (no units)
        samplingFactor: the number of sampled points per telescope FWHM
        samplingArcsec: if given, then use this instead of FWHM/samplingFactor
        taper: the illumination taper in dB to pass to au.primaryBeamArcsec
               if zero, then it uses an Airy function as the antenna beam,
               otherwise it uses a Gaussian
        obscuration: diameter in m to pass to au.primaryBeamArcsec
        widthMultiplier: the value by which to multiply the default values of 
                         gwidth/jwidth
        convolutionPixelSize: size of pixels in the model (if samplingArcsec 
                              is smaller than 5 times this default value, then 
                              the default value will be reduced accordingly)
        minlevels: a list of values above which to perform 1D Gaussian fits
        truncate: if taper=0, sets whether to truncate Airy at the first null
                  if taper>0, sets the intensity level at which to truncate 
                              the Gaussian

        Returns:
        if returnProfile == False, then 4 values (all in arcsec)
            the FWHM size of the theoretical beam,
            the effective restoring beam,
            the sampling rate,
            the 1D Gaussian-fitted FWHM
            the radius of the null of the GJinc function (in image pixels)
        If returnProfile == True, then 5 values:
           myxaxis: x-axis (angle)
           mygjinc: the function used (intensity)
           result: y-axis after convolution w/ GJinc and the boxcar (intensity)
           samplingArcsec: the sampling rate
           myfwhm: the effective restoring beam (dictionary keyed by minlevel, e.g. 0)
           radiusOfNullInPixels: the radius of the null of the GJinc function 
                                 (in image pixels)
    
        - Todd Hunter
        """
        if (type(frequency) == str):
            frequency = parseFrequencyArgument(frequency)*1e-9
        fwhm = primaryBeamArcsec(frequency=frequency, diameter=diameter, 
                                 taper=taper, obscuration=obscuration, 
                                 showEquation=False, fwhmfactor=fwhmfactor)
        if (samplingArcsec == None):
            samplingArcsec = fwhm/(1.0*samplingFactor)
        if (samplingArcsec < 5*convolutionPixelSize and samplingArcsec > 0):
            convolutionPixelSize = samplingArcsec / 5.0
        jwidth = 1.55*pixelsize*widthMultiplier
        # casa default gwidth=-1, which means 2.52*sqrt(log(2)) * pixel
        gwidth = 2.52*pixelsize*widthMultiplier*(np.log(2)**0.5)
        if (img != None):
#            print "Using beam profile from image"
            myxaxis, myfunction, row, column, imgfreq = extractCutFromImage(img,row=row,column=column,stokes=stokes,interpolate=True)
            frequencyHz = frequency*1.0e9
            if (imgfreq != 0):
                imgScaling = imgfreq/frequencyHz
                myxaxis *= imgfreq/frequencyHz
            npixels = len(myxaxis)
#            print "Peak=%f at x=%f" % (np.max(myfunction),myxaxis[np.argmax(myfunction)])
        elif (taper < 0.1):
            print "Using Airy disk truncated at first null instead of Gaussian"
            myxaxis, myfunction = self.buildAiryDisk(fwhm, 3, convolutionPixelSize, truncate=truncate,
                                                     diameter=diameter, obscuration=obscuration)
        else:
            myxaxis = np.arange(-3*fwhm,3*fwhm+0.5*convolutionPixelSize, convolutionPixelSize)
            myfunction = self.gauss(myxaxis,[fwhm,truncate])
        convSize = len(myxaxis)

        # for plotting purposes only
        initialFWHM = self.findFWHM(myxaxis,myfunction)
        casajinc = self.grdjinc1(myxaxis, jwidth, normalize=False)
        myjinc = self.jinc(myxaxis, jwidth)
        jincFWHM = self.findFWHM(myxaxis,myjinc)
        mygjincGauss = self.gjincGauss(myxaxis, gwidth)
        gjincGaussFWHM = self.findFWHM(myxaxis,mygjincGauss)

        mygjinc = self.trunc(self.gjinc(myxaxis, gwidth=gwidth, jwidth=jwidth, useCasaJinc=useCasaJinc, normalize=False))
        edgePixel = np.where(mygjinc > 0)[0][0]
        centerPixel = len(mygjinc)/2
        widthInPixels = 2*(centerPixel-edgePixel)
        radiusOfNullInPixels = (centerPixel-edgePixel)*convolutionPixelSize/pixelsize
        
        gjincFWHM = self.findFWHM(myxaxis, mygjinc)
        gridded = spsig.convolve(myfunction, mygjinc, mode='same')
        # normalize
        gridded /= np.max(gridded)
        griddedFWHM = self.findFWHM(myxaxis,gridded)
        myboxcar = self.buildBoxcar(myxaxis, samplingArcsec)
        boxcarFWHM = self.findFWHM(myxaxis, myboxcar)
        result = spsig.convolve(gridded, myboxcar, mode='same')
        # normalize
        result /= np.max(result)
        myfwhm = self.findFWHM(myxaxis,result)
        fittedFWHM = {}
        for minlevel in minlevels:
            # Fit a normal Gaussian, not a truncated one!
            fittedFWHM[minlevel], junk = self.gaussfit(myxaxis,result,minlevel=minlevel,truncate=False)
        if (makeplot):
            pb.clf()
            desc = pb.subplot(111)
            halfwidthOfPlot = 2*fwhm
            pb.plot(myxaxis,myfunction,'k', myxaxis,myjinc,'m', #  myxaxis,casajinc,'k',
                    myxaxis,mygjincGauss,'c', myxaxis,mygjinc,'b',
                    myxaxis,myboxcar,'g' ,myxaxis,gridded,'y', myxaxis,result,'r',
                    [-halfwidthOfPlot,halfwidthOfPlot],[0.5,0.5],'k:',
                    myxaxis,self.gauss(myxaxis,fittedFWHM[0.0]),'m')
            pb.xlabel('Offset (arcsec)')
            pb.xlim([-halfwidthOfPlot,halfwidthOfPlot])
            desc.yaxis.set_major_locator(MultipleLocator(0.1))
            desc.xaxis.set_minor_locator(MultipleLocator(2))
            mysize = 11
            pb.ylim([-0.1,1.02])
            pb.text(0.651,0.95,'pixel spacing = %.2f"'%(pixelsize), transform=desc.transAxes, size=mysize)
            pb.text(0.651,0.90,'frequency = %.2f GHz'%(frequency), transform=desc.transAxes, size=mysize)
            if (img != None):
                pb.text(0.5,1.06,os.path.basename(img), color='k', transform=desc.transAxes, ha='center')
                if (row != None):
                    pb.text(0.021,0.95,'using image cut as beam (row=%d)'%(row),color='k', transform=desc.transAxes,size=mysize)
                else:
                    pb.text(0.021,0.95,'using image cut as beam  (column=%d)'%(column),color='k', transform=desc.transAxes,size=mysize)
                pb.text(0.021,0.90,'unscaled FWHM of image = %.2f"' % (initialFWHM/imgScaling), color='k', transform=desc.transAxes,size=mysize) 
            else:
                pb.text(0.021,0.95,'desired PB FWHM = %.2f'%(fwhm), color='k', transform=desc.transAxes, size=mysize)
                if (truncate != False):
                    pb.text(0.021,0.90,'truncated at %.2f"'%(truncate), color='k', transform=desc.transAxes, size=mysize)
                else:
                    pb.text(0.021,0.90,'not truncated', color='k', transform=desc.transAxes, size=mysize)
            pb.text(0.021,0.85,'achieved PB FWHM = %.2f"'%(initialFWHM), color='k', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.80,'Jinc FWHM = %.2f"'%(jincFWHM), color='m', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.75,'Gauss FWHM = %.2f"'%(gjincGaussFWHM), color='c', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.70,'GJinc FWHM = %.2f"'%(gjincFWHM), color='b', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.65,'gridded FWHM = %.2f"'%(griddedFWHM), color='y', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.60,'desired sampling = %.2f"'%(samplingArcsec), color='g', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.55,'sampling = %.2f"'%(boxcarFWHM), color='g', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.50,'final FWHM = %.2f"'%(myfwhm), color='r', transform=desc.transAxes,size=mysize)
            pb.text(0.021,0.45,'Gaussfit FWHM = %.2f"'%(fittedFWHM[0.0]), color='m', transform=desc.transAxes,size=mysize)
            pb.title('GJinc: jwidth=%f, gwidth=%f' % (jwidth, gwidth))
            pb.draw()
            if (plotfile == ''):
                png = 'gjincBeam.png'
            else:
                png = plotfile
            pb.savefig(png)
            print "Plot left in %s" % (png)
        if (returnProfile):
            return(myxaxis, mygjinc, result, samplingArcsec, fittedFWHM, radiusOfNullInPixels)
        else:
            return(fwhm, myfwhm, samplingArcsec, fittedFWHM, radiusOfNullInPixels)

def effectiveTaper(fwhmFactor=1.16, diameter=12, obscuration=0.75, 
                   use2007formula=True):
    """
    The inverse of (Baars formula multiplied by the central
    obstruction factor).  Converts an observed value of the constant X in
    the formula FWHM=X*lambda/D into a taper in dB (positive value).
    if use2007formula == False, use Equation 18 from ALMA Memo 456     
    if use2007formula == True, use Equation 4.13 from Baars 2007 book
    -- Todd Hunter
    """
    cOF = centralObstructionFactor(diameter, obscuration)
    if (fwhmFactor < 1.02 or fwhmFactor > 1.22):
        print "Invalid fwhmFactor (1.02<fwhmFactor<1.22)"
        return
    if (baarsTaperFactor(10,use2007formula)*cOF<fwhmFactor):
        increment = 0.01
        for taper_dB in np.arange(10,10+increment*1000,increment):
            if (baarsTaperFactor(taper_dB,use2007formula)*cOF-fwhmFactor>0): break
    else:
        increment = -0.01
        for taper_dB in np.arange(10,10+increment*1000,increment):
            if (baarsTaperFactor(taper_dB,use2007formula)*cOF-fwhmFactor<0): break
    return(taper_dB)

def baarsTaperFactor(taper_dB, use2007formula=True):
    """
    Converts a taper in dB to the constant X
    in the formula FWHM=X*lambda/D for the parabolic illumination pattern.
    We assume that taper_dB comes in as a positive value.
    use2007formula:  False --> use Equation 18 from ALMA Memo 456.
                     True --> use Equation 4.13 from Baars 2007 book
    - Todd Hunter
    """
    tau = 10**(-0.05*taper_dB)
    if (use2007formula):
        return(1.269 - 0.566*tau + 0.534*(tau**2) - 0.208*(tau**3))
    else:
        return(1.243 - 0.343*tau + 0.12*(tau**2))

def goldsmithTaperFactor(taper_dB):
    """
    Equation 67 from Goldsmith 2002 single dish summer school lecture book.
    Converts a taper in dB to the constant X in the formula FWHM=X*lambda/D for
    Gaussian illumination pattern.  We assume that taper_dB comes in as a
    positive value.
    - Todd Hunter
    """
    return(1.02 + 0.0135*taper_dB)

def centralObstructionFactor(diameter=12.0, obscuration=0.75):
    """
    Computes the scale factor of an Airy pattern as a function of the
    central obscuration, using Table 10.1 of Schroeder's "Astronomical Optics".
    -- Todd Hunter
    """
    epsilon = obscuration/diameter
    myspline = scipy.interpolate.UnivariateSpline([0,0.1,0.2,0.33,0.4], [1.22,1.205,1.167,1.098,1.058], s=0)
    factor = myspline(epsilon)/1.22
    if (type(factor) == np.float64):
        # casapy 4.2
        return(factor)
    else:
        # casapy 4.1 and earlier
        return(factor[0])
    
def primaryBeamArcsec(vis='', spw='', frequency='',wavelength='',
                      diameter=12.0, taper=10.0, obscuration=0.75,
                      verbose=False, showEquation=True, use2007formula=True,
                      fwhmfactor=None):
    """
    Implements the Baars formula: b*lambda / D.
      if use2007formula==False, use the formula from ALMA Memo 456        
      if use2007formula==True, use the formula from Baars 2007 book
        (see au.baarsTaperFactor)     
      In either case, the taper value is expected to be entered as positive.
        Note: if a negative value is entered, it is converted to positive.
    The effect of the central obstruction on the pattern is also accounted for
    by using a spline fit to Table 10.1 of Schroeder's Astronomical Optics.
    The default values correspond to our best knowledge of the ALMA 12m antennas.
      diameter: outer diameter of the dish in meters
      obscuration: diameter of the central obstruction in meters
      fwhmfactor: if given, then ignore the taper
    Specify one of the following combinations:
    0) vis and spw (uses median dish diameter)
    1) vis (uses median freq of OBSERVE_TARGET spws, and median dish diameter)
    2) frequency in GHz (assumes 12m)
    3) wavelength in mm (assumes 12m)
    4) frequency in GHz and diameter (m)
    5) wavelength in mm and diameter (m)
    For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/PrimaryBeamArcsec
    -- Todd Hunter
    """
    if (type(vis) != str):
        print "The first argument of primaryBeamArcsec is vis, which must be a string."
        print "Use frequency=100 or frequency='100GHz' to request 100 GHz."
        return
    if (fwhmfactor != None):
        taper = effectiveTaper(fwhmfactor,diameter,obscuration,use2007formula)
        if (taper == None): return
    if (taper < 0):
        taper = abs(taper)
    if (obscuration>0.4*diameter):
        print "This central obscuration is too large for the method of calculation employed here."
        return
    if (vis != ''):
      try:
          antennaTable = vis+'/ANTENNA'
          tb.open(antennaTable)
      except:
          print "Could not open table = %s" % antennaTable 
          return(0)
      diameter = np.median(np.unique(tb.getcol('DISH_DIAMETER')))
      print "Median dish diameter = %.1fm" % (diameter)
      tb.close()
      if (spw != ''):
        try:
            spwTable = vis+'/SPECTRAL_WINDOW'
            tb.open(spwTable)
            num_chan = tb.getcol('NUM_CHAN')
            refFreqs = tb.getcol('REF_FREQUENCY')
            tb.close()
        except:
            print "Could not open table = %s" % antennaTable 
            return(0)
        frequencyHz = refFreqs[spw]
        frequency = frequencyHz*1e-9
        if (verbose):
            print "Found frequency = %f GHz and dish diameter = %.1fm" % (frequency,diameter)
      else: # only the vis was given
          frequencyHz = medianFrequencyOfIntent(vis)
          frequency = frequencyHz * 1e-9
          print "Median OBSERVE_TARGET frequency = %.3f GHz" % (frequency)
    else:
        if (frequency != '' and wavelength != ''):
            print "You must specify either frequency or wavelength, not both!"
            return(0)
    if (frequency != ''):
        if (type(frequency) == str):
            frequency = parseFrequencyArgument(frequency)
        elif (frequency < 10000):
            frequency *= 1e9
        lambdaMeters = c_mks/frequency
    elif (wavelength != ''):
        lambdaMeters = wavelength*0.001
    else:
        print "You must specify either frequency (in GHz or a string with units) or wavelength (in mm)"
        return(0)
#  print "wavelength = %.3f mm" % (lambdaMeters*1000)
    b = baarsTaperFactor(taper,use2007formula) * centralObstructionFactor(diameter, obscuration)
    if (showEquation):
        if (use2007formula):
            formula = "Baars (2007) Eq 4.13"
        else:
            formula = "ALMA memo 456 Eq. 18"
        print "Coefficient from %s for a -%.1fdB edge taper and obscuration ratio=%g/%g = %.3f*lambda/D" % (formula, taper, obscuration, diameter, b)
    return(b*lambdaMeters*3600*180/(diameter*math.pi))

def imageCentroid(imgfile, threshold=0, axis3channel=None, axis4channel=None):
    """
    Computes the statistics and center of mass of a casa image using
    scipy.ndimage.measurements.center_of_mass.
    threshold: the pixel value below which to ignore when computing the centroid
    axis3channel: which channel to use on 3rd axis (default=all)
    axis4channel: which channel to use on 4th axis (default=all)
    Returns:
    a tuple of the X,Y coordinates of the centroid
    -Todd Hunter
    """
    if (os.path.exists(imgfile) == False):
        print "Could not locate image file: ", imgfile
        return
    if (threshold < 0):
        print "Only zero or positive thresholds are supported."
        return
    casaimage.open(imgfile)
    if (axis3channel==None):
        allpixels=(casaimage.getchunk()).squeeze()
    else:
        ndim = len(np.shape(casaimage.getchunk()))
        blc = np.zeros(ndim)
        trc = np.zeros(ndim)
        trc[:2] = -1
        if (ndim > 2):
            blc[2] = axis3channel
            trc[2] = axis3channel
            if (ndim > 3):
                if (axis4channel != None):
                    blc[3] = axis4channel
                    trc[3] = axis4channel
                else:
                    trc[3] = -1
        allpixels = casaimage.getchunk(blc,trc)
        
    casaimage.close()
    if (threshold > 0):
        allpixels -= threshold
        idx = np.where(allpixels < 0)
        allpixels += threshold
        allpixels[idx] = 0
    idx = np.where(allpixels > 0)
    if (len(idx[0]) < 1):
        print "No positive pixels remain."
        return
    print "Image statistics: mean=%f median=%f max=%f min=%f" % (np.mean(allpixels), np.median(allpixels),
                                                                 np.max(allpixels), np.min(allpixels))
    result = ndimage.measurements.center_of_mass(allpixels)
    return(result)
    
def getfwhm(imgfile,pkXmin='min',pkXmax='max',pkYmin='min',pkYmax='max',
            pixelSize=None, axis3channel=0, axis4channel=0, plotfile=None, 
            ignoreIdenticalZeros=True, plotrange=[0,0,0,0], gaussian=None, 
            showlog=False, plotrange2=[0,0,0,0]):
    """
    Directly estimate the actual FWHM of the CASA image provided, with no 
    assumption about shape except that the function has a well defined peak 
    and is approximately azimuthally symmetric.  It takes the average of two 
    median values: the median radius of the first 5 points above half-power, 
                   and the first 5 points below half-power.
    INPUT:
    imgfile - a CASA image
    OPTIONAL INPUT
    pk{X,Y}{min,max} - pixel coordinate range (integers) within which to search
         for peak and FWHM. so long as this region contains the peak and the 
         half max point, you should get reasonable results. (default is to 
         consider all pixels)
    pixelSize - if None, use value from image header (supports deg or rad units)
    axis3channel - which channel of the cube to use (if naxis>2) 
    axis4channel - which channel of the cube to use (if naxis>3)
    plotfile - if True, or a string, then write a png file
    plotrange2 - [xmin, xmax, ymin, ymax] 
    gaussian - the FWHM of a Gaussian profile to overlay on the plot
    showlog - show the log of the pixel values in a second panel
    plotrange2 - [xmin, xmax, ymin, ymax] for the log plot 
    RETURN
    full width half max in pixels (or in units of pixel size that was specified)
    SIDE EFFECTS
    opens an interactive matplotlib window
    
    EXAMPLE
    getfwhm('uid3/best.tp.image',pixelSize=0.2)
    
    v1 B.Mason 23aug2013
    """
    radiusUnits=''
    if (os.path.exists(imgfile) == False):
        print "Image not found"
        return
    if (pixelSize == None):
        radiusUnits='(arcsec)'
        try:
            f = imhead(imgfile, mode='list')
            units = f['cunit1']
            pixelSize = abs(f['cdelt1'])
            pixelSize2 = abs(f['cdelt2'])
        except:
            # if the image has no frequency axis, then this might still work
            units = imhead(imgfile,mode='get',hdkey='cunit1')
            pixelSize = abs(imhead(imgfile,mode='get',hdkey='cdelt1')['value'])
            pixelSize2 = abs(imhead(imgfile,mode='get',hdkey='cdelt2')['value'])
        arseconds=True
        if (units.lower().find('deg') >= 0):
            pixelSize *= 3600
            pixelSize2 *= 3600
        elif (units.lower().find('rad') >= 0):
            pixelSize *= 3600*180/np.pi
            pixelSize2 *= 3600*180/np.pi
        elif (units.lower().find('arcsec') < 0):
            print "Unrecognized pixel units in header: %s (assuming arcsec)" % (units)
        if (pixelSize != pixelSize2):
            print "WARNING: the pixels are not square!"
        pixelSize = (pixelSize*pixelSize2)**0.5
        print "Got pixelSize = %f arcsec" % (pixelSize)
    casaimage.open(imgfile)
    allpixels=(casaimage.getchunk()).squeeze()
    casaimage.close()
    naxis = len(np.shape(allpixels))
    naxis1 = np.shape(allpixels)[0]
    nx=(allpixels.shape)[0]
    ny=(allpixels.shape)[1]
    if pkXmin=='min':
        pkXmin=0
    if pkXmax=='max':
        pkXmax=nx-1
    if pkYmin=='min':
        pkYmin=0
    if pkYmax=='max':
        pkYmax=ny-1
    # restrict the set considered
    # --fix: squeeze out singleton dimensions of these arrays-
    if (naxis == 4):
        pixels=(allpixels[pkXmin:pkXmax,pkYmin:pkYmax,axis3channel:axis3channel+1,axis4channel:axis4channel+1]).squeeze()
    elif (naxis == 3):
        pixels=(allpixels[pkXmin:pkXmax,pkYmin:pkYmax,axis3channel:axis3channel+1]).squeeze()
    else:
        pixels=(allpixels[pkXmin:pkXmax,pkYmin:pkYmax]).squeeze()
    # this is code for an automatic edit that didn't work very
    # robustly - you're better off restricting the analyzed area
    #if cut > 0.0:
    # medval=np.median(pixels)
    # sigma=np.mean(np.abs( pixels - medval))
    # pixels[np.where( abs(pixels - medval) > cut*sigma)]=medval
    nx=(pixels.shape)[0]
    ny=(pixels.shape)[1]
    pkval=pixels.max()
    # construct an array of radius values from
    # the peak pixel
    coords=pixels
    xvals=(np.tile(np.arange(nx),(ny,1))).transpose()
    yvals=np.tile(np.arange(ny),(nx,1))
#    print "shape(xvals)=%s, shape(yvals)=%s shape(pixels)=%s" % (str(np.shape(xvals)), str(np.shape(yvals)), str(np.shape(pixels)))
    # allow for more than one pixel matching the peak value
    #indices = np.where(pixels == np.max(pixels))[0]
    # --fix:
    indices = np.where(pixels == np.max(pixels))
    xmax=np.median(xvals[indices])
    ymax=np.median(yvals[indices])
    # report physical coords in full image-
    print " Max found at pixel ",xmax+pkXmin," ",ymax+pkYmin
    r=np.sqrt( (xvals-xmax)**2 + (yvals-ymax)**2)*pixelSize
    # estimate two ways and average
    #fwhm= 2.0*0.5* (np.max( r[np.where(pixels > 0.5*pkval)[0]] ) + np.min( r[np.where(pixels < 0.5*pkval)[0]] ))
    # --fix:
    #fwhm= 2.0*0.5* (np.max( r[np.where(pixels > 0.5*pkval)] ) + np.min( r[np.where(pixels < 0.5*pkval)] ))
    # --fix2 (better estimate) - median of the 5 pixels on either size of 0.5xpeak
    rinner=np.sort(r[np.where(pixels>0.5*pkval)])
    if (ignoreIdenticalZeros):
        lowValues = np.where(np.logical_and(pixels<0.5*pkval, pixels!=0))
    else:
        lowValues = np.where(pixels<0.5*pkval)
    router=np.sort(r[lowValues])
    nValues = 5
    if (rinner.size > nValues and router.size > nValues):
        fwhm= 2.0*0.5* ( np.median(rinner[rinner.size-1-nValues:rinner.size-1]) + np.median(router[0:nValues]))
    print " peak = ", pkval
#    print "max r > 0.5*pk = ",np.max(r[np.where(pixels>0.5*pkval)])
#    print "min r < 0.5*pk = ",np.min(r[np.where(pixels<0.5*pkval)])
#    print "fwhm = ", fwhm
    # make a plot
    x = r.reshape(r.size)
    y = pixels.reshape(pixels.size)/pkval
#    print "shape(x)=%s, shape(y)=%s" % (str(np.shape(x)), str(np.shape(y)))
    plt.clf()
    if (showlog):
        fig = plt.gcf()
        ax = fig.add_subplot(1,2,1)
    p1 = plt.plot(x,y,'b.',[r.min(),r.max()],[0.5,0.5],'r',[fwhm*0.5,fwhm*0.5],[0.0,1.0],'g')
    if (plotrange[:2] != [0,0]):
        pb.xlim(plotrange[:2])
    else:
        pb.xlim([0,np.max(r)*1.15])
    if (gaussian != None):
        plt.hold(True)
        gx = np.arange(0,pb.xlim()[1],pb.xlim()[1]*0.01)
        gy = np.exp(-gx**2/(2*(gaussian/2.35482)**2))
        plt.plot(gx,gy,'m-')
    if (plotrange[2:] != [0,0]):
        pb.ylim(plotrange[2:])
    else:
        pb.ylim([np.min([0,np.min(y)]), 1.05])        
    plt.xlabel('radius %s' % radiusUnits)
    plt.ylabel('pixel value')
    
    plt.title(os.path.basename(imgfile))
    if (showlog==False):
        plt.legend(p1,["data","0.5","estimated HWHM (FWHM=%.2f%s)"%(fwhm,radiusUnits.strip(')').strip('('))])
    else:
        plt.text(0.08,0.96,"estimated HWHM (FWHM=%.2f%s)"%(fwhm,radiusUnits.strip(')').strip('(')),size=9,transform=gca().transAxes,color='g')
        ax = fig.add_subplot(1,2,2)
        plt.subplots_adjust(wspace=0.3)
        p1 = plt.plot(x,y,'b.', [r.min(),r.max()],[0.5,0.5],'r', [fwhm*0.5,fwhm*0.5],[1e-5,1.0],'g')
        ax.set_yscale('log')
        plt.xlabel('radius %s' % radiusUnits)
        plt.ylabel('log(pixel value)')
        if (plotrange[:2] != [0,0]):
            pb.xlim(plotrange[:2])
        else:
            pb.xlim([0,np.max(r)*1.15])
        if (gaussian != None):
            plt.hold(True)
            plt.text(0.5,0.92,'Gaussian %.2f"'%(gaussian),size=9,transform=gca().transAxes,color='m')
            x = np.arange(0,pb.xlim()[1],pb.xlim()[1]*0.01)
            y = np.exp(-x**2/(2*(gaussian/2.35482)**2))
            plt.plot(x,y,'m-')
            if (plotrange2[:2] != [0,0]):
                pb.xlim(plotrange2[:2])
            else:
                pb.xlim([0,np.max(r)*1.15])
            if (plotrange2[2:] != [0,0]):
                pb.ylim(plotrange2[2:])
            else:
                pb.ylim([np.min([0,np.min(y)]), 1.05])        

    if (plotfile != None):
        if (plotfile == True):
            # automatic naming convention
            plotfile = '%s.getfwhm.png' % (os.path.basename(imgfile))
        plt.savefig(plotfile)
        print "Plot saved in %s" % (plotfile)
    return fwhm 

def averageTheRepeatedValues(x, y, median=False, returnStdev=False):
    """
    Accepts paired lists and averages the entries that have the same x value,
    where the x value can be a string or integer or float.
    median: if True, then take the median (and MAD) rather than mean (and stdev)
    returnStdev: if True, also return the standard deviation (or MAD)
    Returns: x, y, and optionally the standardDeviation (or MAD)
    -Todd Hunter
    """
    x = np.array(x)
    y = np.array(y)
    result_x = np.unique(x)
    lenx = len(result_x)
    result_y = np.empty(result_x.shape)
    if (returnStdev):
        stdev_y = np.empty(result_x.shape)
    for i, newx in enumerate(result_x):
#        if (i%100 == 0): print "done %d/%d" % (i,lenx)
        idx = np.where(x == newx)
        if (median):
            result_y[i] = np.median(y[idx])
            if (returnStdev):
                stdev_y[i] = MAD(y[idx])
        else:
            result_y[i] = np.mean(y[idx])
            if (returnStdev):
                stdev_y[i] = np.std(y[idx])
    if (returnStdev):
        return result_x, result_y, stdev_y
    else:
        return result_x, result_y
                        
def getfwhm2(imgfile,pkXmin='min',pkXmax='max',pkYmin='min',pkYmax='max',
             pixelSize=None, axis3channel=0, axis4channel=0, plotfile=None,
             ignoreIdenticalZeros=True, maxRadius=-1, plotrange=[0,0,0,0],
             initialPlot=False,s=0,gaussian=None,showlog=False,
             plotrange2=[0,0,0,0],centroid=False,threshold=0,showplot=False):
    """
    Directly estimate the actual FWHM of the CASA image provided, with no
    assumption about shape except that the function has a well defined peak
    and is approximately azimuthally symmetric.  It finds the peak, subtracts
    half, then solves for the zero crossing, and doubles the result.
    - Todd Hunter
    INPUT:
    imgfile - a CASA image
    OPTIONAL INPUT
    pk{X,Y}{min,max} - pixel coordinate range (integers) within which to search for peak
    and FWHM. So long as this region contains the peak and the half max point
    you should get reasonable results. (default is to consider all pixels)
    pixelSize - if None, use value from image header (supports deg or rad units)
    axis3channel - which channel of the cube to use (if naxis>2) 
    axis4channel - which channel of the cube to use (if naxis>3)
    plotfile - if True, or a string, then write a png file
    maxRadius - set this to limit the area searched for the half-power (in arcsec), 
                which is useful for large images of a small source
    initialPlot: stop after making an initial plot of the radially averaged data
    s: the positive smoothing factor to pass to scipy.interpolate.UnivariateSpline
    gaussian - the FWHM of a Gaussian profile to overlay on the plot
    showlog - show the log of the pixel values in a second panel
    plotrange2 - [xmin, xmax, ymin, ymax] for the log plot
    centroid - if True, call imageCentroid to find the (fractional) pixel
    threshold - value (in % of peak) below which to ignore in imageCentroid
    RETURN
    full width half max in pixels (or in units of the pixel size that was
    specified)
    SIDE EFFECTS
    opens an interactive matplotlib window
    
    EXAMPLE
    getfwhm2('uid3/best.tp.image',pixelSize=0.2)
    """
    radiusUnits=''
    if (os.path.exists(imgfile) == False):
        print "Image not found"
        return
    if (pixelSize == None):
        radiusUnits='(arcsec)'
        units = imhead(imgfile,mode='get',hdkey='cunit1')
        if (type(units) == 'dict'):
            units = units['value']
        pixelSize = abs(imhead(imgfile,mode='get',hdkey='cdelt1')['value'])
        pixelSize2 = abs(imhead(imgfile,mode='get',hdkey='cdelt2')['value'])
        arseconds=True
        print "units = ", units
        if (units.lower().find('deg') >= 0):
            pixelSize *= 3600
            pixelSize2 *= 3600
        elif (units.lower().find('rad') >= 0):
            pixelSize *= 3600*180/np.pi
            pixelSize2 *= 3600*180/np.pi
        elif (units.lower().find('arcsec') < 0):
            print "Unrecognized pixel units in header: %s (assuming arcsec)" % (units)
        if (pixelSize != pixelSize2):
            print "WARNING: the pixels are not square!"
        pixelSize = (pixelSize*pixelSize2)**0.5
        print "Got pixelSize = %f arcsec" % (pixelSize)
    casaimage.open(imgfile)
    allpixels=(casaimage.getchunk()).squeeze()
    casaimage.close()
    naxis = len(np.shape(allpixels))
    naxis1 = np.shape(allpixels)[0]
    nx=(allpixels.shape)[0]
    ny=(allpixels.shape)[1]
    if pkXmin=='min':
        pkXmin=0
    if pkXmax=='max':
        pkXmax=nx-1
    if pkYmin=='min':
        pkYmin=0
    if pkYmax=='max':
        pkYmax=ny-1
    # restrict the set considered
    # --fix: squeeze out singleton dimensions of these arrays-
    if (naxis == 4):
        pixels=(allpixels[pkXmin:pkXmax,pkYmin:pkYmax,axis3channel:axis3channel+1,axis4channel:axis4channel+1]).squeeze()
    elif (naxis == 3):
        pixels=(allpixels[pkXmin:pkXmax,pkYmin:pkYmax,axis3channel:axis3channel+1]).squeeze()
    else:
        pixels=(allpixels[pkXmin:pkXmax,pkYmin:pkYmax]).squeeze()
    nx=(pixels.shape)[0]
    ny=(pixels.shape)[1]
    pkval=pixels.max()
    # construct an array of radius values from
    # the peak pixel
    xvals=(np.tile(np.arange(nx),(ny,1))).transpose()
    yvals=np.tile(np.arange(ny),(nx,1))
#    print "shape(xvals)=%s, shape(yvals)=%s shape(pixels)=%s" % (str(np.shape(xvals)), str(np.shape(yvals)), str(np.shape(pixels)))
    if (centroid):
        threshold = pkval*threshold*0.01
        result = imageCentroid(imgfile,threshold,axis3channel,axis4channel)
        if (len(result) == 2):
            xmax, ymax = result
        elif (len(result) == 3):
            xmax, ymax, axis3max = result
        elif (len(result) == 4):
            xmax, ymax, axis3max, axis4max = result
        else:
            print "Too many axes in this image."
            return
    else:
        # allow for more than one pixel matching the peak value
        indices = np.where(pixels == np.max(pixels))
        xmax = np.median(xvals[indices])
        ymax = np.median(yvals[indices])
    # report physical coords in full image-
    print " Max found at pixel ",xmax+pkXmin," ",ymax+pkYmin
    r = np.sqrt( (xvals-xmax)**2 + (yvals-ymax)**2)*pixelSize
    x = r.reshape(r.size)
    y = pixels.reshape(pixels.size)/pkval
    order = np.argsort(x)
    x = np.array(sorted(x))
    y = np.array(y[order])
    allx = x[:]
    ally = y[:]
    if (maxRadius > 0):
        idx = np.where(x<maxRadius)
        x = x[idx]
        y = y[idx]
    if (True):
        keepRange = max(np.where(y != 0.0)[0])
        maxNonZero = x[keepRange]
        discard = len(x)-keepRange-1
        if (discard > 0):
            print "Discarding of %d/%d pixels because they are all zero beyond radius=%f" % (discard,len(x),maxNonZero)
        xNonZero = x[:keepRange]
        yNonZero = y[:keepRange]
    else:
        maxNonZero = x[-1]
        xNonZero = x[:]
        yNonZero = y[:]
    print "Averaging the values at the same radius."
    if (initialPlot):
        # Check that averageTheRepeatedValues worked
        plt.clf()
        plt.hold(True)
    x,y = averageTheRepeatedValues(xNonZero,yNonZero)
    print "%d points averaged into %d" % (len(xNonZero), len(x))
    if (initialPlot):
        plt.plot(x,y,'r.')
        plt.draw()
        if (plotrange[:2] != [0,0]):
            plt.xlim(plotrange[:2])
        else:
            plt.xlim([0,maxNonZero])
        if (plotrange[2:] != [0,0]):
            plt.ylim(plotrange[:2])
        else:
            plt.ylim([-0.1, 1.1])
        return
    #
    fwhm = findFWHM(x, y, s=s)
    if (showplot or plotfile != None):
        if (showplot==False):
            pb.ioff()
        # make a plot
        pb.clf()
        if (showlog):
            fig = pb.gcf()
            ax = fig.add_subplot(1,2,1)
        p1 = pb.plot(allx,ally,'b.', x, y, 'r.',
                      [r.min(),r.max()],[0.5,0.5],'r-',
                      [fwhm*0.5,fwhm*0.5],[0.0,1.0],'g-')
        if (plotrange[:2] != [0,0]):
            pb.xlim(plotrange[:2])
        elif (maxRadius > 0):
            pb.xlim([0,maxRadius])
        else:
            pb.xlim([0,maxNonZero]) # np.max(r)*1.15])
        if (gaussian != None):
            pb.hold(True)
            gx = np.arange(0,pb.xlim()[1],pb.xlim()[1]*0.01)
            gy = np.exp(-gx**2/(2*(gaussian/2.35482)**2))
            pb.plot(gx,gy,'m-')
        if (plotrange[2:] != [0,0]):
            pb.ylim(plotrange[2:])
        else:
            pb.ylim([np.min([0,np.min(y)]), 1.05])        
        pb.xlabel('radius %s' % radiusUnits)
        pb.ylabel('pixel value')
        if (len(os.path.basename(imgfile)) > 90):
            fontsize=8
        else:
            fontsize=10
        pb.title(os.path.basename(imgfile),fontsize=fontsize)
        if (showlog==False):
            pb.legend(p1,["data","0.5","estimated HWHM (FWHM=%.2f%s)"%(fwhm,radiusUnits.strip(')').strip('('))])
        else:
            plt.text(0.08,0.96,"estimated HWHM (FWHM=%.2f%s)"%(fwhm,radiusUnits.strip(')').strip('(')),size=9,transform=gca().transAxes,color='g')
            ax = fig.add_subplot(1,2,2)
            pb.subplots_adjust(wspace=0.3)
            p1 = pb.plot(x,y,'b.', [r.min(),r.max()],[0.5,0.5],'r', [fwhm*0.5,fwhm*0.5],[1e-5,1.0],'g')
            ax.set_yscale('log')
            pb.xlabel('radius %s' % radiusUnits)
            pb.ylabel('log(pixel value)')
            if (plotrange[:2] != [0,0]):
                pb.xlim(plotrange[:2])
            else:
                pb.xlim([0,np.max(r)*1.15])
            if (gaussian != None):
                pb.hold(True)
                pb.text(0.5,0.92,'Gaussian %.2f"'%(gaussian),size=9,transform=gca().transAxes,color='m')
                x = np.arange(0,pb.xlim()[1],pb.xlim()[1]*0.01)
                y = np.exp(-x**2/(2*(gaussian/2.35482)**2))
                pb.plot(x,y,'m-')
                if (plotrange2[:2] != [0,0]):
                    pb.xlim(plotrange2[:2])
                elif (plotrange[:2] != [0,0]):
                    pb.xlim(plotrange[:2])
                else:
                    pb.xlim([0,np.max(r)*1.15])
                if (plotrange2[2:] != [0,0]):
                    pb.ylim(plotrange2[2:])
#   #            elif (plotrange[2:] != [0,0]):
#   #                pb.ylim([10*np.log10(plotrange[2]),10*np.log10(plotrange[3])])
                else:
                    pb.ylim([np.min([0,np.min(y)]), 1.05])        
    
        if (plotfile != None):
            if (plotfile == True):
                # automatic naming convention
                plotfile = '%s.getfwhm.png' % (os.path.basename(imgfile))
            pb.savefig(plotfile)
            print "Plot saved in %s" % (plotfile)
        if (showplot==False):
            pb.ion()
    return fwhm 

def TimeOnSource(ms='',field='',includeLatency=False,verbose=True,asdm='',help=False,vm=''):
    """
    See:   help au.timeOnSource
    -- Todd Hunter
    """
    return(timeOnSource(ms,field,includeLatency,verbose,asdm,help,vm))

def computeClockTimeOfMS(vis=None, vm=None):
    """
    Computes delta time from first to last scan in a dataset, either from
    the measurement set itself, or from its a ValueMapping structure.
    The ValueMapping method assumes that the times and scans are in ascending order.
    - Todd Hunter
    """
    if (vm != None):
        times = vm.getTimesForScans(np.unique(vm.scans))
        mjdsecmin = 1e12
        mjdsecmax = 0
        for t in times:
            #  This is too slow:
            #        mjdsecmin = np.amin([np.amin(t),mjdsecmin])
            #        mjdsecmax = np.amax([np.amax(t),mjdsecmax])
            #  Assume the times are in ascending order:
            mjdsecmin = np.amin([t[0],mjdsecmin]) 
            mjdsecmax = np.amax([t[-1],mjdsecmax])
        #  Account for the first half of the first scan, and last half of the last scan
        deltaT = 0.5*(abs(np.min(times[0][np.where(times[0] > mjdsecmin)]) - mjdsecmin) + 
                      abs(np.max(times[-1][np.where(times[-1] < mjdsecmax)]) - mjdsecmax))
        [mjdmin,utmin] = mjdSecondsToMJDandUT(mjdsecmin)
        [mjdmax,utmax] = mjdSecondsToMJDandUT(mjdsecmax)
        clockTimeMinutes = (mjdmax-mjdmin+deltaT/86400.)*1440.
    elif (vis != None):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        times = mymsmd.timesforscans(mymsmd.scannumbers())
        mymsmd.close()
        mjdsecmin = np.min(times)
        mjdsecmax = np.max(times)
        deltaT = 0.5*(abs(np.min(times[np.where(times > mjdsecmin)]) - mjdsecmin) + 
                      abs(np.max(times[np.where(times < mjdsecmax)]) - mjdsecmax))
        clockTimeMinutes = (mjdsecmax - mjdsecmin + deltaT)/60.
    else:
        print "You must specify either vis or vm"
        return
    return(clockTimeMinutes)

def timeOnSource(ms='',field='',includeLatency=False,verbose=True,
                 asdm='',help=False,vm='',gapFactor=None):
    """
    Uses ValueMapping to get the integration timestamps and computes a
    list of durations on the fields specified, attempting to detect and
    account for the inter-subscan latency.  Returns a dictionary indexed
    by the source ID integer:
    {0: {'num_of_subscans': 2,
         'scans': [5],
         'field_id': [0],
         'source_name': '3c279',
         'minutes_on_source': 58.716000556945801,
         'minutes_on_source_with_latency': 65.664000511169434
         },
     ...
     'clock_time': 120
     'minutes_on_science': 58.716
     'minutes_on_science_with_latency': 65.66
     'percentage_time_on_science': 20.40
    }

It also prints a string convenient to a wikitable of format:
| date | SB name | exec UID | UT start-end | LST start-end | Total time | Time on source | el range | med pwv | antennas | 

Notes on this string:
1) If the pointing table has been deleted it will print "pointing table empty" in the elevation range column.
2) If there is no on-source time, it will print "no onsource time" in the elevation range column.
3) If neither the CalWVR.xml nor ASDM_CALWVR files are present, it will print "unknown" in the pwv column.
4) The median pwv is over the entire dataset, not just the on-source scans.
5) For the number of antennas, it does not detect whether an antenna has been totally flagged!

    For further help and examples, see http://casaguides.nrao.edu/index.php?title=TimeOnSource
    -- Todd Hunter
    """
    if (help or ms==''):
        print "Usage: timeOnSource(ms,field='',verbose=True,help=False,vm='')"
        print "  Returns a list of durations (in sec) on the fields specified, attempting"
        print "  to detect and account for inter-subscan latency, unless includeLatency=T"
        print "  in which case it will return the total time from start to end of scan."
        print "  Fields can be specified by a single name or ID, or a list of IDs, e.g. '2,3,4'"
        return
    if (os.path.exists(ms) == False):
        print "Could not open ms = %s" % (ms)
        return({})
    if (vm==''):
#        Someday I should implement this:
#        if (casadef.casa_version >= '4.1.0'):
#            mymsmd = createCasaTool(msmdtool)
#            mymsmd.open(vis)
#        else:
        if (verbose):
            print "Running ValueMapping... (this may take a minute)"
        vm = ValueMapping(ms)
    tb.open(ms+'/FIELD')
    sourceIDs = tb.getcol('SOURCE_ID')
#    print "sourceIDs: ", sourceIDs
    tb.close()
    telescopeName = getObservatoryName(ms)
    mydict = {}
    if (field == ''):
        field = range(len(sourceIDs))
    elif (type(field) == int):
        field = [field]
    elif (type(field) == str):
        if (field.find(',') >= 0):
            field = field.split(',')
            fd = []
            for f in field:
                fd.append(int(f))
            field = fd
        else:
            try:
                field = int(field)
                field = [field]
            except:
                field = vm.getFieldIdsForFieldName(field)
                if (len(field) < 1):
                    print "No match for field name = " % (field)
                    return({})
    elif (type(field) == list):
        if (type(field[0]) == str):
            nf = []
            for f in field:
                nf.append(vm.getFieldIdsForFieldName(f))
            field = nf
    if (verbose):
        print "Considering non-CalAtmosphere, non-CalPointing, non-CalSideband scans."
        print "Total time on scans (including inter-subscan latency):"
    durations = []
    subscansAll = []
    fieldId = -1
    previousField = -1
    legend = "Field "
    multiField = False
    totalMinutes = 0
    scienceMinutesWithLatency = 0
    mydict = {}
    legend = ""
    multiFieldScansObserved = []
    for findex in range(len(field)):
        f = field[findex]
        durationWithLatency = 0
        scienceDurationWithLatency = 0
        scans = vm.getScansForField(f)
#        print scans, "= scans on field ", f
        scansObserved = []
        totalSubscans = 0
        multiField = False
        if (findex < len(field)-1):
          if (sourceIDs[f] == sourceIDs[field[findex+1]]): # and scans[0] == vm.getScansForField(field[findex+1])[0]):
              multiField = True
              legend += '%2d,' % (f)
#              print multiFieldScansObserved, scans, len(scans)
              for s in scans:
                  multiFieldScansObserved.append(s)
              continue
          else:
              legend += '%2d' % (f)
        else:
          if (sourceIDs[f] == sourceIDs[field[findex-1]]): #  and scans[0] == vm.getScansForField(field[findex-1])[0]):
              multiField = True
              for s in scans:
                  multiFieldScansObserved.append(s)
              legend += '%2d' % (f)
          else:
              legend += '%2d' % (f)
        subscansPerScan = []
        if (multiField):
            scans = np.unique(multiFieldScansObserved)
        for s in scans:
            intents = vm.getIntentsForScan(s)
#            print "Scan %d intents = " % (s), intents
            skip = False
            for i in intents:
                if (i.find('CALIBRATE_ATMOSPHERE') >= 0 or 
                    i.find('CALIBRATE_POINTING') >= 0 or 
                    i.find('CALIBRATE_SIDEBAND') >= 0):
                    skip = True
            if (skip):
#                print "Skipping calibration scan %d" % (s)
                continue
            scansObserved.append(s)
            times = vm.getTimesForScans(s)
            for t in times:
                (d,subscans) = computeDurationOfScan(s,t,verbose=False,gapFactor=gapFactor,vis=ms)
                scanLength = np.max(t) - np.min(t)
                if (scanLength == 0):
                    # This happens with simulated data as it has no subscans
                    scanLength = d
                durationWithLatency += scanLength
                totalSubscans += subscans
                subscansPerScan.append(subscans)
                if ('OBSERVE_TARGET#ON_SOURCE' in intents or 'OBSERVE_TARGET.ON_SOURCE' in intents):
                    scienceDurationWithLatency += scanLength
        totalMinutes += durationWithLatency/60.
        scienceMinutesWithLatency += scienceDurationWithLatency/60.
        if (verbose):
            if (totalSubscans > 1 and multiField==False):
                print "Source %2d = Field %s = %s: %.1f sec = %.1f min (%d scan%s: %s, %d subscans)" % (sourceIDs[f],
                   legend, vm.getFieldNamesForFieldId(f),
                   durationWithLatency, durationWithLatency/60.,
                   len(scansObserved), 's' if len(scansObserved)>1 else '', scansObserved, totalSubscans)
            else:
                print "Source %2d = Field %s = %s: %.1f sec = %.1f min (%d scan%s: %s)" % (sourceIDs[f],
                   legend, vm.getFieldNamesForFieldId(f),
                   durationWithLatency, durationWithLatency/60.,
                   len(scansObserved), 's' if len(scansObserved)>1 else '', scansObserved)
#        if (includeLatency == True):
#            durations.append(durationWithLatency)
#            subscansAll.append(totalSubscans)
        if (len(legend.split(',')) > 1):
            myfield = [int(x) for x in legend.split(',')]
        else:
            myfield = [f]
        mydict[sourceIDs[f]] = {'field_ids': myfield,
                     'source_name':vm.getFieldNamesForFieldId(f),
                     'scans': scansObserved,
                     'num_of_scans': len(scansObserved),
                     'num_of_fields': len(legend.split(',')),
                     'num_of_subscans': subscansPerScan,
                     'minutes_on_source_with_latency': durationWithLatency/60.,
                     'minutes_on_source': 0  # fill this in later
                     }
        legend = ""
    fullreport = True
    if (fullreport):
        [wikiline2,wikiline3,clockTimeMinutes,csvline] = lstrange(ms,verbose=False,vm=vm)
    else:
        clockTimeMinutes = computeClockTimeOfMS(vm=vm)
    print "Clock time = %.2f min, Total time = %.2f min,  science time = %.2f min" % (clockTimeMinutes, totalMinutes, scienceMinutesWithLatency)
    csvline += ',%.2f,%.2f' % (totalMinutes, scienceMinutesWithLatency)
    
    if (verbose):
        print "\nMy attempt to detect and account for inter-subscan latency follows:"

    legend = ""
    multiField = False
    totalMinutes = 0
    scienceMinutes = 0
    fid = 0
    multiFieldScansObserved = []
    for findex in range(len(field)):
        f = field[findex]
        # f is the field ID
        duration = 0
        scienceDuration = 0
        scans = vm.getScansForField(f)
        scansObserved = []
        totalSubscans = 0
        multiField = False
        if (findex < len(field)-1):
          if (sourceIDs[f] == sourceIDs[field[findex+1]]): #  and scans[0] == vm.getScansForField(field[findex+1])[0]):
            multiField = True
            legend += '%2d,' % (f)
            for s in scans:
                multiFieldScansObserved.append(s)
            continue
          else:
            legend += '%2d' % (f)
        else:
          if (sourceIDs[f] == sourceIDs[field[findex-1]]): #  and scans[0] == vm.getScansForField(field[findex-1])[0]):
            multiField = True
            legend += '%2d' % (f)
            for s in scans:
                multiFieldScansObserved.append(s)
          else:
            legend += '%2d' % (f)
        
        if (multiField):
            scans = np.unique(multiFieldScansObserved)
        for s in scans:
            intents = vm.getIntentsForScan(s)
            skip = False
            for i in intents:
                if (i.find('CALIBRATE_ATMOSPHERE') >= 0 or 
                    i.find('CALIBRATE_POINTING') >= 0 or
                    i.find('CALIBRATE_SIDEBAND') >= 0):
                    skip = True
            if (skip):
#                print "Skipping calibration scan %d" % (s)
                continue
            scansObserved.append(s)
            times = vm.getTimesForScans(s)
            for t in times:
#                print "Running au.computeDurationOfScan(%d,%s,verbose=False,gapFactor=%g,vis='%s')" % (s,str(t),gapFactor,ms)
                (d,subscans) = computeDurationOfScan(s,t,verbose=False,gapFactor=gapFactor,vis=ms)
                duration += d
                totalSubscans += subscans
                if ('OBSERVE_TARGET#ON_SOURCE' in intents or 'OBSERVE_TARGET.ON_SOURCE' in intents):
                    scienceDuration += d
        totalMinutes += duration/60.
        scienceMinutes += scienceDuration/60.
        if (verbose):
            fieldWarning = ""
            if (totalSubscans > 1 and multiField==False):
                print "Source %2d = Field %s = %s: %.1f sec = %.1f min (%d scan%s: %s, %d subscans%s)" % (sourceIDs[f],
                 legend, vm.getFieldNamesForFieldId(f), duration, duration/60.,
                 len(scansObserved), 's' if len(scansObserved)>1 else '', scansObserved, totalSubscans, fieldWarning)
            else:
                print "Source %2d = Field %s = %s: %.1f sec = %.1f min (%d scan%s: %s)" % (sourceIDs[f],
                    legend, vm.getFieldNamesForFieldId(f), duration, duration/60.,
                    len(scansObserved), 's' if len(scansObserved)>1 else '', scansObserved)
        legend = ""
        mydict[sourceIDs[f]]['minutes_on_source'] = duration/60.
        mydict['minutes_on_science'] = scienceMinutes
        mydict['minutes_on_science_with_latency'] = scienceMinutesWithLatency
        mydict['percentage_time_on_science'] = 100*scienceMinutes/clockTimeMinutes
        mydict['clock_time'] = clockTimeMinutes
        mydict['source_ids'] = list(sourceIDs)
        mydict['num_of_sources'] = len(sourceIDs)
# might add this someday        
#        elevs = csvline.split(',')
#        startElev = float(elevs[-2])
#        stopElev = float(elevs[-1])
#        mydict['elevation_range'] = [startElev,stopElev]
    if (fullreport):
        wikiline2 += '%.1f | %.1f | ' % (totalMinutes, scienceMinutes)
        wikiline2 += wikiline3
    # Now get the PWV if possible
    pwvmean = -1
    if (telescopeName.find('ALMA')>=0):
        if (os.path.exists('ASDM_CALWVR') or os.path.exists(ms+'/ASDM_CALWVR')):
            if (os.path.exists(ms+'/ASDM_CALWVR')):
                [pwvmean, pwvstd]  = getMedianPWV(ms)
            else:
                [pwvmean, pwvstd]  = getMedianPWV('.')
        elif (os.path.exists('ASDM_CALATMOSPHERE') or os.path.exists(ms+'/ASDM_CALATMOSPHERE')):
            if (os.path.exists(ms+'/ASDM_CALATMOSPHERE')):
                [pwvmean, pwvstd]  = getMedianPWV(ms)
            else:
                [pwvmean, pwvstd]  = getMedianPWV('.')
        elif (os.path.exists(ms+'/CalWVR.xml')):
            [pwvtime, pwv, antenna] = readpwv(ms)
            pwvmean = np.mean(pwv)
        elif (os.path.exists('CalWVR.xml')):
            [pwvtime, pwv, antenna] = readpwv('.')
            pwvmean = np.mean(pwv)
        else:
            print "No ASDM_CALWVR, ASDM_CALATMOSPHERE or CalWVR.xml table found.  You should importasdm with asis='*' or copy the CalWVR.xml file from your ASDM to your working directory (or your ms directory)."
    tb.open(ms+'/ANTENNA')
    nAntennas = len(tb.getcol('NAME'))
    tb.close()
    if (fullreport): 
        if (pwvmean < 0):
            wikiline2 += ' unknown_PWV | %d ' % (nAntennas)
        else:
            wikiline2 += ' %.2f | %d |' % (pwvmean, nAntennas)
        wikiline2 += '   |'   # Requested by Andreas Lundgren on 2012-05-23  
    print "Latency removed: Total time = %.1f min,   science time = %.1f min" % (totalMinutes, scienceMinutes)
    csvline += ',%.1f,%.1f' % (totalMinutes, scienceMinutes)
    if (fullreport): 
        print "wikiline = %s" % (wikiline2)
        print csvline
    print "WARNING: This task does not account for any flagging."
    return(mydict) 
    # end of timeOnSource  vm.
    
def computeDurationOfScan(scanNumber,t=None, vis=None, returnSubscanTimes=False,
                          verbose=False,gapFactor=None,includeDate=False):
    """
    This function is used by timeOnSource() to empirically determine the number of
    subscans and the total duration of all the subscans of a particular scan.
    Inputs:
    scanNumber = the scan number, simply for generating a file list of timestamps
    t = a sequence of integration timestamps (optional for casa >= 4.1.0)
    vis = the measurement set (not necessary if t is given)
    Returns:
    1) duration in seconds
    2) the number of subscans
    and if returnSubscanTimes==True
    3) the begin/end timestamps of each subscan
    4) the begin/end timestampStrings of each subscan
    -- Todd Hunter
    """
    if (t==None and vis == None):
        print "You must specify either vis or t."
        return
    if (t == None or casadef.casa_version >= '4.1.0'):
        if (casadef.casa_version < '4.1.0'):
            print "For this version of casa, you must specify t rather than vis."
            return
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        t = np.unique(mymsmd.timesforscan(scanNumber))
    else:
        t = np.unique(t)
    if (len(t) <= 1):
        if (casadef.casa_version < '4.1.0'):
            print "This version of CASA is too old for this function to handle single-dump integrations."
            return(0,0)
        else:
            if (scanNumber==1):
                duration = np.min(mymsmd.timesforscan(scanNumber+1)) - t[0]
            else:
                duration = t[0] - np.max(mymsmd.timesforscan(scanNumber-1))
            mymsmd.close()
            if (returnSubscanTimes):
                timestampsString = mjdsecToTimerange(t[0]-0.5*duration,t[0]+0.5*duration,
                                                     decimalDigits=1,includeDate=includeDate)
                return(duration,1,{0:t},{0:timestampsString})
            else:
                return(duration,1)
    else:
        if (casadef.casa_version >= '4.1.0'):
            mymsmd.close()
        d = np.max(t) - np.min(t)
        # initial estimate for interval
        diffs = []
        for i in range(1,len(t)):
            diffs.append(t[i]-t[i-1])
        avgInterval = np.median(diffs)
        startTime = previousTime = t[0]
        subscans = 1
        if (gapFactor == None):
            if (avgInterval > 1):
                gapFactor = 2
            else:
                gapFactor = 3.
        startTime = previousTime = t[0]
        duration = 0
        tdiffs = []
        s = ''
        timestamps = {}
        timestampsString = {}
        for i in range(1,len(t)):
            s += "%.2f " % (t[i]-t[0])
            tdiff = t[i]-previousTime
            tdiffs.append(tdiff)
            if (tdiff > gapFactor*avgInterval):
                if (verbose):
                    print "    Dropped %.1f seconds" % (t[i]-previousTime+avgInterval)
                subscanLength = t[i-1] - startTime + avgInterval
                duration += subscanLength
                if (subscanLength > 1.5*avgInterval):
                    # Don't count single point subscans because they are probably not real.
                    timestamps[subscans] = [startTime,t[i-1]]
                    timestampsString[subscans] = mjdsecToTimerange(startTime,t[i-1],decimalDigits=1,includeDate=includeDate)
                    if (verbose):
                        print "Scan %d: Subscan %d: %s, duration=%f" % (scanNumber,subscans,s,subscanLength)
                    s = ''
                    subscans += 1
                elif (verbose):
                    print "dropped a dump of length %f because it was between subscans" % (subscanLength)
                startTime = t[i]
            previousTime = t[i]
        duration += t[len(t)-1] - startTime
        timestamps[subscans] = [startTime,t[len(t)-1]]
        timestampsString[subscans] = mjdsecToTimerange(startTime,t[len(t)-1],decimalDigits=1,includeDate=includeDate)
    if (returnSubscanTimes):
        return(duration, subscans, timestamps, timestampsString)
    else:
        return(duration, subscans)
#

def plotWVRSolutions(caltable='',spw=[],field=[],subplot=22,sort='number',
                     antenna='',xrange=[0,0], yrange=[0,0],figfile='',
                     unwrap=False,help=False,xaxis='ut',interactive=True,ms=''):
    """
    Because running plotcal on WVR tables includes the common mode delay,
    it is not so useful, as all antennas often appear very similar.  In
    this function, we compute the phase difference for each baseline and
    plot this vs. time.  -  Todd Hunter
    Options:
    antenna: can be ID or name; single value, or list: 0,'0','0,1','DV04,DV05'
    field: must be field ID, or list of IDs, or comma-delimited string of IDs
    figfile: will append .0.png, .1.png, etc. for successive pages
    interactive: True or False (True will require user input after showing each page)
    ms: specify the ms name rather than look for it in the caltable
    sort: by baseline 'number',  or by baseline 'length'
    subplot:   valid values: 11,12,21,22,23,32,42  (any 3rd digit is ignored)
    unwrap: attempt to further unwrap the 360-deg phase wraps after
            Ed's algorithm
    xaxis: 'seconds' or 'ut' (default)
    xrange: min/max time to show:  specify in seconds if xaxis='seconds'
            or floating point UT hours if 'ut'.  The latter will 
            probably not work well if the data cross the 0/24 hour mark.
    yrange: min/max phase to show
    For further help and examples, see:
      https://safe.nrao.edu/wiki/bin/view/ALMA/PlotWVRSolutions
    --- Todd Hunter
    """
    if (help):
        print "Usage: plotWVRSolutions(caltable='', spw='', field='', subplot=22, sort='number', antenna='',"
        print "         xrange=[0,0], yrange=[0,0], figfile='', unwrap=False, help=False, xaxis='ut')"
        print "   antenna: can be id or name; single value, or list:  0,'!0','0,1','DV04,DV05'"
        print "   field: must be field ID, or list of IDs, or comma-delimited string of IDs"
        print "   interactive: True or False (True requires user input after showing each page)"
        print "   ms: specify the ms name associated with the table rather than look for it in the table"
        print "   sort: by baseline 'number',  or by unprojected baseline 'length' (shortest first)"
        print "   subplot:  valid values: 11,12,21,22,23,32,42  (any 3rd digit is ignored)"
        print "   unwrap: attempt to further unwrap the 360-deg phase wraps after Ed's algorithm"
        print "   xaxis: 'seconds' or 'ut' (default)"
        print "   xrange: min/max time to show:  specify in seconds if xaxis='seconds'"
        print "           or floating point UT hours if 'ut'.  The latter will not"
        print "           well if the data cross the 0/24 hour mark."
        print "   yrange: min/max phase to show (degrees)"
        return
    plotctr = 0
    myhspace = 0.25
    mywspace = 0.25
    maxFieldsInLegend = 24

    if (type(antenna) == str):
        if (antenna.find('&')>=0):
            print "The '&' character is not supported (yet)."
            return
    if (sort != '' and sort != 'length' and sort != 'number'):
        print "Invalid sort option.  Options are 'length' or 'number'."
        return
    if (xaxis != 'ut' and xaxis.find('sec')<0):
        print "Invalid xaxis option.  Options are 'ut' or 'seconds'."
        return

    validSubplots= [11,12,21,22,23,32,42]
    if (type(subplot) == str):
        subplot = int(subplot)
    if (subplot > 100):
        # allow 111, 221, etc. to be consistent with other casa commands
        subplot /= 10
    if ((subplot in validSubplots) == False):
        print "Invalid subplot option.  Options are: ", validSubplots
        print "With an optional trailing digit that will be ignored."
        return
    xframe = xframeStart = subplot*10
    xframeStop = xframeStart + ((subplot%10)*(subplot/10))
    # row column
    topRow = [111,121,122,211,221,222,231,232,233,321,322,421,422]
    bottomRow = [111,121,122,212,223,224,234,235,236,325,326,427,428]
    leftColumn = [111,121,211,212,221,223,231,234,321,323,325,421,423,425,427]
    subplotRows = subplot/10
    
    if (subplot == 11):
        mysrcsize = 10
        mysize = 10
        titlesize = 12
    else:
        mysrcsize = 8
        mysize = 8
        titlesize = 10
        
    if (os.path.exists(caltable)):
        try:
            print "Opening cal table..."
            tb.open(caltable)
        except:
            print "Could not open caltable = ", caltable
            return
    else:
        print "Caltable does not exist = ", caltable
        return
    times = tb.getcol("TIME")
    antennas = tb.getcol("ANTENNA1")
    uniqueAntennaIds = np.unique(antennas)
    fields = tb.getcol("FIELD_ID")
    uniqueFields = np.unique(fields)
    names = tb.colnames()
    if ('SNR' not in names):
        print "This does not appear to be a cal table. Is it the .ms?"
        return
    if ('SPECTRAL_WINDOW_ID' in names):
        msName = tb.getkeyword('MSName')      
        cal_desc_id = tb.getcol("SPECTRAL_WINDOW_ID")
        spectralWindowTable = tb.getkeyword('SPECTRAL_WINDOW').split()[1]
        ParType = tb.getkeyword('ParType')    # string = 'Complex'
        if (ParType != 'Complex'):
            print "This does not appear to be a gain calibration table because the data type is %s." % (ParType)
            return
        gain = tb.getcol('CPARAM')[0][0]  # Here we must be assuming single-pol corrections
        tb.close()
#        tb.open(spectralWindowTable)
    else:  # old-style cal table
        cal_desc_id = tb.getcol("CAL_DESC_ID")
        gain = tb.getcol("GAIN")[0][0]  # Here we must be assuming single-pol corrections
        tb.open(caltable+'/CAL_DESC')
        msName = tb.getcell('MS_NAME',0)
        tb.close()
    if (ms != ''):
        msName = ms
    print "Running ValueMapping on %s... (this may take a minute)" % (msName)
    if (os.path.exists(msName)):
        vm = ValueMapping(msName)
        msFound = True
    else:
        if (caltable.find('/')>=0):
            tokens = caltable.split('/')
            fname = ''
            for i in range(len(tokens)-1):
                fname += tokens[i] + '/'
            print "failed to open %s, will try %s" % (msName,fname+msName)
            if (os.path.exists(fname+msName)):
                vm = ValueMapping(fname+msName)
                msFound = True
                msName = fname+msName
            else:
                msFound = False
        else:
            msFound = False
    
    # Continue to parse the command line
    if (type(figfile) == str):
        if (figfile.find('/')>=0):
            directories = figfile.split('/')
            directory = ''
            for d in range(len(directories)-1):
                directory += directories[d] + '/'
            if (os.path.exists(directory)==False):
                print "Making directory = ", directory
                os.system("mkdir -p %s" % directory)

    # Parse the antenna string to emulate plotms
    myValidCharacterListWithBang = ['~', ',', ' ', '*', '!',] + [str(m) for m in range(10)]
    removeAntenna = []
    if (type(antenna) == str):
      if (len(antenna) == sum([m in myValidCharacterListWithBang for m in antenna])):
         # a simple list of antenna numbers was given 
         tokens = antenna.split(',')
         antlist = []
         removeAntenna = []
         for token in tokens:
             if (len(token) > 0):
                 if (token.find('*')==0 and len(token)==1):
                     antlist = uniqueAntennaIds
                     break
                 elif (token.find('!')==0):
                     antlist = uniqueAntennaIds
                     removeAntenna.append(int(token[1:]))
                 elif (token.find('~')>0):
                     (start,finish) = token.split('~')
                     antlist +=  range(int(start),int(finish)+1)
                 else:
                     antlist.append(int(token))
         antlist = np.array(antlist)
         for rm in removeAntenna:
#             print "Removing antenna %d = %s" % (rm, vm.getAntennaNamesForAntennaId(rm))
             antlist = antlist[np.where(antlist != rm)[0]]
         antlist = list(antlist)
         if (len(antlist) < 1 and len(removeAntenna)>0):
             print "Too many negated antennas -- there are no antennas left to plot."
             return(vm)
      else:
         # The antenna name (or list of names) was specified
         tokens = antenna.split(',')
         if (msFound):
             antlist = []
             uniqueAntennaNames = vm.uniqueAntennas
             for token in tokens:
                 if (token in uniqueAntennaNames):
                     antlist = list(antlist)  # needed in case preceding antenna had ! modifier
                     antlist.append(vm.getAntennaIdsForAntennaName(token))
                 elif (token[0] == '!'):
                     if (token[1:] in uniqueAntennaNames):
                         antlist = uniqueAntennaIds
                         removeAntenna.append(vm.getAntennaIdsForAntennaName(token[1:]))
                     else:
                         print "Negated antenna %s is not in the ms. It contains: " % (token), uniqueAntennaNames
                         return(vm)
                 else:
                     twoants = token.split('&')
                     if (len(twoants) > 1):
                         myid = vm.getAntennaIdsForAntennaName(twoants[0])
                         if (twoants[0] in uniqueAntennaNames):
                             antlist.append(twoants[0])
                         if (twoants[1] in uniqueAntennaNames):
                             antlist.append(twoants[1])
                         print "The '&' character is not exactly supported"
                     else:
                         print "Antenna %s is not in the ms. It contains: " % (token), uniqueAntennaNames
                         return(vm)
             antlist = np.array(antlist)
             for rm in removeAntenna:
#                 print "Removing antenna %d = %s" % (rm, vm.getAntennaNamesForAntennaId(rm))
                 antlist = antlist[np.where(antlist != rm)[0]]
             antlist = list(antlist)
             if (len(antlist) < 1 and len(removeAntenna)>0):
                 print "Too many negated antennas -- there are no antennas left to plot."
                 return(vm)
         else:
             print "Antennas cannot be specified my name if the ms is not found."
             return(vm)
    elif (type(antenna) == list):
      # it's a list of integers
      antlist = antenna
    else:
      # It's a single, integer entry
      antlist = [antenna]

    if (len(antlist) > 0):
      antennasToPlot = np.intersect1d(uniqueAntennaIds,antlist)
    else:
      antennasToPlot = uniqueAntennaIds

    legend = ''
    for a in antennasToPlot:
        if (a != antennasToPlot[0]):
            legend += ', '
        if (msFound):
            legend += vm.getAntennaNamesForAntennaId(a)
    if (msFound):
        print "Baselines including these antennas will be plotted = ", legend

    spwlist = spw
    if (spwlist == []):
#        print "cal_desc_id = ", cal_desc_id
        spwlist = vm.spwInfo.keys()
    elif (type(spw) == int):
        spwlist = [spw]
    elif (type(spw) == str):
        if (str.isdigit(spw)):
            spwlist = [int(spw)]
        elif (spw.find(',')>=0):
            spwstrings = spw.split(',')
            spwlist = []
            for i in spwstrings:
                spwlist.append(int(i))
        else:
            spwlist = vm.spwInfo.keys()
#            print "spw is a blank string"
    else:
        print "Invalid spw"
        return
    print "spws in the dataset = ", vm.spwInfo.keys() # range(len(vm.spwInfo))
    print "spws to plot = ", spwlist
    
    for spw in spwlist:
        if (spw not in vm.spwInfo.keys() or spw < 0):
            print "spw %d is not in the dataset" % (spw)
            return
    if (len(spwlist) > 1):
        print "*** Note: WVR solutions for different spws differ only by the frequency ratio."
        print "*** So, examining only one of them is usually sufficient (and faster)."

    # Parse the field string to emulate plotms
    removeField = []
    if (type(field) == str):
     if (len(field) == sum([m in myValidCharacterListWithBang for m in field])):
         # a list of field numbers was given
         tokens = field.split(',')
         fieldlist = []
         for token in tokens:
             if (token.find('*')>=0):
                 fieldlist = uniqueFields
                 break
             elif (token.find('!')==0):
                 fieldlist = uniqueFields
                 removeField.append(int(token[1:]))
             elif (len(token) > 0):
                 if (token.find('~')>0):
                     (start,finish) = token.split('~')
                     fieldlist +=  range(int(start),int(finish)+1)
                 else:
                     fieldlist.append(int(token))
         fieldlist = np.array(fieldlist)
         for rm in removeField:
             fieldlist = fieldlist[np.where(fieldlist != rm)[0]]
         fieldlist = list(fieldlist)
         if (len(fieldlist) < 1 and len(removeField)>0):
             print "Too many negated fields -- there are no fields left to plot."
             return(vm)
     else:
         # The field name (or list of names, or wildcard) was specified
         tokens = field.split(',')
         if (msFound):
             fieldlist = []
             removeField = []
             for token in tokens:
                 myloc = token.find('*')
                 if (myloc > 0):
                     for u in uniqueFields:
                         if (token[0:myloc]==vm.getFieldNamesForFieldId(u)[0:myloc]):
                             if (DEBUG):
                                 print "Found wildcard match = %s" % vm.getFieldNamesForFieldId(u)
                             fieldlist.append(u)
                         else:
                             if (DEBUG):
                                 print "No wildcard match with = %s" % vm.getFieldNamesForFieldId(u)
                 elif (myloc==0):
                     for u in uniqueFields:
                         fieldlist.append(u)
                 elif (token in vm.uniqueFields):
                     fieldlist = list(fieldlist)  # needed in case preceding field had ! modifier
                     fieldlist.append(vm.getFieldIdsForFieldName(token))
                 elif (token[0] == '!'):
                     if (token[1:] in vm.uniqueFields):
                         fieldlist = uniqueFields
                         removeField.append(vm.getFieldIdsForFieldName(token[1:]))
                     else:
                         print "Field %s is not in the ms. It contains: " % (token), vm.uniqueFields
                         return(vm)
                 else:
                     print "Field %s is not in the ms. It contains: " % (token), vm.uniqueFields
                     return(vm)
             fieldlist = np.array(fieldlist)
             for rm in removeField:
                 fieldlist = fieldlist[np.where(fieldlist != rm)[0]]
             fieldlist = list(fieldlist)
             if (len(fieldlist) < 1 and len(removeField)>0):
                 print "Too many negated fields -- there are no fields left to plot."
                 return(vm)
         else:
             print "Fields cannot be specified my name if the ms is not found."
             return(vm)
    elif (type(field) == list):
      # it's a list of integers
      fieldlist = field
    else:
      # It's a single, integer entry
      fieldlist = [field]

    if (len(fieldlist) > 0):
      fieldsToPlot = np.intersect1d(uniqueFields,np.array(fieldlist))
      if (len(fieldsToPlot) < 1):
          print "Source not found in ms"
          return(vm)
    else:
      fieldsToPlot = uniqueFields  # use all fields if none are specified

    print "fields in the dataset = ", range(len(vm.uniqueFields))
    print "Fields to plot = ", fieldsToPlot
    for x in fieldsToPlot:
        if (x < 0 or x >= len(vm.uniqueFields)):
            print "Field %d is not in the dataset" % (x)
            return

    # Fill the array of baselineLengths
    antennaIndex1 = []
    antennaIndex2 = []
    baselines = []
    for i in range(len(uniqueAntennaIds)):
        for j in range(i,len(uniqueAntennaIds)):
            antennaIndex1.append(i)
            antennaIndex2.append(j)
    if (msFound):
        baselineLength = np.zeros([len(uniqueAntennaIds), len(uniqueAntennaIds)])
        for i in range(len(uniqueAntennaIds)):
            for j in range(i,len(uniqueAntennaIds)):
                if ((i != j) and (i not in removeAntenna) and (j not in removeAntenna)):
                    baselineLength[i][j] = getBaselineLength(msName,i,j,verbose=False)[0]
                    if (i in antennasToPlot or j in antennasToPlot):
                        baselines.append([i,j,baselineLength[i][j]])

    sortedBaselines = baselines
    # sort the baselineLengths of the antennas to plot
    if (sort.find('length')>=0):
        for i in range(1,len(sortedBaselines)):
            for j in range(1,len(sortedBaselines)):
                if (sortedBaselines[j][2] < sortedBaselines[j-1][2]):
                    swap = sortedBaselines[j-1]
                    sortedBaselines[j-1] = sortedBaselines[j]
                    sortedBaselines[j] = swap
    pb.ion()  # Added on April 26, 2012 to address Crystal's problem
    pb.clf()
    for s in range(len(spwlist)):
        spw = spwlist[s]
        matchField = np.where(cal_desc_id == spw)[0]
        index = 0
        for myi in range(len(baselines)):
            if (sort.find('length')<0):
                i = baselines[myi][0]
                j = baselines[myi][1]
            else:
                i = sortedBaselines[myi][0]
                j = sortedBaselines[myi][1]
            matches = np.intersect1d(matchField,np.where(antennas==i)[0])
            antenna1 = antennas[matches]
            time1 = times[matches]
            gain1 = gain[matches]
            fields1 = fields[matches]
            matches2 = np.intersect1d(matchField,np.where(antennas==j)[0])
            gain2 = gain[matches2]
# This was only needed to check that times agreed, and they do.
#            antenna2 = antennas[matches2]
#            time2 = times[matches2]
#            fields2 = fields[matches2]
#            (agreement, failures) = checkTimeAgreement(i,j,time1,time2,fid=0)
#            if (agreement == False):
#                print "Time mismatch at baseline %d-%d, " % (antenna1[0],antenna2[0])
#                continue
            startTime = time1[0]
            if (xaxis.find('sec')>=0):
                timeplot = time1 - startTime
            else:
#                print "converting starting MJD seconds (%f) to UT hours" % (startTime)
                timeplot = 24*(time1/86400. - floor(time1[0]/86400.))
            phasediff = np.arctan2(np.imag(gain1), np.real(gain1)) - np.arctan2(np.imag(gain2),np.real(gain2))
            phasediff = phaseUnwrap(phasediff)
            posvalues = phasediff[np.where(phasediff>0)[0]]
            if (np.median(posvalues) > math.pi/2.):
                phasediff -= np.median(posvalues)
            else:
                phasediff -= np.median(phasediff)
            if (unwrap):
                  for i in range(len(phasediff)):
                    while (phasediff[i] > math.pi):
                        phasediff[i] -= 2*math.pi
                    while (phasediff[i] < -math.pi):
                        phasediff[i] += 2*math.pi
            phasediff *= 180/np.pi
            xframe += 1
            if (xframe > xframeStop):
                if (len(fieldsToPlot) <= maxFieldsInLegend and len(fieldsToPlot) < len(overlayColors)):
                    DrawSourceLegend(yrange, fieldsToPlot, msFound, vm, subplotRows, mysrcsize)
                if (interactive):
                    pb.draw()
                    myinput = raw_input("Press return for next page (q to quit): ")
                else:
                    if (figfile!=''):
                        print "Plotting page %d" % (plotctr)
                    myinput = ''
                if (figfile!=''):
                    if (figfile == True):
                        pb.savefig(caltable+'.plotWVRSolutions.%d.png'%plotctr, density=108)
                    else:
                        pb.savefig(figfile.split('.png')[0]+'.%d.png'%plotctr, density=108)
                    plotctr += 1
                if (myinput.find('q')>=0):
                    return
                pb.clf()
                xframe = xframeStart+1
#            print "Plotting baseline %d-%d (%s-%s) on spw %d" % (i,j,
#                    vm.getAntennaNamesForAntennaId(i),vm.getAntennaNamesForAntennaId(j),spw)
            adesc = pb.subplot(xframe)
            pb.hold(True)
            resizeFonts(adesc,mysize)
            if ((xrange[0] != 0 or xrange[1] != 0) and yrange[0] ==0 and yrange[1]==0):
                # recalculate the y limits for the displayed range
                tmatches1 = np.where(timeplot > xrange[0])[0]
                tmatches2 = np.where(timeplot <= xrange[1])[0]
                tmatches = np.intersect1d(tmatches1,tmatches2)
                phasediff -= np.median(phasediff[tmatches])
                ylim = [np.min(phasediff[tmatches]), np.max(phasediff[tmatches])]
                myyrange = ylim[1]-ylim[0]
                ylim = [ylim[0]-0.1*myyrange,ylim[1]+0.1*myyrange]
            else:
                ylim = pb.ylim()
            list_of_date_times = mjdSecondsListToDateTime(time1)
            timeplotMatches = pb.date2num(list_of_date_times)
            for f in range(len(fieldsToPlot)):
                field = fieldsToPlot[f]
                matches = np.where(fields1 == field)[0]
                if (xaxis.find('ut') >= 0):
                    pdesc = adesc.plot_date(timeplotMatches[matches],phasediff[matches],'.')
                    adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,30)))
                    adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
                    adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
                    adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
                    RescaleXAxisTimeTicks(pb.xlim(), adesc)
                else:
                    pdesc = pb.plot(timeplot[matches],phasediff[matches],'.')
                if (len(fieldsToPlot) < len(overlayColors)):
                    pb.setp(pdesc, color=overlayColors[field])
                else:
                    pb.setp(pdesc, color='b')
            if (xframe in bottomRow):
                if (xaxis.find('sec')>=0):
                    pb.xlabel("Time since start (sec)", size=mysize)
                else:
                    pb.xlabel("Time (UT on %s)"%(plotbp3.utdatestring(startTime)), size=mysize)
            if (xframe in leftColumn):
                pb.ylabel("Phase difference (deg)", size=mysize)
            if (msFound):
                pb.title('%.0fm Baseline %d-%d=%s-%s, spw%d=%.1fGHz' % (baselineLength[antenna1[0]][antennas[matches2][0]],
                        antenna1[0], antennas[matches2][0],
                        vm.getAntennaNamesForAntennaId(antenna1[0]),
                        vm.getAntennaNamesForAntennaId(antennas[matches2][0]),spw, np.mean(getFrequencies(msName,spw)*1e-9)),
                        size=mysize)
            else:
                pb.title('Baseline %d-%d, spw %d' % (antenna1[0], antennas[matches2][0], spw), size=mysize)

            pb.subplots_adjust(hspace=myhspace, wspace=mywspace)
            yFormatter = ScalarFormatter(useOffset=False)
            adesc.yaxis.set_major_formatter(yFormatter)
            adesc.xaxis.grid(True,which='major')
            adesc.yaxis.grid(True,which='major')
            if (xrange[0] != 0 or xrange[1] != 0):
                if (xaxis.find('sec')>=0):
                    pb.xlim(xrange)
                else:
                    avgdatetime = num2date(np.mean(timeplotMatches[matches]))
                    avgdate = datetime.datetime.date(avgdatetime)
                    d1 = date2num(avgdate) + xrange[0]/24.
                    d2 = date2num(avgdate) + xrange[1]/24.
                    pb.xlim([d1,d2])
                pb.ylim(ylim)
            else:
                if (xaxis.find('sec')>=0):
                    pb.xlim(0, np.max(times)-np.min(times))

            xlim = pb.xlim()
            if (xlim[1] - xlim[0] < 10/1440.):
                adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,1)))
                adesc.xaxis.set_minor_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,30)))
            elif (xlim[1] - xlim[0] < 0.5/24.):
                adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,5)))
                adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,1)))
            elif (xlim[1] - xlim[0] < 1/24.):
                adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
                adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,2)))
                
            if (yrange[0] != 0 or yrange[1] != 0):
                pb.ylim(yrange)
                
            if (xframe in leftColumn and xframe in topRow):
                (xlim,ylim,myxrange,myyrange) = GetLimits()
                pb.text(0, 1.12, caltable+' computed for '+msName.split('/')[-1],
                        size=titlesize, transform=adesc.transAxes)
        if (len(fieldsToPlot) <= maxFieldsInLegend and len(fieldsToPlot) < len(overlayColors)):
            DrawSourceLegend(yrange, fieldsToPlot, msFound, vm, subplotRows, mysrcsize)
                        
    pb.draw()
    if (figfile!=''):
        if (figfile == True):
            try:
                pb.savefig(caltable+'.plotWVRSolutions.%d.png'%plotctr, density=108)
            except:
                print "WARNING:  Could not save plot file.  Do you have write permission here?"
        else:
            try:
                pb.savefig(figfile+'.%d.png'%plotctr, density=108)
            except:
                print "WARNING:  Could not save plot file.  Do you have write permission here?"
# end of plotWVRSolutions()

def DrawSourceLegend(yrange, fieldsToPlot, msFound, vm, subplotRows, mysrcsize):
    (xlim,ylim,myxrange,myyrange) = GetLimits()
    if (yrange[0] == 0 and yrange[1] == 0):
        # Make space for source labels at the bottom of the plot
        pb.ylim([ylim[0] - myyrange*0.25, ylim[1]])
        (xlim,ylim,myxrange,myyrange) = GetLimits()
    for f in range(len(fieldsToPlot)):
        field = fieldsToPlot[f]
        if (msFound):
            myfieldstring = '%d: %s' % (field, vm.getFieldNamesForFieldId(field))
        else:
            myfieldstring = 'field %d' % (field)
        if (f < (1+len(fieldsToPlot))/2):
            myxpos = 0.05
            myypos = (f+0.3)*0.03*subplotRows  # 0.02, 0.078 0.137
        else:
            myxpos = 0.50
            myypos = (f-(1+len(fieldsToPlot))/2+0.3)*0.03*subplotRows
        pb.text(myxpos, myypos, myfieldstring, color=overlayColors[field],
                size=mysrcsize, transform=pb.gca().transAxes)

def GetLimits():
    """
    Gets the current plot limits and ranges and returns them.
    -- Todd Hunter
    """
    xlim = pb.xlim()
    ylim = pb.ylim()
    myxrange = xlim[1]-xlim[0]
    myyrange = ylim[1]-ylim[0]
    return(xlim,ylim,myxrange,myyrange)

def phaseUnwrap(phase):
   """
   Algorithm from Ed Fomalont called from plotWVRSolutions.  Accepts angle in radians.
   Take phase difference, adds 4.5 turns, mods by 1 turn, subtract 0.5 turns. - Todd Hunter
   """
   for i in range(1,len(phase)):
       phaseDiff = phase[i]-phase[i-1]
       pd = np.mod(phaseDiff + 4.5*(2*np.pi), 2*np.pi) - np.pi
       phase[i] = phase[i-1]+pd
   return(phase)
   
def checkTimeAgreement(a,b,t1,t2, fid):
    """
    Initially used by plotWVRSolutions to confirm that times match between antennas.
    But not currently used.  -- Todd Hunter
    """
    failures = []
    for i in range(len(t1)):
        if (fid != 0):
            fid.write('%2d %2d %.2f %.2f\n'%(a,b,t1[i],t2[i]))
        if (np.abs(t1[i] - t2[i]) > 1):
            failures.append(i)
    if (len(failures) > 0):
        return(False, failures)
    else:
        return(True, failures)

def scaleweights(msfile, wtfac=1.0, antenna='', square=False, squareroot=False,
                 spw=''):
    """
    scaleweights:  scale data weights by a user supplied factor (or square or 
                   square root them)
    Originally created by S.T. Myers 2011-08-23  v1.0 from flagaverage.py 
                     (CAS-2422)
    Improved and maintained by Todd Hunter 2014
    Note: this function assumes equivalence between spw and data_descriptor_id.
         If this is not the case for your data, email the maintainer.         
    Usage:
    au.scaleweights(msfile, wtfac, antenna)
    * wtfac =  multiplicative weight factor
    * antenna = restrict scaling to baselines including this single 
                        antenna ID (int or string)
    * square = Boolean, if True, then square the weights 
    * squareroot = Boolean, if True, then take the square root of the weights 
    * spw = integer or string or list of spws to process
    For examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/Scaleweights
    """
    if (os.path.exists(msfile) == False):
        print "Could not find ms file = ", msfile
        return(2)

    if type(wtfac) is not types.FloatType and type(wtfac) is not types.IntType:
        print 'ERROR: wtfac must be a float or integer'
        return(1)
    if (square == False and squareroot == False):
        print 'Will scale weights by a factor of '+str(wtfac)
    elif (square and squareroot):
        print "You cannot select both square and squareroot"
        return
    elif (square):
        print "Will square the existing weights"
    elif (squareroot):
        print "Will square root the existing weights"
        
    try:
        ms.open(msfile,nomodify=False)
    except:
        print "ERROR: failed to open ms tool on file "+msfile
        return(3)
    # Find number of data description IDs
    tb.open(msfile+"/DATA_DESCRIPTION")
    ddspwlist=tb.getcol("SPECTRAL_WINDOW_ID")
    ddpollist=tb.getcol("POLARIZATION_ID")
    tb.close()
    ndd = ddspwlist.__len__()
    print 'Found '+str(ndd)+' DataDescription IDs'
    # Now the polarizations (number of correlations in each pol id)
    tb.open(msfile+"/POLARIZATION")
    ncorlist=tb.getcol("NUM_CORR")
    tb.close()
    #
    ntotrow=0
    ntotpts=0
    spw = parseSpw(msfile,spw)
    print "Will process spws = ", spw
    for idd in range(ndd):
      if (idd in spw):
        # Find number of correlations in this DD
        pid = ddpollist[idd]
        ncorr = ncorlist[pid]
        # Select this DD (after reset if needed)
        if idd>0: ms.selectinit(reset=True)
        ms.selectinit(idd)
        #ms.selecttaql('SUM(WEIGHT)<'+str(wtcut))
        nwchan=0
        #recf = ms.getdata(["flag"])
        #(nx,nc,ni) = recf['flag'].shape
        # get the weights
        recw = ms.getdata(["weight"])
        antenna1 = ms.getdata(['ANTENNA1'])['antenna1']
        antenna2 = ms.getdata(['ANTENNA2'])['antenna2']
        (nx,ni) = recw['weight'].shape
        for j in range(ni):
            doscale = False
            if (antenna == ''):
                doscale = True
            elif (str(antenna) == str(antenna1[j]) or str(antenna) == str(antenna2[j])):
                doscale = True
            if (doscale):
                for i in range(nx):
                    if (square):
                        recw['weight'][i,j] = np.square(recw['weight'][i,j])
                    elif (squareroot):
                        recw['weight'][i,j] = np.sqrt(recw['weight'][i,j])
                    else:
                        recw['weight'][i,j] *= wtfac
                    nwchan += 1
        ms.putdata(recw)
        ntotrow+=ni
        ntotpts+=nwchan
        print 'Scaled '+str(nwchan)+' spectral points in '+str(ni)+' rows in DD='+str(idd)
    #
    print 'Scaled Total '+str(ntotpts)+' spectral points in '+str(ntotrow)+' rows'
    ms.close()
    return

def resetweights(msfile,wtval=1.0,spw=''):
    """
    resetweights:  set data weights to a user supplied value
    Usage:
    au.resetweights(msfile,wtval)
    * msfile = name of measurement set
    * wtval =  new weight value
    * spw = integer or string or list of spws to process
    -- Todd Hunter
    """
    if (os.path.exists(msfile) == False):
        print "Could not find ms file = ", msfile
        return(2)

    if type(wtval) is not types.FloatType and type(wtval) is not types.IntType:
        print 'ERROR: wtval must be a float or integer'
        return(1)

    print 'Will set weights to '+str(wtval)

    try:
        ms.open(msfile,nomodify=False)
    except:
        print "ERROR: failed to open ms tool on file "+msfile
        return(3)
    # Find number of data description IDs
    tb.open(msfile+"/DATA_DESCRIPTION")
    ddspwlist=tb.getcol("SPECTRAL_WINDOW_ID")
    ddpollist=tb.getcol("POLARIZATION_ID")
    tb.close()
    ndd = ddspwlist.__len__()
    print 'Found '+str(ndd)+' DataDescription IDs'
    # Now the polarizations (number of correlations in each pol id
    tb.open(msfile+"/POLARIZATION")
    ncorlist=tb.getcol("NUM_CORR")
    tb.close()
    #
    ntotrow=0
    ntotpts=0
    spw = parseSpw(msfile,spw)
    print "Will process spws = ", spw
    for idd in range(ndd):
      if (idd in spw):
        # Find number of correlations in this DD
        pid = ddpollist[idd]
        ncorr = ncorlist[pid]
        # Select this DD (after reset if needed)
        if idd>0: ms.selectinit(reset=True)
        ms.selectinit(idd)
        #ms.selecttaql('SUM(WEIGHT)<'+str(wtcut))
        nwchan=0
        #recf = ms.getdata(["flag"])
        #(nx,nc,ni) = recf['flag'].shape
        # get the weights
        recw = ms.getdata(["weight"])
        (nx,ni) = recw['weight'].shape
        for j in range(ni):
            for i in range(nx):
                recw['weight'][i,j] = wtval*recw['weight'][i,j]/recw['weight'][i,j]
                nwchan+=1
        ms.putdata(recw)
        ntotrow+=ni
        ntotpts+=nwchan
        print 'Set '+str(nwchan)+' spectral points in '+str(ni)+' rows in DD='+str(idd)
    #
    print 'Set Total '+str(ntotpts)+' spectral points in '+str(ntotrow)+' rows'
    ms.close()
    return

def splitListIntoContiguousLists(mylist):
    """
    Called by copyweights.
    Converts [1,2,3,5,6,7] into [[1,2,3],[5,6,7]], etc.
    -Todd Hunter
    """
    mylists = []
    newlist = [mylist[0]]
    for i in range(1,len(mylist)):
        if (mylist[i-1] != mylist[i]-1):
            mylists.append(newlist)
            newlist = [mylist[i]]
        else:
            newlist.append(mylist[i])
    mylists.append(newlist)
    return(mylists)
    
def compareWeights(vis, vis2):
    """
    Checks whether the 'WEIGHT' columns are equal in two measurement sets, requiring 
    that both have the same number of rows. 
    - Todd Hunter
    """
    if (not os.path.exists(vis)):
        print "Can not find vis = ", vis
        return
    if (not os.path.exists(vis2)):
        print "Can not find vis2 = ", vis2
        return
    mytb = createCasaTool(tbtool)
    mytb2 = createCasaTool(tbtool)
    mytb.open(vis)
    mytb2.open(vis2)
    nrows = len(mytb.getcol('TIME'))
    nrows2 = len(mytb2.getcol('TIME'))
    if (nrows != nrows2):
        mytb.close()
        mytb2.close()
        print "These measurement sets have an unequal number of rows."
        return
    wt = mytb.getcol('WEIGHT')
    wt2 = mytb2.getcol('WEIGHT')
    check = (wt==wt2)
    if (check.all()):
        print "The weights are identical."
    else:
        print "The weights are not all the same."
        print "%g percent are the same." % (sum(check)*100.0/len(check))
    mytb.close()
    mytb2.close()

def transferWeights(vis, outputvis):
    """
    Copies the weights from one ms to another ms, requiring that both have
    the same number of rows.  This is useful for copying weights from a
    continuum-subtracted dataset to the corresponding continuum dataset.
    vis: the measurement set from which to read the weights
    outputvis: the measurement set to which to write the weights
    - Todd Hunter
    """
    if (not os.path.exists(vis)):
        print "Can not find vis = ", vis
        return
    if (not os.path.exists(outputvis)):
        print "Can not find outputvis = ", outputvis
        return
    mytb = createCasaTool(tbtool)
    mytb2 = createCasaTool(tbtool)
    mytb.open(vis)
    mytb2.open(outputvis, nomodify=False)
    nrows = len(mytb.getcol('TIME'))
    nrows2 = len(mytb2.getcol('TIME'))
    if (nrows != nrows2):
        mytb.close()
        mytb2.close()
        print "These measurement sets have an unequal number of rows."
        return
    print "Reading weights"
    wt = mytb.getcol('WEIGHT')
    print "Writing weights"
    mytb2.putcol('WEIGHT', wt)
    mytb.close()
    mytb2.close()
    

def copyweights(msfile):
    """
    copyweights copies the WEIGHT column to the WEIGHT_SPECTRUM column by
    using the same value for all channels in the spectrum (on a 
    per-polarization basis).
    
    Usage: copyweights(msfile)
    -- Todd Hunter
    """
    if (os.path.exists(msfile) == False):
        print "Could not find ms file = ", msfile
        return(2)
    mytb = createCasaTool(tbtool)
    mytb.open(msfile)
    colnames = mytb.colnames()
    mytb.close()
    """
    myms = createCasaTool(mstool)
    try:
        myms.open(msfile,nomodify=False)
    except:
        print "ERROR: failed to open ms tool on file "+msfile
        return(3)
    """
    # Find number of data description IDs
    mytb.open(msfile+"/DATA_DESCRIPTION")
    ddspwlist=mytb.getcol("SPECTRAL_WINDOW_ID")
    ddpollist=mytb.getcol("POLARIZATION_ID")
    mytb.close()
    ndd = ddspwlist.__len__()
    print 'Found '+str(ndd)+' DataDescription IDs'
    # Now the polarizations (number of correlations in each pol id)
    mytb.open(msfile+"/POLARIZATION")
    ncorlist=mytb.getcol("NUM_CORR")
    mytb.close()
    mytb.open(msfile, nomodify=False)
    #
    ntotrow=0
    ntotpts=0
    for idd in range(ndd):
        print "working on data descriptor %d/%d" % (idd+1,ndd)
        myms = mytb.getcol('DATA_DESC_ID')
        indices = np.where(myms == idd)[0]
        mylists = splitListIntoContiguousLists(indices)
        for m in range(len(mylists)):
            mylist = mylists[m]
            startrow = mylist[0]
            stoprow = mylist[-1]
            nrow = stoprow-startrow+1
            data = mytb.getvarcol("DATA", startrow, nrow)
            recw = mytb.getvarcol("WEIGHT", startrow, nrow)
            recws = mytb.getvarcol("WEIGHT_SPECTRUM", startrow, nrow)
            for row in recws.keys():
                datarow = np.real(data[row])/np.real(data[row])
                for pol in range(len(datarow)):
                    multiplier = recw[row][pol]
                    datarow[pol] *= multiplier
                recws[row] = datarow
            mytb.putvarcol('WEIGHT_SPECTRUM', recws, startrow, nrow)

    mytb.close()
    return

def getDataShapes(vis):
    """
    Finds and returns the number of polarizations in non-WVR (BBC 0) spws.
    Return value can be [1], [1,2], [1,2,4], [2,4], [1,4], [4]
    -- Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not find ms file = ", vis
        return(2)
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return

    try:
        ms.open(vis)
    except:
        print "ERROR: failed to open ms tool on file "+vis
        return(3)
    # Find number of data description IDs
    mytb = createCasaTool(tbtool)
    mytb.open(vis+"/DATA_DESCRIPTION")
    ddspwlist=mytb.getcol("SPECTRAL_WINDOW_ID")
    ddpollist=mytb.getcol("POLARIZATION_ID")
    mytb.close()
    ndd = ddspwlist.__len__()
#    print 'Found '+str(ndd)+' DataDescription IDs'
    # Now the polarizations (number of correlations in each pol id)
    mytb.open(vis+"/POLARIZATION")
    ncorlist = mytb.getcol("NUM_CORR")
    mytb.close()
    ncorrs = []
    for idd in range(ndd):
        # Find number of correlations in this DD
        pid = ddpollist[idd]
        ncorr = ncorlist[pid]
        if (ncorr == 1):
#            print "Single-pol spw = ", ddspwlist[idd]
            if (getBasebandNumber(vis, ddspwlist[idd]) == 0):  # WVR is always BBC 0
                continue
        ncorrs.append(ncorr)
    #
    ncorrs = np.unique(ncorrs)
#    print "unique sizes of correlations = ", ncorrs
    return(ncorrs)

def getObservationStop(vis):
    """
    Read the stop time of the observation and report it in MJD seconds.
    -Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "vis does not exist = %s" % (vis)
        return(2)
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mytb = createCasaTool(tbtool)
    try:
        mytb.open(vis+'/OBSERVATION')
    except:
        print "ERROR: failed to open OBSERVATION table on file "+vis
        return(3)

    time_range = mytb.getcol('TIME_RANGE')[0]
    mytb.close()
    if (type(time_range) == np.ndarray):
        time_range = time_range[-1]
    return(time_range)

def getObservationStopDate(vis):
    """
    Read the stop time of the observation and reports the date.
    '2013-01-31 07:36:01 UT'
    -Todd Hunter
    """
    mjdsec = getObservationStop(vis)
    obsdateString = mjdToUT(mjdsec/86400.)
    return(obsdateString)

def getObservationStart(vis):
    """
    Read the start time of the observation and report it in MJD seconds.
    -Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "vis does not exist = %s" % (vis)
        return(2)
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mytb = createCasaTool(tbtool)
    try:
        mytb.open(vis+'/OBSERVATION')
    except:
        print "ERROR: failed to open OBSERVATION table on file "+vis
        return(3)

    time_range = mytb.getcol('TIME_RANGE')[0]
    mytb.close()
    if (type(time_range) == np.ndarray):
        time_range = time_range[0]
    return(time_range)

def getObservationStartDate(vis):
    """
    Read the start time of the observation and reports the date.
    '2013-01-31 07:36:01 UT'
    -Todd Hunter
    """
    mjdsec = getObservationStart(vis)
    obsdateString = mjdToUT(mjdsec/86400.)
    return(obsdateString)

def timeShift(vis='', seconds=''):
    """
    Shift the observation time of an ms by a specified number of seconds in
    the OBSERVATION table TIME_RANGE column.
    This is simply a debugging tool and is not meant to correct a dataset!
    Todd Hunter
    """

    if (os.path.exists(vis) == False):
        print "vis does not exist = %s" % (vis)
        return(2)
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    try:
        tb.open(vis+'/OBSERVATION',nomodify=False)
    except:
        print "ERROR: failed to open OBSERVATION table on file "+vis
        return(3)

    time_range = tb.getcol('TIME_RANGE')
    print "Time range changed from: %f - %f (%s - %s)" % (time_range[0], time_range[1],
                                                          plotbp3.utstring(time_range[0]),
                                                          plotbp3.utstring(time_range[1]))
    time_range[0] += seconds
    time_range[1] += seconds
    tb.putcol('TIME_RANGE',time_range)
    tb.close()
    print "                     to: %f - %f (%s - %s)" % (time_range[0], time_range[1],
                                                          plotbp3.utstring(time_range[0]),
                                                          plotbp3.utstring(time_range[1]))

def timeDifference(vis='', vis2=''):
    """
    Find the difference in observation start time between two ms.
    using the OBSERVATION table TIME_RANGE column.
    Todd Hunter
    """

    if (os.path.exists(vis) == False):
        print "vis does not exist = %s" % (vis)
        return(2)
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  vis1 does not appear to be an ms."
        return
    if (os.path.exists(vis2) == False):
        print "vis2 does not exist = %s" % (vis2)
        return(2)
    if (os.path.exists(vis2+'/table.dat') == False):
        print "No table.dat.  vis2 does not appear to be an ms."
        return
    try:
        tb.open(vis+'/OBSERVATION')
    except:
        print "ERROR: failed to open OBSERVATION table on file "+vis
        return(3)
    time_range = tb.getcol('TIME_RANGE')
    tb.close()
    try:
        tb.open(vis2+'/OBSERVATION')
    except:
        print "ERROR: failed to open OBSERVATION table on file "+vis2
        return(3)
    time_range2 = tb.getcol('TIME_RANGE')
    tb.close()
    print "Time difference (vis2-vis1) = %f sec" % (time_range2[0]-time_range[0])

def uvwDifference(vis='', vis2=''):
    """
    Find the difference in uvw's between two (nearly) identical ms.
    Useful for confirming that fixvis did the right thing.
    Todd Hunter
    """

    if (os.path.exists(vis) == False):
        print "vis does not exist = %s" % (vis)
        return(2)
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  vis does not appear to be an ms."
        return
    if (os.path.exists(vis2) == False):
        print "vis2 does not exist = %s" % (vis2)
        return(2)
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  vis2 does not appear to be an ms."
        return
    try:
        tb.open(vis)
    except:
        print "ERROR: failed to open file "+vis
        return(3)
    uvw1 = tb.getcol('UVW')
    tb.close()
    try:
        tb.open(vis2)
    except:
        print "ERROR: failed to open file "+vis2
        return(3)
    uvw2 = tb.getcol('UVW')
    field = tb.getcol('FIELD_ID')
    tb.close()
    if (len(uvw1) != len(uvw2)):
        print "These ms differ in their number of rows (%d vs. %d)." % (len(uvw1),len(uvw2))
        return
    else:
        print "Boths ms have %d rows. Good." % (len(uvw1))
    fields = []
    differences = 0
    u = []
    v = []
    w = []
    for i in range(len(uvw1)):
        deltaU = uvw1[i][0]-uvw2[i][0]
        deltaV = uvw1[i][1]-uvw2[i][1]
        deltaW = uvw1[i][2]-uvw2[i][2]
        if (abs(deltaU)>0 or abs(deltaV)>0 or abs(deltaW)>0):
            u.append(abs(deltaU))
            v.append(abs(deltaV))
            w.append(abs(deltaW))
            fields.append(field[i])
            differences += 1
    fields = np.unique(fields)
    print "Found %d rows that differ." % (differences)
    if (differences > 0):
        print "Fields that differ: ", fields
        print "Median absolute differences: %f,%f,%f" % (np.median(u),np.median(v),np.median(w))

def getRADecStringForField(vis, myfieldId, usemstool=False, forcePositiveRA=False):
    """
    Returns an RA/Dec sexagesimal string for the specified field in the specified ms.
    myfieldId can be integer or string integer
    """
    return(rad2radec(getRADecForField(vis,myfieldId,usemstool,forcePositiveRA)))

def getRADecForField(vis, myfieldId, usemstool=False, forcePositiveRA=False):
    """
    Returns [RA,Dec] in radians for the specified field in the specified ms.
    myfieldId can be integer or string integer
    -- Todd Hunter
    """
    if (casadef.casa_version >= '4.2.0' and  usemstool):
        myms = createCasaTool(mstool)
        myms.open(vis)
        mydir = myms.getfielddirmeas(fieldid=myfieldId) # dircolname defaults to 'PHASE_DIR'
        mydir = np.array([[mydir['m0']['value']], [mydir['m1']['value']]]) # simulates tb.getcell
        myms.close()
    else:
        mytb = createCasaTool(tbtool)
        try:
            mytb.open(vis+'/FIELD')
        except:
            print "Could not open FIELD table for ms=%s" % (vis)
            return([0,0])
        mydir = mytb.getcell('DELAY_DIR',int(myfieldId))
        if (forcePositiveRA):
            if (mydir[0] < 0):
                mydir[0] += 2*math.pi
        mytb.close()
    return(mydir)

def getOUS(asdm):
    """
    Find the OUS that an ASDM is associated with by reading the ExecBlock.xml table.
    -- Todd Hunter
    """
#  <EntityRef entityId="uid://A002/X314ea1/X239" partId="X00000000" entityTypeName="OUSStatus" documentVersion="1.0" />
    execblock = asdm.strip() + '/ExecBlock.xml'
    if (os.path.exists(execblock) == False):
        print "Could not open %s" % (execblock)
        return
    cmd = "grep OUSStatus %s" % execblock
    status, output = commands.getstatusoutput(cmd)
    tokens = output.split()
    if (tokens < 5):
        print "Unexpected result = ", output
        return('')
    ous = tokens[1].split('=')[-1]
    ous = ous[1:-1] # chop off the double quotes
    ousUnderscore = ous.replace(':','_').replace('/','_')
    if (1 == 0):
        # apparently, minidom cannot parse EntityRef's
        xmlscans = minidom.parse(execblock)
        rowlist = xmlscans.getElementsByTagName("row")
        row = rowlist[0].getElementsByTagName("sessionReference")
        ousEntity = str(row[0].childNodes[0].nodeValue)  # this comes out simply as '\n'
    print "ous = %s = %s" % (ous, ousUnderscore)
    print "Now, you might wish to run (from bash):  pipelineMakeRequest %s intents_hif.xml procedure_hifcal.xml false" % (ous)
    return(ous)

def getSubscanTimesFromASDM(asdm, field=''):
    """
    Reads the subscan information from the ASDM's Subscan.xml file and
    returns a dictionary of form:
    {scan: {subscan: {'field': '3c273, 'integrationTime': 2.016,
                      'numIntegration': 5, 'subscanLength': 10.08}}}
    -- dbarkats
    """
    if (asdmLibraryAvailable == False):
        print "The ASDM bindings library is not available on this machine. Using minidom code instead."
        return(au_noASDMLibrary.getSubscanTimesFromASDM_minidom(asdm,field))
    a = ASDM()
    a.setFromFile(asdm,True)
    subscanTable = a.subscanTable().get()  

    # get the start time of the ASDM
    dateStart, dateStart_mjdSec = getObservationStartDateFromASDM(asdm)
    dateEnd, dateEnd_mjdSec = getObservationEndDateFromASDM(asdm)

    scandict = {}
    scanNumbers = 0
    subscanTotalTime= 0
    for row in subscanTable:
        scanNumber = row.scanNumber()
        subscanNumber = row.subscanNumber()
        startTime = row.startTime().get() *1e-9
        endTime = row.endTime().get() *1e-9
        numIntegration = row.numIntegration()
        fieldName = row.fieldName()
        if (field=='' or fieldName==field):
            subscanLength = (endTime-startTime)
            subscanTotalTime += subscanLength
            integrationTime = subscanLength / (1.0*numIntegration)
            if (scanNumber not in scandict):
                scandict[scanNumber] = {}
                scanNumbers += 1
            scandict[scanNumber][subscanNumber] = {'subscanLength': subscanLength, 'numIntegration': numIntegration, 'integrationTime': integrationTime, 'field': fieldName, 'startTime':startTime,'endTime':endTime}
    print "Found %d scans" % (scanNumbers)
    totalTime = (dateEnd_mjdSec - dateStart_mjdSec)
    print totalTime, subscanTotalTime
    latency = totalTime - subscanTotalTime
    print "Total latency = %g/%g seconds = %g percent" % (latency, totalTime, latency*100/totalTime)
    return(scandict)
      
    
def getCorrelatorNameFromMS(vis):
    """
    Returns the correlator used in the specified measurement set.
    -- Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not find MS = ", vis
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    cmode = vis+'/ASDM_CORRELATORMODE'
    if (os.path.exists(cmode) == False):
        print "Cannot find the ASDM_CORRELATORMODE table.  You need to run importasdm with asis='CorrelatorMode'."
        return
    mytb = createCasaTool(tbtool)
    mytb.open(cmode)
    corrName = mytb.getcol('correlatorName')[0]
    mytb.close()
    return corrName
    
def getCorrelatorName(asdm):
    """
    Returns the correlator used in the specified ASDM.
    -- Todd Hunter
    """
#    <correlatorName>ALMA_ACA</correlatorName> 
    execblock = asdm + '/CorrelatorMode.xml'
    if (os.path.exists(execblock) == False):
        print "Could not open %s" % (execblock)
        return
    xmlscans = minidom.parse(execblock)
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    row = rowlist[0].getElementsByTagName("correlatorName")
    myName = str(row[0].childNodes[0].nodeValue)
    return(myName)
        
def getObservatoryNameFromASDM(asdm):
    """
    Returns the observatory name in the specified ASDM.
    -- Todd Hunter
    """
#    uid___A002_X54d35d_X761/ExecBlock.xml:    <telescopeName>ALMA</telescopeName>
    execblock = asdm + '/ExecBlock.xml'
    if (os.path.exists(execblock) == False):
        print "Could not open %s" % (execblock)
        return
    xmlscans = minidom.parse(execblock)
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    row = rowlist[0].getElementsByTagName("telescopeName")
    myName = str(row[0].childNodes[0].nodeValue).strip(' ')
#    print "Observatory = ", myName
    return(myName)

def getObservationStartDateFromASDMs(asdmlist, outfile='asdm_dates.txt',
                                     getAntennas=False, getSBFrequencies=False):
    """
    For a list of ASDMs, writes a file containing the start date/time of each.
    asdmlist: either a list of strings, or a string containing a wildcard pattern
    getAntennas: if True, then also list the antennas
    -- Todd Hunter
    """
    if (type(asdmlist)==str):
        asdmlist = sorted(glob.glob(asdmlist))
    f = open(outfile,'w')
    for asdm in asdmlist:
        if (asdm.find('.ms') > 0): continue
        if (asdm.find('.txt') > 0): continue
        utdate, mjdsec = getObservationStartDateFromASDM(asdm)
        if (getAntennas):
            antennas = ','.join(readAntennasFromASDM(asdm))
        else:
            antennas = ''
        mf = getMeanFreqFromASDM(asdm)
        if (getSBFrequencies):
            lsb = str(np.round(mf['lsb']['meanfreq']*1e-9, 1))
            usb = str(np.round(mf['usb']['meanfreq']*1e-9, 1))
        else:
            lsb = ''
            usb =''
        f.write("%s %s %s %s %s\n" % (asdm,utdate,antennas,lsb,usb))
        
    f.close()
    print "Result left in %s" % (outfile)
        
def getObservationStartDateFromASDM(asdm):
    """
    Returns the start date/time and MJD seconds in the specified ASDM.
    -- Todd Hunter
    """
#    uid___A002_X54d35d_X761/ExecBlock.xml:    <startTime>ALMA</startTime>
    execblock = asdm + '/ExecBlock.xml'
    if (os.path.exists(execblock) == False):
        print "Could not open %s" % (execblock)
        return
    xmlscans = minidom.parse(execblock)
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    row = rowlist[0].getElementsByTagName("startTime")
    mjdsec = int(row[0].childNodes[0].nodeValue) * 1e-9
    utdate = mjdsecToUT(mjdsec)
    return(utdate, mjdsec)

def getObservationEndDateFromASDM(asdm):
    """
    Returns the end date/time and MJD seconds in the specified ASDM.
    --  based on getObservationStartDateFromASDM
    """
#    uid___A002_X54d35d_X761/ExecBlock.xml:    <startTime>ALMA</startTime>
    execblock = asdm + '/ExecBlock.xml'
    if (os.path.exists(execblock) == False):
        print "Could not open %s" % (execblock)
        return
    xmlscans = minidom.parse(execblock)
    rowlist = xmlscans.getElementsByTagName("row")
    fid = 0
    row = rowlist[0].getElementsByTagName("endTime")
    mjdsec = int(row[0].childNodes[0].nodeValue) * 1e-9
    utdate = mjdsecToUT(mjdsec)
    return(utdate, mjdsec)
        
def getObservatoryName(ms):
    """
    Returns the observatory name in the specified ms.
    -- Todd Hunter
    """
    try:
        antTable = ms+'/OBSERVATION'
        mytb = createCasaTool(tbtool)
        mytb.open(antTable)
        myName = mytb.getcell('TELESCOPE_NAME')
        mytb.close()
    except:
        print "Could not open OBSERVATION table to get the telescope name: %s" % (antTable)
        myName = ''
    return(myName)
    
def computeAzElFromRADecMJD(raDec, mjd, observatory='ALMA', verbose=False):
    """
    Computes the az/el for a specified J2000 RA/Dec, MJD and observatory.

    raDec must either be a tuple in radians: [ra,dec],
        or a string of the form "hh:mm:ss.sss -dd:mm:ss.ss"
    mjd must either be in days, or a date string of the form:
               2011/10/15 05:00:00  or   2011/10/15-05:00:00
            or 2011-10-15 05:00:00  or   2011-10-15-05:00:00
    observatory: must be either a name recognized by the CASA me tool, or a JPL Horizons
                 ID listed in the JPL_HORIZONS_ID dictionary at the top of this module.
    returns the [az,el] in radians
    - Todd Hunter
    """
    if (observatory == 'MAUNAKEA'):
        # Convert from a value known to JPL Horizons to a value known to CASA
        observatory = 'SMA'
    elif (observatory in JPL_HORIZONS_ID.values()):
        observatory = JPL_HORIZONS_ID.keys()[JPL_HORIZONS_ID.values().index(str(observatory))]
    me = createCasaTool(metool)
    if (type(raDec) == str):
        # Then assume it is of the format "hh:mm:ss.sss -dd:mm:ss.ss"
        tokens = raDec.split()
        if (len(tokens) < 2):
            tokens = raDec.split(',')
            if (len(tokens) < 2):
                print "If you give a string, it must be of the format: hh:mm:ss.sss -dd:mm:ss.ss"
                return
        raDec = radec2rad(raDec)
        if (verbose):
            print "RA Dec in radians = ", raDec
    if (type(mjd) == str):
        mjd = dateStringToMJD(mjd)
        if (mjd == None):
            print "Invalid date string"
            return
        print "MJD = ", mjd
    mydir = me.direction('J2000', qa.quantity(raDec[0],'rad'), qa.quantity(raDec[1],'rad'))
    me.doframe(me.epoch('mjd', qa.quantity(mjd, 'd')))
    me.doframe(me.observatory(observatory))
    myazel = me.measure(mydir,'azel')
    myaz = myazel['m0']['value']
    myel = myazel['m1']['value']
    if (verbose):
        print "%s: Azim = %.3f deg   Elev = %.3f deg" % (observatory, myaz*180/np.pi, myel*180/np.pi)
    return([myaz,myel])

def mjdToLocalTime(mjd, tz):
    """
    Converts an MJD to a local time as a datetime structure.
    tz: a string (See http://stackoverflow.com/questions/13866926/python-pytz-list-of-timezones)
    -Todd Hunter
    """
    utc = mjdListToDateTime([float(mjd)])[0]
    utc_dt = pytz.utc.localize(utc)
    local_dt = utc_dt.astimezone(pytz.timezone(tz))
    return(local_dt)
    
def mjdToChileTime(mjd):
    """
    Converts an MJD to Chile/Continetnal time as a datetime structure.
    -Todd Hunter
    """
    return(mjdToLocalTime(float(mjd), 'Chile/Continental'))

def mjdToMountainTime(mjd):
    """
    Converts an MJD to US Mountain time as a datetime structure.
    -Todd Hunter
    """
    return(mjdToLocalTime(float(mjd), 'US/Mountain'))

def computeUTForElevation(elevation, radec=None, date='', mjd=0, observatory='ALMA',
                          intervalMinutes=5, vis=None, field=None, useJPL=False):
    """
    For a specified RA/Dec, date/MJD, and elevation, compute the UT time that the
    object will cross that point.
    raDec must either be a tuple in radians: [ra,dec],
        or a string of the form "hh:mm:ss.sss -dd:mm:ss.ss"
    mjd: modified Julian date (optional, default = today)
    date: string date (optional)
        Either of these formats is valid: 2011/10/15, 2011-10-15
    The time portion is optional.
    elevation: in degrees
    observatory: location to run the calculation for
    intervalMinutes: grid size to use
    vis: the measurement set from which to read the field coordinates
    field: the field ID or name in the measurement set to use, or name of a planet
            if a planet, then find its position on the specified date (or today)
    useJPL: if True, query JPL Horizons for planets instead of casa ephemerides
    
    -Todd Hunter
    """
    mindiffRising = 1e9
    mindiffSetting = 1e9
    if (mjd==0 and date==''):
        mjd = getMJD()
    elif (date != ''):
        mjd = dateStringToMJD(date, verbose=False)
    previousEl = np.pi
    if (radec == None):
        if (vis==None and field==None):
            print "You must specify either radec, field or (vis and field)"
            return
        if (field == None):
            print "If you specify vis, then you must also specify field ID or field name."
            return
        if (vis == None):
            print "Since vis has not been specified, I will assume that %s is a planet." % (field)
            radec = planet(field,mjd=mjd,useJPL=useJPL)['directionRadians']
        else:
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(vis)
            try:
                field = int(field)
                fieldname = mymsmd.namesforfields(field)[0]
            except:
                fieldname = field
                if (fieldname not in mymsmd.namesforfields()):
                    print "%s is not in the measurement set" % (fieldname)
                    return
                field = mymsmd.fieldsforname(field)[0]
            mymsmd.close()
            myms = createCasaTool(mstool)
            myms.open(vis)
            radec = direction2radec(myms.getfielddirmeas(fieldid=field))
            myms.close()
            print "Got field %d = %s at %s" % (field,fieldname,radec)
    for m in np.arange(mjd,mjd+1,intervalMinutes/1440.):
        az,el = computeAzElFromRADecMJD(radec, m, observatory, verbose=False)
        diff = abs(elevation-el*180/np.pi)
        if (previousEl < np.pi):
            if (el > previousEl):
                if (diff < mindiffRising):
                    mindiffRising = diff
                    mjdAtMinDiffRising = m
            else:
                if (diff < mindiffSetting):
                    mindiffSetting = diff
                    mjdAtMinDiffSetting = m
        previousEl = el
    if (mindiffRising < 1):
        if (observatory == 'ALMA'):
            local_dt = mjdToChileTime(mjdAtMinDiffRising)
            localrise = " = %s Chile time" % (local_dt.strftime('%H:%M'))
            local_dt = mjdToChileTime(mjdAtMinDiffSetting)
            localset = " = %s Chile time" % (local_dt.strftime('%H:%M'))
        elif (observatory.find('VLA') >= 0):
            local_dt = mjdToMountainTime(mjdAtMinDiffRising)
            localrise = " = %s Mountain time" % (local_dt.strftime('%H:%M'))
            local_dt = mjdToMountainTime(mjdAtMinDiffSetting)
            localset = " = %s Mountain time" % (local_dt.strftime('%H:%M'))
        else:
            localrise = ''
            localset = ''
        print " rising: %s UT %s" % (mjdsecToUTHM(mjdAtMinDiffRising*86400), localrise)
        print "setting: %s UT %s" % (mjdsecToUTHM(mjdAtMinDiffSetting*86400), localset)
    else:
        print "Object never crosses that elevation (mindiff=%fdeg)" % (mindiff)
    
def nutation(radec=None, mjdsec=None, vis=None, fieldId=None):
    """
    Computes the effect of nutation on celestial equatorial coordinates, based on the formula
    of Hohenkerek et al. 1992 (see Rick Fisher's home page), which is good to about an arc
    second.
    inputs:
       radec: a tubple in radians or a sexagesimal string ('hh:mm:ss.s +dd:mm:ss.s')
       mjdsec: time in MJD seconds (default = now)
    returns:
       deltaRa and deltaDec in arc seconds
    -Todd Hunter
    """
    if (radec != None):
        if (type(radec) == str):
            ra,dec = radec2rad(radec)
            radec = [ra,dec]
        if (mjdsec == None):
            mjdsec = getCurrentMJDSec()
    elif (vis == None):
        print "You must either give radec or vis+fieldId"
        return
    else:
        radec = getRADecForField(vis, fieldId, usemstool=True)
        ra = radec[0][0]
        dec = radec[1][0]
        radec = [ra,dec]
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        mjdsec = np.mean(mymsmd.timesforfield(fieldId))
        mymsmd.close()

    d = mjdToJD(mjdsec/86400) - 2451545.0
    dL = -17.3 * np.sin((125.0 - 0.5295*d)*np.pi/180.) - 1.4*np.sin((200.0 + 1.97129*d)*np.pi/180.)
    dE = 9.4 * np.cos((125-0.05295*d)*np.pi/180) + 0.7*np.cos((200.0 + 1.97129*d)*np.pi/180.)
    dRA = (0.9175 + 0.3978*np.sin(radec[0])*np.tan(radec[1]))*dL - np.cos(radec[0])*np.tan(radec[1])*dE
    dDec = 0.3978*np.cos(radec[0])*dL + np.sin(radec[0])*dE
    return([dRA, dDec])
                        
def refraction(elevationDegrees, pressure=563, temperature=273, RH=20):
    """
    Computes the radio refraction angle in arc seconds,
    using the formula of Ulich (1981) and Brussaard & Watson (1995).
    Should add the formulae from CSV-2934 once it is resolved.
    Inputs:
    elevationDegrees: in degrees
    temperature: in Kelvin
    pressure: in mbar
    RH: in percentage
    -Todd Hunter
    """
    Pdry = pressure
    T = temperature
    esat = 6.105*np.exp(25.22*(T-273)/T - 5.31*np.log(T/273))
    Pw = 0.01*RH/esat
    elev = elevationDegrees*np.pi/180
    f = np.cos(elev)/(np.sin(elev) + 0.00175*np.tan(87.5-elev))
    Ro = 16.01*Pdry/T - 1.15*Pw/T + (7.734937e4)*Pw/(T**2)
    Rsec = Ro*f
    return(Rsec)

def computeRADecFromAzElUnixtime(filename, outname=None, timeColumn=1,
                                 azimuthColumn=2, elevationColumn=3,
                                 observatory='ALMA'):
    """
    Reads an ASCII file with unixtime, azimuth and elevation as columns
    and produces a new file with UT, right ascension, hour angle and
    declination.
    timeColumn: the column number containing time (columns start at zero)
                in unix time (seconds since 1970)
    azimuthColumn: the column number containing azimuth in degrees
    elevationColumn: the column number containing elevation in degrees
    observatory: the name of the observatory for the azimuth, elevation values.
                 Must be either a name recognized by the CASA me tool, or a
                 JPL Horizons ID listed in the JPL_HORIZONS_ID dictionary at
                 the top of this module.
    - Todd Hunter
    """
    f = open(filename,"r")
    if (outname == None):
        outname = filename + ".radec"
    o = open(outname,'w')
    unixtime = []
    azimuth = []
    elevation = []
    ra = []
    dec = []
    o.write('# Minutes  UnixTime(sec)  Az(degree) El(degree)  MJD  UT(hrs)  RA(hours) Dec(degree) HA(hours)\n')
    [latitude, longitude, obs] = getObservatoryLatLong(observatory)
    for line in f.readlines():
        tokens = line.split()
        if (len(tokens) < max([timeColumn,azimuthColumn,elevationColumn])):
            continue
        unixtime.append(float(tokens[timeColumn]))
        azimuth.append(float(tokens[azimuthColumn])*np.pi/180.)
        elevation.append(float(tokens[elevationColumn])*np.pi/180.)
        mjd = jdToMJD(ComputeJulianDayFromUnixTime(unixtime[-1]))
        ut = 24*(mjd-np.floor(mjd))
        LST = ComputeLST(mjd*86400, longitude)
        a,b = computeRADecFromAzElMJD([azimuth[-1], elevation[-1]],
                                      mjd, observatory=observatory,
                                      verbose=False)
        ra.append(a*12/np.pi)
        dec.append(b*180/np.pi)
        hourAngle = LST-ra[-1]
        if (hourAngle > 12): hourAngle -= 24
        o.write(line[:-1] + ' %.4f %.4f %.6f %.6f %.4f\n'%(mjd,ut,ra[-1],dec[-1],hourAngle))
    f.close()
    o.close()
    if (len(unixtime) < 1):
        print "No data found in file"
        return
    print "Results left in file = ", outname
    
def computeRADecFromAzElMJD(azel, mjd, observatory='ALMA', verbose=True,
                            my_metool=None, refractionCorrection=False,
                            nutationCorrection=False):
    """
    Computes the J2000 RA/Dec for a specified AZELGEO coordinate, MJD and
    observatory.

    azel must either be a tuple in radians
    mjd must either be in days, or a date string of the form:
               2011/10/15 05:00:00  or   2011/10/15-05:00:00
            or 2011-10-15 05:00:00  or   2011-10-15-05:00:00
    observatory: must be either a name recognized by the CASA me tool, or a
         JPL Horizons ID listed in the JPL_HORIZONS_ID dictionary at the top
         of this module.
    refractionCorrection: subtract the (positive) refractionCorrection to the
         elevation prior to conversion
    nutationCorrection: apply the nutation correction after conversion
    returns the [RA,Dec] in radians
    - Todd Hunter
    """
    if (observatory == 'MAUNAKEA'):
        # Convert from a value known to JPL Horizons to a value known to CASA"
        observatory = 'SMA'
    elif (observatory in JPL_HORIZONS_ID.values()):
        observatory = JPL_HORIZONS_ID.keys()[JPL_HORIZONS_ID.values().index(str(observatory))]
    myme = my_metool
    if (my_metool == None):
        myme = createCasaTool(metool)
    if (type(mjd) == str):
        mjd = dateStringToMJD(mjd)
        if (mjd == None):
            print "Invalid date string"
            return
        print "MJD = ", mjd
    if (refractionCorrection):
        azel[1] -= refraction(azel[1]*180/np.pi) / (180*3600/np.pi)
    mydir = myme.direction('AZELGEO', qa.quantity(azel[0],'rad'), qa.quantity(azel[1],'rad'))
    myme.doframe(myme.epoch('mjd', qa.quantity(mjd, 'd')))
    myme.doframe(myme.observatory(observatory))
    myradec = myme.measure(mydir,'J2000')
    myra = myradec['m0']['value']
    if (myra < 0):
        myra += 2*np.pi
    mydec = myradec['m1']['value']
    if (nutationCorrection):
        dRA, dDec = nutation([myra,mydec], mjdsec=mjd*86400.)
        myra += dRA*np.pi/180./3600.
        mydec += dDec*np.pi/180./3600.
    if (verbose):
        print "RA = %.3f hr   Dec = %.3f deg" % (myra*12/np.pi, mydec*180/np.pi)
    if (my_metool == None):
        myme.done()
    return([myra,mydec])

def unnormalize(vis='',spwID='', scan='', state=None):
    """
    Multiply the cross-correlation spectra by the autocorrelation.
    Under development....
    -- T. Hunter
    """
    antenna1 = '0'
    antenna2 = '1'
    data = Visibility(vis,antenna1=antenna1, antenna2=antenna2,spwID=spwID,scan=scan,state=state, cross_auto_all='all')
    data.setAntennaPair(antenna1,antenna2)
    data.getAmpAndPhase()
    data.getSpectralData()
    print "shape(specFreq, amp)", np.shape(data.specFreq), np.shape(data.amp[0])
    pb.plot(1e-9*data.specFreq,data.amp[0])
    pb.title('Scan %d, Antennas %s-%s' % (scan,antenna1,antenna2))
    pb.xtitle('Freq (GHz)')
    pb.draw()

def analyzeWeights(vis='',antenna1='', antenna2='',scan=''):
    """
    Compares the SIGMA and WEIGHT for the first row of the table and
    checks if weight = 1/sigma**2.  If no arguments are specified, it
    uses the antenna numbers and scan number in the first row.
    -- T. Hunter
    """
    tb.open(vis)
    pol = 0
    if (antenna1==''):
        antenna1 = tb.getcol('ANTENNA1')[0]
    if (antenna2==''):
        antenna2 = tb.getcol('ANTENNA2')[0]
    if (scan==''):
        scan = tb.getcol('SCAN_NUMBER')[0]
    queryString = "ANTENNA1==%d AND ANTENNA2==%d AND SCAN_NUMBER==%d"%(int(antenna1),int(antenna2),int(scan))
    print "Checking first row with %s." % (queryString)
    subtable = tb.query(queryString)
    npols = len(subtable.getcol('SIGMA')[:,0])
    for pol in range(npols):
      weight = subtable.getcol('WEIGHT')[pol][0]
      sigma = subtable.getcol('SIGMA')[pol][0]
      product = sigma*math.sqrt(weight)
      if (abs(product -1) > 1e-5):
        print "Pol%d: The weights differ from the 1/sigma**2 by a factor of %g." % (pol, product)
      else:
        print "Pol%d: The weights are equal to 1/sigma**2." % (pol)
      

def compareAntennaPositionCorrections(antenna1='', parameter1='',
                                      antenna2='', parameter2=''):
    """
    Computes the difference (in mm) between two antenna baseline solutions
    on a per antenna basis.  The input format is the same as for gencal.
    Returns dictionaries of the vector differences and magnitudes.
    Example:
    antenna1='DV03,DV04'
    antenna2='DV03,DV04'
    parameter1=[-0.00011,3.965e-08,0.000126, -0.0001939,-2.638e-05,0.0001716]
    parameter2=[-0.00012,3.966e-08,0.000136, -0.0001839,-2.648e-05,0.0002716]
    -- Todd Hunter
    """
    if (antenna1=='' or antenna2=='' or parameter1=='' or parameter2==''):
        print "Usage: compareAntennaPositionCorrections(antenna1='', parameter1='', antenna2='', parameter2='')"
        return
    p1 = np.array(parameter1).reshape(len(parameter1)/3, 3)
    p2 = np.array(parameter2).reshape(len(parameter2)/3, 3)
    differences = {}
    magnitudes = {}
    mag = []
    ant1 = antenna1.split(',')
    ant2 = antenna2.split(',')
    antennas = np.unique(ant1+ant2)
    antennasPrinted = []
    for a1 in range(len(ant1)):
        ant = ant1[a1]
        myindex = ant2.index(ant)
        if (myindex >= 0):
            antennasPrinted.append(ant)
            differences[ant] = (p1[a1] - p2[myindex])*1000
            mag.append(sqrt(sum(np.array([differences[ant]])**2)))
            magnitudes[ant] = mag[-1]
            print "%s %+.3f %+.3f %+.3f   total = %+.3f mm" % (ant,
                                                        differences[ant][0],
                                                        differences[ant][1],
                                                        differences[ant][2],
                                                        magnitudes[ant]
                                                        )
    print "Standard deviation = %+.3f mm" % (np.std(mag))
    firstTime = True
    for ant in antennas:
        if (ant not in antennasPrinted):
            if (firstTime):
                print "Solutions present in only one argument:"
                firstTime = False
            if (ant in ant1):
                myindex = ant1.index(ant)
                magnitude = sqrt(sum(np.array([p1[myindex]])**2))*1000
                print "%s %+.3f %+.3f %+.3f   total = %+.3f mm" % (ant,
                                                        p1[myindex][0]*1000,
                                                        p1[myindex][1]*1000,
                                                        p1[myindex][2]*1000,
                                                        magnitude)
            else:
                myindex = ant2.index(ant)
                magnitude = sqrt(sum(np.array([p2[myindex]])**2))*1000
                print "%s %+.3f %+.3f %+.3f   total = %+.3f mm" % (ant,
                                                        p2[myindex][0]*1000,
                                                        p2[myindex][1]*1000,
                                                        p2[myindex][2]*1000,
                                                        magnitude)
                   
    return(differences, magnitudes)
        

def buildtarfile(path=os.path.dirname(__file__), outpath='~'):
    """
    Create a tar file with the minimum required files to distribute casa-related
    tools. Include a README file containing the date and time of creation, and
    user who built them.  For further help and examples, see
      https://safe.nrao.edu/wiki/bin/view/ALMA/Buildtarfile
    -- Todd Hunter
    """
    pathbits = path.split('/')
    datestring = datetime.date.today().strftime('%Y-%m-%d %h:%m:%s')
    if (pathbits[-1] == 'analysis_scripts'):
        inpath = ''
        for p in range(len(pathbits)-1):
            if (pathbits[p] != ''):
                inpath += '/'
            inpath += pathbits[p]
    else:
        inpath = path
    cmd = 'echo Built on %s by %s > %s/analysis_scripts/README' % (datetime.datetime.now().ctime(), os.getenv('USER'),inpath)
    print cmd
    os.system(cmd)
    cmd = 'echo CVS ID%s >>  %s/analysis_scripts/README' % (version(), inpath)
    print cmd
    os.system(cmd)
    print "Extracting files from %s" % (inpath)
    tarfile = '%s/analysis_scripts.tar' % (outpath)
    cmd = "cd %s ; tar --exclude='CVS' -cvf %s" % (inpath,tarfile)
    files = ['analysisUtils.py','fileIOPython.py','mpfit.py','calDatabaseQuery.py','tmUtils.py',
             'plotbandpass3.py','readscans.py','XmlObjectifier.py','README','AOS_Pads_XYZ_ENU.txt',
             'au_noASDMLibrary.py','TicraImages','compUtils.py']
    for f in files:
        cmd += ' analysis_scripts/%s' % (f)
    print "Running: %s" % (cmd)
    os.system(cmd) 
    print "Tar file left at = %s" % (tarfile)
    print "To deploy to ftpsite, run: cp %s /home/ftp/pub/casaguides/" % (tarfile)

def findClosestTime(mytimes, mytime):
    myindex = 0
    mysep = np.abs(mytimes[0]-mytime)
    for m in range(1,len(mytimes)):
        if (np.abs(mytimes[m] - mytime) < mysep):
            mysep = np.abs(mytimes[m] - mytime)
            myindex = m
    return(myindex)

def getChanRangeFromFreqRange(vis=None, fieldid=0, spwid=None, minf=None, maxf=None, refframe='TOPO'):

    """
    returns a list of the two channels in an SPW corresponding
       to the minimum and maximum frequency in the given ref frame
    
    vis - MS name
    fieldid - field id of the observed field (for reference frame calculations)
    spwid - id of the SPW in question
    minf - minimum freq in Hz
    maxf - maximum freq in Hz
    refframe - frequency reference frame

    written by Dirk Petry
    """

    if(vis==None or spwid==None or minf==None or maxf==None):
        raise Exception('getChanRangeFromFreqRange: need to provide values for vis, spwid, minf, and maxf')

    rval = [-1,-1]

    if(minf>maxf):
        return rval

    iminf = -1
    imaxf = -1

    ms.open(vis)
    a = ms.cvelfreqs(fieldids=[fieldid],spwids=[spwid],mode='frequency', outframe=refframe)
    ms.close()

    maxc = len(a)-1

    ascending = True
    lowedge = a[0]
    ilowedge = 0
    upedge = a[maxc]
    iupedge = maxc
    if(maxc>0 and (a[maxc]<a[0])): # frequencies are descending
        print "Frequencies are descending in spw ", spwid
        ascending = False
        lowedge = a[maxc]
        upedge = a[0]
        ilowedge = maxc
        iupedge = 0

    if(minf<lowedge):
        if(maxf>lowedge):
            if(maxf>upedge):
                iminf = ilowedge
                imaxf = iupedge
            else:
                iminf = ilowedge
                # use imaxf from below search
                imaxf = -2
        #else:
            # both imaxf and iminf are -1
    else:
        if(minf<upedge):
            if(maxf>=upedge):
                # take iminf from below search
                iminf = -2
                imaxf = iupedge
            else:
                #take both iminf and imaxf from above search 
                iminf = -2
                imaxf = -2
        #else:
            # both imaxf and iminf are -1

    if ascending:
        if iminf==-2:
            for i in xrange(0,len(a)):
                if a[i]>=minf:
                    print "Found ",i," ",a[i]
                    iminf = i
                    break
        if imaxf==-2:
            for j in xrange(iminf,len(a)):
                if a[j]>=maxf:
                    print "Found ",j," ",a[j]
                    imaxf = j
                    break
        rval = [iminf,imaxf]
    else:
        if iminf==-2:
            for i in xrange(len(a)-1, -1, -1):
                if a[i]>=minf:
                    print "Found ",i," ",a[i]
                    iminf = i
                    break
        if imaxf==-2:
            for j in xrange(iminf,-1,-1):
                if a[j]>=maxf:
                    print "Found ",j," ",a[j]
                    imaxf = j
                    break
        rval = [imaxf, iminf]

    return rval

def replaceTsysScan(calTable, antenna, spw, pol, fromscan, toscan, newvalue=None, verbose=True):
    """
    This is a utility to replace the Tsys spectrum from one combination
    of antenna+spw+pol+scan with the value from a different scan of the same
    antenna+spw+pol. The spw number should be the original number in the
    parent ms.  It automatically detects and processes
    old cal tables (casa 3.3) or new cal tables (casa 3.4).
        antenna:  the ID (integer or string integer) not the name
        spw: integer or string integer
        pol: 'X' or 'Y'
        fromscan: integer or string integer
        toscan: integer or string integer
        newvalue: if specified, put this value into all channels
                  (in this case, set fromscan=toscan)
    Returns: the number of rows replaced, and if newvalue is specfied, the
              median factor by which the values changed
    - Todd Hunter
    """
    fromscan = int(fromscan)
    if (fromscan < 0):
        print "Invalid fromscan number"
        return
    toscan = int(toscan)
    if (toscan < 0):
        print "Invalid toscan number"
        return
    try:
        antenna = int(antenna)
        if (antenna < 0):
            print "Invalid antenna number"
            return
    except:
        print "Antenna must be given by number, not name."
        return
    if (type(spw) == list):
        spwsToFix = spw
    else:
        spwsToFix = [int(spw)] # Original spw ids
    scaleFactor = 1.0
    pols = ['X', 'Y']  # for now, assume this is always true
    if (pol not in pols):
        print "pol must be one of: ", pols
        return
    pol = pols.index(pol)
    tb.open(calTable,nomodify=False)
    antennas = tb.getcol('ANTENNA1')
    scans = tb.getcol('SCAN_NUMBER')
    names = tb.colnames()
    fromlist = []
    if ('CAL_DESC_ID' not in names):
        spws = tb.getcol('SPECTRAL_WINDOW_ID')
        newCalTable = True
    else:
        spws = tb.getcol('CAL_DESC_ID')  # These start at zero
        tb.close()
        newCalTable = False
        tb.open(calTable+'/CAL_DESC')
        truespws = list(tb.getcol('SPECTRAL_WINDOW_ID')[0])
        tb.close()
        tb.open(calTable,nomodify=False)

    change = []
    for i in range(len(antennas)):
        for spw in spwsToFix:
            if (newCalTable):
                myspw = spw
                colname = 'FPARAM'
            else:
                myspw = truespws.index(spw)
                colname = 'GAIN'
            if (antennas[i] == antenna and spws[i] == myspw and
                scans[i] == fromscan):
                if (verbose):
                    print "Reading from row %d" % (i)
                gain = tb.getcell(colname,i)
                if (newvalue == None):
                    fromlist.append(gain[pol] * scaleFactor)
                else:
                    mymedian = np.median(np.ma.masked_array(gain[pol], np.isnan(gain[pol])))
                    change.append(newvalue / mymedian)
                    if (verbose):
                        print change[-1], newvalue, mymedian
                    fromlist.append(newvalue * (gain[pol]/gain[pol]))

    replaced = 0
    for i in range(len(antennas)):
        for spw in spwsToFix:
            if (newCalTable):
                myspw = spw
                colname = 'FPARAM'
            else:
                myspw = truespws.index(spw)
                colname = 'GAIN'
            if (antennas[i] == antenna and spws[i] == myspw and
                scans[i] == toscan):
                if (verbose):
                    print "Writing to row %d" % (i)
                gain = tb.getcell(colname,i)
                gain[pol] = fromlist[replaced]
                tb.putcell(colname,i,gain)
                replaced += 1
    if (verbose):
        print "Replaced %d rows for antenna=%d, spw=%s, pol=%s, scan=%d" % (replaced,antenna,str(spw),pol,toscan)
    mymedian = 0
    if (newvalue != None and replaced>0):
        mymedian = np.median(np.ma.masked_array(change, np.isnan(change)))
        if (verbose):
            print "The median change in value was a factor of %f" % (mymedian)
    tb.close()
    if (newvalue != None):
        return(replaced, mymedian)
    else:
        return(replaced)

def createCasaTool(mytool):
    """
    A wrapper to handle the changing ways in which casa tools are invoked.
    Todd Hunter
    """
    if (type(casac.Quantity) != type):  # casa 4.x
        myt = mytool()
    else:  # casa 3.x
        myt = mytool.create()
    return(myt)

def parseSpw(vis, spw):
    """
    Parse the antenna argument (integer or string or list) to emulate 
    plotms selection.
    vis: name of the measurement set to get the valid spw list from
    spw: integer or string or list
    Todd Hunter
    """
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    uniqueSpws = range(mymsmd.nspw())
    mymsmd.close()
    return(parseSpwArgument(spw,  uniqueSpws))

def parseSpwArgument(spw, uniqueSpwsInCalTable):
    """
    Parse the antenna argument (integer or string or list) to emulate 
    plotms selection.
    spw: integer or string or list
    uniqueSpwsInCalTable: list or comma-delimited string
    Todd Hunter
    """
    if (type(uniqueSpwsInCalTable) == str):
        uniqueSpwsInCalTable = uniqueSpwsInCalTable.split(',')
    if (spw == ''):
        return(uniqueSpwsInCalTable)
    if (type(spw) == str):
        tokens = spw.split(',')
        spwsToPlot = []
        removeSpw = []
        for token in tokens:
            if (len(token) > 0):
                if (token.find('*')>=0):
                    spwsToPlot = uniqueSpwsInCalTable
                    break
                elif (token.find('!')==0):
                    spwsToPlot = uniqueSpwsInCalTable
                    removeSpw.append(int(token[1:]))
                elif (token.find('~')>0):
                    (start,finish) = token.split('~')
                    spwsToPlot +=  range(int(start),int(finish)+1)
                else:
                    spwsToPlot.append(int(token))
            spwsToPlot = np.array(spwsToPlot,dtype=int)
            removeSpw = np.array(removeSpw,dtype=int)
            for rm in removeSpw:
                spwsToPlot = spwsToPlot[np.where(spwsToPlot != rm)[0]]
            spwsToPlot = list(spwsToPlot)
            if (len(spwsToPlot) < 1 and len(removeSpw)>0):
                print "Too many negated spws -- there are no spws left."
                return
    elif (type(spw) == list):
        spwsToPlot = np.sort(spw)
    else:
        spwsToPlot = [spw]
    return(spwsToPlot)

def parseTimerangeArgument(timerange, vis):
    """
    Converts 'HH:MM HH:MM' to [MJDsec1, MJDsec2] for a measurement set.
    """
    timerange = timerange.replace('~',' ').split()
    timerange[0] = timerange[0].replace('-',' ')
    timerange[1] = timerange[1].replace('-',' ')
    if (len(timerange[0].split())<2):
        # only the UT was given, so insert the date
        timerange[0] = getObservationStartDate(vis).split()[0] + ' %s' % (timerange[0])
    if (len(timerange[1].split())<2):
        timerange[1] = getObservationStartDate(vis).split()[0] + ' %s' % (timerange[1])
    timerange[0] = dateStringToMJDSec(timerange[0], verbose=False)
    timerange[1] = dateStringToMJDSec(timerange[1], verbose=False)
    return(timerange)

def parseBasebandArgument(basebands):
    if (type(basebands) == str):  # '1,2'
        basebands = [int(i) for i in basebands.split(',')]
    elif (type(basebands) != list and type(basebands) != np.array):  # 1
        basebands = [basebands]
    else:  # ['1','2'] or [1,2]
        basebands = [int(i) for i in basebands]

    return(basebands)

def parseAntenna(vis, antenna):
    """
    Parse an antenna argument (integer or string or list) to emulate 
    plotms selection, given a measurement set.
    Returns: an integer list of antenna IDs:
    antenna='' will return all antenna IDs
    Todd Hunter
    """
    if (casadef.casa_version >= '4.1.0'):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        if (casadef.subversion_revision >= '27137'):
            uniqueAntennaIds = mymsmd.antennaids()
        else:
            uniqueAntennaIds = range(mymsmd.nantennas())
        mymsmd.close()
    else:
        print "Running ValueMapping to translate antenna names"
        vm = ValueMapping(vis)
        uniqueAntennaIds = range(vm.numAntennas)
    if (antenna == ''):
        return(uniqueAntennaIds)
    return(parseAntennaArgument(antenna, uniqueAntennaIds, vis))

def parseAntennaArgument(antenna, uniqueAntennaIds, msname='', verbose=False):
    """
    Parse an antenna argument (integer or string or list) to emulate 
    plotms selection, given a list of unique antenna IDs present in
    the dataset.
    antenna: can be string, list of integers, or single integer
    uniqueAntennaIds: list of integers, or comma-delimited string
    Todd Hunter
    """
    myValidCharacterListWithBang = ['~', ',', ' ', '*', '!',] + [str(m) for m in range(10)]
    if (type(uniqueAntennaIds) == str):
        uniqueAntennaIds = uniqueAntennaIds.split(',')
    if (type(antenna) == str):
        if (len(antenna) == sum([m in myValidCharacterListWithBang for m in antenna])):
            # a simple list of antenna numbers was given 
            tokens = antenna.split(',')
            antlist = []
            removeAntenna = []
            for token in tokens:
                if (len(token) > 0):
                    if (token.find('*')==0 and len(token)==1):
                        antlist = uniqueAntennaIds
                        break
                    elif (token.find('!')==0):
                        antlist = uniqueAntennaIds
                        removeAntenna.append(int(token[1:]))
                    elif (token.find('~')>0):
                        (start,finish) = token.split('~')
                        antlist +=  range(int(start),int(finish)+1)
                    else:
                        antlist.append(int(token))
            antlist = np.array(antlist,dtype=int)
            removeAntenna = np.array(removeAntenna,dtype=int)
            for rm in removeAntenna:
                antlist = antlist[np.where(antlist != rm)[0]]
            antlist = list(antlist)
            if (len(antlist) < 1 and len(removeAntenna)>0):
                print "Too many negated antennas -- there are no antennas left."
                return
        else:
            # The antenna name (or list of names) was specified
            if (verbose): print "name specified"
            tokens = antenna.split(',')
            if (msname != ''):
                if (casadef.casa_version < '4.1.0'):
                    print "Running ValueMapping to translate antenna names"
                    vm = ValueMapping(msname)
                    uniqueAntennas = vm.uniqueAntennas
                else:
                    mymsmd = createCasaTool(msmdtool)
                    mymsmd.open(msname)
                    if (casadef.subversion_revision >= '27137'):
                        uniqueAntennas = mymsmd.antennanames()
                    else:
                        uniqueAntennas = getAntennaNames(msname)
                antlist = []
                removeAntenna = []
                for token in tokens:
                    if (token in uniqueAntennas):
                        antlist = list(antlist)  # needed in case preceding antenna had ! modifier
                        if (casadef.casa_version < '4.1.0'):
                            antlist.append(vm.getAntennaIdsForAntennaName(token))
                        else:
                            antlist.append(mymsmd.antennaids(token)[0])
                    elif (token[0] == '!'):
                        if (token[1:] in uniqueAntennas):
                            antlist = uniqueAntennaIds
                            if (casadef.casa_version < '4.1.0'):
                                removeAntenna.append(vm.getAntennaIdsForAntennaName(token[1:]))
                            else:
                                removeAntenna.append(mymsmd.antennaids(token[1:]))
                        else:
                            print "Antenna %s is not in the ms. It contains: " % (token), uniqueAntennas
                            return
                    else:
                        print "Antenna %s is not in the ms. It contains: " % (token), uniqueAntennas
                        return
                antlist = np.array(antlist,dtype=int)
                removeAntenna = np.array(removeAntenna,dtype=int)
                for rm in removeAntenna:
                    antlist = antlist[np.where(antlist != rm)[0]]
                antlist = list(antlist)
                if (len(antlist) < 1 and len(removeAntenna)>0):
                    print "Too many negated antennas -- there are no antennas left."
                    return
                if (casadef.casa_version >= '4.1.0'):
                    mymsmd.close()
            else:
                print "Antennas cannot be specified my name if the ms is not found."
                return
    elif (type(antenna) == list or type(antenna) == np.ndarray):
        # it's a list or array of integers
        if (verbose): print "converting int to list"
        antlist = list(antenna)
    else:
        # It's a single, integer entry
        if (verbose): print "converting int to list"
        antlist = [antenna]
    return(antlist)

def flagTsysTable(caltable='', antenna='', spw='', time='', debug=False):
    """
    Flags a Tsys cal table, because flagdata can not yet flag caltables when
    selecting on time or scan.
    antenna: can be ID or name or list thereof
    spw: integer or list
    time: MJDseconds or '2011/10/15 05:00:00' or '2011/10/15-05:00:00'
          or a list of datetimes: '2011/10/15 05:00:00,2011/10/15-05:00:00'
          or a list of times: '05:00:00,06:00:00' on start date of first row
    pols: is not an argument:  all pols will be flagged!
    """
    if (os.path.exists(caltable) == False):
        print "Could not locate file: %s" % (caltable)
        return
    mytb = createCasaTool(tbtool)
    mytb.open(caltable,nomodify=False)
    times = mytb.getcol('TIME')
    if ('SPECTRAL_WINDOW_ID' not in mytb.colnames()):
        print "This function does not operate on old-style cal tables."
        mytb.close()
        return
    if (type(time) == str):
        if (time != ''):
            tokens = time.split(',')
            mydate = mjdsecToUT(times[0]).split()[0].replace('-','/')
            if (len(tokens) > 1):
                mytimes = []
                for t in tokens:
                    t = t.strip()
                    if (len(t) < 9):
                        t = mydate + ' ' + t
                        print "Prepending date (%s): %s" % (mydate,t)
                    mytimes.append(dateStringToMJDSec(t))
            else:
                if (len(time) < 9):
                    time = mydate + ' ' + time
                    print "Prepending date (%s): %s" % (mydate,time)
                mytimes = [dateStringToMJDSec(time)]
        else:
            mytimes = ''
    elif (type(time) != list):
        # single MJDsec
        mytimes = [time]
    elif (type(time[0]) == str):
        mytimes = []
        for t in range(len(time)):
            if (len(time[t].strip()) < 9):
                time[t] = mydate + ' ' + time[t].strip()
                print "Prepending date (%s): %s" % (mydate,time[t])
            mytimes.append(dateStringToMJDSec(time[t].strip()))
    else: # 
        mytimes = time
    antennas = mytb.getcol('ANTENNA1')
    uniqueAntennaIds = np.unique(antennas)
    msname = mytb.getkeyword('MSName')      
    antenna = parseAntennaArgument(antenna, uniqueAntennaIds, msname)
    print "Antenna list = ", antenna
    spws = mytb.getcol('SPECTRAL_WINDOW_ID')
    uniqueSpws = np.unique(spws)
    spw = parseSpwArgument(spw, uniqueSpws)
    print "spw list = ", spw
    uniqueTimes = np.unique(times)
    print "unique times in table: ", uniqueTimes.astype(int)
    print "unique times in table: ", plotbp3.mjdsecArrayToUTString(uniqueTimes)
    print "mytimes to flag = ", mytimes
    flags = mytb.getcol('FLAG')
    npol = np.shape(flags)[0]
    nchan = np.shape(flags)[1]
    nrows = np.shape(flags)[2]
    threshold = 10 # seconds
    rowsToFlag = []
    rowsFlagged = []
    for i in range(nrows):
        if (mytimes == ''):
            timeMatch = True
        else:
            timeMatch = plotbp3.sloppyMatch(times[i], mytimes, threshold, debug)
        if ((antennas[i] in antenna or len(antenna)==0) and (spws[i] in spw or len(spw)==0) and timeMatch):
            myflag = mytb.getcell('FLAG', i)
            rowsToFlag.append(i)
            for p in range(npol):
                for ch in range(nchan):
                    if (myflag[p][ch] == False):
                        if (len(rowsFlagged) == 0):
                            rowsFlagged.append(i)
                        elif (rowsFlagged[-1] != i):
                            rowsFlagged.append(i)
                        myflag[p][ch] = True
            mytb.putcell('FLAG',i,myflag)
    mytb.close()
    alreadyFlagged = list(set(rowsToFlag).difference(set(rowsFlagged)))
    print "Flagged %d/%d rows: %s" % (len(rowsFlagged), nrows, str(rowsFlagged))
    print "%d/%d rows were already flagged: %s" % (len(rowsToFlag)-len(rowsFlagged), len(rowsToFlag), alreadyFlagged)

def removeTsysSpike(calTable='', antenna=-1, spw=-1, startchan=-1, endchan=-1):
    """
    This is a utility to interpolate across a spike in the Tsys values for
    one antenna, one spw, both polarizations. The spw number should be the
    original number in the parent ms.  It automatically detects and processes
    old cal tables (casa 3.3) or new cal tables (casa 3.4).
    - Todd Hunter
    """
    antenna = int(antenna)
    spw = int(spw)
    tb.open(calTable,nomodify=False)
    antennas = tb.getcol('ANTENNA1')
    names = tb.colnames()
    if ('CAL_DESC_ID' not in names):
        spws = tb.getcol('SPECTRAL_WINDOW_ID')
        newCalTable = True
    else:
        spws = tb.getcol('CAL_DESC_ID')  # These start at zero
        tb.close()
        newCalTable = False
        tb.open(calTable+'/CAL_DESC')
        truespws = list(tb.getcol('SPECTRAL_WINDOW_ID')[0])
        tb.close()
        tb.open(calTable,nomodify=False)

    replaced = 0
    for i in range(len(antennas)):
        if (newCalTable):
            myspw = spw
            colname = 'FPARAM'
        else:
            myspw = truespws.index(spw)
            colname = 'GAIN'
        if (antennas[i] == antenna and spws[i] == myspw):
            print "Replacing row %d" % (i)
            gain = tb.getcell(colname, i)
            for j in range(len(gain)):
                for chan in range(startchan,endchan):
                    gain[j][chan] = 0.5*(gain[j][startchan-1] + gain[j][endchan])
            tb.putcell(colname,i,gain)
            replaced += 1
    #
    tb.close() 
    print "Replaced %d rows" % (replaced)

def replaceTsys(calTable='', antenna=-1, spw=-1, frompol='X', topol='Y',
                scaleFactor=1.0):
    """
    This is a utility to copy a scaled version of the Tsys values for one
    antenna, one spw, one polarization, to another polarization.  The spw
    number should be the original number in the parent ms.  It automatically
    detects and processes old cal tables (casa 3.3) or new cal tables
    (casa 3.4).
      antenna: integer or string ID (not the name)
      spw: integer or string
      frompol: the polarization to copy from
      to pol: the polarization to copy to
      scaleFactor: optional scale factor to apply when copying
    - Todd Hunter
    """
    antenna = int(antenna)
    spw = int(spw)
    pols = ['X', 'Y']  # for now, assume this is always true
    frompol = pols.index(frompol)
    topol = pols.index(topol)
    tb.open(calTable,nomodify=False)
    antennas = tb.getcol('ANTENNA1')
    names = tb.colnames()
    if ('CAL_DESC_ID' not in names):
        spws = tb.getcol('SPECTRAL_WINDOW_ID')
        newCalTable = True
    else:
        spws = tb.getcol('CAL_DESC_ID')  # These start at zero
        tb.close()
        newCalTable = False
        tb.open(calTable+'/CAL_DESC')
        truespws = list(tb.getcol('SPECTRAL_WINDOW_ID')[0])
        tb.close()
        tb.open(calTable,nomodify=False)
    replaced = 0
    for i in range(len(antennas)):
        if (newCalTable):
            myspw = spw
            colname = 'FPARAM'
        else:
            myspw = truespws.index(spw)
            colname = 'GAIN'
        if (antennas[i] == antenna and spws[i] == myspw):
            print "Replacing row %d" % (i)
            gain = tb.getcell(colname,i)
            if (len(gain) > 2):
                print "This file has more than two polarizations, for which this script has not been tested."
                tb.close()
                return
            if (len(gain) < 2):
                print "This file has less than two polarizations, for which this script cannot be used."
                tb.close()
                return
            gain[topol] = gain[frompol] * scaleFactor
            tb.putcell(colname,i,gain)
            replaced += 1
    #
    tb.close()
    print "Replaced %d rows" % (replaced)

def pruneFilelist(filelist):
    """
    Reduce size of filenames in filelist to the extent that current working
    directory agrees with the path.
    """
    mypwd = os.getcwd() + '/'
    newfilelist = []
    for f in filelist:
        fstart = 0
        if (f.find(mypwd) == 0):
            fstart = len(mypwd)
        newfilelist.append(f[fstart:])
    return(newfilelist)
    
def concatenatePDFs(filelist, pdfname, pdftk='pdftk', gs='gs', cleanup=False,
                    quiet=False):
    """
    Takes a list or a string list of PDF filenames (space-delimited), and an
    output name, and concatenates them.
    It first tries pdftk (better quality), and if that fails, it tries
    ghostscript (more commonly installed).
    Todd Hunter
    """
    if (type(filelist) == list):
        filelist = ' '.join(filelist)
    cmd = '%s %s cat output %s' % (pdftk, filelist, pdfname)
    if not quiet: print "Running command = %s" % (cmd)
    mystatus = os.system(cmd)
    if (mystatus != 0):
        print "status = ", mystatus
        cmd = '%s -q -sPAPERSIZE=letter -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=%s %s' % (gs,pdfname,filelist)
        print "Running command = %s" % (cmd)
        mystatus = os.system(cmd)
        if (mystatus != 0):
            gs = '/opt/local/bin/gs'
            cmd = '%s -q -sPAPERSIZE=letter -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=%s %s' % (gs,pdfname,filelist)
            print "Running command = %s" % (cmd)
            mystatus = os.system(cmd)
            if (mystatus != 0):
                print "Both pdftk and gs are missing, no PDF created."
                cleanup = False
    if (cleanup):
        os.system('rm %s' % filelist)
    return (mystatus)

def plotSamplersWithTsys(vis, caltable=None, channels=20, scan=None, filter='',
                         skipPlotbandpass=False, skipPlotms=False, markersize=10, showatm=False):
    """
    Runs Atmcal, checkSamplers, plotbandpass, plotms, and montageTwoPngLists
    in order to create side-by-side plots of the autocorrelation on the sky
    subscan of the first ATM calibration scan (or a specified scan) and the
    corresponding Tsys, near channel zero.
    channels: The number of channels to show on the x-axis
    scan: the scan number to use
    filter: an antenna name to skip (e.g. when Tsys has no solutions for it)
    skipPlotbandpass: do not remove or generate Tsys plots
    skipPlotms: do not generate autocorrelation amplitude plots
    markersize: size of the points in the plotbandpass plots
    showatm: pass this option to plotbandpass
    Todd Hunter
    """
    if (caltable == None):
        caltable = vis+'.tsys'
        if (os.path.exists(caltable) == False):
            gencal(vis, caltype='tsys', caltable=caltable)
    elif (os.path.exists(caltable) == False):
        print "Could not find caltable."
        return
    else:
        print "Found caltable."
    atmcal = Atmcal(vis)
    if (scan == None):
        scan = atmcal.scans[0]
    scans = str(scan)
    if (scan not in atmcal.scans):
        print "This scan is not an ATM cal scan.  Try: %s" % (str(atmcal.scans))
        return
    spwlist = ','.join(str(atmcal.spwsforscan_nonchanavg[scan]).strip('[').strip(']').split())
    if (skipPlotbandpass==False):
        os.system('rm %s*.png' % (caltable))
        print "Running plotbandpass('%s',xaxis='chan',scans='%s', interactive=False,subplot=11,figfile='%s.scan%s', buildpdf=True, plotrange=[-0.5,%d,0,0],showpoints=True,showBasebandNumber=True,spw='%s',markersize=%d,showatm=%s)" % (caltable,scans,caltable,scans,channels,spwlist,markersize,showatm)
        plotbandpass(caltable, xaxis='chan', scans=scans, interactive=False,subplot=11,markersize=markersize,
                     figfile=caltable+'.scan'+scans, buildpdf=True, plotrange=[-0.5,channels,0,0],showpoints=True,
                     showBasebandNumber=True,xcolor='b',ycolor='r',spw='%s'%(spwlist),showatm=showatm)
    tsysfiles = sorted(glob.glob(caltable+'.scan'+scans+'*.png'))
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    plotfiles = []
    if (skipPlotms == False):
        samplers = checkSamplers(vis, ac=atmcal)
    sky = 1
    timerange = atmcal.timestampsString[int(scans)][sky]
    antnames = mymsmd.antennanames(range(mymsmd.nantennas()))
    for a in antnames:
        for spw in atmcal.spwsforscan_nonchanavg[scan]:
            plotfile = vis+'.%s.spw%02d.autocorr.png'%(a,spw)
            if (skipPlotms == False):
                baseband = mymsmd.baseband(spw)
                plotms(vis, spw=str(spw)+':0~%d'%(channels), xaxis='chan', interactive=False, scan=scans, timerange=timerange,
                       yaxis='amp',coloraxis='corr', avgtime='10000', iteraxis='spw',antenna=a+'&&&',overwrite=True,
                       plotfile=plotfile, plotrange=[-0.5,channels,0,0],
                       title=vis+' scan %s %s BB%d chan 0 ratios: XX=%.2f, YY=%.2f'%(scans,a,baseband,samplers[a][baseband][0],samplers[a][baseband][1]))
            plotfiles.append(plotfile)
    mymsmd.close()
    pdfname = vis+'.scan%s.autocorrsky_tsys.%dchannels.pdf' % (scans,channels)
    montageTwoPngLists(plotfiles, tsysfiles, sidebyside=False, pdfname=pdfname, filter=filter)
    return(pdfname)

def pngWidthHeight(filename):
    """
    Reads the width and height of a png image (in pixels).
    -Todd Hunter
    """
    if (os.path.exists(filename) == False):
        print "Cannot find file = ", filename
        return
    f = open(filename, 'rb')
    data = f.read()
    if (data[:8] == '\211PNG\r\n\032\n'and (data[12:16] == 'IHDR')):
        w, h = struct.unpack('>LL', data[16:24])
        width = int(w)
        height = int(h)
    else:
        raise Exception('not a png image')
    f.close()
    return width, height
                                            
def montage(pnglist, tile='2X2', geometry='1000x1000+0+0', plotfile='', sort=True,
            background=None,trim=False, shave=None):
    """
    Calls the montage program with the specified arguments.
    pnglist: list of strings, or a string with a wildcard character.
    tile: number of columns X rows
    geometry: passed to the montage command
    plotfile: the name of the png file to produce
    sort: if True, and if pnglist is a string, then sort the output of glob.glob
    background: set the background color (e.g. #000000)
    trim: trim the blank areas around each image
    shave: geometry (e.g. '50x100' to remove 50 pixels from sides, 100 from top/bottom)
    """
    if (type(pnglist) == str):
        pnglist = glob.glob(pnglist)
        if (sort):
            pnglist = sorted(pnglist)
    pnglist = ' '.join(pnglist)
    if (plotfile == '' or plotfile==True):
        plotfile = 'montage.png'
    if (background != None and background != ''):
        background = '-background ' + background
    else:
        background = ''
    if (shave != None and shave != ''):
        shave = '-shave ' + shave
    else:
        shave = ''
    if (trim):
        trim = '-trim'
    else:
        trim = ''
    cmd = "montage -tile %s -geometry %s %s %s %s %s %s" % (tile,geometry,background,trim,shave,pnglist,plotfile)
    print "Running %s" % cmd
    os.system(cmd)
    print "Result left in %s" % (plotfile)

def montagePngs(png1, png2, outname, sidebyside=True, png3=None, geometry=None,
                trim=True, spacing=2, background='black'):
    """
    Takes 2 or 3 pngs, and puts them onto one page.
    sidebyside: if False, then put them one atop the other.
    trim: if True, pass '-trim' to the montage commands
    background: the color to use in the '-background' option of the montage commands
    spacing: the gap between pngs, in pixels (if geometry is not specified)
    geometry: the string to use in the '-geometry' option of the montage commands
           format =   'WidthOfFinalImage x HeightOfSingleImage + Xgap + Ygap'
             example = '600x400+20+20'
    -Todd Hunter
    """
    if (os.path.exists(png1) == False):
        print "Could not find file png1 = ", png1
        return
    if (os.path.exists(png2) == False):
        print "Could not find file png2 = ", png2
        return
    if (png3 != None):
        npngs = 3
        tile = '1X3'
    else:
        npngs = 2
        if (sidebyside):
            tile = '2X1'
        else:
            tile = '1X2'
    if (geometry == None):
        geometry = '%dx500+%d+%d' % (500*npngs,spacing,spacing)
    if (trim):
        trim = '-trim'
    else:
        trim = ''
    cmd = "montage %s -background %s -tile %s -geometry %s  %s %s "%(trim,background,tile,geometry,png1,png2)
    if (png3 != None): cmd += png3
    cmd += ' ' + outname
    print "Running %s" % (cmd)
    mystatus = os.system(cmd)
    if (mystatus != 0 and mystatus != 256):
        # MacOS location of montage
        mystatus = os.system('/opt/local/bin/'+cmd)
    
def montageTwoPngLists(pnglist1, pnglist2, pdfname='', sidebyside=True, geometry=None,
                       filter='', trim=True, spacing=2, background='black'):
    """
    Takes two lists of N pngs, and puts them side-by-side on an N-page pdf.
    pnglist: either a python list of filenames, or a single string containing a directory
             name and/or a template filename with wildcards (e.g. 'DV*.png')
    pdfname: the name of the PDF to produce    
    sidebyside: True (place them left/right),  False (place the second above the first)
    filter: remove all pngs that include this string in the name (e.g. 'DV10')
    geometry: the string to use in the '-geometry' option of the montage commands
           format =   'WidthOfFinalImage x HeightOfSingleImage + Xgap + Ygap'
             example = '600x400+20+20'
    trim: if True, pass '-trim' to the montage commands
    background: the color to use in the '-background' option of the montage commands
    spacing: the gap between pngs, in pixels (if geometry is not specified)
    - Todd Hunter
    """
    if (type(pnglist1) == str):
        # assume we want all pngs in this directory
        if (pnglist1.find('*') < 0):
            pnglist1 = sorted(glob.glob(pnglist1+'/*.png'))
        else:
            pnglist1 = sorted(glob.glob(pnglist1))
    if (type(pnglist2) == str):
        # assume we want all pngs in this directory
        if (pnglist2.find('*') < 0):
            pnglist2 = sorted(glob.glob(pnglist2+'/*.png'))
        else:
            pnglist2 = sorted(glob.glob(pnglist2))
    if (filter != ''):
        newpnglist1 = []
        for png in pnglist1:
            if (png.find(filter) < 0):
                newpnglist1.append(png)
        pnglist1 = newpnglist1
        newpnglist2 = []
        for png in pnglist2:
            if (png.find(filter) < 0):
                newpnglist2.append(png)
        pnglist2 = newpnglist2
    l1 = len(pnglist1)
    l2 = len(pnglist2)
    if (l1 != l2):
        print "The two lists are not of equal length (%d vs. %d)" % (l1, l2)
        return
    plotfiles = []
    dirname = os.path.dirname(pdfname)
    if (dirname != ''):
        if (os.path.exists(dirname) == False):
            print "Creating directory: ", dirname
            os.mkdir(dirname)
        dirname += '/'
    for i in range(len(pnglist1)):
        page =  dirname + os.path.basename(pdfname).strip('.pdf') + ".page%03d.png" % (i)
        plotfiles.append(page)
        montagePngs(pnglist1[i], pnglist2[i], outname=page, background=background,
                    sidebyside=sidebyside, spacing=spacing, geometry=geometry)
    buildPdfFromPngs(plotfiles,pdfname=pdfname)
    return(pdfname)

def countPagesInPDF(pdf, pdfinfo='pdfinfo'):
    """
    Counts the number of pages in a PDF.
    pdf: the name of the PDF file
    pdfinfo: the path to the pdfinfo executable
    -Todd Hunter
    """
    if (os.path.exists(pdf) == False):
        print "Could not find file ", pdf
        return 0
    cmd = pdfinfo + ' ' + pdf + '| grep Pages'
    status, output = commands.getstatusoutput(cmd)
    pages = output.split()
    if (len(pages) > 1):
        return(int(pages[1]))
    else:
        return 0

def comparePngs(png1, png2, compare='compare', metric='AE', cleanup=True):
    """
    Compares two pngs images using the ImageMagick compare command.
    Returns 0 if identical, or positive integer if not.
    compare: the path to the compare command
    cleanup: if True, remove the difference image even if there are differences
    """
    if (os.path.exists(png1) == False):
        print "Could not find file ", png1
        return 0
    if (os.path.exists(png2) == False):
        print "Could not find file ", png2
        return 0
    diffimage = png1.replace('.png','') + '.diff.png'
    cmd = compare + ' -verbose -metric %s '%(metric) + png1 + ' ' + png2 + ' ' + diffimage
    status, output = commands.getstatusoutput(cmd)
    if (output.find('dB') >= 0):
        dB = int(output.split('dB')[0].split('\n')[-1])
        if (cleanup or dB==0):
            os.remove(diffimage)
        else:
            print "Wrote image: ", diffimage
    else:
        dB = -1
        print output
        print "Wrote image: ", diffimage
    return (dB)

def buildPdfFromPngs(pnglist=[],pdfname='',convert='convert',gs='gs',
                     pdftk='pdftk',maxcount=0,cleanup=True,quiet=False):
    """
    Will convert a list of PNGs into PDF, then concatenate them into one PDF.
    Arguments:
    pnglist: list of PNG files ['a.png','b.png'], or a string which is assumed
             to be a directory in which all *.png's will be grabbed.  If this
             string contains a *, it will not assume that it is a wildcard
             string with which to identify files as pngs to grab.
    pdfname:  the filename to produce (default = my.pdf)
    convert: specify full path to ImageMagick's convert command (if necessary)
    gs:  specify the full path to ghostscript's gs command (if necessary)
    pdftk: specify the full path to the pdftk command (if necessary)
    maxcount: maximum number of files to include
    cleanup: remove the temporary single-page PDFs
    """
    filelist = ''
    if (type(pnglist) == str):
        # assume we want all pngs in this directory
        if (pnglist.find('*') < 0):
            pnglist = sorted(glob.glob(pnglist+'/*.png'))
        else:
            pnglist = sorted(glob.glob(pnglist))
            if not quiet: print "pnglist = ", pnglist
    if (len(pnglist) < 1):
        return("You must specify at least one file with pnglist=['myfile1','myfile2',...].")
    pnglist = pruneFilelist(pnglist)
    if not quiet: print "Pruned list = ", pnglist
    count = 0
    for p in pnglist:
        if (maxcount > 0 and count >= maxcount): break
        count += 1
#        print "Checking if I have write privilege on %s" % (p)
        if (os.access(p,os.W_OK)):
            onepdf = '%s.pdf' % (p)
        else:
            onepdf = '/tmp/%s.pdf' % (p.split('/')[-1])
        cmd = '%s %s %s' % (convert,p,onepdf)
        if not quiet: print "Running command = ", cmd
        mystatus = os.system(cmd)
        if (mystatus == 0):
            filelist += onepdf + ' '
        elif (mystatus == 256):
            return("Could not find one or more of the png files.")
        else:
            # MacOS location of convert
            convert = '/opt/local/bin/convert'
            cmd = '%s %s %s' % (convert, p,onepdf)
            if not quiet: print "Running command = ", cmd
            mystatus = os.system(cmd)
            if (mystatus == 0):
                filelist += onepdf + ' '
            elif (mystatus == 256):
                return("Could not find one or more of the png files.")
            else:
                mystring = "ImageMagick's convert command is missing, no PDF created. You can set the full path to convert with convert=''"
                return(mystring)
    if (pdfname == ''):
        pdfname = './my.pdf'
    if (os.path.dirname(pdfname) == ''):
        pdfname = './' + pdfname
    mypath = os.path.dirname(pdfname)
    print "Checking if I have write privilege on %s." % (mypath)
    if (os.access(mypath, os.W_OK) == False):
#        print "no"
        pdfname = '/tmp/%s' % (os.path.basename(pdfname))
    else:
        pdfname = pruneFilelist([pdfname])[0]
        
#    else:
#        print "yes"
    if (len(pnglist) > 1):
        mystatus = concatenatePDFs(filelist,pdfname,pdftk=pdftk,gs=gs,quiet=quiet)
    else:
        cmd = 'cp %s %s' % (filelist,pdfname)
        print "Running command = %s" % (cmd)
        mystatus = os.system(cmd)
    if (mystatus == 0):
        print "PDF left in %s" % (pdfname)
        if (cleanup):
            os.system("rm -f %s" % filelist)
    else:
        print "No PDF created. pdftk and gs (ghostscript) might both be missing"
        print "If so, you can set the full path to pdftk with pdftk='', or to gs with gs=''"
    return('')
# end of buildPdfsFromPngs

def clearflags(caltable='', absoluteValue=False):
    """
    Clear all flags in a 3.4 tsys table, with an option to replace the
    FPARAM with the absolute value of the existing FPARAM.
    Todd Hunter
    """
    tb.open(caltable,nomodify=False)
    caltime = tb.getcol('TIME')
    for i in range(len(caltime)):
        flag = tb.getcell('FLAG',i)
        fparam = tb.getcell('FPARAM',i)
        c = 0
        for f in flag:
            lf = list(f)
            c += lf.count(1)
        if (c > 0):
            flag *= 0
            tb.putcell('FLAG',i,flag)
            if (absoluteValue):
                fparam = tb.getcell('FPARAM',i)
                fparam = np.abs(fparam)
                tb.putcell('FPARAM',i,fparam)
                print "Cleared %d flags in row %d and took absolute value of gain" % (c,i)
            else:
                print "Cleared %d flags in row %d" % (c,i)
    tb.close()

def countflags(vis):
    """
    Examine all data descriptors in an ms and report the
    number of flags, total points and percentage flagged in a dictionary.
    Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    # Find number of data description IDs
    mytb.open(vis+"/DATA_DESCRIPTION")
    ddspwlist = mytb.getcol("SPECTRAL_WINDOW_ID")
    ddpollist = mytb.getcol("POLARIZATION_ID")
    mytb.close()
    ndd = ddspwlist.__len__()
    print 'Found '+str(ndd)+' DataDescription IDs'

    myms = createCasaTool(mstool)
    myms.open(vis)
    totalflags = 0
    totalpoints = 0
    # loop over data descriptors
    for idd in range(ndd):
        # Select this DD (after reset if needed)
        print "Examining DD%d of %d" % (idd+1,ndd)
        if idd>0: myms.selectinit(reset=True)
        myms.selectinit(idd)
        flags = myms.getdata(["flag"])
        flatflags = flags['flag'].flatten()
        totalflags += len(np.where(flatflags == 1)[0])
        totalpoints += len(flatflags)
    myms.close()
    percentage = 100*totalflags/(1.0*totalpoints)
    print "Found %d flags (%.4f%%) out of %d possible." % (totalflags, percentage, totalpoints)
    mydict = {'total':totalpoints, 'flagged':totalflags, 'percent':percentage}
    return(mydict)

def listflagsSlow(ms='',maxrows=0, verbose=False, startrow=0):
    """
    Examine all rows in an ms that have flagged data, and report statistics.
    See also au.countflags (much faster), and fg.setflagsummary()
    verbose: if True, list all row numbers
    maxrows: if maxrows > 0, then stop after examining maxrows
    Todd Hunter
    """
    tb.open(ms)
    times = tb.getcol('TIME')
    totalrows = 0
    totalflags = 0
    totalpoints = 0
    interval = 1000
    lt = len(times)/interval
    print "Total rows in ms = %d" % (len(times))
    rows = []
    fo = open(ms.split('/')[-1]+'.listflags','w')
    for i in range(startrow,len(times)):
        flags = tb.getcell('FLAG',i)
        for f in flags:
            lf = list(f)
            c = lf.count(1)
            totalrows += 1
            if (c > 0):
                if (verbose):
                    print "Found %d flags in row %d" % (c,i)
                rows.append(i)
                fo.write('%d %d\n'%(i,c))
                totalflags += c
            totalpoints += len(lf)
        if (totalrows>=maxrows and maxrows>0): break
        if (i%lt == 0):
            print "Row %d: Done %.1f%% (%d flags found)" % (i,100.0*i/lt/interval, totalflags)
    tb.close()
    print "This dataset has %d rows." % (len(times))
    fo.write("This dataset has %d rows.\n" % (len(times)))
    print "Found %d flags (%.4f%%) in %d different rows." % (totalflags, 100*totalflags/(1.0*totalpoints), totalrows)
    fo.write("Found %d flags (%.4f%%) in %d different rows.\n" % (totalflags, 100*totalflags/(1.0*totalpoints), totalrows))
    fo.close()

def getFields(vis):
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/FIELD')
    fields = mytb.getcol('NAME')
    mytb.close()
    return(fields)
    
def getFieldsForTime(ft, time):
    """
    Return the field with an observation time closest to the specified time.
    Input: a ValueMapping structure (vm.fieldsForTimes), and an MJD_seconds time
    Output: field name
    Called by detectNegativeTsys()
    Todd Hunter
    """
    mindiff = 1e8
    myfield = 'None'
    for src in ft.keys():
        diff = ft[src] - time
        if (np.min(np.abs(diff)) < mindiff):
            mindiff = np.min(np.abs(diff))
            myfield = src
    return(myfield)

def parseFrequencyArgumentToGHz(bandwidth):
    """
    Converts a frequency string into floating point in GHz, based on the units.
    If the units are not present, then the value is assumed to be GHz if less
    than 1000.
    -Todd Hunter
    """
    value = parseFrequencyArgument(bandwidth)
    if (value > 1000):
        value *= 1e-9
    return(value)

def parseFrequencyArgumentToHz(bandwidth):
    """
    Converts a frequency string into floating point in Hz, based on the units.
    If the units are not present, then the value is assumed to be GHz if less
    than 1000 (in contrast to parseFrequencyArgument).
    -Todd Hunter
    """
    value = parseFrequencyArgumentToGHz(bandwidth) * 1e9
    return(value)

def parseFrequencyArgument(bandwidth):
    """
    Converts a string frequency into floating point in Hz, based on the units.
    If the units are not present, then the value is simply converted to float.
    -Todd Hunter
    """
    bandwidth = str(bandwidth)
    ghz = bandwidth.lower().find('ghz')
    mhz = bandwidth.lower().find('mhz')
    khz = bandwidth.lower().find('khz')
    hz = bandwidth.lower().find('hz')
    if (ghz>0):
        bandwidth = 1e9*float(bandwidth[:ghz])
    elif (mhz>0):
        bandwidth = 1e6*float(bandwidth[:mhz])
    elif (khz>0):
        bandwidth = 1e3*float(bandwidth[:khz])
    elif (hz>0):
        bandwidth = float(bandwidth[:hz])
    else:
        bandwidth = float(bandwidth)
    return(bandwidth)

def channelsForPreBandpass(vis, spw, bandwidth, verbose=False):
    """
    Determines the channel range at the center of the spw that corresponds
    to the specified bandwidth, centered on the spw.
    spw: integer or string
    bandwidth: floating point Hz, or string with specified units of GHz, MHz or Hz
    """
    if (os.path.exists(vis) == False):
        print "Could not find MS"
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    spw = int(spw)
    if (type(bandwidth) == str):
        bandwidth = parseFrequencyArgument(bandwidth)
    nchan = mymsmd.nchan(spw)
    chanwidth = abs(mymsmd.chanwidths(spw)[0])  # assume constant widths
    mymsmd.close()
    centralChannels = int(0.5+bandwidth/chanwidth)
    # 1000, 100    (1000-100)/2=450  1000-450=550
    startchan = int((nchan-centralChannels)/2)
    if (startchan < 0):
        startchan = 0
    endchan = nchan-startchan-1
    if (endchan-startchan+1 < centralChannels and endchan+1<nchan):
        endchan += 1
    actualChannels = endchan-startchan+1
    channelRange = '%d~%d' % (startchan,endchan)
    if (verbose):
        print "%d-%d=%d, %d channels: actual range = %f Hz" % (endchan,startchan, endchan-startchan,
                                                               actualChannels,actualChannels*chanwidth)
    return(channelRange)

def spwsForScan(mymsmd):
    """
    Return a dictionary keyed by scan number, with values equal to the non-chanavg, non-WVR,
    non-SQLD spws associated with that scan.
    -Todd Hunter
    """
    spws = {}
    for scan in mymsmd.scannumbers():
        spws[scan] = list(np.intersect1d(np.intersect1d(mymsmd.spwsforscan(scan), 
                                                        getNonWvrSpws(mymsmd)),
                                                        getNonChanAvgSpws(mymsmd)))
    return(spws)

def spwsforfield(vis, field):
    """
    This is a temporary replacement for msmd.spwsforfield until the bug found on Oct 9, 2013
    has been fixed in casa.  - Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not find MS"
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    if (field not in mymsmd.namesforfields(range(mymsmd.nfields()))):
        print "Field %s is not in the MS" % (field)
        return
    if (type(field) != str):
        spws = mymsmd.spwsforfield(field)
    elif (field.isdigit()):
        spws = mymsmd.spwsforfield(int(field))
    else:
        fieldIds = mymsmd.fieldsforname(field)
        if (len(fieldIds) == 1):
            spws = mymsmd.spwsforfield(field)
        elif (len(fieldIds) == 0):
            print "This field is not in the MS"
            return
        else:
            spws = []
            for fid in fieldIds:
                spws += list(mymsmd.spwsforfield(fid))
            spws = np.unique(spws)
    mymsmd.close()
    return(spws)

def getScansForTime(ft, time):
    """
    Return the scan with an observation time closest to the specified time.
    Input: a ValueMapping structure (vm.scansForTimes), and an MJD_seconds time
    Output: field name
    Called by detectNegativeTsys()
    Todd Hunter
    """
    mindiff = 1e12
    myfield = 'None'
    for scan in ft.keys():
        diff = ft[scan] - time
        if (np.min(np.abs(diff)) < mindiff):
            mindiff = np.min(np.abs(diff))
            myscan = scan
    return(myscan)

def plotTsys(vis='', antenna = '', spw='', xaxis='freq', gs='gs',
             buildpdf=False, interactive=True, overlay='',
             plotrange=[0,0,0,0],pol='', figfile='', renumber=False,
             replace={}, showatm=False, scan='', verbose=False, fontsize=12):
    """
    Plot the Tsys from the SYSCAL table of the specified ms.  
    Produce a multi-page pdf.
       xaxis: 'freq' (default) or 'chan'
       gs: full path to ghostscript's gs
       antenna: a single antenna ID (as integer or string) or name
       overlay: '' or 'antenna'
       pol: '' or 'X' or 'Y'
       spw: single value or list: '5' or 5 or [5]
       figfile:  '' (no png produced) or filename
       buildpdf: True or False
       interactive: True or False
       plotrange: [xmin, xmax, ymin, ymax]
       renumber: renumbers the spws to start at 0, default order: (9,11,13,15-->0,1,2,3)
       replace: provide a dictionary for the renumbering, e.g. {9:0, 11:1, 13:2, 15:3}
       showatm: overlay atmospheric transmission
       scan: limit the result to this single scan
       verbose: if True, then print median for each spw/antenna
    Consider moving this to class CalTableExplorer someday
    Todd Hunter
    """
    if (buildpdf and figfile==''):
        figfile = True
    median=plotTcal(vis=vis, antenna=antenna, spw=spw, xaxis=xaxis,t='tsys',gs=gs,
             buildpdf=buildpdf, interactive=interactive,figfile=figfile,
             overlay=overlay, plotrange=plotrange, pol=pol, renumber=renumber,
             replace=replace, showatm=showatm, scan=scan, verbose=verbose, fontsize=fontsize)
    return(median)

def plotTrx(vis='', antenna = '', spw='', xaxis='freq', gs='gs',
            buildpdf=False, interactive=True, overlay='',
            plotrange=[0,0,0,0],pol='',figfile='', renumber=False, replace={},
            showatm=False, scan='', verbose=False, fontsize=12):
    """
    Plot the Trx from the SYSCAL table of the specified ms.  
    Produce a multi-page pdf.
       xaxis: 'freq' (default) or 'chan'
       gs: full path to ghostscript's gs
       antenna: a single antenna ID (as integer or string) or name
       overlay: '' or 'antenna'
       pol: '' or 'X' or 'Y'
       spw: single value or list: '5' or 5 or [5]
       figfile:  '' (no png produced) or filename
       buildpdf: True or False
       interactive: True or False
       plotrange: [xmin, xmax, ymin, ymax]
       renumber: renumbers the spws to start at 0, in the original order (9,11,13,15-->0,1,2,3)
       replace: provide a dictionary for the renumbering, e.g. {9:0, 11:1, 13:2, 15:3}
       showatm: overlay atmospheric transmission
       scan: limit the result to this single scan
       verbose: if True, then print median for each spw/antenna
    Consider moving this to class CalTableExplorer someday
    Todd Hunter
    """
    if (buildpdf and figfile==''):
        figfile = True
    median=plotTcal(vis=vis, antenna=antenna, spw=spw, xaxis=xaxis,t='trx',gs=gs,
             buildpdf=buildpdf, interactive=interactive,figfile=figfile,
             overlay=overlay, plotrange=plotrange, pol=pol, renumber=renumber,
             replace=replace, showatm=showatm, scan=scan, verbose=verbose, fontsize=fontsize)
    return(median)

def plotTsky(vis='', antenna = '', spw='', xaxis='freq', gs='gs',
             buildpdf=False, interactive=True, overlay='',
             plotrange=[0,0,0,0],pol='',figfile='',renumber=False, replace={},
             showatm=False, scan='', verbose=False, fontsize=12):
    """
    Plot the Tsky from the SYSCAL table of the specified ms.  
    Produce a multi-page pdf.
       xaxis: 'freq' (default) or 'chan'
       antenna: a single antenna ID (as integer or string) or name
       gs: full path to ghostscript's gs
       overlay: '' or 'antenna'
       pol: '' or 'X' or 'Y'
       spw: single value or list: '5' or 5 or [5]
       figfile:  '' (no png produced) or filename
       buildpdf: True or False
       interactive: True or False
       plotrange: [xmin, xmax, ymin, ymax]
       renumber: renumbers the spws to start at 0, in the original order (9,11,13,15-->0,1,2,3)
       replace: provide a dictionary for the renumbering, e.g. {9:0, 11:1, 13:2, 15:3}
       showatm: overlay atmospheric transmission
       scan: limit the result to this single scan
       verbose: if True, then print median for each spw/antenna
    Consider moving this to class CalTableExplorer someday
    Todd Hunter
    """
    if (buildpdf and figfile==''):
        figfile = True
    median=plotTcal(vis=vis, antenna=antenna, spw=spw, xaxis=xaxis,t='tsky',gs=gs,
             buildpdf=buildpdf, interactive=interactive, figfile=figfile,
             overlay=overlay,plotrange=plotrange,pol=pol, renumber=renumber,
             replace=replace, showatm=showatm, scan=scan, verbose=verbose, fontsize=fontsize)
    return(median)

def plotspws(vis, intents=['*ATMOS*', '*PHASE*', '*BANDPASS*', '*TARGET*'], tsystable='', plotfile=''):
    """
    Makes a plot summarizing the location of ALMA spws in a dataset.
    -Todd Hunter
    """
    from recipes.almahelpers import tsysspwmap
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    almaspws = mymsmd.almaspws(tdm=True,fdm=True)
    sciencespws = []
    for intent in intents:
        intentspws = mymsmd.spwsforintent(intent)
        spws = np.intersect1d(intentspws,almaspws)
        if (intent.find('TARGET')>=0):
            sciencespws = spws
    pb.clf()
    pb.subplot(211)
    pb.title('USB')
    pb.ylabel('Spw')
    pb.hold(True)
    if (tsystable == ''):
        tsystable = os.path.dirname(vis)+'/'+os.path.basename(vis)+'.tsys'
    sciencetsys = []
    if (os.path.exists(tsystable) and len(sciencespws) > 0):
        try:
            tsysmap = tsysspwmap(vis, tsystable)
            print "Science spws: ", sciencespws
            tsysmapstring = 'Tsys spw map: '
            for spw in sciencespws:
                tsysmapstring += '%d: %d,  ' % (spw,tsysmap[spw])
            print tsysmapstring
            sciencetsys = np.array(tsysmap)[sciencespws]
        except:
            tsysmap = []
    else:
        print "Could not open tsystable = ", tsystable
        tsysmap = []
    pb.subplot(212)
    pb.xlabel('Frequency (GHz)')
    pb.ylabel('Spw')
    pb.title('LSB')
    mysize = 7
    for intent in intents:
        print "Working on intent = ", intent
        intentspws = mymsmd.spwsforintent(intent)
        spws = np.intersect1d(intentspws,almaspws)
        for spw in spws:
            print "Working on spw = ", spw
            freqs = mymsmd.chanfreqs(spw) * 1e-9
            sideband = mymsmd.sideband(spw)
            if (sideband == -1):
                adesc = pb.subplot(211)
            else:
                bdesc = pb.subplot(212)
            idx = np.where(tsysmap == spw)
            color = 'k-'
            if (spw in sciencetsys):
                color = 'r' # color the Tsys windows chosen for science spws
            pb.plot([np.min(freqs), np.max(freqs)], [spw,spw], color)
            allintents = mymsmd.intentsforspw(spw)
            titleString = ''
            for allintent in allintents:
                for myintent in intents:
                    if (allintent.find(myintent.replace('*','')) >= 0):
                        if (titleString.find(myintent.replace('*','')) < 0):
                            titleString += myintent.replace('*','') + ','
            titleString.rstrip(',')
            pb.text(np.mean(freqs), spw+0.1, ' BB%d: %s'%(mymsmd.baseband(spw),titleString), size=mysize)
    mymsmd.close()
    pb.subplot(211)
    pb.ylim([pb.ylim()[0], pb.ylim()[1]+1])
    pb.subplot(212)
    pb.ylim([pb.ylim()[0], pb.ylim()[1]+1])
    adesc.yaxis.set_major_locator(MultipleLocator(2))
    bdesc.yaxis.set_major_locator(MultipleLocator(2))
    resizeFonts(adesc,mysize)
    resizeFonts(bdesc,mysize)
    pb.draw()
    if (plotfile != ''):
        if (plotfile == True):
            plotfile = os.path.basename(vis.rstrip('/') + '.plotspws.png')
        pb.savefig(plotfile)
        print "Saved plot in ", plotfile

def plotTcal(vis='', antenna = '', spw='', xaxis='freq', t='tsys', gs='gs',
             buildpdf=False, interactive=True, overlay='',
             plotrange=[0,0,0,0],pol='', figfile='', renumber=False, replace={},
             showatm=False, scan='',verbose=False, fontsize=12):
    """
    Plot either the Tsys, Trx or Tsky from the SYSCAL table of the specified
    ms.  Can produce a multi-page pdf.
       t: 'tsys' (default), 'trx' or 'tsky'
       xaxis: 'freq' (default) or 'chan'
       gs: full path to ghostscript's gs
       antenna: a single antenna ID (as integer or string) or name
       overlay: '' or 'antenna'
       pol: '' or 'X' or 'Y'
       spw: single value or list: '5' or 5 or [5]
       figfile:  '' (no png produced) or filename
       buildpdf: True or False
       interactive: True or False
       plotrange: [xmin, xmax, ymin, ymax]
       renumber: renumbers the spws to start at 0, in the original order (9,11,13,15-->0,1,2,3)
       replace: provide a dictionary for the renumbering, e.g. {9:0, 11:1, 13:2, 15:3}
       showatm: overlay atmospheric transmission
       scan: limit the results to a single scan
       verbose: if True, then print median for each spw/antenna
    Consider moving this to class CalTableExplorer someday
    Todd Hunter
    """
    medianValues = []
    if (os.path.exists(vis) == False):
        print "The ms does not exist."
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (os.path.exists(vis+'/SYSCAL') == False):
        print "The SYSCAL table for that ms does not exist."
        return
    t = t.lower()
    if (t!='tsys' and t!='trx' and t!='tsky'):
        print "t must be either tsys, trx or tsky"
        return
    if (overlay != '' and overlay != 'antenna'):
        print "You can only overlay 'antenna' or nothing ('')."
        return
    pol = str(pol).upper()
    if (pol not in ['','X','Y']):
        if (pol == '0'):
            pol = 'X'
        elif (pol == '1'):
            pol = 'Y'
        else:
            print "pol must be X or Y or '' or 0 or 1"
            return
    antenna = parseAntenna(vis,antenna)
    print "Antennas to show = ", np.unique(antenna)
    if (casadef.casa_version >= '4.1.0'):
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
    else:
        scanString = ''
    antennaNames = getAntennaNames(vis)
    tb.open(vis+'/SYSCAL')
    antennas = tb.getcol('ANTENNA_ID')
    times = tb.getcol('TIME')
    intervals = tb.getcol('INTERVAL')
    times -= 0.5*intervals
    if (len(antennas) < 1):
        print "The SYSCAL table is blank"
        return
    print "Antennas in data = ", np.unique(antennas)
    spws = tb.getcol('SPECTRAL_WINDOW_ID')
    if (renumber):
        if (replace == {}):
            ctr = 0
            for u in np.unique(spws):
                replace[u] = ctr
                ctr += 1
        newspws = copy(spws)
        for k, v in replace.iteritems(): newspws[spws==k] = v
        spws = newspws
    uniqueAntennas = np.unique(antennas)
    tb.close()
    print "spws = ", np.unique(spws)
    if (scan != ''):
        if (casadef.casa_version < '4.1.0'):
            print "The scan parameter is not supported in this casa version (<4.1.0)."
            return
    if (casadef.casa_version >= '4.1.0'):
        scans = []
        print "Matching times to scans..."
        for i in range(len(times)):
            tol = 0
            myscans = mymsmd.scansfortimes(times[i]+30,tol=tol)
            while (len(myscans) < 1):
                tol += 1
                myscans = mymsmd.scansfortimes(times[i]+30,tol=tol)
            scans.append(myscans[0])
        print "scans = ", np.unique(scans)
    pdfs = ''
    lines = ['-','--','..','-.']
    pb.clf()
    adesc = pb.subplot(111)
    if (spw == ''):
        # default to all spws
        spwlist = np.unique(spws)
    elif (type(spw) == list):
        if (type(spw[0]) == int):
            spwlist = spw
        else:
            spwlist = map(int, spw)
    elif (type(spw) == str):
        if (spw.find(',')>=0):
            intstrings = spw.split(',')
            spwlist = map(int, intstrings)
        else:
            if (spw.isdigit()):
                spwlist = [int(spw)]
            else:
                print "spw must be '' or an integer or integer string"
                return
    else:
        spwlist = [int(spw)]
    myinput = ''
    for spw in spwlist:
      if (spw not in spws):
          print "spw %d is not in the SYSCAL table." % (spw)
          continue
      colorctr = 0
      if (myinput == 'q'):
          break
      pb.clf()
      adesc = pb.subplot(111)
      medians = []

      # figure out how many there will be
      ctr = 0
      for i in range(len(antennas)):
          if (spws[i] == spw):
              if (antennas[i] in antenna):
                  ctr += 1
              
      shownAtm = False
      for i in range(len(antennas)):
        if (antennas[0] == antennas[i]):
            colorctr = 0
        if (spws[i] == spw):
          if (antennas[i] in antenna):
            if (scan != ''):
                scan = int(scan)
                if (scan != scans[i]): continue
            if (overlay==''):
                pb.clf()
                adesc = pb.subplot(111)
                mycolor = 'k'
            else:
                colorctr += 1
                mycolor = overlayColors[colorctr]
            tb.open(vis+'/SYSCAL')
            if (t == 'tsys'):
                tsys = tb.getcell('TSYS_SPECTRUM',i)
                ylab = 'Tsys (K)'
            elif (t == 'trx'):
                tsys = tb.getcell('TRX_SPECTRUM',i)
                ylab = 'Trx (K)'
            elif (t == 'tsky'):
                tsys = tb.getcell('TSKY_SPECTRUM',i)
                ylab = 'Tsky (K)'
            tb.close()
#            print "Appending to medians: %f, %s" % (np.median(tsys),np.shape(tsys))
            medians.append(np.median(tsys))
            try:
                freq = getFrequencies(vis, spws[i])*1e-9
            except:
                print "spw %d is not in the ms=%s.  Try setting renumber=True." % (spws[i],vis)
                return
            if (xaxis=='freq'):
                for j in range(len(tsys)):
                    if (pol=='' or (pol=='X' and j==0) or (pol=='Y' and j==1)):
                        if (renumber and len(freq) != len(tsys[j])):
                            # resample freq back down to tsys
                            newIncrement =  (freq[-1]-freq[0])/(len(tsys[j])-1.0)
                            freq = np.mgrid[freq[0]:(freq[-1]+newIncrement):newIncrement]
                        pb.plot(freq,tsys[j],'-', color=mycolor, ls=lines[j])
                        if (verbose):
                            if (casadef.casa_version >= '4.1.0'):
                                print "Scan %2d, spw %2d, ant %2d=%s: Median for pol%d = %f" % (scans[i], spws[i], antennas[i], antennaNames[antennas[i]], j, np.median(tsys[j]))
                            else:
                                print "Median for pol%d = %f" % (j,np.median(tsys[j]))
                    pb.hold(True)
                pb.xlabel('Frequency (GHz)', size=fontsize)
                if (showatm==True and (overlay=='' or not shownAtm)):
                    shownAtm = True
                    pwv, pwvstd = getMedianPWV(vis)
                    P=563
                    H=20
                    T=273
                    airmass=1.0
                    sideband = mymsmd.sideband(spw)
                    if (sideband < 0):
                        net_sideband=1
                    else:
                        net_sideband=2
                    chanfreqs = mymsmd.chanfreqs(spw)
                    if (len(chanfreqs) < 2):
                        print "This spw has only 1 channel"
                        continue
                    refFreqInTable = chanfreqs[0] - 0.5*(chanfreqs[1]-chanfreqs[0])
                    chans = range(len(chanfreqs))
                    freq, chans, transmission, TebbSky, tau = CalcAtmosphere(chans,chanfreqs*1e-9,pwv,refFreqInTable,
                                                                             net_sideband,P,H,T,airmass)
                    if (plotrange[2] != 0 or plotrange[3] != 0):
                        y0,y1 = plotrange[2:]
                    else:
                        y0,y1 = pb.ylim()
                    yrange = y1-y0
                    pb.plot(freq, y0+transmission*yrange,'m-')
                    if (antennaNames[antennas[i]].find('CM')>=0):
                        myString = "PWV = %.2f mm" % (pwv)
                    else:
                        myString = "median PWV = %.2f mm" % (pwv)
                        
                    pb.text(0.1,0.95,myString, transform=pb.gca().transAxes,color='m')
                else:
                    pass
#                   print "showatm=%s, i=%d" % (showatm,i)
            else:
                chan = range(len(freq))
                for j in range(len(tsys)):
                    if (renumber and len(chan) != len(tsys[j])):
                        # resample freq back down to tsys
                        chan = range(len(tsys[j]))
                    pb.plot(chan, tsys[j], '-', color=mycolor)
                    pb.hold(True)
                    print "Mean for pol%d = %f" % (j,np.mean(tsys[j]))
                pb.xlabel('Channel',size=10)
            if (overlay==''):
                pb.hold(False)
            yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
            adesc.yaxis.set_major_formatter(yFormat)
            pb.ylabel(ylab,size=fontsize)
            adesc.xaxis.grid(True,which='major')
            adesc.yaxis.grid(True,which='major')
            (mjd, utstring) = mjdSecondsToMJDandUT(times[i])
            if (plotrange[0] != 0 or plotrange[1] != 0):
                pb.xlim([plotrange[0],plotrange[1]])
            if (len(plotrange) > 2):
                if (plotrange[2] != 0 or plotrange[3] != 0):
                    pb.ylim([plotrange[2],plotrange[3]])
                
            if (casadef.casa_version >= '4.1.0'):
                scanString = 'scan %d' % (myscans[0])
            else:
                scanString = ''
            if (overlay=='antenna'):
                pb.title('%s  spw %d  %s  time %s' % (vis.split('/')[-1],spws[i],scanString,utstring),size=10)
                for a in range(len(uniqueAntennas)):
                    if (a*0.06 > 1.02):
                        x = 1.02
                        y -= 0.03
                    else:
                        y = 1.05
                        x = a*0.06
                    pb.text(x, y, '%s'%antennaNames[uniqueAntennas[a]], 
                            color=overlayColors[a], transform=pb.gca().transAxes,size=8)
            else:
                pb.title('%s  antenna %d=%s  spw %d  %s  time %s' % (vis.split('/')[-1],antennas[i],
                                     antennaNames[antennas[i]],spws[i],scanString,utstring),size=10)
            if (figfile == True):
                png = vis + '.%s.spw%d.%s.%s.png' % (antennaNames[antennas[i]],spws[i],scanString.replace(' ',''),t)
            else:
                png = figfile
            if (os.access('.',os.W_OK) == False):
                png = '/tmp/'+png
            if (overlay=='' or i==len(antennas)-1):
                resizeFonts(adesc,fontsize)
                if (figfile != ''):
                    print "Saving figure in %s" % (png)
                    pb.savefig(png)
                    if (buildpdf):
                        os.system('convert %s %s.pdf' % (png,png))
                    pdfs += png + '.pdf '
                if (interactive):
                    pb.draw()
                    if (ctr > 1 and i<len(antennas)-1):
                        myinput = raw_input("Press return for next page (q to quit): ")
                        if (myinput == 'q'):
                            break
      # end 'for' loop over rows in the table
      if (len(medians) > 0):
          print "Median value for spw %d = %.1f K" % (spw, np.median(medians))
          medianValues.append(np.median(medians))
      else:
          print "No data for this spw/scan combination"
          if (casadef.casa_version >= '4.1.0'):
              for scan in np.unique(scans):
                  print "Scan %2d has spws %s" % (scan,str(mymsmd.spwsforscan(scan)))
      if (interactive):
          pb.draw()
          if (myinput != 'q'):
              if (spwlist[-1] != spw):
                  myinput = raw_input("Press return for next spw (q to quit): ")
              else:
                  myinput = 'q'
          if (myinput == 'q'):
              break
    if (buildpdf):
        pdf = vis + '.' + t + '.pdf'
        if (os.access('.',os.W_OK) == False):
            pdf = '/tmp/'+pdf
        cmd = '%s -q -sPAPERSIZE=letter -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=%s %s' % (gs,pdf,pdfs)
        print "Running command: %s" % (cmd)
        os.system(cmd)
    if (casadef.casa_version >= '4.1.0'):
        mymsmd.close()
    # end of plotTcal
    return(medianValues)

def spwsforintent_nonwvr_nonchanavg(mymsmd, intent = 'OBSERVE_TARGET#ON_SOURCE', includeSQLD=False):
    """
    Uses the msmd tool to return the spws for the specified intent that are not WVR
    nor channel-averaged spws.  This is a good way to find science spws.
    - Todd Hunter
    """
    ignore = list(mymsmd.wvrspws()) + list(mymsmd.chanavgspws())
    if (includeSQLD):
        ignore = list(set(ignore) - set(mymsmd.almaspws(sqld=True)))
    spws = list(mymsmd.spwsforintent(intent))
    science_spws = [x for x in spws if x not in ignore]
    return(science_spws)

def checkOrder(inpFreq,inpData) :
    if ((inpFreq[1]-inpFreq[0]) > 0) :
        return inpFreq,inpData,0
    else :
        return inpFreq[::-1], inpData[::-1], 1

def getLoadTemperatures(vis, antenna = None, doplot=False):
    """
    Gets the load temperatures and timestamps from the ASDM_CALDEVICE
    table (if present). Returns a dictionary keyed by antenna, then scan
    number.  Keys are provide for both the antenna name and ID.
    -Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "The measurement set is not found."
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (casadef.casa_version < '4.1.0'):
        print "This version of CASA is too old.  It needs msmd (4.1 or newer)."
        return
    mytable = vis+'/ASDM_CALDEVICE'
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    scans = mymsmd.scannumbers()
    antennas = range(mymsmd.nantennas())
    antennaNames = mymsmd.antennanames(antennas)
    mydict = {}
    for ant in antennas:
        mydict[ant] = {}
        mydict[antennaNames[ant]] = {}
    if (os.path.exists(mytable) == False):
        print "The ASDM_CALDEVICE table is not present. You need to importasdm(asis='CalDevice') to get"
        print "correct load temperatures.  Will proceed using default temperature for the hot load and "
        print "ambient load, which is only a concern if you want to recalculate Tsys."
        for ant in antennas:
            for scan in scans:
                mydict[ant][scan] = {'hot':356, 'amb':287}
                mydict[antennaNames[ant]][scan] = {'hot':356, 'amb':287}
        mymsmd.close()
        return(mydict)
    mytb = createCasaTool(tbtool)
    mytb.open(mytable)
    temperatureLoad = mytb.getcol('temperatureLoad')
    timeInterval = mytb.getcol('timeInterval')
    antennaIds = mytb.getcol('antennaId')
    calLoadNames = mytb.getcol('calLoadNames')
    antennaId = np.array([int(x.split('_')[1]) for x in antennaIds])
    if (antenna != None):
        if (antenna not in antennaId):
            print "Antenna %d not in this dataset (0..%d)" % (antenna,np.max(antennaId))
            return
    mytb.close()
    times = []
    for ant in antennas:
        for scan in scans:
            for row in range(len(antennaId)):
                if (ant==antennaId[row]):
                    meanscantime = np.mean(mymsmd.timesforscan(scan))
                    times.append(meanscantime)
                    amb = list(calLoadNames[:,row]).index('AMBIENT_LOAD')
                    hot = list(calLoadNames[:,row]).index('HOT_LOAD')
                    ambLoad = temperatureLoad[amb][row]
                    hotLoad = temperatureLoad[hot][row]
                    mydict[antennaId[row]][scan] = {'hot':hotLoad,'amb':ambLoad}
                    mydict[antennaNames[antennaId[row]]][scan] = {'hot':hotLoad,'amb':ambLoad}
                    break
    mymsmd.close()
    if (antenna != None):
        indices = np.where(antennaId == antenna)[0]
    else:
        indices = range(len(antennaId))
    if (doplot):
        pb.clf()
        pb.plot(times,np.ones(len(times)),'k.')
        pb.hold(True)
        pb.plot(timeInterval[0][indices],np.zeros(len(indices)),'b.')
        pb.ylim([-1,2])
        pb.draw()
    return(mydict)

def defaultSBGainsForBand(band):
    """
    Accepts the ALMA band number.
    Returns the default sideband gains for the signal and image bands used by TelCal.
    Taken from AtmosphereScan.cpp of TelCal.
    - Todd Hunter
    """
    if (band <= 3):
        g_signal = 0.99
        g_image = 0.01
    elif (band <= 6):
        g_signal = 0.97
        g_image = 0.03
    elif (band <= 8):
        g_signal = 0.90
        g_image = 0.10
    else:
        g_signal = 0.5
        g_image = 0.5
    return(g_signal, g_image)

def computeFDMTsys(vis, caltable=None, spw=None,
                   scan=None, antenna=None, 
                   fdmspw=None, parentms='', lo1=None, 
                   newcaltable=None, asdm=None, pwv='cal', etaF=0.98,
                   Tatm='cal', figfile='', plots=1, pol=0, siteAltitude_m=5000):
    """
    This function is under development, and my get superceded by class Atmcal.
    
    Reads the T_rx spectrum from the SYSCAL table and interpolates it to the
    corresponding FDM channel width.  It then reads the sideband gain ratios
    from the ASDM_CALATMOSPHERE table, and the PWV in order to calculate a new 
    high-resolution Tsys spectrum, which it writes to a new caltable.
    pwv: 'median' (take median of all antennas)
         'cal' (use the value in the CAL_ATMOSPHERE table
         or a value in mm
    etaF: forward coupling efficiency of the antenna
    newcaltable: the name of the new cal table to write
    Note: uses the global constants: h and k    
    -Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "Could not open measurement set = ", vis
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (caltable != None):
        from recipes.almahelpers import tsysspwmap
        tsysmap = tsysspwmap(vis=vis, tsystable=caltable)
    else:
        tsysmap = None
    
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/SYSCAL')
    spws = mytb.getcol('SPECTRAL_WINDOW_ID')
    mjdsec = mytb.getcol('TIME')
    interval = mytb.getcol('INTERVAL')
    trx_spectra = mytb.getcol('TRX_SPECTRUM')
    tsky_spectra = mytb.getcol('TSKY_SPECTRUM')
    tcal_spectra = mytb.getcol('TCAL_SPECTRUM')
    tsys_spectra = mytb.getcol('TSYS_SPECTRUM')
    antenna_id = mytb.getcol('ANTENNA_ID')
    mytb.close()
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    if (antenna == None):
        antenna = mymsmd.antennanames(0)[0]
        print "Using antenna %s" % (antenna)
    if (scan == None):
        scans = mymsmd.scansforintent('CALIBRATE_ATMOSPHERE#ON_SOURCE')
        scan = scans[0]
        print "Using scan %d" % (scan)

    loadTemperatures = getLoadTemperatures(vis)
    TambientLoad = loadTemperatures[antenna][scan]['amb']
    ThotLoad = loadTemperatures[antenna][scan]['hot']
    print "ambient=%f, hot=%f" % (TambientLoad, ThotLoad)

    scienceSpws = np.array(spwsforintent_nonwvr_nonchanavg(mymsmd))
    print "science spws = ", scienceSpws
    if (tsysmap == None):
        row = 0
        spw = spws[row]
        if (fdmspw == None):
            print "You must specify fdmspw if the caltable is not specified."
            return
    elif (fdmspw==None):
        fdmspw = scienceSpws[0]
        spw = tsysmap[fdmspw]
        row = np.where(spws == spw)[0][0]
    else:
        spw = tsysmap[fdmspw]
        row = np.where(spws == spw)[0][0]
        
    print "Using row (%d) with a Tsys spw (%d) that corresponds to science spw = %d" % (row, spw, fdmspw)
    myTimes = [mjdsec[row]-0.5*interval[row], mjdsec[row]+0.5*interval[row]]
    result = getCalAtmosphereInfo(vis, scan=scan, antenna=antenna, pol=pol)
    mjdsec = result[4]
    telescopeName = mymsmd.observatorynames()[0]
    field = mymsmd.fieldsfortimes([mjdsec[row]])[0]
    mydirection = getRADecForField(vis, field)
    myazel = computeAzElFromRADecMJD(mydirection, mjdsec[row]/86400., telescopeName, verbose=False)
    airmass = elevationToAirmass(myazel[1]*180./np.pi)
    water = result[6]
    groundPressure = result[7]
    groundTemperature = result[8]
    groundRelHumidity = result[9]
    if (pwv == 'cal'):
        pwv = water[row]
        print "Got pwv=%f mm from CALATMOSPHERE table" % (pwv)
    elif (pwv == 'median'):
        medianPwv, stdev = getMedianPWV(vis, myTimes=myTimes)
        print "Median PWV = %f +- %f" % (medianPwv, stdev)
        pwv = medianPwv

    g_signal = result[0]
    g_signal = g_signal[0]
    g_image = 1 - g_signal
    print "Got g_signal[0] = %f = %.2f dB" % (g_signal, -10*np.log10(1-g_signal))
    tdmspw = spws[row]
    net_sideband = [mymsmd.sideband(s) for s in range(mymsmd.nspw())]
    freq_tdm = mymsmd.chanfreqs(spws[row])
    tdm_chanwidth = freq_tdm[1]-freq_tdm[0]  # replace when msmd.chanwidth is available
    refFreq = freq_tdm[0]-0.5*tdm_chanwidth
    fdm_chanwidth = abs(mymsmd.chanfreqs(fdmspw)[1]-mymsmd.chanfreqs(fdmspw)[0]) * tdm_chanwidth/abs(tdm_chanwidth)
    mymsmd.close()
    freq_signal = np.arange(refFreq, freq_tdm[-1]+0.5*tdm_chanwidth, fdm_chanwidth)
    chans = range(len(freq_signal))
    Tbg = Tcmb
    if (Tatm == 'cal'):
        Tatm = groundTemperature[row]
    Tsp = groundTemperature[row]
    freq, chans, transmission, TebbSky, opacity = \
        CalcAtmosphere(chans, freq_signal*1e-9, pwv, vis, 
                       asdm, antenna_id[row], 
                       refFreq, 
                       net_sideband[tdmspw], groundPressure[row],
                       groundRelHumidity[row],Tatm,
                       airmass, siteAltitude_m=siteAltitude_m)
    tau_signal = opacity
    tsky_signal = TebbSky
#    print "Median Tsky_signal = %fK   Tebbsky = %f" % (np.median(tsky_signal), np.median(TebbSky))

    getLOsStatus = getLOs(vis)
    if (getLOsStatus != []):
        lo1s = interpretLOs(vis,parentms)
        if (lo1s == None): return
        LO1 = lo1s[spws[row]]
        print "Found LO1 = %f" % (LO1)
    elif (lo1 != None):
        LO1 = lo1
    else:
        print "Could not find LO1"
        return
    freq_tdm_image = 2*LO1 - freq_tdm
    freq_image = 2*LO1 - freq_signal
    print "mean image freq = %f" % (np.mean(freq_image))
    refFreq_image = 2*LO1 - refFreq
    freq, chans, transmission_image, TebbSky_image, opacity = \
        CalcAtmosphere(chans, freq_image*1e-9, pwv, vis, 
                       asdm, antenna_id[row], 
                       refFreq_image, 
                       net_sideband[tdmspw], 
                       groundPressure[row],groundRelHumidity[row],Tatm,
                       airmass, siteAltitude_m=siteAltitude_m)
    tau_image = opacity
    tsky_image = TebbSky_image
    # Here, freq_signal is the FDM resolution
    hvk = h*freq_signal/k
    Jatm_signal = (hvk / (np.exp(hvk/Tatm) - 1))
    Jbg_signal = hvk / (np.exp(hvk/Tbg) - 1)
    Jsp_signal = hvk / (np.exp(hvk/Tsp) - 1)
    Jebb_signal = hvk / (np.exp(hvk/tsky_signal) - 1)
    Jem_signal = Jebb_signal - Jbg_signal*np.exp(-tau_signal)
    Jatm_signal = (Jebb_signal - Jbg_signal*np.exp(-tau_signal)) / (1-np.exp(-tau_signal))
    Jsky_signal = g_signal*(etaF*Jem_signal + (1-etaF)*Jsp_signal)
    Jamb_signal = g_signal*hvk / (np.exp(hvk/TambientLoad)-1)
    Jhot_signal = g_signal*hvk / (np.exp(hvk/ThotLoad)-1)
    #replace the line below when we change method
    Jsky_signal = etaF*(Jatm_signal*(1-np.exp(-tau_signal))+Jbg_signal*np.exp(-tau_signal)) + (1-etaF)*Jsp_signal

    hvk_image = h*freq_image/k
    Jbg_image = hvk_image / (np.exp(hvk_image/Tbg) - 1)
    Jatm_image = hvk_image / (np.exp(hvk_image/Tatm) - 1)
    Jsp_image = hvk_image / (np.exp(hvk_image/Tsp) - 1)
    Jebb_image = hvk / (np.exp(hvk/tsky_image) - 1)
    Jem_image = Jebb_image - Jbg_image*np.exp(-tau_image)
    Jatm_image = (Jebb_image - Jbg_image*np.exp(-tau_image)) / (1-np.exp(-tau_image))
    Jsky_image = g_image*(etaF*Jem_image + (1-etaF)*Jsp_image)
    Jamb_image = g_image*hvk_image / (np.exp(hvk_image/TambientLoad)-1)
    Jhot_image = g_image*hvk_image / (np.exp(hvk_image/ThotLoad)-1)
    # replace the line below when we change the method
    Jsky_image = etaF*(Jatm_image*(1-np.exp(-tau_image))+Jbg_image*np.exp(-tau_image)) + (1-etaF)*Jsp_image

    trx_spectrum = trx_spectra[pol,:,row]
    tsky_spectrum = tsky_spectra[pol,:,row]
    tcal_spectrum = tcal_spectra[pol,:,row]
    tcal_predict = (Jatm_signal - Jbg_signal) + g_image*np.exp(tau_signal-tau_image)*(Jatm_image-Jbg_image)
    
    tmpFreq, tmpData, checker = checkOrder(freq_tdm, trx_spectrum)
    tck = splrep(tmpFreq, tmpData, s=0)
    trx_spectrum_fdm = splev(freq_signal, tck, der=0)

    tmpFreq, tmpData, checker = checkOrder(freq_tdm, tsky_spectrum)
    tck = splrep(tmpFreq, tmpData, s=0)
    tsky_spectrum_interpolated = splev(freq_signal, tck, der=0)
    Tsky_predict = g_signal*Jsky_signal + g_image*Jsky_image
    ratioSpectrum = (tsky_spectrum_interpolated + trx_spectrum_fdm*1) / (Tsky_predict + trx_spectrum_fdm*1)

    tsys_spectrum_fdm = (exp(tau_signal)/(g_signal*etaF)) * (trx_spectrum_fdm + g_signal*Jsky_signal  + g_image*Jsky_image)
    tsys_spectrum_applied = tsys_spectrum_fdm * ratioSpectrum

    sx = 3
    sy = 3
    pb.clf()
    if (plots > 1):
        pb.subplot(sx,sy,1)
        pb.subplots_adjust(hspace=0.3,wspace=0.4)
        pb.plot(freq_tdm*1e-9, trx_spectrum, 'k-', freq_signal*1e-9, trx_spectrum_fdm, 'r-')
        pb.xlim([np.min(freq_tdm*1e-9),np.max(freq_tdm*1e-9)])
        pb.ylabel('T_rx (K)')
        pb.title("%s spw=%d"%(vis,spws[row]), size=10)
    
        pb.subplot(sx,sy,2)
        pb.plot(freq_signal*1e-9, tsky_signal, 'r-') # , freq_signal*1e-9, TebbSky, 'm-')
        pb.xlim([np.min(freq_signal*1e-9),np.max(freq_signal*1e-9)])
        ylims = [np.min([np.min(tsky_signal),np.min(tsky_image)]),np.max([np.max(tsky_signal),np.max(tsky_image)])]
        ylims_signal = [ylims[0]-0.1*(ylims[1]-ylims[0]), ylims[1]+0.1*(ylims[1]-ylims[0])]
        pb.ylim(ylims_signal)
        pb.ylabel('T_sky_signal (K)')
        pb.title("red: temp=%.1fK" % (Tatm), size=10)
    
        pb.subplot(sx,sy,3)
        pb.plot(freq_image*1e-9, tsky_image, 'r-') #, freq_image*1e-9, TebbSky_image, 'm-')
        pb.xlim([np.max(freq_image*1e-9),np.min(freq_image*1e-9)])
        pb.ylim(ylims_signal)
        pb.ylabel('T_sky_image (K)')
        pb.title("black=TelCal result", size=10) # , magenta=using TebbSky", size=10)    
    
        pb.subplot(sx,sy,4)
        pb.plot(freq_signal*1e-9, Tsky_predict, 'r-') #, freq_signal*1e-9, Tsky_predict_from_at, 'm-')
        pb.xlim([np.min(freq_tdm*1e-9),np.max(freq_tdm*1e-9)])
        pb.ylim(ylims_signal)
        pb.ylabel('Tsky_predict (K)')
    
        pb.subplot(sx,sy,5)
        pb.plot(freq_signal*1e-9, tau_signal, 'r-')
        pb.xlim([np.min(freq_signal*1e-9),np.max(freq_signal*1e-9)])
        ylims = [np.min([np.min(tau_signal),np.min(tau_image)]),np.max([np.max(tau_signal),np.max(tau_image)])]
        ylims_tau = [ylims[0]-0.1*(ylims[1]-ylims[0]), ylims[1]+0.1*(ylims[1]-ylims[0])]
        pb.ylim(ylims_tau)
        pb.ylabel('tau_signal')
        
        pb.subplot(sx,sy,6)
        pb.plot(freq_image*1e-9, tau_image, 'r-')
        pb.xlim([np.max(freq_image*1e-9),np.min(freq_image*1e-9)])
        pb.ylim(ylims_tau)
        pb.ylabel('tau_image')
        
        pb.subplot(sx,sy,7)
        pb.plot(freq_tdm*1e-9, tsky_spectrum, 'k-', freq_signal*1e-9, Tsky_predict, 'r-')
        # , freq_signal*1e-9, Tsky_predict_from_at, 'm-')
        pb.xlim([np.min(freq_tdm*1e-9),np.max(freq_tdm*1e-9)])
        pb.ylabel('T_sky_spectrum (K)')
    
        pb.subplot(sx,sy,8)
#    print "lens=%d,%d  %d,%d" % (len(freq_signal), len(tsys_spectrum_fdm), len(freq_tdm), len(tsys_spectra[pol,:,row]))
    pb.plot(freq_tdm*1e-9, tsys_spectra[pol,:,row], 'k-',
            freq_signal*1e-9, tsys_spectrum_applied, 'r-'
#            freq_signal*1e-9, tsys_spectrum_fdm, 'b-', 
#            freq_signal*1e-9, tsys_spectrum_applied_from_at, 'm-',
            )
    pb.xlim([np.min(freq_tdm*1e-9),np.max(freq_tdm*1e-9)])
    pb.ylabel('T_sys (K)')
    if (plots > 1):
        adesc = pb.subplot(sx,sy,9)
        pb.plot(freq_tdm*1e-9, tcal_spectrum, 'k-', freq_signal*1e-9, tcal_predict, 'r-')
        #            freq_signal*1e-9, tcal_predict_from_at, 'm-')
        pb.xlim([np.min(freq_tdm*1e-9),np.max(freq_tdm*1e-9)])
        pb.ylabel('T_cal (K)')
        yFormat = matplotlib.ticker.ScalarFormatter(useOffset=False)
        adesc.yaxis.set_major_formatter(yFormat)
    else:
        titleString = '%s.spw%d.scan%d.pol%d' % (antenna,spw,scan,pol)
        pb.title(titleString)

    pb.draw()
    if (figfile != ''):
        if (figfile == True):
            figfile = titleString + '.png'
        pb.savefig(figfile)
        print "plot left in %s" % (figfile)

def CalcAtmosphere(chans,freqs,pwv,
                   refFreqInTable, net_sideband,P,H,T,airmass,
                   verbose=False, atmType=1, siteAltitude_m=5000):
    """
    Uses the at tool in CASA to compute atmospheric model.
    chans: all channels, regardless of whether they are flagged
    freqs: frequencies (in GHz) corresponding to chans
    atmType: 1, 2, or 3, default=1=tropical, 2=midLatSummer, 3=midLatWinter
    returns 5 arrays:
       freq, chans, transmission (0..1), TebbSky, tau
    """
    if (verbose):
        print "Using zenith PWV=%.3fmm, airmass=%.3f, P=%.2fmb, H=%.2f%%, T=%.2fK..." % (pwv,airmass,P,H,T)
    tropical = 1
    midLatitudeSummer = 2
    midLatitudeWinter = 3
    numchan = len(freqs)
    reffreq=0.5*(freqs[numchan/2-1]+freqs[numchan/2])
    chansep = (freqs[-1]-freqs[0])/(numchan-1)
    nbands = 1
    # from AtmosphereScan.cpp
    maxAltitude = 48.0  
    h0 = 2.0  
    dP = 5.0  
    dPm = 1.1 
    myqa = createCasaTool(qatool)
    maxAltitude = create_casa_quantity(myqa, maxAltitude,'km')
    h0 = create_casa_quantity(myqa, h0,'km')
    dP = create_casa_quantity(myqa, dP,'mbar')
    fCenter = create_casa_quantity(myqa, reffreq,'GHz')
    fResolution = create_casa_quantity(myqa, chansep,'GHz')
    fWidth = create_casa_quantity(myqa, numchan*chansep,'GHz')
    at.initAtmProfile(humidity=H,temperature=create_casa_quantity(myqa, T,"K"),
                      altitude=create_casa_quantity(myqa, siteAltitude_m,"m"),
                      pressure=create_casa_quantity(myqa, P,'mbar'),atmType=atmType,
                      dP=dP, maxAltitude=maxAltitude, h0=h0, dPm=dPm)
    at.initSpectralWindow(nbands,fCenter,fWidth,fResolution)
    at.setUserWH2O(create_casa_quantity(myqa, pwv,'mm'))
    # This does not affect the opacity, but it does effect TebbSky, so do it manually.
    at.setAirMass(airmass)

    rc = at.getRefChan()
    n = at.getNumChan()
    if (casadef.casa_version < '4.0.0'):
        dry = np.array(at.getDryOpacitySpec(0)['dryOpacity'])
        wet = np.array(at.getWetOpacitySpec(0)['wetOpacity'].value)
        TebbSky = []
        for chan in range(n):  # do NOT use numchan here, use n
            TebbSky.append(at.getTebbSky(nc=chan, spwid=0).value)
        TebbSky = np.array(TebbSky)
        # readback the values to be sure they got set
        rf = at.getRefFreq().value
        cs = at.getChanSep().value
    else:
        dry = np.array(at.getDryOpacitySpec(0)[1])
        wet = np.array(at.getWetOpacitySpec(0)[1]['value'])
        TebbSky = at.getTebbSkySpec(spwid=0)[1]['value']
        # readback the values to be sure they got set
        rf = at.getRefFreq()['value']
        cs = at.getChanSep()['value']
        if (at.getRefFreq()['unit'] != 'GHz'):
            print "There is a unit mismatch for refFreq in the code."
        if (at.getChanSep()['unit'] != 'MHz'):
            print "There is a unit mismatch for chanSep in the code."

    chans = range(0,n)
    transmission = np.exp(-airmass*(wet+dry))
#    TebbSky *= (1-np.exp(-airmass*(wet+dry)))/(1-np.exp(-wet-dry))

    if (refFreqInTable*1e-9>np.mean(freqs)):
        if ((net_sideband % 2) == 0):
            sense = 1
        else:
            sense = 2
    else:
        if ((net_sideband % 2) == 0):
            sense = 2
        else:
            sense = 1

    if (sense == 1):
        # The following looks right for LSB   sense=1
        freq = rf + cs*0.001*(0.5*n-1-np.array(range(n)))
    else:
        # Using numchan can cause an inconsistency for small number of channels
        # The following looks right for USB  sense=2
        freq = rf+cs*0.001*(np.array(range(n))-0.5*n+1)
    if (verbose):
        print "...median tau = %f, transmission = %f" % (np.median(airmass*(wet+dry)), np.median(transmission))
    return(freq, chans, transmission, TebbSky, airmass*(wet+dry))

def detectNegativeTsys(vis='', antenna = '', spw='', showfield=False,
                       vm='', pol='', edge=0, timerange=''):
    """
    Reads the SYSCAL table of the specified ms and searches for negative
    values of TSYS_SPECTRUM, printing a summary for each row as it finds
    them.  If an antenna is specified (ID or name), then only that antenna 
    will be displayed.  If an spw is specified (integer or string), then 
    only that spw will be displayed.  If edge is non-zero, then that many
    channels will be ignored on both edges of the spws.  timerange is an
    integer starting at 0, and represents each unique time in the solution.
    -Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "The ms does not exist."
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (os.path.exists(vis+'/SYSCAL') == False):
        print "The SYSCAL table for that ms does not exist."
        return
    if (edge < 0):
        print "The value of edge must be >= 0."
        return
    if (type(antenna) == str):
        if (len(antenna) > 0):
            if (antenna.isdigit()==False):
                antennaName = antenna
                antenna = getAntennaIndex(vis, antenna)
            else:
                antenna = int(antenna)
                antennaName = getAntennaName(vis, antenna)
                
    else:
        antennaName = getAntennaName(vis, antenna)
    antennaNames = getAntennaNames(vis)
    mymsmd = ''
    if (showfield):
        if (casadef.casa_version < '4.1.0'):
            if (vm==''):
                print "Running ValueMapping (because showfield=True and vm=0)..."
                vm = ValueMapping(vis)
        elif (vm != ''):  # this is for testing vm in >=4.1.0
            print "Running ValueMapping (because showfield=True and vm!=0)..."
            vm = ValueMapping(vis)
        else:
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(vis)
    tb.open(vis+'/SYSCAL')
    antennas = tb.getcol('ANTENNA_ID')
    spws = tb.getcol('SPECTRAL_WINDOW_ID')
    times = tb.getcol('TIME')
    intervals = tb.getcol('INTERVAL')
    uniqueTimes = np.unique(times)
    total = 0
    totalPossible = 0
    maxFieldLength = 16
    if (showfield):
        header = "Row  Antenna  spw  time(interval)  scan(startTime)  fieldname   polarization"
    else:
        header = "Row  Antenna  spw  time(interval)  polarization"
    headerPrinted = False
    for i in range(len(spws)):
        tsys = tb.getcell('TSYS_SPECTRUM',i)
        for polarization in range(len(tsys)):
            negatives = np.where(tsys[polarization]<0)[0]
            neg = len(negatives)
            if (edge > 0):
                howManyNegatives = len(np.where(tsys[polarization][edge:-edge]<0)[0])
            else:
                howManyNegatives = neg
            possible = np.size(tsys[polarization])
            uniqueTime = list(uniqueTimes).index(times[i])
            if (antenna=='' or antennas[i]==int(antenna)):
                if (spw=='' or spws[i] == int(spw)):
                    if (pol=='' or polarization==int(pol)):
                        if (timerange=='' or timerange==uniqueTime):
                            totalPossible += possible
            if (howManyNegatives > 0):
                medianValue = np.median(tsys[polarization][negatives])
                if (antenna=='' or antennas[i]==int(antenna)):
                    if (spw=='' or spws[i] == int(spw)):
                        if (pol=='' or polarization==int(pol)):
                            if (timerange=='' or timerange==uniqueTime):
                                if (headerPrinted == False):
                                    print header
                                    headerPrinted = True
                                myhhmmss = mjdSecondsToMJDandUT(times[i])[1].split()[1]
                                if (float(intervals[i]) > 1e6):
                                    myhhmmss = '+%5dd(%.0fd)' % ((times[i]-times[0])/86400.,intervals[i]/86400.)
                                else:
                                    myhhmmss += '(%02d:%02.0f)' % (int(float(intervals[i])/60.),intervals[i]%60)
                                if (showfield):
                                    if (casadef.casa_version < '4.1.0' or mymsmd == ''):
                                        myscan = getScansForTime(vm.scansForTimes,times[i])
                                        intents = vm.getIntentsForScan(myscan)
                                        while ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents and myscan>1):
                                            myscan -= 1
                                            intents = vm.getIntentsForScan(myscan)
                                        myscantimes = vm.getTimesForScan(myscan)
                                        myscanhhmmss0 = mjdSecondsToMJDandUT(np.min(myscantimes))[1].split()[1]
                                        myscanhhmmss1 = mjdSecondsToMJDandUT(np.max(myscantimes))[1].split()[1]
                                        myfield = vm.getFieldsForScan(myscan)[0]
                                    else:
                                        myscan = mymsmd.scansfortimes(times[i])
                                        if (len(myscan) < 1):
                                            myscan = mymsmd.scannumbers()[-1]
                                        else:
                                            myscan = myscan[0]
                                        intents = mymsmd.intentsforscan(myscan)
                                        while ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents and myscan>1):
                                            myscan -= 1
                                            intents = mymsmd.intentsforscan(myscan)
                                        myscantimes = mymsmd.timesforscan(myscan)
                                        myscanhhmmss0 = mjdSecondsToMJDandUT(np.min(myscantimes))[1].split()[1]
                                        myscanhhmmss1 = mjdSecondsToMJDandUT(np.max(myscantimes))[1].split()[1]
                                        myfield = mymsmd.namesforfields(mymsmd.fieldsforscan(myscan)[0])[0]
                                    if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents):
                                        print "       WARNING: scan %d does not have CALIBRATE_ATMOSPHERE intent" % (myscan)
                                    if (len(myfield) < maxFieldLength):
                                        myfield += ' '*(maxFieldLength-len(myfield))
                                    if (len(myfield) > maxFieldLength):
                                        myfield = myfield[0:maxFieldLength]
                                    result = "%4d [%2d=%s, %2d, %d=%s, %2d (%s), %16s, %d) found %4d of %4d (median=%g)" % (i,antennas[i], antennaNames[antennas[i]], spws[i], uniqueTime, myhhmmss, myscan, myscanhhmmss0, myfield, polarization, neg, possible, medianValue)
                                else:
                                    result = "%4d [%2d=%s, %2d, %d=%s, %d], found %3d out of %3d (median=%g)" % (i,
                                            antennas[i], antennaNames[antennas[i]], spws[i], uniqueTime, myhhmmss,
                                            polarization, neg, possible, medianValue)
                                print result
                                total += neg
    tb.close()
    if (total == 0):
        print "No negatives found!"
    else:
        print "A total of %d negative values encountered out of %d possible (%.4f%%)." % (total,totalPossible,(100.*total)/totalPossible)
    if (mymsmd != ''):
        mymsmd.close()
    return()

def detectNegativeTrx(vis='', antenna = '', spw='', showfield=False, vm='',
                      pol='', edge=0, showAllRowsForAntenna=-1):
    """
    Reads the SYSCAL table of the specified ms and searches for negative
    values of TRX_SPECTRUM, printing a summary for each row as it finds
    them.  If an antenna is specified (ID or name), then only that antenna 
    will be displayed.  If an spw is specified (integer or string), then 
    only that spw will be displayed.  If edge is non-zero, then that many
    channels will be ignored on both edges of the spws.    -Todd Hunter
    """
    if (os.path.exists(vis) == False):
        print "The ms does not exist."
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (os.path.exists(vis+'/SYSCAL') == False):
        print "The SYSCAL table for that ms does not exist."
        return
    if (edge < 0):
        print "The value of edge must be >= 0."
        return
    if (type(antenna) == str):
        if (len(antenna) > 0):
            if (antenna.isdigit()==False):
                antennaName = antenna
                antenna = getAntennaIndex(vis, antenna)
            else:
                antenna = int(antenna)
                antennaName = getAntennaName(vis, antenna)
                
    else:
        antennaName = getAntennaName(vis, antenna)
    antennaNames = getAntennaNames(vis)
    mymsmd = ''
    if (showfield):
        if (casadef.casa_version < '4.1.0'):
            if (vm == ''):
                print "Running ValueMapping (because showfield=True and vm=0)..."
                vm = ValueMapping(vis)
        elif (vm != ''):  # this is for testing vm in >=4.1.0
            print "Running ValueMapping (because showfield=True and vm!=0)..."
            vm = ValueMapping(vis)
        else:
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(vis)
    tb.open(vis+'/SYSCAL')
    antennas = tb.getcol('ANTENNA_ID')
    spws = tb.getcol('SPECTRAL_WINDOW_ID')
    times = tb.getcol('TIME')
    intervals = tb.getcol('INTERVAL')
    total = 0
    totalb = 0  # number of spw's with >50percent of channels negative
    totalPossible = 0
    maxFieldLength = 16
    if (showfield):
        header = "Row  Antenna  spw  time(interval)  scan(startTime)  fieldname   polarization"
    else:
        header = "Row  Antenna  spw  time(interval)  polarization"
    headerPrinted = False
    for i in range(len(spws)):
        trx = tb.getcell('TRX_SPECTRUM',i)
        for polarization in range(len(trx)):
            negatives = np.where(trx[polarization]<0)[0]
            neg = len(negatives)
            if (edge > 0):
                howManyNegatives = len(np.where(trx[polarization][edge:-edge]<0)[0])
            else:
                howManyNegatives = neg
            possible = np.size(trx[polarization])
            if (antenna=='' or antennas[i]==int(antenna)):
                if (spw=='' or spws[i] == int(spw)):
                    if (pol=='' or polarization==int(pol)):
                        totalPossible += possible
            if (howManyNegatives > 0 or antennas[i]==showAllRowsForAntenna):
                if (howManyNegatives > 0):
                    medianValue = np.median(trx[polarization][negatives])
                    medianString = '(median=%g)' % medianValue
                else:
                    medianString = ''
                if (antenna=='' or antennas[i]==int(antenna)):
                    if (spw=='' or spws[i] == int(spw)):
                        if (pol=='' or polarization==int(pol)):
                            if (headerPrinted == False):
                                print header
                                headerPrinted = True
                            myhhmmss = mjdSecondsToMJDandUT(times[i])[1].split()[1]
                            if (float(intervals[i]) > 1e6):
                                myhhmmss = '+%5dd(%.0fd)' % ((times[i]-times[0])/86400.,intervals[i]/86400.)
                            else:
                                myhhmmss += '(%02d:%02.0f)' % (int(float(intervals[i])/60.),intervals[i]%60)
                            if (showfield):
                                if (casadef.casa_version < '4.1.0' or mymsmd == ''):
                                    myscan = getScansForTime(vm.scansForTimes,times[i])
                                    intents = vm.getIntentsForScan(myscan)
                                    while ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents and myscan>1):
                                        myscan -= 1
                                        intents = vm.getIntentsForScan(myscan)
                                    myscantimes = vm.getTimesForScan(myscan)
                                    myscanhhmmss0 = mjdSecondsToMJDandUT(np.min(myscantimes))[1].split()[1]
                                    myscanhhmmss1 = mjdSecondsToMJDandUT(np.max(myscantimes))[1].split()[1]
                                    myfield = vm.getFieldsForScan(myscan)[0]
                                else:
                                    myscan = mymsmd.scansfortimes(times[i])
                                    if (len(myscan) < 1):
                                        myscan = mymsmd.scannumbers()[-1]
                                    else:
                                        myscan = myscan[0]
                                    intents = mymsmd.intentsforscan(myscan)
                                    while ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents and myscan>1):
                                        myscan -= 1
                                        intents = mymsmd.intentsforscan(myscan)
                                    myscantimes = mymsmd.timesforscan(myscan)
                                    myscanhhmmss0 = mjdSecondsToMJDandUT(np.min(myscantimes))[1].split()[1]
                                    myscanhhmmss1 = mjdSecondsToMJDandUT(np.max(myscantimes))[1].split()[1]
                                    myfield = mymsmd.namesforfields(mymsmd.fieldsforscan(myscan)[0])[0]
                                if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents):
                                    print "       WARNING: scan %d does not have CALIBRATE_ATMOSPHERE intent" % (myscan)
                                if (len(myfield) < maxFieldLength):
                                    myfield += ' '*(maxFieldLength-len(myfield))
                                if (len(myfield) > maxFieldLength):
                                    myfield = myfield[0:maxFieldLength]
                                result = "%4d [%2d=%s, %2d, %s, %2d (%s), %16s, %d] found %4d of %4d %s" % (i,antennas[i], antennaNames[antennas[i]], spws[i], myhhmmss, myscan, myscanhhmmss0, myfield, polarization, neg, possible, medianString)
                            else:
                                result = "%4d [%2d=%s, %2d, %s, %d], found %3d out of %3d (median=%g)" % (i,
                                   antennas[i],antennaNames[antennas[i]],spws[i], myhhmmss,
                                   polarization, neg, possible, medianValue)
                            print result
                            total += neg
                            if ((1.0*neg)/(1.0*possible) > 0.1):
                                totalb += 1
                                print "this spw has >10% of channels negative!!"
    tb.close()
    if (total == 0):
        print "No negative Trx found!"
    else:
        print "A total of %d negative Trx values encountered out of %d possible (%.4f%%)." % (total, totalPossible,(100.*total)/totalPossible)
    if (totalb == 0):
        print "But no spws with >10% negative Trx found. So most problems are probably edge channels"
    else:
        print "Warning: ", totalb, " spws had >10% negative Trx and have serious problems."
    if (mymsmd != ''):
        mymsmd.close()
    return(vm)

def detectLoadTemp(vis='', showfield=False, vm='',antenna=''):
    """
    Reads the CALDEVICE table of the specified ms and searches for unusual
    values of temperatureLoad, printing a summary for each row as it finds
    them.  Unusual is Tamb outside range 10-20C or Thot outside range 80-90C.
    -Bill Dent
    """
    Tamb_lo=10.0
    Tamb_hi=20.0
    Thot_lo=70.0
    Thot_hi=90.0

    if (os.path.exists(vis) == False):
        print "The ms does not exist."
        return
    if (os.path.exists(vis+'/table.dat') == False):
        print "No table.dat.  This does not appear to be an ms."
        return
    if (os.path.exists(vis+'/CALDEVICE') == False):
        print "The CALDEVICE table for that ms does not exist."
        return
    if (type(antenna) == str):
        if (len(antenna) > 0):
            if (antenna.isdigit()==False):
                antennaName = antenna
                antenna = getAntennaIndex(vis, antenna)
            else:
                antenna = int(antenna)
                antennaName = getAntennaName(vis, antenna)
                
    else:
        antennaName = getAntennaName(vis, antenna)
    antennaNames = getAntennaNames(vis)
    print "Antennas being checked: ", antennaNames
    if (showfield and vm==''):
        print "Running ValueMapping (because showfield=True)..."
        vm = ValueMapping(vis)
    tb.open(vis+'/CALDEVICE')
    antennas = tb.getcol('ANTENNA_ID')
    times = tb.getcol('TIME')
    intervals = tb.getcol('INTERVAL')
    times = times-0.5*intervals
    total = 0
    maxFieldLength = 1
    nrows=len(antennas)
    print 'nrows ', nrows
    for i in range(0,nrows):
       T_amb= tb.getcell('TEMPERATURE_LOAD',i)[0]
       T_hot= tb.getcell('TEMPERATURE_LOAD',i)[1]
       if(T_amb < Tamb_lo or T_amb > Tamb_hi):
           antbad=tb.getcell('ANTENNA_ID',i)
           times[0]=tb.getcell('TIME',i)
           if(showfield):
               myscan = getScansForTime(vm.scansForTimes,times[0])
               myfield = getFieldsForTime(vm.fieldsForTimes,times[0])
               print "Scan", myscan," field",myfield," Antenna:", antennaNames[antbad]," Ambient load out of range. T_amb:", T_amb
           else:
               print "Row ", i, " Ambient load out of range. T_amb: ", T_amb," Antenna: ", antennaNames[antbad]
           total += 1
       if(T_hot < Thot_lo or T_hot > Thot_hi):
           antbad=tb.getcell('ANTENNA_ID',i)
           times[0]=tb.getcell('TIME',i)
           if(showfield):
               myscan = getScansForTime(vm.scansForTimes,times[0])
               myfield = getFieldsForTime(vm.fieldsForTimes,times[0])
               print "Scan", myscan," field",myfield," Antenna:", antennaNames[antbad]," Hot load out of range. T_hot:", T_hot
           else:
               print "Row ", i, " Hot load out of range. T_hot: ", T_hot," Antenna:", antennaNames[antbad]
           total += 1

    tb.close()
    if (total == 0):
        print "No problems in load temperatures found!"
    else:
        print "A total of %d load temperature problems encountered." % (total)
    return(vm)

def nearestScanForTime(mymsmd, mytime):
    """
    An extension to mymsmd.scansfortimes()
    Todd Hunter
    """
    myscans = mymsmd.scansfortimes(mytime)
    if (len(myscans) > 0):
        return(myscans[0])
    # need to find the nearest scan
    if (np.min(mymsmd.timesforscan(1)) > mytime):
        return(1)
    if (np.max(mymsmd.timesforscan(mymsmd.nscans())) < mytime):
        return(mymsmd.nscans())
    # the time lies between 2 scans
    for s in range(1,mymsmd.nscans()):
        if ((np.max(mymsmd.timesforscan(s)) < mytime) and (np.min(mymsmd.timesforscan(s+1)) > mytime)):
            if (mytime - np.max(mymsmd.timesforscan(s)) >= np.min(mymsmd.timesforscan(s+1)) - mytime):
                return(s+1)
            else:
                return(s)
    print "Failed to find nearest scan to time %f.  Returning final scan." % (mytime)
    return(mymsmd.nscans())
    
def detectNaNTsys(caltable='', antenna = '', spw='', showfield=False, vm='',
                  pol='', edge=0, vis=''):
    """
    Reads a caltable and searches for NaN
    values of FPARAM, printing a summary for each row as it finds
    them.  If an antenna is specified (ID or name), then only that antenna 
    will be displayed.  If an spw is specified (integer or string), then 
    only that spw will be displayed.  If edge is non-zero, then that many
    channels will be ignored on both edges of the spws.
    -Todd Hunter
    """
    if (os.path.exists(caltable) == False):
        print "The caltable does not exist."
        return
    if (edge < 0):
        print "The value of edge must be >= 0."
        return
    if (vis == ''):
        mytb = createCasaTool(tbtool)
        mytb.open(caltable)
        try:
            vis = mytb.getkeyword('MSName')
        except:
            print "Not a valid cal table."
            return
        mytb.close()
    if (type(antenna) == str):
        if (len(antenna) > 0):
            if (antenna.isdigit()==False):
                antennaName = antenna
                antenna = getAntennaIndex(vis, antenna)
            else:
                antenna = int(antenna)
                antennaName = getAntennaName(vis, antenna)
                
    else:
        antennaName = getAntennaName(vis, antenna)
    antennaNames = getAntennaNames(vis)
    mymsmd = ''
    if (showfield):
        if (casadef.casa_version < '4.1.0'):
            if (vm == ''):
                print "Running ValueMapping (because showfield=True and vm=0)..."
                vm = ValueMapping(vis)
        elif (vm != ''):  # this is for testing vm in >=4.1.0
            print "Running ValueMapping (because showfield=True and vm!=0)..."
            vm = ValueMapping(vis)
        else:
            mymsmd = createCasaTool(msmdtool)
            mymsmd.open(vis)
    tb.open(caltable)
    antennas = tb.getcol('ANTENNA1')
    spws = tb.getcol('SPECTRAL_WINDOW_ID')
    times = tb.getcol('TIME')
    intervals = tb.getcol('INTERVAL')
    total = 0
    maxFieldLength = 16
    if (showfield):
        header = "Row  Antenna  spw  time(interval)  scan(startTime)  fieldname   polarization"
    else:
        header = "Row  Antenna  spw  time(interval)  polarization"
    headerPrinted = False
    for i in range(len(spws)):
        tsys = tb.getcell('FPARAM',i)
        for polarization in range(len(tsys)):
            negatives = []
            if (edge > 0):
                possible = np.size(tsys[polarization][edge:-edge])
                for t in range(possible):
                    if (tsys[polarization][t+edge] != tsys[polarization][t+edge]):
                        negatives.append(t+edge)
            else:
                possible = np.size(tsys[polarization])
                for t in range(possible):
                    if (tsys[polarization][t] != tsys[polarization][t]):
                        negatives.append(t)
            howManyNegatives = len(negatives)
            if (howManyNegatives > 0):
                medianValue = np.median(tsys[polarization][negatives])
                if (antenna=='' or antennas[i]==int(antenna)):
                    if (spw=='' or spws[i] == int(spw)):
                        if (pol=='' or polarization==int(pol)):
                            if (headerPrinted == False):
                                print header
                                headerPrinted = True
                            myhhmmss = mjdSecondsToMJDandUT(times[i])[1].split()[1]
                            if (float(intervals[i]) > 1e6):
                                myhhmmss = '+%5dd(%.0fd)' % ((times[i]-times[0])/86400.,intervals[i]/86400.)
                            else:
                                myhhmmss += '(%02d:%02.0f)' % (int(float(intervals[i])/60.),intervals[i]%60)
                            if (showfield):
                                if (casadef.casa_version < '4.1.0' or mymsmd == ''):
                                    myscan = getScansForTime(vm.scansForTimes,times[i])
                                    intents = vm.getIntentsForScan(myscan)
                                    while ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents and myscan>1):
                                        myscan -= 1
                                        intents = vm.getIntentsForScan(myscan)
                                    myscantimes = vm.getTimesForScan(myscan)
                                    myscanhhmmss0 = mjdSecondsToMJDandUT(np.min(myscantimes))[1].split()[1]
                                    myscanhhmmss1 = mjdSecondsToMJDandUT(np.max(myscantimes))[1].split()[1]
                                    myfield = vm.getFieldsForScan(myscan)[0]
                                else:
                                    myscan = nearestScanForTime(mymsmd, times[i])
                                    intents = mymsmd.intentsforscan(myscan)
#                                    print "Scan %d has intent = %s" % (myscan,str(intents))
                                    while ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents and myscan>1):
                                        myscan -= 1
                                        intents = mymsmd.intentsforscan(myscan)
#                                        print "Scan %d has intent = %s" % (myscan,str(intents))
                                    myscantimes = mymsmd.timesforscan(myscan)
                                    myscanhhmmss0 = mjdSecondsToMJDandUT(np.min(myscantimes))[1].split()[1]
                                    myscanhhmmss1 = mjdSecondsToMJDandUT(np.max(myscantimes))[1].split()[1]
                                    myfield = mymsmd.namesforfields(mymsmd.fieldsforscan(myscan)[0])[0]
                                if ('CALIBRATE_ATMOSPHERE#ON_SOURCE' not in intents):
                                    print "       WARNING: scan %d does not have CALIBRATE_ATMOSPHERE intent" % (myscan)
                                if (len(myfield) < maxFieldLength):
                                    myfield += ' '*(maxFieldLength-len(myfield))
                                if (len(myfield) > maxFieldLength):
                                    myfield = myfield[0:maxFieldLength]
                                result = "%4d [%2d=%s, %2d, %s, %2d (%s), %16s, %d] found %4d of %4d (median=%g)" % (i,antennas[i], antennaNames[antennas[i]], spws[i], myhhmmss, myscan, myscanhhmmss0, myfield, polarization, howManyNegatives, possible, medianValue)
                            else:
                                result = "%4d [%2d=%s, %2d, %s, %d), found %3d out of %3d (median=%g)" % (i,
                              antennas[i],antennaNames[antennas[i]],spws[i], myhhmmss, polarization, howManyNegatives, possible, medianValue)
                            print result
                            total += howManyNegatives
    tb.close()
    if (total == 0):
        print "No NaNs found!"
    else:
        print "A total of %d NaN values encountered." % (total)
    if (mymsmd != ''):
        mymsmd.close()
    return(vm)

def listflagscal(caltable='',maxrows=0, verbose=False):
    """
    Examine all rows in a caltable that have flagged data, and report statistics.
    Options:
    verbose: if True, list all row numbers
    maxrows: if maxrows > 0, then stop after examining maxrows
    Todd Hunter
    """
    tb.open(caltable)
    times = tb.getcol('TIME')
    fields = tb.getcol('FIELD_ID')
    antennas = tb.getcol('ANTENNA1')
    totalrows = 0
    totalflags = 0
    totalpoints = 0
    rows = []
    fo = open(caltable.split('/')[-1]+'.listflags','w')
    for i in range(len(times)):
        flags = tb.getcell('FLAG',i)
        for f in flags:
            lf = list(f)
            c = lf.count(1)
            if (c > 0):
                if (verbose):
                    print "Found %d flags in row %d, antenna=%d, field=%d" % (c,i,antennas[i],fields[i])
                totalrows += 1
                rows.append(i)
                fo.write('%d %d\n'%(i,c))
                totalflags += c
            totalpoints += len(lf)
        if (totalrows>=maxrows and maxrows>0): break
    tb.close()
    print "This caltable has %d rows." % (len(times))
    fo.write("This caltable has %d rows.\n" % (len(times)))
    print "Found %d flags (%.4f%%) in %d different rows." % (totalflags, 100*totalflags/(1.0*totalpoints), totalrows)
    fo.write("Found %d flags (%.4f%%) in %d different rows.\n" % (totalflags, 100*totalflags/(1.0*totalpoints), totalrows))
    fo.close()
    
def findChannelRanges(filename='', threshold=0.0, minwidth=1, startchan=0, 
            chanavg=1, nchan=0, absorption=False, extrachan=0, figfile='',
            spw='', outfile='', subcube=False, invertstring=''):
    """
    Takes as input an ascii spectrum output from an image cube at a specific
    location:
       column 0 is the frequency/velocity axis
       column 1 is the flux density axis.
    This function finds all channel ranges wider than 'minwidth' channels
    that are below a 'threshold' flux density.  It can thus be used to
    find a list of channel ranges that are free of *emission* lines. Using
    'startchan' and 'chanavg', it can convert the resulting channel ranges
    back to the parent uv dataset, accounting for any channel averaging that
    was used in CLEAN.  It also reports a list of the inverse channel ranges
    (in this case, minwidth is not applied).  It returns these two lists as
    strings.
    * The 'nchan' argument can be used to tell it how many channels
    were in the original dataset in case a final block of channels was not
    CLEANed. Note that if you are processing multiple subcubes from a single
    spw and will combine the channel lisst, then you probably do not want
    to use this parameter.
    * The 'absorption' argument can be used if you are trying to
    avoid *absorption* lines instead of emission lines.  In this case the
    threshold should be set to just below the typical continuum level, as
    it will simply negate the data and the threshold and process as normal.
    * The 'extrachan' argument will remove additional channels from both sides
    of each offending region.
    * If present, the 'spw' argument will be inserted at the beginning of
    the string followed by a colon.
    * If absorption=True and threshold is a list of two values, the more
    negative one will be interpreted as the absorption threshold and the more
    positive one will be interpreted as the emission threshold.
    * If 'outfile' is present, the printed results will be written to this
    file.
    * If 'subcube' is True, then the linefull region will not propagate to
    channels less than the startchan.  Otherwise it will fill to channel zero.
    * If 'invertstring' is a non-empty string, it will simply invert this
    list of channel ranges and stop.
    Todd Hunter
    """
    if (len(invertstring) > 0):
      myspw = spw
      checkForMultipleSpw = invertstring.split(',')
      mystring = ''
      for c in range(len(checkForMultipleSpw)):
        checkspw = checkForMultipleSpw[c].split(':')
        if (len(checkspw) > 1 and spw==''):
            spw = checkspw[0]
            checkForMultipleSpw[c] = checkspw[1]
        goodstring = checkForMultipleSpw[c]
        goodranges = goodstring.split(';')
        if (str(spw) != ''):
            mystring += str(spw) + ':'
        if (int(goodranges[0].split('~')[0]) > startchan):
            mystring += '%d~%d;' % (startchan,int(goodranges[0].split('~')[0])-1)
        multiWindows = False
        for g in range(len(goodranges)-1):
            r = goodranges[g]
            s = goodranges[g+1]
            mystring += '%d~%d' % (int(r.split('~')[1])+1, int(s.split('~')[0])-1)
            multiWindows = True
            if (g < len(goodranges)-2):
                mystring += ';'
        if (int(goodranges[-1].split('~')[-1]) < startchan+nchan-1):
            if (multiWindows):
                mystring += ';'
            mystring += '%d~%d' % (int(goodranges[-1].split('~')[-1])+1, startchan+nchan-1)
        if (c < len(checkForMultipleSpw)-1):
            mystring += ','
        spw = myspw  # reset to the initial value
      print "inverse = '%s'" % mystring
      return(mystring)
    if (filename == ''):
        print "Usage: findChannelRanges(filename='', threshold=0.0, minwidth=1, startchan=0,"
        print "                         chanavg=1, extrachan=0, figfile='', spw='', outfile='',"
        print "                         subcube=False, invertstring='')"
        return
    if (os.path.exists(filename) == False):
        print "File does not exist = ", filename
        return
    if (chanavg < 1):
        print "chanavg must be 1 (i.e. no averaging) or greater"
        return
    f = open(filename,'r')
    lines = f.readlines()
    velocity = []
    flux = []
    for line in lines:
        if (line.find('#') >= 0):
            continue
        (a,b) = line.split()
        velocity.append(float(a))
        if (absorption):
            flux.append(-float(b))
        else:
            flux.append(float(b))
    f.close()
    pb.clf()
    desc = pb.subplot(111)
    if (type(threshold) == list):
        # reduce a list of one to a single value
        if (len(threshold) < 2):
            threshold = threshold[0]
    thresholdList = threshold
    if (absorption):
        if (type(threshold) == list):
            threshold = -np.min(thresholdList)
            emissionThreshold = -np.max(thresholdList)
            print "Setting emissionThreshold to ", emissionThreshold
        else:
            threshold *= -1
        pb.plot(range(len(velocity)),-np.array(flux),'r-')
    else:
        pb.plot(range(len(velocity)),flux,'r-')
    pb.xlabel('Channel')
    pb.hold(True)
    w0 = -1
    goodranges = []
    for ch in range(len(velocity)):
        if ((flux[ch] < threshold) and
            (type(thresholdList) != list or flux[ch] > emissionThreshold)):
            if (w0 < 0):
                # A good range just started
                w0 = ch
        elif (w0 >= 0):
            # A good range just ended
            w1 = ch-1-extrachan
            w0 += extrachan
            if (w0 < len(velocity) and w1 >= 0):
                if ((w1-w0+1) >= minwidth):
                    goodranges.append([w0,w1])
            w0 = -1
    if (w0 >= 0):
        w1 = len(velocity)-1
        if (len(goodranges) > 0):
            w0 += extrachan
        if ((w1-w0+1) >= minwidth):
            goodranges.append([w0,w1])
    f = open(filename+'.ranges','w')
    mystring = "'"
    if (str(spw) != ''):
        mystring += str(spw) + ':'
    imagechans = 0
    uvchans = 0
    goodranges_in_uv = []
    linefreefluxes = []
    for i in range(len(goodranges)):
        if (i>0):
            mystring += ';'
        c0 = startchan+goodranges[i][0]*chanavg
        c1 = startchan+(goodranges[i][1])*chanavg
        goodranges_in_uv.append([c0,c1])
        linefreefluxes += flux[c0:c1+1]
        imagechans += (goodranges[i][1]+1-goodranges[i][0])
        uvchans += (c1-c0+1)
        mystring += '%d~%d' % (c0,c1)
        if (absorption):
            pb.plot(range(goodranges[i][0],goodranges[i][1]+1),
                    -np.array(flux[goodranges[i][0]:goodranges[i][1]+1]),
                    'k-')
        else:
            pb.plot(range(goodranges[i][0],goodranges[i][1]+1),
                    flux[goodranges[i][0]:goodranges[i][1]+1],
                    'k-')

    if (absorption):
        pb.plot([0,len(velocity)], [-threshold,-threshold],'b--')
        if (type(thresholdList) == list):
            pb.plot([0,len(velocity)], [-emissionThreshold,-emissionThreshold],'g--')
    else:
        pb.plot([0,len(velocity)], [threshold,threshold],'b--')
    goodstring = mystring + "'"
    print "linefree = ", goodstring
    if (outfile != ''):
        try:
            output = open(outfile,'w')
        except:
            print "Could not open output file = ", outfile
            return
        output.write("linefree = %s\n" % goodstring)
    percent = 100.*imagechans/len(velocity)
    print "%d/%d image channels selected (%.2f%%)" % (imagechans,len(velocity),percent)
    if (outfile != ''):
        output.write("%d/%d image channels selected (%.2f%%)\n" % (imagechans,len(velocity),percent))

    # Invert the channels selected
    badranges = []
    mystring = "'"
    if (str(spw) != ''):
        mystring += str(spw) + ':'
    if (1==1):
        if (goodranges_in_uv[0][0] > 0):
            if (subcube==False):
                # This was the original logic
                badranges.append([0,goodranges_in_uv[0][0]-1])
            else:
                # This is the new logic, meant for when you have split up
                # your spw into two chunks.
                if (startchan <= goodranges_in_uv[0][0]-1):
                    badranges.append([startchan,goodranges_in_uv[0][0]-1])
        for i in range(len(goodranges_in_uv)-1):
            badranges.append([goodranges_in_uv[i][1]+1, goodranges_in_uv[i+1][0]-1])
        if (goodranges_in_uv[len(goodranges_in_uv)-1][1] < nchan-1):
            badranges.append([goodranges_in_uv[len(goodranges_in_uv)-1][1]+1, nchan-1])
        # Now build a string of the inverted list
        for i in range(len(badranges)):
            if (i>0):
                mystring += ';'
            c0 = badranges[i][0]
            c1 = badranges[i][1]
            mystring += '%d~%d' % (c0,c1)

    badstring = mystring + "'"
    print "linefull = ", badstring
    if (outfile != ''):
        output.write("linefull = %s\n" % badstring)
    desc.xaxis.grid(True,which='major')
    desc.yaxis.grid(True,which='major')
    pb.draw()
    sigma = np.std(linefreefluxes)
    pb.title('%s:  linefree(%.0f%%)=black (sigma=%g),  linefull=red'%(filename,
                                                                      percent,
                                                                      sigma),
             size=12)
    if (len(figfile) > 0):
        if (figfile.find('.png') < 0):
            figfile += '.png'
        pb.savefig(figfile)
        print "Figured saved to %s" % (figfile)
    return(goodstring[1:-1],badstring[1:-1])

def makeSimulatedImage(phasecenter='J2000 16h25m46.98000s -25d27m38.3300s',
                       sourcecenter='',
                       flux=1.0, freq=100, field='', pointingspacing=2.0,
                       configuration='alma.out10.cfg', bandwidth='1GHz', niter=100,
                       imsize=256, mapsize='', integration='10min',
                       totaltime='200min', cellsize='auto', threshold='10mJy/beam',
                       shape='point', majoraxis=0, minoraxis=0, positionangle=0,
                       refdate='2012/05/21', hourangle='transit', componentList=None,
                       writefits=False
              ):
    """
    Create a simulated ALMA image of a point source or uniform disk at a 
    specified direction and flux density (in Janskys). Here are the parameters:

    phasecenter: required argument, example: 'J2000 06h00m00.00s -04d00m00.0s'
    sourcecenter: if not specified, then assumed to be same as phasecenter
    flux: flux density of point source (in Jy)
    freq: frequency (in GHz)
    field: field name to use for simobserve project directory name
    configuration: anything in /usr/lib64/casapy/data/alma/simmos/
    bandwidth: in GHz
    imsize: in pixels
    mapsize: '' or value in arcsec
    totaltime: e.g. '200min'  for 200 minutes (not '200m')
    integration: e.g. '20s'  for 200 seconds (not '20sec')
    cellsize: floating point value or 'auto' (~4 pix per beam)
    pointingspacing: units of primary beam, default = 2.0 (i.e. no mosaic)
    threshold: for CLEAN
    shape: 'point' or 'disk'
    majoraxis: value in arcsec
    minoraxis: value in arcsec
    positionangle: value in degrees
    refdate:  'YYYY/MM/DD'
    hourangle: 'transit' or '-3h'
    componentList: use the componentList instead of phasecenter, shape & size
    writefits: if True, then run exportfits to create a FITS image
    
    --Todd Hunter
    """
    if (field == ''):
        field = 'makeimage'
        project = field
    else:
        project = field + '.makeimage'
    phasecenter = phasecenter.replace(',',' ')
    sourcecenter = sourcecenter.replace(',',' ')
    if (phasecenter.find(',') > 0):
        print "phasecenter must not have a comma"
        return
    if (sourcecenter.find(',') > 0):
        print "sourcecenter must not have a comma"
        return
    if (phasecenter.find(':') > 0):
        print "phasecenter must be entered in this format: HHhMMmSS.SSs +DDdMMmSS.SSs"
        return
    if (sourcecenter.find(':') > 0):
        print "sourcecenter must be entered in this format: HHhMMmSS.SSs +DDdMMmSS.SSs"
        return
    if (sourcecenter == ''):
        sourcecenter = phasecenter
    if (shape != 'point' and shape != 'disk' and componeontList == None):
        print "The shape argument must be either 'point' or 'disk'."
        return
    if (componentList == None):
        cl.done()
        componentList = '%s.cl' % (field)
        os.system('rm -rf %s' % componentList)
        if (majoraxis != 0 and minoraxis == 0):
            print "Setting minor axis equal to major axis."
            minoraxis = majoraxis
        cl.addcomponent(dir=sourcecenter, flux=flux, fluxunit='Jy',
                    freq='%.1fGHz'%freq, shape=shape,
                    majoraxis='%farcsec' % majoraxis,
                    minoraxis='%farcsec' % minoraxis,
                    positionangle='%fdeg' % positionangle)
        cl.rename(componentList)
        cl.close()
    else:
        cl.open(componentList)
        refdir = cl.getrefdir(0)
        cl.close()
        phasecenter = direction2radecForSimobserve(refdir)
    if (cellsize == 'auto'):
        cellsize = 25.0/freq  #0.25 arcsec at 100GHz * 256 = 64arcsec
    else:
        if (type(cellsize) == str):
            print "Cellsize must be 'auto' or a floating point value"
            return
    graphics = 'none'
    config = configuration
    if (config.find('.cfg')>0):
        config = config[0:-4]
    imagename = '%s/%s.%s' % (project,project,config)
    if (casadef.casa_version <= '3.3.0'):
        halfpower = 0.4  # 12m Airy pattern is too narrow, so go further out
        simobserve(project=project,complist=componentList,
                   antennalist=configuration, totaltime=totaltime,
                   mapsize=[mapsize,mapsize],graphics=graphics,
                   compwidth=bandwidth,overwrite=True,
                   direction=phasecenter, integration=integration,
                   pointingspacing='%.2fPB'%(pointingspacing),
                   setpointings=True, hourangle=hourangle, refdate=refdate)
    else:
        halfpower = 0.5 # 10.7m Airy pattern is now used in CASA for ALMA
        simobserve(project=project,complist=componentList,
                   antennalist=configuration, totaltime=totaltime,
                   mapsize=[mapsize,mapsize],graphics=graphics,
                   obsmode="int", compwidth=bandwidth,overwrite=True,
                   direction=phasecenter, integration=integration,
                   pointingspacing='%.2fPB'%(pointingspacing),
                   setpointings=True, hourangle=hourangle, refdate=refdate)
    vis = '%s.%s.ms'%(project,config)
    if (os.path.exists(project+'/'+vis+'.listobs')):
        os.remove(project+'/'+vis+'.listobs')
    print "Running listobs(vis='%s/%s', listfile='%s/%s.listobs')" % (project,vis,project,vis)
    listobs(vis=project+'/'+vis, listfile=project+'/'+vis+'.listobs')
    print "Running simanalyze(project='%s',vis='%s',imsize=[%d,%d], imdirection='%s', cell='%.2farcsec',niter=%d,overwrite=True,analyze=False,threshold='%s',graphics='%s')" % (project,vis,imsize,imsize,phasecenter,cellsize,niter,threshold,graphics)
    simanalyze(project=project, vis=vis,
               imsize=[imsize,imsize], imdirection=phasecenter,
               cell='%.2farcsec'%(cellsize), niter=niter,overwrite=True,
               analyze=False, threshold=threshold,graphics=graphics)
    if (writefits):
        print "Calling exportfits('%s','%s',overwrite=True)" % (imagename+'.image', imagename+'.image.fits')
        exportfits(imagename+'.image', imagename+'.image.fits',overwrite=True)
        print "Calling exportfits('%s','%s',overwrite=True)" % (imagename+'.psf', imagename+'.psf.fits')
        exportfits(imagename+'.psf', imagename+'.psf.fits',overwrite=True)
        
    imview(raster={'file':'%s.image' % (imagename), 'colorwedge':True},
           out='%s.image.png' % (imagename)
#          , contour={'file':'%s.flux.pbcoverage' % (imagename),
#                    'levels':[halfpower]}
           )
    imview(raster={'file':'%s.psf' % (imagename), 'colorwedge':True},
           out='%s.psf.png' % (imagename)
#           ,contour={'file':'%s.flux.pbcoverage' % (imagename),
#                    'levels':[halfpower]}
           )
    print "Visibility data left in: %s/%s" % (project,vis)
    print "Images left in: %s.image and %s.psf" % (imagename,imagename)
    if exportfits:
        print "FITS Images left in: %s.image.fits and %s.psf.fits" % (imagename,imagename)
    print "Pngs left in: %s.image.png and %s.psf.png" % (imagename,imagename)

def ds9regionToList(region):
    """
    Converts markers in a DS9 region file specified as sexagesimal RA/Dec
    into pairs of RA,Dec in degrees.
    Useful as input to for aplpy's FITSFigure.show_markers().
    -Todd Hunter
    """
    t = open(region)
    lines = t.readlines()
    xcen = []
    ycen = []
    for line in lines:
        token = line.split('(')
        token1 = token[1].split(')')
        [radeg,decdeg] = radec2deg(token1[0])
        xcen.append(radeg)
        ycen.append(decdeg)
    return([xcen,ycen])

def ispec(image, outfile=None, region='', sep=' ', format='%e',
          overwrite=True, blc=None, trc=None, pol=0, 
          showplot=False, source=None):
    """
    Emulates AIPS' ISPEC function to produce an ASCII spectrum from a
    CASA image, using the region tool (rg) and the image tool (ia).
    Operates on a single pixel and a single polarization only.
    source: append this source name to the filename
    region: the region to use (alternative to blc,trc)
    sep: the column separator string to use in the output file
    blc, trc: the pixel range to use as a list (i.e. [40,50])
              If trc is not specified, it is assumed to equal blc.
              Currently, blc must equal trc.
    Returns: two lists:
      frequency in Hz, flux density 
    Todd Hunter
    """
    if (region=='' and blc==None):
        print "You must specify either the region parameter or blc & trc"
        return
    myrg = createCasaTool(rgtool)
    if (blc != None):
        if (len(blc) == 2):
            blc.append(pol)
        else:
            print "blc must be a list of length 2: [x,y]"
            return
    if (trc != None):
        if (len(trc) == 2):
            trc.append(pol)
        else:
            print "type(trc)=%s, len(trc)=%d, trc=%s" % (type(trc),len(trc),str(trc))
            print "trc must be a list of length 2:  [x,y]"
            return
        region = myrg.box(blc=blc,trc=trc)
    elif (region == ''):
        trc = blc
        region = myrg.box(blc=blc,trc=trc)
    if (outfile == None):
        outfile = image + '.%d.%d' % (blc[0],blc[1])
        if (source != None):
            outfile = image + '.' + source
        outfile += '.ispec'
    myia = createCasaTool(iatool)
    myia.open(image)
#    print "Calling toASCII(outfile='%s',region='%s',mask='%s',sep='%s',format='%s',maskvalue=%d,overwrite=%s)" % (outfile,str(region),mask,sep,format,maskvalue,overwrite)
#    This only writes out the Jansky value, not the frequency.
#    myia.toASCII(outfile=outfile, region=region, mask=mask, sep=sep, 
#                 format=format, maskvalue=maskvalue,overwrite=overwrite)
    pixels = myia.getregion(region=region)
    freqHz = []
    npixels = len(pixels[0,0,0])
    for pixel in range(npixels):
        freqHz.append(myia.coordmeasures(pixel=[0,0,0,pixel])['measure']['spectral']['frequency']['m0']['value'])
    myia.close()
    f = open(outfile,'w')
    for i in range(len(freqHz)):
        f.write('%f %f\n' % (freqHz[i], pixels[0,0,0,i]))
    f.close()
    if (showplot):
        pb.clf()
        pb.plot(np.array(freqHz)*1e-9, pixels[0,0,0], 'b-')
        pb.xlabel('Frequency (GHz)')
        pb.draw()
    myrg.done()
    return(np.array(freqHz), pixels[0,0,0])

def findRADec(image, radec='',round=False, getvalue=False, beam=None):
    """
    Takes an image and converts an RA/Dec into a pixel coordinate. It
    is the opposite of findPixel.
    radec: either a sexagesimal string or a tuple in radians
           the RA and Dec can be separated by a space or a comma
           the Dec string can be either colon or period-delimited
           the RA string must be colon-delimited
    round: round the result to the nearest integral pixel
    getvalue: if True, the return the pixel value here (see also au.ispec for cubes)
    beam: if not None, then interpret this as the FWHM beam in arcsec, assume the
          image is in MJy/sr, and compute the Jy for this pixel
    - Todd Hunter
    """
    if (os.path.exists(image) == False):
        print "Could not find image file"
        return
    if (radec == ''):
        print "You must specify a position as a sexagesimal string (or radian tuple) using the radec parameter"
        return
    myia = createCasaTool(iatool)
    myia.open(image)
    if (type(radec) == str):
        radec = radec2rad(radec.replace('&',' '))
    raunits = myia.coordmeasures()['measure']['direction']['m0']['unit']
    decunits = myia.coordmeasures()['measure']['direction']['m1']['unit']
    nrapixels = myia.shape()[0]
    ndecpixels = myia.shape()[1]
    ra = []
    dec = []
    x = range(nrapixels)
    for i in x:
        myra = myia.coordmeasures([i,0,0,0])['measure']['direction']['m0']['value']
        if (raunits.find('deg')>=0):
            myra *= np.pi/180.
        ra.append(myra)
    raDiff = np.array(ra)-radec[0]
    if (np.mean(raDiff) < -2*np.pi+0.1):
        raDiff += 2*np.pi
    if (np.mean(raDiff) > 2*np.pi-0.1):
        raDiff -= 2*np.pi
    xpix = findZeroCrossing(x,raDiff)
    if (len(xpix) < 1):
        print "RA Coordinate is not within the image"
        return
    x = range(ndecpixels)
    for i in x:
        mydec = myia.coordmeasures([0,i,0,0])['measure']['direction']['m1']['value']
        if (decunits.find('deg')>=0):
            mydec *= np.pi/180.
        dec.append(mydec)
    decDiff = np.array(dec)-radec[1]
    if (np.mean(decDiff) < -2*np.pi+0.1):
        decDiff += 2*np.pi
    if (np.mean(decDiff) > 2*np.pi-0.1):
        decDiff -= 2*np.pi
    ypix = findZeroCrossing(x, decDiff)
    if (len(ypix) < 1):
        print "Dec Coordinate is not within the image"
        return
    if (getvalue):
        myrg = createCasaTool(rgtool)
        blc = [int(np.round(xpix[0])), int(np.round(ypix[0]))]
        region = myrg.box(blc=blc, trc=blc)
        pixels = myia.getregion(region=region)
        print "Pixel value = ", pixels[0][0]
        if (beam != None):
            jansky = pixels[0][0]*1e6*np.pi*0.25*(beam/206264.8)**2/np.log(2)
            print "Assuming MJy/sr, the flux density is %f Jy" % (jansky)
        myrg.done()
    myia.close()
    if (round):
        return([int(np.round(xpix[0])),int(np.round(ypix[0]))])
    else:
        return([xpix[0], ypix[0]])


def findPixel(image, pixelfile='', pixel='', referencePosition=None, 
              precision=2, outputfile=None, getvalue=False, beam=None):
    """
    Takes an image and converts a pixel, or list of pixels read from a file into a list
    of RA,Decs, and (optionally) the separation from a reference position in arcseconds.
    Image should be recognizable to casa (FITS or casa native image or cube).
    Expects pixelfile containing lines in any of these formats:
      sourcename1 '243, 347'\n
      sourcename2 "243, 347"\n
      sourcename3 243, 347\n
    Pixels can be integers or floating point values.
    Ignores lines with '#' as the first character, and lines lacking a comma.
    Reference Position should be [RA,Dec] in degrees.
    getvalue: if True, the return the pixel value here (see also au.ispec for cubes)
    beam: if not None, then interpret this as the FWHM beam in arcsec, assume the
          image is in MJy/sr, and compute the Jy for this pixel
    - Todd Hunter
    """
    if (os.path.exists(image) == False):
        print "Could not find image file"
        return
    myia = createCasaTool(iatool)
    myia.open(image)
    if (pixelfile == '' and pixel==''):
        print "You must provide either a pixelfile or a single pixel"
        return
    maxSourceNameLength = 0
    if (pixelfile == ''):
        pixels = pixel.split(',')
        pixels = [[int(pixels[0]), int(pixels[1])]]
        sourceNames = ['']
    else:
        if (os.path.exists(pixelfile) == False):
            print "Could not find pixel file"
            return
        p = open(pixelfile, 'r')
        lines = p.readlines()
        p.close()
        pixels = []
        sourceNames = []
        for line in lines:
            tokens = line.split(',')
            if (len(tokens) < 2): continue
            if (line.find('#') == 0): continue
            sourceNames.append(line.split()[0])
            if (len(sourceNames[-1]) > maxSourceNameLength):
                maxSourceNameLength = len(sourceNames[-1])
            if (line.find("'") >= 0):
                delimiter = "'"
            elif (line.find('"') >= 0):
                delimiter = '"'
            else:
                delimiter = ' '
            x = tokens[0].split(delimiter)[-1]
            y = tokens[1].split(delimiter)[0]
            pixels.append([float(x),float(y)])
#    print "pixels = ", pixels
    NAME = 'NAME' + ' '*(maxSourceNameLength - 4)
    outline = '%s    PIXEL        RA         DEC   ' %  (NAME)
    if (referencePosition != None):
        outline += 'Separation (arcsec)'
    if (pixel == ''):
        if (outputfile == None):
            outputfile = pixelfile+'.radec'
        outfile = open(outputfile, 'w')
        outfile.write(outline+'\n')
    for i in range(len(pixels)):
        x = pixels[i][0]
        y = pixels[i][1]
        ra = myia.coordmeasures([x,y])['measure']['direction']['m0']['value']
        dec = myia.coordmeasures([x,y])['measure']['direction']['m1']['value'] 
        raDeg = ra * 180/np.pi
        decDeg = dec * 180/np.pi
        raString = qa.formxxx('%.12frad' %(ra), format='hms', prec=precision+1)
        decString = qa.formxxx('%.12frad'%(dec),format='dms',prec=precision-1).replace('.',':',2)
        # Pad names with trailing spaces to align the output columns
        sourceNames[i] += ' ' * (maxSourceNameLength - len(sourceNames[i]))
        if (decString[1] == '0'):
            decString = decString[0] + decString[2:] # strip off leading zero in dec
        if (x == int(x) and y == int(y)):
            outline = '%s   %d %d   %s %s' % (sourceNames[i], x, y, raString, decString)
        else:
            outline = '%s   %.3f %.3f   %s %s' % (sourceNames[i], x, y, raString, decString)
        if (referencePosition != None):
            separation = angularSeparation(referencePosition[0], referencePosition[1], raDeg, decDeg)
            outline += '  %f' % (separation*3600)
        print outline
        if (pixel == ''):
            outfile.write(outline+'\n')
    if (pixel == ''):
        outfile.close()
        print "Output file = ", outputfile
    if (getvalue):
        myrg = createCasaTool(rgtool)
        blc = [int(pixel.split(',')[0]), int(pixel.split(',')[1])]
        region = myrg.box(blc=blc, trc=blc)
        pixels = myia.getregion(region=region)
        print "Pixel value = ", pixels[0][0]
        if (beam != None):
            jansky = pixels[0][0]*1e6*np.pi*0.25*(beam/206264.8)**2/np.log(2)
            print "Assuming MJy/sr, the flux density is %f Jy" % (jansky)
        myrg.done()
    myia.close()
        
def antposcorrmm(parameter=[], antenna='', sort=''):
    """
    Converts a list of antenna position corrections into human-readable
    millimeters.
    sort='name': will sort the output by antenna name
    sort='magnitude': will sort the output by the magnitude of the correction
    Todd Hunter
    """
    if (type(parameter) == list):
        if (len(parameter) < 3):
            print "Invalid parameter"
            return
    elif (type(parameter) == str):
        strings = parameter.split(',')
        parameter = map(float, strings)
    else:
        print "Parameter must be a list of floats, or a string list of floats"
        return
    if (type(antenna) == list):
        if (len(antenna) < len(parameter)/3):
            print "Mismatch between number of parameters (%d) and antennas (%d)" % (len(parameter), len(antenna))
            return
    elif (type(antenna) == str):
        if (antenna != ''):
            antstrings = antenna.split(',')
            if (len(antstrings) < len(parameter)/3):
                print "Mismatch between number of parameters (%d) and antennas (%d)" % (len(parameter), len(antstrings))
                return
        elif (sort != ''):
            print "You cannot sort if no antenna list is provided."
            return
    else:
        print "If specified, antenna must be a list of strings, or a string list of strings"
        return
    parameter = 1000*np.array(parameter)  # convert to mm
    totals = []
    if (antenna != ''):
        print "Antenna  X      Y      Z       Total"
    else:
        print "  X      Y      Z       Total"

    if (sort.find('name')>=0 or sort.find('antenna')>=0):
        sortedAntennas = []
        for s in antstrings:
            sortedAntennas.append(s)
        sortedAntennas.sort()
    elif (sort.find('mag')>=0):
        sortedAntennas = []
        sortedTotals = []
        for i in range(len(parameter)/3):
            total = (parameter[i*3]**2+parameter[i*3+1]**2+parameter[i*3+2]**2)**0.5
            sortedTotals.append(total)
        indices = np.argsort(sortedTotals)
        sortedAntennas = list(np.array(antstrings)[indices])
    elif (sort != ''):
        print "Unrecognized sorting scheme: ", sort
        sort = ''
    for j in range(len(parameter)/3):
        if (sort != ''):
            i = antstrings.index(sortedAntennas[j])
        else:
            i = j
        total=(parameter[i*3]**2+parameter[i*3+1]**2+parameter[i*3+2]**2)**0.5
        totals.append(total)
        outline = ''
        if (antenna != ''):
            outline += antstrings[i] + "  " # antstrings[i] + "  "
        outline += "%+.3f %+.3f %+.3f     %.3f mm" % (parameter[i*3],
                       parameter[i*3+1], parameter[i*3+2], total)
        print outline
    print "Abs(min), Abs(max) = %.3f/%.3f mm,  Median = %.3f mm   st.dev = %.3f mm" % (np.min(np.abs(totals)),np.max(np.abs(totals)),np.median(totals),np.std(totals))

def locateSciencePath(pathEnding):
    """
    This method will locate any file in the active analysisUtils
    "science" subdirectory tree. You need to call it with the
    trailing part of the path beyond the ~/AIV/science/ directory.
    e.g. 'PadData/almaAntPos.txt'
    -Todd Hunter
    """
    tokens = __file__.split('/')
    mypath = ''
    for i in range(len(tokens)-len(pathEnding.split('/'))):
        mypath += tokens[i] + '/'
    mypath += pathEnding
    return(mypath)
        
def getMostRecentMove(antenna, history=1, before=None):
    """
    Searches the antennaMoves.txt file for the most recent move(s) of the
    specified antenna name (e.g. 'DV01'), and returns a single string of 
    results.

    antenna: name string ('DV01')
    history: maximum number of moves to return
    before: date to search before 'YYYY-MM-DD' (default = today)
    
    Todd Hunter
    """
    mypath = locateSciencePath('PadData/antennaMoves.txt')
    if (before!=None and before!=''):
        result = os.popen('grep %s %s | tail -%d' % (antenna,mypath,100)).read()[:-1]
        results = result.split('\n')
        (y,m,d) = before.split('-')
        beforedate = datetime.date.today().replace(int(y),int(m),int(d))
        drop = 0
        # determine how many moves happened after the specified 'before' date
        for d in range(len(results)-1,-1,-1):
            datestring = results[d].split()[0]
            date = datestring.split('T')[0]
            (y,m,d) = date.split('-')
            obsdate = datetime.date.today().replace(int(y),int(m),int(d))
            if (obsdate > beforedate):
                drop += 1
        result = ''
        start = len(results)-drop-history
        if (start < 0):
            start = 0
        # reassemble the response
        for d in range(start, len(results)-drop):
            result += results[d] + '\n'
    else:
        result = os.popen('grep %s %s | tail -%d' % (antenna,mypath,history)).read()[:-1]
    return(result)

def mostRecentMoves(vis, history=1, relativeToToday=False):
    """
    Reads the antenna names from an ms and checks the antennaMoves.txt file 
    for the most recent move with respect to today (not the observed date), 
    then sorts for most recent first.  Returns the antenna names in the
    order of the longest time since its previous move coming first.
    
    -Todd Hunter
    """
    names = getAntennaNames(vis)
    me = createCasaTool(metool)
    if (relativeToToday):
        mjdsec = me.epoch('mjd','today')['m0']['value'] * 86400
        now = "today"
    else:
        mjdsec = getObservationStart(vis)
        now = "this observation"
    obsdateString = mjdToUT(mjdsec/86400.)
    Y,M,D = obsdateString.split()[0].split('-')
    obsdate = datetime.date.today().replace(int(Y),int(M),int(D))
    before = obsdateString.split()[0]
    moves = []
    for antenna in names:
        moves.append(getMostRecentMove(antenna,history,before=before))
    m = sorted(moves,reverse=True)
    print "%s = Observation start" % (obsdateString)
    print "YYYY-MM-DD HH:MM Name From To"
    for move in m:
        if (len(move) > 0):
#            print "move = %s." % (move[:-1])
            y,m,d = move.split('T')[0].split('-')
            movedate = datetime.date.today().replace(int(y),int(m),int(d))
            diff = obsdate - movedate
            if (diff.days < 0):
                print "%-31s  %5d days after %s" % (move[:-1],abs(diff.days),now)
            else:
                print "%-31s  %5d days before %s" % (move[:-1],abs(diff.days),now)
    return ([move.split()[1] for move in sorted(moves)])


def checkAntennaPositionFiles(historyLength=6, antenna=''):
    """
    Shows how recently the antenna position files have been updated
    by displaying the most recent entries.    It finds these files
    (antennaMoves.txt and almaAntPos.txt) in the same directory tree
    as your analysisUtils was found.
    Optional: supply an antenna (or pad) name, and the antenna moves output 
              will be restricted to that antenna (or pad).
    -- Todd Hunter
    """
    mypath = locateSciencePath('PadData/antennaMoves.txt')
    print "Recent antenna moves (assumed to be in chronological order):"
    if (antenna == ''):
        os.system('tail -%d %s' % (historyLength,mypath))
    else:
        os.system('grep %s %s | tail -%d' % (antenna,mypath,historyLength))
    mypath = locateSciencePath('PadData/almaAntPos.txt')
    dates = []
    print "Recent baseline tracks (sorted by measTime):"
    for c in commands.getoutput('grep measTime %s' % mypath).split('\n'):
        dates.append(c.split()[1])
    dates.sort()
    for c in dates[-historyLength:]:
        print c

def sensitivity(freq, bandwidth, etime, elevation=None, pwv=None, 
#                telescope=None, diam=None, nant=None, 
                antennalist=None, doimnoise=None, mode='tsys-atm',
                integration=None, debug=None, t_amb=270, airmass=None,
                tau=None, tsys_only=False, t_rx=None, h0=2.0, 
                tau0=None):
    """
    This is a wrapper for simutil.sensitivity, for those who don't know 
    about it.  For ALMA, it also calculates the Tsys.
    -Todd Hunter

    Parameters:
    freq:      value in GHz, or string with units
    bandwidth: value in GHz, or string with units
    time:      string with units of seconds
    elevation: value in degrees, or string with units
    airmass:   airmass (alternative to specifying the elevation)
        (if neither elevation nor airmass is specified, then zenith is used)
    pwv:         value in mm
    antennalist: telescope antenna configuration file
    domimnoise:  default is None
    integration: length of individual integration (string with units)
    debug: T/F
    mode:      'tsys-atm' (default) or 'tsys-manual'
         for tsys-atm, also specify pwv
         for tsys-manual, also specify tau0 & t_sky (as t_atmosphere, e.g. 260K)
    tau:       opacity to use (instead of the atm model result)
    tau0:      zenith opacity to use (instead of the atm model result)
    t_amb:     physical temperature of atmosphere in K
    tsys_only: T/F, T=only compute and return the Tsys, not the sensitivity
    t_rx:      receiver temperature to use (instead of tabulated value)
    h0:        water vapor scale height in km (default=2.0)

    Examples:
    au.sensitivity('660GHz', '3.75GHz', '60s', elevation='80deg', pwv=0.472,
            antennalist = 'alma_cycle1_2.cfg')
    au.sensitivity('22GHz', '1.0GHz', '60s', elevation='80deg', pwv=5,
            antennalist= 'vla.a.cfg')
    """
    # Check casa version
    casaVersionString = casalog.version()
    if (int(casalog.version().split()[2].split('.')[1]) > 3 and tsys_only==False):
        print "This function does not yet work in %s due to the cal table format" % casaVersionString
        print "change, unless tsys_only=True."
        return
    if (tau != None and tau0 != None):
        print "You can only specify one of: tau and tau0 (zenith)"
        return
    if (pwv==None and mode != 'tsys-manual'):
        print "You need to specify a PWV."
        return
    if (antennalist == None):
        print "For antennalist, you need to specify 'alma' or a configuration file, like alma.cycle1.1 or sma.compact"
        return
    if (antennalist.lower() == 'alma' and tsys_only == False):
        print "antennalist='alma' is only supported if tsys_only=True"
        print "Otherwise, give a real configuration file, like alma.cycle1.1"
        return
    if (elevation==None and airmass==None):
        elevation = 90
    if (elevation != None):
        elevation = float(str(elevation).split('deg')[0])
        if (airmass != None):
            print "Ignoring airmass because elevation was specified"
        airmass = 1/np.sin(elevation*np.pi/180.)
    else:
        if (airmass < 1 or airmass==None):
            print "Invalid airmass"
            return
        elevation = 180*math.asin(1/airmass)/np.pi
    print "elevation = %.2f, airmass = %.3f" % (elevation,airmass)
    elevation = '%fdeg' % elevation
    if (antennalist != None):
        if (antennalist.find('.cfg') < 0):
            antennalist += '.cfg'
        if (os.path.exists(antennalist) == False):
            repotable=os.getenv("CASAPATH").split()[0]+"/data/alma/simmos/"
            antennalist = repotable + antennalist
    elif (tsys_only == False):
        print "You need to provide an antennalist parameter, unless tsys_only=True"
        return
    telescope=None
    diam=None
    nant=None
    su = simutil.simutil()
    if (type(freq) == float):
        freq = '%fGHz' % freq
    elif (type(freq) == int):
        freq = '%dGHz' % freq

    if (type(bandwidth) == float):
        bandwidthGHz = bandwidth
        bandwidth = '%fGHz' % bandwidth
    elif (type(bandwidth) == int):
        bandwidthGHz = bandwidth
        bandwidth = '%dGHz' % bandwidth
    else:
        if (bandwidth.find('GHz') >= 0):
            bandwidthGHz = float(bandwidth.split('GHz')[0])
        elif (bandwidth.find('MHz') >= 0):
            bandwidthGHz = float(bandwidth.split('MHz')[0])*1e-3
        elif (bandwidth.find('kHz') >= 0):
            bandwidthGHz = float(bandwidth.split('kHz')[0])*1e-6
        elif (bandwidth.find('Hz') >= 0):
            bandwidthGHz = float(bandwidth.split('Hz')[0])*1e-9
        else:
            bandwidthGHz = float(bandwidth)
    casaVersion = int(casalog.version().split()[4][1:-1])
    if (tsys_only == False):
        if (casaVersion >= 20186):
            jansky = simutil.simutil.sensitivity(su, freq, bandwidth, etime, elevation,
                                             pwv, telescope, diam, nant,
                                             antennalist, doimnoise, integration,
                                             debug, mode, tau0, t_amb)
        else:
            if (tau0 != None or mode != 'tsys-atm'):
                print "The tau0 and mode options only work for casa version >= 20186"
                return
            jansky = simutil.simutil.sensitivity(su, freq, bandwidth, etime, elevation,
                                             pwv, telescope, diam, nant,
                                             antennalist, doimnoise, integration,
                                             debug)

    if (antennalist == None):
        thisIsAlma = False
    else:
        thisIsAlma = (antennalist.lower().split('/')[-1].find('alma') >= 0) \
            or (antennalist.lower().split('/')[-1].find('aca') >= 0)
    # Compute wavelength in microns
    if (freq.find('GHz') >= 0):
        wavelength = 1e4*c/(float(freq.split('GHz')[0])*1e9)
    elif (freq.find('MHz') >= 0):
        wavelength = 1e4*c/(float(freq.split('MHz')[0])*1e6)
    elif (freq.find('kHz') >= 0):
        wavelength = 1e4*c/(float(freq.split('kHz')[0])*1e3)
    elif (freq.find('Hz') >= 0):
        wavelength = 1e4*c/float(freq.split('Hz')[0])
    else:
        wavelength = 1e4*c/(float(freq)*1e9)
        freq = '%sGHz' % (freq)

    frequencyGHz = 1e-5*c/wavelength
    t_rx_casa = None
    if (thisIsAlma and t_rx==None):
        telescope = "ALMA"
        su.telescopename = telescope  # prevents crash of noisetemp()
        (eta_p, eta_s, eta_b, eta_t, eta_q, t_rx) = simutil.simutil.noisetemp(su, telescope, freq, diam)
        print "Frequency: %f GHz    Bandwidth: %.9f GHz" % (frequencyGHz,bandwidthGHz)
        if (wavelength > 0):
            microns = (-wavelength**2*np.log(eta_p)/(16*np.pi**2))**0.5
            print "Antenna Ruze efficiency:          eta_p=%.4f (%.1f um rms)" % (eta_p,microns)
        else:
            print "Antenna Ruze efficiency:          eta_p=%.4f" % (eta_p)
        print "Forward efficiency:               eta_s=%.4f" % (eta_s)
        print "Subreflector blockage efficiency: eta_b=%.4f" % (eta_b)
        print "Illumination efficiency:          eta_t=%.4f" % (eta_t)
        print "Aperture efficiency:              eta_p*s*b*t = eta_a=%.4f" % (eta_p*eta_s*eta_b*eta_t)
        print "Correlator quantum efficiency:    eta_q=%.4f" % (eta_q)
        t_rx_casa = t_rx
        if (frequencyGHz > 600):
            g = 1
            if (frequencyGHz > 750):
                if (t_rx > 300):
                    t_rx *= 0.5
            elif (t_rx > 160):
                t_rx *= 0.5
        else:
            g = 0
        print "Using tabulated receiver temperature: T_rx = %.1fK" % (t_rx)
    else:
        eta_s = 0.95
        if (frequencyGHz > 600):
            g = 1
        else:
            g = 0
        if (t_rx != None):
            print "Using user-specified receiver temperature: T_rx = %.1fK" % (t_rx)
        else:
            print "T_rx is unknown. You must specify either the value or the telescope (via the antennalist parameter)."
            return

    if (thisIsAlma or tsys_only==True):
        elevationDegrees = float(elevation.split('deg')[0])
        airmass = 1.0/math.sin(elevationDegrees*math.pi/180.)
        if (mode != 'tsys-manual'):
            my_tau, my_t_sky, my_t_sky_RJ = estimateALMAOpacity(pwv,frequencyGHz,airmass,h0,verbose=False)
            print "Computed tau=%f, tau0=%f, t_sky=%f (airmass=%f)" % (my_tau, my_tau/airmass, 
                                                                   my_t_sky,airmass)
        if (tau == None and tau0 == None):
            tau = my_tau
            tau0 = my_tau/airmass
        elif (tau == None):
            tau = tau0*airmass
        else:
            tau0 = tau/airmass
        if (mode != 'tsys-manual'):
            t_sky = my_t_sky
            t_sky_RJ = my_t_sky_RJ
        else:
            t_sky = t_amb*(1-np.exp(-tau))
            t_sky_RJ = 0
            
        print "   Using tau=%f" % tau
        print "         tau0=%f" % tau0
        print "         t_amb=%f" % t_amb
        print "         t_sky=%f" % t_sky
        print "             g=%f" % g
        print "         eta_s=%f" % eta_s
        print "          t_rx=%f" % (t_rx)
        tsys = (1+g)*(t_rx + t_sky*eta_s + (1-eta_s)*t_amb) / \
                   (eta_s*np.exp(-tau*airmass))
        if (t_sky_RJ == 0):
            print "Tsys_correct = %.2f K,  Tsky = %.2f K" % (tsys, t_sky)
        else:
            print "Tsys_correct = %.2f K,  Tsky = %.2f K (Rayleigh-Jean = %.2f K)" % (tsys, t_sky, t_sky_RJ)
        if (t_rx_casa != None):
            tsys_casa = (t_rx_casa + t_sky*eta_s + (1-eta_s)*t_amb) / \
                        (eta_s*np.exp(-tau*airmass))
            tsys_casa2 = (t_rx_casa) / \
                         (eta_s*np.exp(-tau*airmass))
            if (casaVersion < 20000):
                print "Tsys_casa3.4 = %.2f K,  Tsky = %.2f K" % (tsys_casa, t_sky)
                print "Ratio (Tsys_correct/Tsys_casa) = %f" % (tsys /tsys_casa)

    if (tsys_only == False):
        if (jansky > 0.1):
            print "Sensitivity = %g Jy" % (jansky)
        elif (jansky > 1e-4):
            print "Sensitivity = %g mJy" % (jansky*1000)
        elif (jansky > 1e-7):
            print "Sensitivity = %g uJy" % (jansky*1000000)
        else:
            print "Sensitivity = %g nJy" % (jansky*1000000000)
        return(jansky)
    else:
        return(tsys)

def plotAtmosphere(frequency=[0,1000],pwv=None,bandwidth=None,telescope='ALMA',
                   temperature=None, altitude=None, latitudeClass=None,
                   pressure=None, humidity=None, numchan=1000, airmass=1.0,
                   elevation=0, figfile='', plotrange=None, 
                   quantity='transmissionPercent', h0=None,
                   drawRectangles=[], drawVerticalBars = [], overlay=False,
                   fontsize=12, showgrid=False, linewidth=[1,1,1],
                   color=['b','b','b'], linestyle=['-','--',':']):
    """
    Simple plotter of atmospheric transmission. The units for input are:
    frequency in GHz (either a single value, or a tuple for the range)
    pwv: in mm
    bandwidth: in GHz (only used if frequency is a single value)
    temperature: in K
    altitude: in m
    latitudeClass: 'tropical', 'midLatitudeWinter'(default), or 'midLatitudeSummer'
    pressure: in mbar
    humidity: in percentage
    elevation: in degrees
    plotrange: for y axis, e.g. [0,100]
    telescope: if not '', then apply nominal values for 'ALMA' or 'EVLA'
    quantity: 'transmission', 'transmissionPercent', 'opacity', or 'tsky'
    h0 (scale height of H2O in km)
    drawRectangles ([[x0,x1],[x2,x3],...])
    drawVerticalBars ([x0,x1,...])
    overlay: if True, the show wet component, dry component and their sum (transmission or opacity only)
    fontsize: of tick labels and axis labels
    showgrid: if True, show dotted lines on major ticks
    linewidth: list of linewidths for each component: [sum, dry, wet]
    colors: list of pylab colors for each component 
    linestyle: list of pylab linestyles for each component
    Note: uses the global physical constants: h and k
    --Todd Hunter
    """
    if (elevation > 0):
        airmass = 1/np.sin(elevation*np.pi/180.)
    else:
        if (airmass < 1):
            print "Invalid airmass"
            return
        elevation = 180*math.asin(1/airmass)/np.pi
    tropical = 1
    midLatitudeSummer = 2
    midLatitudeWinter = 3
    if (latitudeClass == None):
        latitudeClass = tropical
    elif (latitudeClass == 'tropical'):
        latitudeClass = tropical
    elif (latitudeClass == 'midLatitudeWinter'):
        latitudeClass = midLatitudeWinter
    elif (latitudeClass == 'midLatitudeSummer'):
        latitudeClass = midLatitudeSummer
    else:
        print 'Unrecognized latitude class.'
        return
    if (telescope == 'ALMA'):
        if (temperature == None):
            temperature = 270
        if (altitude == None):
            altitude = 5059
        if (pressure == None):
            pressure = 563
        if (humidity == None):
            humidity = 20
        if (pwv == None):
            pwv = 1.0
        if (h0 == None):
            h0 = 2.0
    elif (telescope.find('VLA') >= 0):
        if (temperature == None):
            temperature = 280
        if (altitude == None):
            altitude = 2124
        if (pressure == None):
            pressure = 785.5
        if (humidity == None):
            humidity = 20
        if (pwv == None):
            pwv = 5.0
        if (h0 == None):
            h0 = 2.0
    elif (telescope.find('SMA') >= 0):
        latitudeClass = tropical
        if (temperature == None):
            temperature = 280
        if (altitude == None):
            altitude = 4072
        if (pressure == None):
            pressure = 629.5
        if (humidity == None):
            humidity = 20
        if (pwv == None):
            pwv = 1.0
        if (h0 == None):
            h0 = 2.0
    else:
        if (temperature == None or altitude==None or pressure==None or humidity == None):
            print "If telescope is not specified, then you must specify pwv, temperature,"
            print " altitude, barometric pressure and relative humidity."
            return
        if (h0 == None):
            h0 = 2.0

    if (type(frequency) == list):
        frequencyRange = frequency
    elif (bandwidth>0):
        if (numchan > 1):
            frequencyRange = [frequency-0.5*bandwidth, frequency+0.5*bandwidth]
        else:
            frequencyRange = [frequency]
    else:
        print "Bandwidth must be non-zero if frequency is a single value"
        return
    reffreq = np.mean(frequencyRange)
    chansep = (np.max(frequencyRange)-np.min(frequencyRange))/(1.0*numchan)
    nbands = 1
    if (numchan > 1):
        freqs = np.arange(frequencyRange[0], frequencyRange[1], chansep)
    else:
        freqs = frequencyRange

    myqa = createCasaTool(qatool)
    fCenter = create_casa_quantity(myqa,reffreq,'GHz')
    if (numchan > 1):
        fResolution = create_casa_quantity(myqa,chansep,'GHz')
        fWidth = create_casa_quantity(myqa,numchan*chansep,'GHz')
    else:
        fResolution = create_casa_quantity(myqa,bandwidth,'GHz')
        fWidth = create_casa_quantity(myqa,bandwidth,'GHz')
    at.initAtmProfile(humidity=humidity,temperature=create_casa_quantity(myqa,temperature,"K"),
                          altitude=create_casa_quantity(myqa,altitude,"m"),
                          pressure=create_casa_quantity(myqa,pressure,'mbar'),
                          h0=create_casa_quantity(myqa,h0,"km"),
                          atmType=latitudeClass)
    at.initSpectralWindow(nbands,fCenter,fWidth,fResolution)
    at.setUserWH2O(create_casa_quantity(myqa,pwv,'mm'))
    dry, wet, TebbSky, rf, cs = getAtmDetails(at)
    if (overlay):
        dryOpacity = airmass*dry
        wetOpacity = airmass*wet
        dryTransmission = np.exp(-dryOpacity)
        wetTransmission = np.exp(-wetOpacity)
        if (quantity == 'transmissionPercent'):
            wetTransmission *= 100
            dryTransmission *= 100
    opacity = airmass*(wet+dry)
    transmission = np.exp(-opacity)
    if (quantity == 'transmissionPercent'):
        transmission *= 100
    TebbSky *= (1-np.exp(-airmass*(wet+dry)))/(1-np.exp(-wet-dry))
    pb.clf()
    desc = pb.subplot(111)
    if (type(linewidth) != list):
        linewidth = [linewidth]
    if (type(color) != list):
        color = [color]
    if (quantity == 'opacity'):
        if (numchan > 1):
            pb.plot(freqs, opacity, ls=linestyle[0], lw=linewidth[0], color=color[0])
            if (overlay):
                pb.hold(True)
                pb.plot(freqs, dryOpacity, ls=linestyle[1], lw=linewidth[1], color=color[1])
                pb.plot(freqs, wetOpacity, ls=linestyle[2], lw=linewidth[2], color=color[2])
        else:
            pb.plot(freqs, opacity, 'bo')
        pb.ylabel('Opacity', size=fontsize)
        if (plotrange != None):
            pb.ylim(plotrange) 
    elif (quantity.find('transmission') >= 0):
        if (numchan > 1):
            pb.plot(freqs, transmission, ls=linestyle[0], lw=linewidth[0], color=color[0])
            if (overlay):
                pb.hold(True)
                pb.plot(freqs, dryTransmission, ls=linestyle[1], lw=linewidth[1], color=color[1])
                pb.plot(freqs, wetTransmission, ls=linestyle[2], lw=linewidth[2], color=color[2])
        else:
            pb.plot(freqs, transmission, 'bo')
        pb.ylabel('Transmission', size=fontsize)
        if (plotrange == None):
            if (quantity == 'transmissionPercent'):
                plotrange = [0,105]
            else:
                plotrange = [0,1.05]
        pb.ylim(plotrange)
    elif (quantity == 'tsky'):
        if (numchan > 1):
            pb.plot(freqs, TebbSky)
        else:
            pb.plot(freqs, TebbSky, 'bo')
        pb.ylabel('Sky temperature (K)', size=fontsize)
        if (plotrange != None):
            pb.ylim(plotrange)
    else:
        print "Unrecognized quantity: %s" % (quantity)
        return
    pb.xlabel('Frequency (GHz)', size=fontsize)
    resizeFonts(desc, fontsize)
    if (showgrid):
        desc.xaxis.grid(True,which='major')
        desc.yaxis.grid(True,which='major')
    title = ''
    y0,y1 = pb.ylim()
    gca = pb.gca()
    for bar in drawRectangles:
        gca.add_patch(Rectangle((bar[0],y0), bar[1]-bar[0], y1-y0, facecolor=[0.9,0.9,0.9], edgecolor='k', linewidth=2))
    for bar in drawVerticalBars:
        pb.plot([bar,bar], [y0,y1], 'k--', linewidth=2)
    pb.xlim(frequencyRange)
    if (telescope != ''):
        title += '%s: ' % telescope
    pb.title('%sPWV=%.3fmm, alt.=%.0fm, h0=%.2fkm, elev=%.0fdeg, T=%.0fK, P=%.0fmb, H=%.0f%%' % (title,pwv,altitude,h0,elevation,temperature,pressure,humidity), size=12)
    pb.draw()
    hvkT = h*np.mean(freqs)*1e9/(k*np.mean(TebbSky))
    J = hvkT / (np.exp(hvkT) - 1)
    print "Mean opacity = %.4f, transmission = %.4f, Tsky = %.4f, Tsky_planck=%g" % (np.mean(opacity), np.mean(transmission), np.mean(TebbSky), np.mean(TebbSky) * J)
    print "Min/Max opacity = %.4f / %.4f   Min/Max transmission = %.4f / %.4f" % (np.min(opacity), np.max(opacity), np.min(transmission), np.max(transmission))
    if (figfile != ''):
        pb.savefig(figfile)

def scaleImage(myimage, boxes=[], factors=[]):
    """
    Reads in a CASA single-plane image, and scales one or more rectangular
    regions by a scale factor.
    Example:  au.scaleImage('B9scaled.image',[[147,91,181,123]],[50])
    Todd Hunter
    """
    if (len(boxes) < 1 or len(factors) < 1):
        print "You must specify at least one box and factor"
        return
    for b in range(len(boxes)):
        if (boxes[b] == []):
            continue
        if (len(boxes[b]) < 4):
            print "Box %d must have 4 values (blc_x, blc_y, trc_x, trc_y)"
            return
    if (os.path.exists(myimage) == False):
        print "Image does not exist = ", myimage
        return
    ia.open(myimage)
    i = ia.getregion()
    previousMax = np.max(i)
    for b in range(len(boxes)):
        if (boxes[b] == []):
            print "Scaling whole image"
            box = [0, 0, len(i),len(i[0])]
        else:
            box = boxes[b]
        i[box[0]:box[2], box[1]:box[3]] *= factors[b]
    newMax = np.max(i)
    print "Prior max=%f,  new max=%f" % (previousMax, newMax)
    ia.putregion(i)
    ia.close()

def overlayHolographyCuts(images, plotfile='', plotrange=[0,0,-40,1], interpolate=False,
                          gaussian=None, overlay=6, interactive=True, skipCM=True,
                          subplot=22, asdmdir=None, titleString=None):
    """
    Extract a single row through the peak of a list of images and overlay them.
    Assumes that the frequencies match.
    plotfile: the name of the plotfile to produce.  ".png" will be appended if not present.
    interpolate: passes this parameter to au.extractCutFromImage
    gaussian: the FWHM of a Gaussian profile to overlay
    overlay: for subplot=22, the maximum number of cuts to overlay before incrementing the subpanel
    subplot: either 22 (default) or 11.  22 is meant for overlaying antennas, while 11
             is meant for overlaying different times for a single antenna
    asdmdir: if specified, then extract the ASDM name from the image name and read 
             the observation start date from the ASDM and print it in the figure.
    titleString: used only if subplot=11
    """
    if (type(images)==str):
        imgstring = images
        images = sorted(glob.glob(images))
    else:
        # assume it is a list
        imgstring = None
    pb.clf()
    panel = 1
    if (subplot%100==22):
        adesc = pb.subplot(2,2,panel)
    elif (subplot%100==11):
        adesc = pb.subplot(1,1,panel)
    else:
        print "invalid subplot value"
        return
    colors = ['k','r','b','c','m','g','y']
    col = colors[:overlay]
    page = 0
    ctr = 0
    aca = 0
    png = []
    if (imgstring != None):
        if (subplot==22):
            pb.text(0, 1.09, imgstring, transform=adesc.transAxes)
        uid = imgstring.split('*')[0]
        uids = imgstring.replace('*','_')
        if (plotfile == True):
            plotfile = uids + '.profiles'
        if (os.path.exists('../data/'+uid)):
            uidDate = getObservationStartDateFromASDM('../data/'+uid)[0]
            pb.text(1.4, 1.09, uidDate, transform=adesc.transAxes)
    for i in range(0,len(images)):
        img = images[i]
        antenna = img.split('-')[1]
        if (antenna.find('CM') == 0 and skipCM):
            aca += 1
            continue
        xaxis1, intensity1, row1, column1, freqHz1 = extractCutFromImage(img,stokes='XX',interpolate=interpolate)
        xaxis2, intensity2, row2, column2, freqHz2 = extractCutFromImage(img,stokes='YY',interpolate=interpolate)
        pb.plot(xaxis1, 10*np.log10(intensity1), ls='-', color=col[ctr])
        pb.hold(True)
        pb.plot(xaxis2, 10*np.log10(intensity2), ls='--', color=col[ctr])
        if (panel in [3,4]):
            pb.xlabel('Offset from peak (arcsec)')
        if (panel in [1,3]):
            pb.ylabel('Relative intensity (dB)')
        pb.draw()
        if (plotrange[:2] != [0,0]):
            pb.xlim(plotrange[:2])
        if (plotrange[2:] != [0,0]):
            pb.ylim(plotrange[2:])
        if (subplot==11):
            pb.title(titleString)
            if (asdmdir == None):
                dateString = ''
            else:
                dateString = getObservationStartDateFromASDM(asdmdir+'/'+img.split('_APC')[0])[0]
                if (img.lower().find('usb') >= 0):
#                    print "Calling getMeanFreqFromASDM('%s')" % (asdmdir+'/'+img.split('_APC')[0])
                    dateString += ' %.1fGHz'%(getMeanFreqFromASDM(asdmdir+'/'+img.split('_APC')[0])['usb']['meanfreq']*1e-9)
                else:
                    dateString += ' %.1fGHz'%(getMeanFreqFromASDM(asdmdir+'/'+img.split('_APC')[0])['lsb']['meanfreq']*1e-9)
            pb.text(0.02, 0.02+ctr*0.03, img + ' ' + dateString, transform=adesc.transAxes,
                    size=8, color=col[ctr])
        else:
            pb.text(ctr*0.18, 1.02, antenna, color=col[ctr], transform=adesc.transAxes)
        ctr += 1
        if ((i+1-aca) % overlay == 0):
            panel += 1
            if (panel <= 4):
                adesc = pb.subplot(2,2,panel)
                ctr = 0
            else:
                if (interactive):
                    myinput = raw_input("Press return to continue or 'q' to quit")
                    if (myinput.find('q') >= 0):
                        return
                if (plotfile != ''):
                    panel = 1
                    pb.subplot(2,2,panel)
                    png.append('%s.page%d.png' % (plotfile,page))
                    pb.savefig(png[-1])
                    page += 1
                    pb.clf()
    if (panel > 1 or ctr > 0):
        if (plotfile != ''):
            if (page == 0):
                if (plotfile.find('.png') < 0):
                    plotfile += '.png'
                png.append('%s' % (plotfile))
            else:
                png.append('%s.page%d.png' % (plotfile,page))
            pb.savefig(png[-1])
            print "Wrote pngs: ", png
        
def overlayCuts(img1, img2, img3=None, row1=None, row2=None, row3=None,
                column1=None, column2=None, column3=None,
                stokes1='XX', plotfile='', plotrange=[0,0,0,0],
                frequency1=None, frequency2=None, frequency3=None,
                panels=1, interpolate=False,
                gaussian=None, scaleByFrequency=True, plotrange2=[0,0,0,0],
                scaleToArcsec=False, diameter=None, truncate=True,
                obscuration=0.75, convolve=None, showspec2=False):
    """
    Extract a single row or column from two (or 3) CASA images and overlays them.
    If an image has multiple Stokes planes, then it must be the first image.
    img, row, column: these parameters are passed to au.extractCutFromImage
    scaleByFrequency: if True, then the xaxis of the first image (and 3rd) will be
           scaled to match the second by their frequency ratio.
    frequency1: the frequency of the first image (if not in header)
    frequency2: the frequency of the second image (if not in header)
    frequency3: the frequency of the third image (if not in header)
    panels: 1, 2, 3, or 4: 2 will also overlay in dB units,
            3: will overlay 45deg cut in dB
            4: will also show residuals w.r.t. img2
            5: will also show residuals of 45deg cut
    gaussian: the FWHM of a Gaussian profile to overlay
    scaleToArcsec: pass to extractCutFromImage
    diameter: the antenna diameter to use for the Airy profile to overlay
    truncate: if True, truncate the Airy profile at the first null
    obscuration: the central obstruction diameter for computing Airy (default = 0.75m)
    convolve: if specified, convolve the Gaussian and Airy by a Gaussian of this width in arcsec
    -Todd Hunter
    """
    if (os.path.exists(img1) == False):
        ticraDir = os.path.dirname(__file__) + '/TicraImages/'
        if (os.path.exists(ticraDir+img1) == False):
            ticraDir = os.getenv("CASAPATH").split()[0]+"/data/alma/responses/"
            if (not os.path.exists(ticraDir+img1)):
                print "First image = %s does not exist" % (img1)
                return
        img1 = ticraDir + img1
    if (os.path.exists(img2) == False):
        holoDir = '/lustre/naasc/thunter/alma/SD/holography/'
        if (os.path.exists(holoDir+img2) == False):
            print "Second image = %s does not exist" % (img2)
            return
        img2 = holoDir + img2
    if (img3 != None):
        if (os.path.exists(img3) == False):
            print "Third image = %s does not exist" % (img2)
            return
        img3 = img3.rstrip('/')
    img1 = img1.rstrip('/')
    img2 = img2.rstrip('/')
    if (stokes1 == 'both'):
        xaxis1, intensity1, row1, column1, freqHz1 = extractCutFromImage(img1,row=row1,column=column1,stokes='XX',interpolate=interpolate, scaleToArcsec=scaleToArcsec)
        xaxis1yy, intensity1yy, row1, column1, freqHz1 = extractCutFromImage(img1,row=row1,column=column1,stokes='YY',interpolate=interpolate, scaleToArcsec=scaleToArcsec)
    else:
        xaxis1, intensity1, row1, column1, freqHz1 = extractCutFromImage(img1,row=row1,column=column1,stokes=stokes1,interpolate=interpolate, scaleToArcsec=scaleToArcsec)

    xaxis2, intensity2, row2, column2, freqHz2 = extractCutFromImage(img2,row=row2,column=column2,interpolate=interpolate, scaleToArcsec=scaleToArcsec)

    if (img3 != None):
        xaxis3, intensity3, row3, column3, freqHz3 = extractCutFromImage(img3,row=row3,column=column3,interpolate=interpolate, scaleToArcsec=scaleToArcsec)
        
    if (scaleByFrequency):
        if (freqHz1 <= 0):
            if (frequency1 == None):
                print "You need to specify the frequency of img1 with the frequency1 parameter, or set scaleByFrequency=False."
                return
            freqHz1 = parseFrequencyArgument(frequency1)
            if (freqHz1 < 2000): freqHz1 *= 1e9  # convert from floating point GHz to Hz
        if (freqHz2 <= 0):
            if (frequency2 == None):
                print "You need to specify the frequency of img2 with the frequency2 parameter, or set scaleByFrequency=False."
                return
            freqHz2 = parseFrequencyArgument(frequency2)
            if (freqHz2 < 2000): freqHz2 *= 1e9  # convert from floating point GHz to Hz
        frequencyRatio = freqHz1 / freqHz2
        xaxis1 *= frequencyRatio
        if (img3 != None):
            if (freqHz3 <= 0):
                if (frequency3 == None):
                    print "You need to specify the frequency of img3 with the frequency3 parameter, or set scaleByFrequency=False."
                    return
                freqHz3 = parseFrequencyArgument(frequency3)
                if (freqHz3 < 2000): freqHz3 *= 1e9  # convert from floating point GHz to Hz
            frequencyRatio3 = freqHz3 / freqHz2
            xaxis3 *= frequencyRatio3
            
#    print "freq 1 = %f, freq 2 = %f" % (freqHz1, freqHz2)
    pb.clf()
    if (panels > 4):
        if (casadef.casa_version < '4.2.0'):
            print "pylab.subplot2grid is not available in this old version of casa."
            return
        rows = 3
        columns = 2
        pb.gcf().set_size_inches([6.5,8])
    elif (panels > 3):
        rows = 2
        columns = 2
        pb.gcf().set_size_inches([7,7])
    else:
        rows = 1
        columns = panels
    if (panels > 4):
        adesc = pb.subplot2grid((rows,columns),(0,0),colspan=2)
    else:
        adesc = pb.subplot(rows,columns,1)
    pb.plot(xaxis1, intensity1, 'k-', xaxis2, intensity2, 'r-')
    if (img3 != None):
        pb.hold(True)
        pb.plot(xaxis3, intensity3, 'r--')
    y0,y1 = pb.ylim()
    pb.ylim([y0,y1*1.1])
    if (plotrange[0] == 0 and plotrange[1] != 0):
        xlabelpol = 0.05 # 0.45
        ylabelpol = 0.3 # 1
    elif (plotrange[0] != 0 and plotrange[1] != 0):
        xlabelpol = 0.40
        ylabelpol = 0.40
    else:
        xlabelpol = 0.05
        ylabelpol = 1
    if (stokes1 == 'both'):
        pb.hold(True)
        if (scaleByFrequency):
            xaxis1yy *= frequencyRatio
        pb.plot(xaxis1yy, intensity1yy, 'k--')
        pb.text(xlabelpol,ylabelpol-0.04*(rows+2),"XX: solid",transform=adesc.transAxes, size=9)
        pb.text(xlabelpol,ylabelpol-0.04*(rows+4),"YY: dashed",transform=adesc.transAxes, size=9)
    if (convolve != None):
        convolvingGaussian = griddedBeam().gauss(xaxis1, convolve)
    if (gaussian != None):
        pb.hold(True)
        gauss = griddedBeam().gauss(xaxis1,gaussian)
        if (convolve != None):
            gauss = spsig.convolve(gauss**0.5, convolvingGaussian, mode='same')
            gauss *= gauss
            gauss /= np.max(gauss)
        pb.plot(xaxis1, gauss,'g-')
    if (panels > 3):
        axisLabelSize = 9
    else:
        axisLabelSize = 11
    if (diameter != None):
        pb.hold(True)
        if (frequency2 == None):
            print "In order to use the diameter parameter, you must set frequency2"
            return
        airyfwhm = primaryBeamArcsec(frequency=frequency2, diameter=diameter, 
                                     taper=0, showEquation=False)
        airyX, airyProfile = griddedBeam().buildAiryDisk(airyfwhm, np.max(xaxis1/airyfwhm),
                                                         convolutionPixelSize=airyfwhm/50.,
                                                         truncate=truncate, obscuration=obscuration)
        if (convolve != None):
            airyProfile = spsig.convolve(airyProfile**0.5, convolvingGaussian, mode='same')
            airyProfile *= airyProfile
            airyProfile /= np.max(airyProfile)
        # look out for ancient pyfits versions in your path!
        pb.plot(airyX, airyProfile, 'b-')
    pb.ylabel('Relative intensity of horiz. cut',size=axisLabelSize)
    if (plotrange[:2] != [0,0]):
        pb.xlim(plotrange[:2])
    else:
        # restrict the x-axis to the overlap region of the two profiles
        pb.xlim([np.max([np.min(xaxis1),np.min(xaxis2)]), np.min([np.max(xaxis1), np.max(xaxis2)])])
    if (plotrange[2:] != [0,0]):
        pb.ylim(plotrange[2:])
    if (panels > 2):
        rowcolumn = ''
        rowcolumn2 = ''
    else:
        rowcolumn = " row=%s, column=%s" % (str(row1),str(column1))
        rowcolumn2 = " row=%s, column=%s" % (str(row1),str(column1))
    if (panels > 3):
        pb.text(-0.2,1.02,os.path.basename(img1)+" (%.1fGHz) %s"%(freqHz1*1e-9,rowcolumn), transform=adesc.transAxes, color='k',size=12-panels,ha='left')
        if (img1 != img2):
            pb.text(0, -0.15, os.path.basename(img2)+" (%.1fGHz) %s"%(freqHz2*1e-9,rowcolumn2), transform=adesc.transAxes, color='r',size=13-panels)
    else:
        pb.text(0, 1+0.015*rows, os.path.basename(img1)+" (%.1fGHz) %s"%(freqHz1*1e-9,rowcolumn), transform=adesc.transAxes, color='k',size=9)
        pb.text(0, 1.04+(panels-2)*0.05, os.path.basename(img2)+" (%.1fGHz) %s"%(freqHz2*1e-9,rowcolumn2), transform=adesc.transAxes, color='r',size=9)
        
    if (scaleByFrequency):
        if (frequencyRatio != 1.0):
            if (panels > 4):
                pb.text(0.75, 0.99-0.04*rows, "X-axis scaled by %.4f" % (frequencyRatio), transform=adesc.transAxes, color='k',size=10, ha='center')
            else:
                pb.text(0.50, 1-0.04*rows, "X-axis scaled by %.4f" % (frequencyRatio), transform=adesc.transAxes, color='k',size=10, ha='center')
    if (panels < 4):
        pb.xlabel('Offset from peak (arcsec)',size=axisLabelSize)
    pb.setp(plt.gca().get_xmajorticklabels(), size=8)
    pb.setp(plt.gca().get_ymajorticklabels(), size=8)
    if (panels > 3):
        adesc = pb.subplot(rows, columns, 1+columns+panels/5)
        xaxisResampled,int1,int2 = alignFunctions(xaxis1, intensity1, xaxis2, intensity2)
        pb.plot(xaxisResampled, 100*(int1-int2)/int2, 'k')
        pb.ylabel('Residuals of horizontal cut (%)',size=axisLabelSize)
        pb.xlabel('Offset from peak (arcsec)',size=axisLabelSize)
        if (plotrange[:2] != [0,0]):
            pb.xlim(plotrange[:2])
        pb.ylim([-27,27])
        if (diameter != None):
            xaxisResampled,int1,int2 = alignFunctions(airyX, airyProfile, xaxis2, intensity2)
            pb.plot(xaxisResampled, 100*(int1-int2)/int2, 'b')
        if (gaussian != None):
            xaxisResampled,int1,int2 = alignFunctions(xaxis1, gauss, xaxis2, intensity2)
            pb.plot(xaxisResampled, 100*(int1-int2)/int2,'g-')
        if (stokes1 == 'both'):
            xaxisResampled,int1,int2 = alignFunctions(xaxis1, intensity1yy, xaxis2, intensity2)
            pb.plot(xaxisResampled, 100*(int1-int2)/int2, 'k--')
            
        pb.setp(plt.gca().get_xmajorticklabels(), size=8)
        pb.setp(plt.gca().get_ymajorticklabels(), size=8)
        adesc.yaxis.set_minor_locator(MultipleLocator(2))
        sixPercentLevel = 0.5*findFWHM(xaxis2,intensity2,level=0.06)
        spec = 6
        spec2 = 10
        pb.plot([sixPercentLevel,sixPercentLevel],[-spec,spec],'k:')
        if (pb.xlim()[0] == 0):
            x0 = 0
        else:
            x0 = -sixPercentLevel
            pb.plot([-sixPercentLevel,-sixPercentLevel],[-spec,spec],'k:')
            if (showspec2):
                pb.plot([-sixPercentLevel,-sixPercentLevel],[-spec2,-spec],'k--')
                pb.plot([-sixPercentLevel,-sixPercentLevel],[spec2,spec],'k--')
                pb.plot([sixPercentLevel,sixPercentLevel],[-spec2,-spec],'k--')
                pb.plot([sixPercentLevel,sixPercentLevel],[spec2,spec],'k--')
        pb.plot([x0,sixPercentLevel],[-spec,-spec],'k:')
        pb.plot([x0,sixPercentLevel],[spec,spec],'k:')
        if (showspec2):
            pb.plot([x0,sixPercentLevel],[-spec2,-spec2],'k--')
            pb.plot([x0,sixPercentLevel],[spec2,spec2],'k--')
        pb.plot(pb.xlim(),[0,0],'r-')
        if (img1 == img2):
            rowAdjust = 0.5
        else:
            rowAdjust = 0
        pb.text(xlabelpol,ylabelpol-0.10*(rows-rowAdjust),"XX: solid",transform=adesc.transAxes, size=8)
        pb.text(xlabelpol,ylabelpol-0.10*(rows+1-rowAdjust),"YY: dashed",transform=adesc.transAxes, size=8)
    if (panels > 1):
        if (panels > 3):
            if (img1 == img2):
                pb.subplots_adjust(wspace=0.3,hspace=0.1,top=0.65)
            else:
                pb.subplots_adjust(wspace=0.3,hspace=0.2,top=0.75)
        else:
            pb.subplots_adjust(wspace=0.3+(panels-2)*0.05)
        adesc = pb.subplot(rows,columns,2+panels/5)
        if (panels != 4):
            pb.xlabel('Offset from peak (arcsec)',size=axisLabelSize)
        pb.plot(xaxis1, 10*np.log10(intensity1), 'k-', xaxis2, 10*np.log10(intensity2), 'r-')
        if (img3 != None):
            pb.hold(True)
            pb.plot(xaxis3, 10*np.log10(intensity3), 'r--')
        if (stokes1 == 'both'):
            pb.hold(True)
            pb.plot(xaxis1yy, 10*np.log10(intensity1yy), 'k--')
            pb.text(xlabelpol,ylabelpol-0.10*(rows-1),"XX: solid",transform=adesc.transAxes, size=8)
            pb.text(xlabelpol,ylabelpol-0.10*(rows),"YY: dashed",transform=adesc.transAxes, size=8)
#            pb.text(xlabelpol,1-0.03*(rows+4),"XX: solid",transform=adesc.transAxes, size=9)
#            pb.text(xlabelpol,1-0.03*(rows+6),"YY: dashed",transform=adesc.transAxes, size=9)
        if (gaussian != None):
            pb.hold(True)
            pb.plot(xaxis1, 10*np.log10(gauss),'g-')
            pb.text(0.5,0.97-0.03*(rows-1-panels/5),'GaussianFWHM: 1.131*L/D=%.2f"' % (gaussian),ha='center',
                    color='g', transform=adesc.transAxes, size=7)
        if (diameter != None):
            pb.hold(True)
            # look out for ancient pyfits versions in your path!
            pb.plot(airyX, 10*np.log10(airyProfile), 'b-')
            pb.text(0.5,0.98-0.05*(rows-panels/5),'AiryFWHM: 1.023*L/%.1fm=%.2f"' % (diameter,airyfwhm),
                    color='b', transform=adesc.transAxes, size=7,ha='center')
        pb.ylabel('Rel. intensity of horiz. cut (dB)',size=axisLabelSize)
        if (plotrange2[:2] != [0,0]):
            pb.xlim(plotrange2[:2])
        elif (plotrange[:2] != [0,0]):
            pb.xlim(plotrange[:2])
        else:
            # restrict the x-axis to the overlap region of the two profiles
            pb.xlim([np.max([np.min(xaxis1),np.min(xaxis2)]), np.min([np.max(xaxis1), np.max(xaxis2)])])
        if (plotrange2[2:] != [0,0]):
            pb.ylim(plotrange2[2:])
        else:
            pb.ylim([-50,2.0])
        pb.setp(plt.gca().get_xmajorticklabels(), size=8)
        pb.setp(plt.gca().get_ymajorticklabels(), size=8)
        if (panels > 2):
            if (stokes1 == 'both'):
                if (row1 == None):
                    xaxis1diagonal, intensity1diagonal, row1diagonal, column1diagonal, freqHz1 = \
                        extractCutFromImage(img1,row=row1,column=-column1,stokes='XX',interpolate=interpolate, scaleToArcsec=scaleToArcsec)
                    xaxis1yydiagonal, intensity1yydiagonal, row1diagonal, column1diagonal, freqHz1 = \
                                  extractCutFromImage(img1,row=row1,column=-column1,stokes='YY',interpolate=interpolate, scaleToArcsec=scaleToArcsec)
                else:
                    xaxis1diagonal, intensity1diagonal, row1diagonal, column1diagonal, freqHz1 = \
                        extractCutFromImage(img1,row=-row1,column=column1,stokes='XX',interpolate=interpolate, scaleToArcsec=scaleToArcsec)
                    xaxis1yydiagonal, intensity1yydiagonal, row1diagonal, column1diagonal, freqHz1 = \
                                  extractCutFromImage(img1,row=-row1,column=column1,stokes='YY',interpolate=interpolate, scaleToArcsec=scaleToArcsec)
                if (scaleByFrequency):
                    xaxis1yydiagonal *= frequencyRatio
            else:
                print "Calling extractCutFromImage('%s',row=%d,column=%s,stokes='%s',interpolate=%s,scaleToArcsec=%s)" % (img1,-row1,column1,stokes1,interpolate,scaleToArcsec)
                if (row1 == None):
                    xaxis1diagonal, intensity1diagonal, row1diagonal, column1diagonal, freqHz1 = \
                        extractCutFromImage(img1,row=row1,column=-column1,stokes=stokes1,interpolate=interpolate, scaleToArcsec=scaleToArcsec)
                else:
                    xaxis1diagonal, intensity1diagonal, row1diagonal, column1diagonal, freqHz1 = \
                        extractCutFromImage(img1,row=-row1,column=column1,stokes=stokes1,interpolate=interpolate, scaleToArcsec=scaleToArcsec)

            if (row2 == None):
                xaxis2diagonal, intensity2diagonal, row2diagonal, column2diagonal, freqHz2 = \
                    extractCutFromImage(img2,row=row2,column=-column2,interpolate=interpolate, scaleToArcsec=scaleToArcsec)
            else:
                xaxis2diagonal, intensity2diagonal, row2diagonal, column2diagonal, freqHz2 = \
                    extractCutFromImage(img2,row=-row2,column=column2,interpolate=interpolate, scaleToArcsec=scaleToArcsec)
            if (scaleByFrequency):
                xaxis1diagonal *= frequencyRatio

            if (img3 != None):
                if (row3 == None):
                    xaxis3diagonal, intensity3diagonal, row3diagonal, column3diagonal, freqHz3 = \
                        extractCutFromImage(img3,row=row3,column=-column3,interpolate=interpolate, scaleToArcsec=scaleToArcsec)
                else:
                    xaxis3diagonal, intensity3diagonal, row3diagonal, column3diagonal, freqHz3 = \
                        extractCutFromImage(img3,row=-row3,column=column3,interpolate=interpolate, scaleToArcsec=scaleToArcsec)

                if (scaleByFrequency):
                    xaxis3diagonal *= frequencyRatio

            adesc = pb.subplot(rows,columns,panels)
            pb.xlabel('Offset from peak (arcsec)',size=axisLabelSize)
            pb.plot(xaxis1diagonal, 10*np.log10(intensity1diagonal), 'k-', xaxis2diagonal, 10*np.log10(intensity2diagonal), 'r-')
            if (img3 != None):
                pb.hold(True)
                pb.plot(xaxis3diagonal, 10*np.log10(intensity3diagonal), 'r--')
            if (stokes1 == 'both'):
                pb.hold(True)
                pb.plot(xaxis1yydiagonal, 10*np.log10(intensity1yydiagonal), 'k--')
                pb.text(xlabelpol,ylabelpol-0.10*(rows-1),"XX: solid",transform=adesc.transAxes, size=8)
                pb.text(xlabelpol,ylabelpol-0.10*(rows),"YY: dashed",transform=adesc.transAxes, size=8)
            if (gaussian != None):
                pb.hold(True)
                pb.plot(xaxis1, 10*np.log10(gauss),'g-')
            if (diameter != None):
                pb.hold(True)
                # look out for ancient pyfits versions in your path!
                pb.plot(airyX, 10*np.log10(airyProfile), 'b-')
            pb.ylabel('Rel. intensity of diag. cut (dB)',size=axisLabelSize)
            if (plotrange2[:2] != [0,0]):
                pb.xlim(plotrange2[:2])
            elif (plotrange[:2] != [0,0]):
                pb.xlim(plotrange[:2])
            else:
                # restrict the x-axis to the overlap region of the two profiles
                pb.xlim([np.max([np.min(xaxis1),np.min(xaxis2)]), np.min([np.max(xaxis1), np.max(xaxis2)])])
            if (plotrange2[2:] != [0,0]):
                pb.ylim(plotrange2[2:])
            else:
                pb.ylim([-50,2.0])
            pb.setp(plt.gca().get_xmajorticklabels(), size=8)
            pb.setp(plt.gca().get_ymajorticklabels(), size=8)
            if (panels > 4):
                adesc = pb.subplot(rows,columns,6)
                xaxisResampled,int1,int2 = alignFunctions(xaxis1diagonal, intensity1diagonal, xaxis2diagonal, intensity2diagonal)
                pb.plot(xaxisResampled, 100*(int1-int2)/int2, 'k')
                pb.ylabel('Residuals of diagonal cut (%)',size=axisLabelSize)
                pb.xlabel('Offset from peak (arcsec)',size=axisLabelSize)
                if (plotrange[:2] != [0,0]):
                    pb.xlim(plotrange[:2])
                pb.ylim([-27,27])
                if (diameter != None):
                    xaxisResampled,int1,int2 = alignFunctions(airyX, airyProfile, xaxis2diagonal, intensity2diagonal)
                    pb.plot(xaxisResampled, 100*(int1-int2)/int2, 'b')
                if (gaussian != None):
                    xaxisResampled,int1,int2 = alignFunctions(xaxis1, gauss, xaxis2diagonal, intensity2diagonal)
                    pb.plot(xaxisResampled, 100*(int1-int2)/int2,'g-')
                pb.setp(plt.gca().get_xmajorticklabels(), size=8)
                pb.setp(plt.gca().get_ymajorticklabels(), size=8)
                adesc.yaxis.set_minor_locator(MultipleLocator(2))
                sixPercentLevel = 0.5*findFWHM(xaxis2diagonal,intensity2diagonal,level=0.06)
                pb.plot([sixPercentLevel,sixPercentLevel],[-spec,spec],'k:')
                if (pb.xlim()[0] == 0):
                    x0 = 0
                else:
                    x0 = -sixPercentLevel
                    pb.plot([-sixPercentLevel,-sixPercentLevel],[-spec,spec],'k:')
                    pb.plot([-sixPercentLevel,-sixPercentLevel],[-spec2,-spec],'k--')
                    pb.plot([-sixPercentLevel,-sixPercentLevel],[spec2,spec],'k--')
                    pb.plot([sixPercentLevel,sixPercentLevel],[-spec2,-spec],'k--')
                    pb.plot([sixPercentLevel,sixPercentLevel],[spec2,spec],'k--')
                pb.plot([x0,sixPercentLevel],[-spec,-spec],'k:')
                pb.plot([x0,sixPercentLevel],[spec,spec],'k:')
                pb.plot([x0,sixPercentLevel],[-spec2,-spec2],'k--')
                pb.plot([x0,sixPercentLevel],[spec2,spec2],'k--')
                pb.plot(pb.xlim(),[0,0],'r-')
            # endif (panels > 4):
        # endif (panels > 2):
    # endif (panels > 1)
    pb.draw()
    if (plotfile != ''):
        if (plotfile == True):
            if (row1 != None):
                cut1 = 'row%d' % (row1)
            else:
                cut1 = 'col%d' % (column1)
            if (row2 != None):
                cut2 = 'row%d' % (row2)
            else:
                cut2 = 'col%d' % (column2)
            png = '%s_%s_%s_%s.png' % (img1,cut1,img2,cut2)
        else:
            png = plotfile
        eps = plotfile.replace('.png','.eps')
        if (panels == 5):
            if (png.find('5.png') < 0): 
                png = png.replace('.png', '5.png')
            if (eps.find('5.eps') < 0): 
                eps = eps.replace('.eps', '5.eps')
        pb.savefig(png)
        pb.savefig(eps,bbox_inches='tight')
        print "Plot saved to %s and %s" % (png,eps)
    # end of overlayCuts()
    
def extractCutsFromImage(myimage,row=None, stokes='XX', channel=0,
                         shiftPeakToCenter=True, scaleToArcsec=True):
    """
    Extract 5 rows of an image and overlay them.
    """
    pb.clf()
    xaxis, intensity, row, column, freqHz = extractCutFromImage(myimage, scaleToArcsec=scaleToArcsec,
                                                                shiftPeakToCenter=shiftPeakToCenter)
    pb.plot(xaxis,intensity,'ro')
    pb.hold(True)
    rows = [row-2, row-1, row+1, row+2]
    for r in rows:
        xaxis, intensity, myrow, column, freqHz = extractCutFromImage(myimage,row=r)
        pb.plot(xaxis,intensity,'k-')
    pb.show()

def extractCutFromImage(myimage, row=None, column=None, stokes='XX', channel=0,
                        gaussfit=False, verbose=False, showplot=False,
                        interpolate=False, plotrange=[0,0,0,0],
                        scaleToArcsec=True, shiftPeakToCenter=True,
                        truncate=False, peakimage=None, normalize=True):
    """
    Extract a single row or column from a CASA image
    row: row to extract, default = center, if negative, then take 45deg cut from (0,0)-(n,n)
          row='auto' means to take the row through the peak
    column: column to extract, default = center, if negative, then take 45deg cut from (0,n)-(n,0)
          column='auto' means to take the column through the peak
      if row=None and column=None, then row is set to 'auto'
         
    gaussfit: if True, perform a Gaussian fit centered on the maximum pixel,
              with its amplitude normalized to one.
    showplot: show the resulting Gaussian fit in a graphics window
    verbose: pass this to griddedBeam().gaussfit
    truncate: pass this to griddedBeam().gaussfit
    interpolate: if True, return the spline interpolated model rather than the raw data
    peakimage: if specified, use the position of the peak from this image instead of myimage
    normalize: if True, divide the intensity by the maximum intensity
    Returns:
       the xaxis along the cut (in arcsec), the intensity data of the cut, the row,
       the column, and the frequency (in Hz)
    - Todd Hunter
    """
    stokesPixel = ['XX','XY','YX','YY'].index(stokes)
    if (os.path.exists(myimage) == False):
        print "Image does not exist = ", myimage
        return
    myia = createCasaTool(iatool)
    if (peakimage != None):
        imageForPeak = peakimage
    else:
        imageForPeak = myimage
    print "Finding peak in %s" % (imageForPeak)
    myia.open(imageForPeak)
    imgPeak = myia.getregion()
    if ((row == None and column == None) or row == 'auto'):
        if (len(np.shape(imgPeak)) < 3):
            results = imstat(imageForPeak)['maxpos']
        else:
            results = imstat(imageForPeak,stokes=stokes,chans=str(channel))
            # imstat will bomb if you don't have write permission in the directory
            results = results['maxpos']
        if (verbose): print "Peak is at ", results
        row = results[0]
        if (verbose): print "Using row=%d" % (row)
    elif (column == 'auto'):
        if (len(np.shape(imgPeak)) < 3):
            results = imstat(imageForPeak)['maxpos']
        else:
            results = imstat(imageForPeak,stokes=stokes,chans=str(channel))['maxpos']
        if (verbose): print "Peak is at ", results
        column = results[1]
        if (verbose): print "Using column=%d" % (column)
    myia.close()
    myia.open(myimage)
    img = myia.getregion()
    header = imhead(myimage,mode='list')
    if (header == None):
        imgfreq = 0
    elif ('restfreq' in header.keys()):
        imgfreq = header['restfreq']
    else:
        imgfreq = 0
    myrg = createCasaTool(rgtool)
    if (len(np.shape(img)) < 3):
        if (header == None):
            try:
                myshape = imhead(myimage, mode='get', hdkey='shape')
                naxis1 = myshape[0]
                naxis2 = myshape[1]
                cdelt1 = headerToArcsec(imhead(myimage, mode='get', hdkey='cdelt1'))
                cdelt2 = headerToArcsec(imhead(myimage, mode='get', hdkey='cdelt2'))
            except:
                bmaj,bmin,bpa,cdelt1,cdelt2,naxis1,naxis2,imgfreq = getFitsBeam(myimage)
            trc = [naxis1,naxis2]
        else:
            trc = [header['shape'][0],header['shape'][1]]
        print "trc = ", trc
        region = myrg.box(blc=[0,0],trc=trc)
    else:
        region = myrg.box(blc=[0,0,stokesPixel,channel],trc=[header['shape'][0],header['shape'][1],stokesPixel,channel])
    img = myia.getregion(region=region)
    myrg.done()
    if (row != None):
        if (header == None):
            arcsecPerPixel = cdelt1
        else:
            arcsecPerPixel = abs(headerToArcsec(header['cdelt1'], header['cunit1']))
        if (row >= 0):
            cut = img[row,:]
        else:
            if (peakimage != None):
                if (len(np.shape(imgPeak)) < 3):
                    results = imstat(imageForPeak)['maxpos']
                else:
                    results = imstat(imageForPeak,stokes=stokes,chans=str(channel))['maxpos']
                peakrow = results[0]
                peakcolumn = results[1]
                print "Image peak is at %d,%d" % (peakrow,peakcolumn)
                # This will be zero if peak is at image center
                peakdiff = peakrow-peakcolumn
            else:
                peakdiff = 0
            cut = []
            n = np.shape(img)[1]
            for x in range(np.shape(img)[0]):
                idx = x-peakdiff 
                if (idx >= 0 and idx < n):
                    if (len(np.shape(cut)) == 3):
                        value = img[x,x-peakdiff,0]
                        cut.append(value)
                    else:
                        value = np.array(img[x,x-peakdiff]).flatten()[0]
                        cut.append(value)
            arcsecPerPixel *= 2**0.5
    elif (column != None):
        if (header == None):
            arcsecPerPixel = cdelt2
        else:
            arcsecPerPixel = headerToArcsec(header['cdelt2'], header['cunit2'])
        if (column >= 0):
            cut = img[:,column]
        else:
            if (peakimage != None):
                if (len(np.shape(imgPeak)) < 3):
                    results = imstat(imageForPeak)['maxpos']
                else:
                    results = imstat(imageForPeak,stokes=stokes,chans=str(channel))['maxpos']
                peakrow = results[0]
                peakcolumn = results[1]
                print "Image peak is at %d,%d" % (peakrow,peakcolumn)
                # This will be zero if peak is at image center
                peakdiff = peakrow-peakcolumn
            else:
                peakdiff = 0
            cut = []
            n = np.shape(img)[1]
            for x in range(np.shape(img)[0]):
                idx = n-x-1-peakdiff 
                if (idx >= 0 and idx < np.shape(img)[1]):
                    if (len(np.shape(cut)) == 3):
                        cut.append(img[x, n-x-1-peakdiff, 0])
                    else:
                        value = np.array(img[x, n-x-1-peakdiff]).flatten()[0]
                        cut.append(value)
            arcsecPerPixel *= 2**0.5
    if (verbose): print "arcsecPerPixel = ", arcsecPerPixel
    myia.close()
    if (len(np.shape(cut)) == 3):
        cut = cut[:,0,0]
    cut = cut/np.max(cut)
    xaxis = np.array(range(len(cut)), dtype=np.float)
    if (shiftPeakToCenter):
        xaxis -= np.argmax(np.abs(cut))
        if (verbose): print "removing %f from xaxis" % (np.argmax(cut))
    myspline = scipy.interpolate.UnivariateSpline(xaxis,cut,s=0)
    npixels = len(xaxis)
    if (shiftPeakToCenter):
        # we want this to be a regular grid including x=0
        xstart = round(np.min(xaxis))
        xend = abs(xstart)
        myxaxis = np.linspace(xstart, xend, 1+(100*npixels)/2)
        medianpixel = np.median(range(len(myxaxis)))
        if (medianpixel != round(medianpixel)):
            print "This error should never happen."
            return
    else:
        myxaxis = np.linspace(np.min(xaxis), np.max(xaxis), 50*(npixels-1))
    myfunction = myspline(myxaxis)
    if (normalize):
        myfunction = myfunction/np.max(myfunction)
    if (shiftPeakToCenter):
        if (verbose): print "Removing argmax=%d, x=%f" % (np.argmax(myfunction), myxaxis[np.argmax(myfunction)])
        xaxis -= myxaxis[np.argmax(myfunction)]
        myxaxis -= myxaxis[np.argmax(myfunction)]
        myspline = scipy.interpolate.UnivariateSpline(myxaxis,myfunction,s=0)
        # we want this to be a regular grid including x=0
        xstart = round(np.min(myxaxis))
        xend = abs(xstart)
        myxaxis = np.linspace(xstart, xend, 1+(100*npixels)/2)
        myfunction = myspline(myxaxis)
        if (normalize):
            myfunction = myfunction/np.max(myfunction)
    if (scaleToArcsec):
        xaxis *= arcsecPerPixel
        myxaxis *= arcsecPerPixel
    if (showplot and gaussfit==False):
        pb.clf()
        pb.plot(xaxis, cut, 'k-', myxaxis, myfunction,'r-')
        if (plotrange[:2] != [0,0]):
            pb.xlim(plotrange[:2])
        if (plotrange[2:] != [0,0]):
            pb.ylim(plotrange[2:])
        pb.title(myimage)
        pb.draw()
    if (gaussfit):
        fwhm,truncate = griddedBeam().gaussfit(xaxis, cut, verbose=verbose, showplot=showplot,
                                         title=myimage, truncate=truncate)
    if (interpolate):
        return(myxaxis,myfunction,row,column,imgfreq)
    else:
        return(xaxis,cut,row,column,imgfreq)

def numberOfChannelsInCube(img):
    """
    Finds the number of channels in a CASA image cube.
    -Todd Hunter
    """
    header = imhead(img,mode='list')
    nchan = 1
    for axis in range(3,5):
        if ('ctype'+str(axis) in header.keys()):
            if (header['ctype'+str(axis)] in ['Frequency','Velocity']):
                nchan = header['shape'][axis-1]
                break
    return(nchan)
    
def imstatCube(img, box, startchan=None, maxwidth=None, minwidth=2, 
               plotfile='', mJy=True, plotrange=[0,0,0,0], mark11=None):
    """
    This function uses the CASA imstat task to compute the rms and standard deviation
    of chunks of a CASA image cube, and plots the result vs. the width of the chunk (in
    channel space).
    img: CASA image cube to analyze
    box: 'x0,y0,x1,y1'
    startchan: center of range of channels to analyze
    minwidth: narrowest group of channels to analyze
    maxwidth: widest group of channels to analyze
    mjy: if True, then scale the statistical values up by 1000 (from Jy/beam to mJy/beam)
    -Todd Hunter
    """
    if (mJy): 
        scale = 1000
    else: 
        scale = 1
    if (type(img) == list):
        nimages = len(img)
    else:
        nimages = 1
        img = [img]
    nrows = int(np.sqrt(nimages))
    ncols = nimages/nrows
    pb.clf()
    for i,myimg in enumerate(img):
        if (not os.path.exists(myimg)): 
            print "Could not find image = ", myimg
            return
        nchan = numberOfChannelsInCube(myimg)
        if startchan == None:
            startchan = nchan/2
        if maxwidth == None:
            maxwidth = nchan-1
        sigmas = []
        rmss = []
        for chan in range(minwidth,maxwidth+1,minwidth):
            ch = startchan-maxwidth/2+chan
            chans = '%d~%d' % (ch,ch+minwidth-1)
            center = imstat(myimg, box=box, chans=chans)
            sigmas.append(center['sigma']*scale)
            rmss.append(center['rms']*scale)
        # Take the median of all the single-channel measurements
        minwidthSigmaMean = np.mean(sigmas)
        minwidthRmsMean = np.mean(rmss)
        minwidthRmsMax = np.max(rmss)
        minwidthRmsMin = np.min(rmss)
        minwidthSigmaMedian = np.median(sigmas)
        minwidthRmsMedian = np.median(rmss)
        sigmas = []
        rmss = []
        channels = np.arange(minwidth,maxwidth+1,minwidth)
        for chan in channels:
            chans = '%d~%d' % (startchan-chan/2, startchan-chan/2+chan-1)
            center = imstat(myimg, box=box, chans=chans)
            sigmas.append(center['sigma']*scale)
            rmss.append(center['rms']*scale)
        desc = pb.subplot(nrows,ncols,i+1)
        pb.plot(channels, sigmas, 'k.-', channels, rmss, 'b.-',
                [minwidth], [minwidthSigmaMean], 'ko',
                [minwidth], [minwidthRmsMean], 'bo',
                [minwidth,minwidth], [minwidthRmsMin,minwidthRmsMax], 'b-')
        pb.hold(True)
        pb.plot([minwidth], [minwidthSigmaMedian], 'ko', mfc='w')
        pb.plot([minwidth], [minwidthRmsMedian], 'bo', mfc='w')
        if (nrows == 1 or i >= ncols):
            pb.xlabel('Number of channels')
        if (i%ncols == 0):
            pb.ylabel('Statistic')
        pb.title(os.path.basename(myimg), size=12-nrows)
        pb.text(0.1, 0.93, 'blue=rms, black=sigma (standard deviation)', 
                transform=desc.transAxes, size=12-nrows)
        if (mark11 != None):
            if (i==0):
                pb.plot([1],[mark11],'b+')
                meanRms11 = minwidthRmsMean
            else:
                pb.text(0.1,0.2,'MeanRms/Mark(panel_1) = %.2f'%(minwidthRmsMean/mark11),
                        transform=desc.transAxes, size=12-nrows)
                pb.text(0.1,0.1,'MeanRms/MeanRms(panel_1) = %.2f'%(minwidthRmsMean/meanRms11),
                        transform=desc.transAxes, size=12-nrows)
        if (plotrange == [0,0,0,0]):
            pb.xlim([0,pb.xlim()[1]])
        else:
            pb.xlim(plotrange[:2])
            pb.ylim(plotrange[2:])
        pb.draw()
    if (plotfile == ''):
        if (nimages == 1):
            plotfile = img[0]+'.imstatCube.png'
        else:
            plotfile = 'imstatCube.png'
    pb.savefig(plotfile)
    print "Plot left in ", plotfile

def extractAzimuthalAverageFromImage(image1,image2=None,image3=None,center=None,
                                     binsize=1.0, xlimits=[0,0], panels=1,
                                     mirror=False, peakimage=None, channel=0,
                                     stokes='XX', showplot=True, outfile='',
                                     plotfile='', normalize=True,
                                     scaleToArcsec=True, useimfit=True,
                                     interpolateToZero=False, maxradius=180):
    """
    A front-end function for azimuthalAverage.  Used to create the ALMA beam
    radial profiles from the TICRA models that will be used in CASA 4.3. 
    image1: the image to analyze
    image2: an optional second image to include as another column in the output
    image3: an optional third image to include as another column in the output
    center: the point about which to compute the average (default = image center)
    binsize: passed to azimuthalAverage
    xlimits: the x-axis limits to use if showplot==True
    panels: if 2, then also show intensity in dB in a second plot panel
    mirror: reflect the profile about x=0
    peakimage: the image for which to automatically find the peak to use as center
    channel: the channel of the peakimage to use
    stokes: the polarization product of the peak image to use ('XX', 'XY, 'YX', or 'YY')
    showplot: if True, open a graphics window showing the profile
    outfile: the text file to write the profile to
    plotfile: the graphics file to generate
    normalize: if True, then divide profiles by peak of peakimage
    scaleToArcsec: if True, read cdelt2 from image1 and scale x-axis by this value in arcsec
    useimfit: if True, use imfit instead of imstat to find the peak of peakimage
    interpolateToZero: insert an entry at radius=0 as avg of 0th and 1st order extrapolation
    maxradius: stop writing to outfile beyond this point (in arcsec if scaleToArcsec==True)
    - Todd Hunter.
    """
    pp = ['XX','XY','YX','YY']
    if (stokes not in pp):
        print "Invalid stokes, must be one of: ", pp
        return
    stokesPlane = pp.index(stokes)
    if (peakimage != None):
        myia = createCasaTool(iatool)
        myia.open(peakimage)
        imgPeak = myia.getregion()
        myia.close()
        if (len(np.shape(imgPeak)) < 3):
            if (useimfit):
                center = findRADec(peakimage, ' '.join(imfitparse(imfit(peakimage)).split()[:2]))
                x,z = azimuthalAverage(peakimage, center=center, binsize=binsize, returnradii=True,
                                       interpolateToZero=interpolateToZero)
                peak = np.nanmax(z)
            else:
                center = imstat(peakimage)['maxpos']
                peak = imstat(peakimage)['max']
        else:
            if (useimfit):
                center = findRADec(peakimage, ' '.join(imfitparse(imfit(peakimage,stokes=stokes,
                                                                        chans=str(channel))).split()[:2]))
                x,z = azimuthalAverage(peakimage, center=center, binsize=binsize, returnradii=True,
                                       axis3=stokesPlane, axis4=channel, interpolateToZero=interpolateToZero)
                peak = np.nanmax(z)
            else:
                center = imstat(peakimage)['maxpos']
                peak = imstat(peakimage,stokes=stokes,chans=str(channel))['max']
        print "Using center = ", center
    else:
        if (normalize):
            print "You must specify peakimage if normalize=True"
            return
    x,y = azimuthalAverage(image1, center=center, binsize=binsize, returnradii=True,
                           axis3=stokesPlane, axis4=channel, interpolateToZero=interpolateToZero)
    if (scaleToArcsec):
        header = imhead(image1,mode='list')
        arcsecPerPixel = headerToArcsec(header['cdelt2'], header['cunit2'])
        x *= arcsecPerPixel
        xaxisLabel = 'Radius (arcsec)'
    else:
        arcsecPerPixel = 1.0
        xaxisLabel = 'Radius (pixels)'        
    if (normalize):
        print "peak = ", peak
        y /= peak
    if (image2 != None):
        x2,z = azimuthalAverage(image2, center=center, binsize=binsize, returnradii=True,
                                axis3=stokesPlane, axis4=channel, interpolateToZero=interpolateToZero)
        x2 *= arcsecPerPixel
        if (normalize):
            z /= peak
        if (np.array_equal(x,x2) == False):
            print "x1/x2 axes differ!"
        if (image3 != None):
            x3,u = azimuthalAverage(image3, center=center, binsize=binsize,
                              returnradii=True, axis3=stokesPlane,
                              axis4=channel, interpolateToZero=interpolateToZero)
            x3 *= arcsecPerPixel
            if (normalize):
                u /= peak
            if (np.array_equal(x,x3) == False):
                print "x1/x3 axes differ!"
    if (mirror):
        idx = np.argsort(-x)
        y = np.array(list(y[idx]) + list(y[1:]))     # -3,-2,-1,0  + 1,2,3
        x = np.array(list(sorted(-x)) + list(x[1:])) # -3,-2,-1,0  + 1,2,3
    if (outfile == ''):
        outfile = image1.strip('.real').strip('.imag') + '.' + stokes + '.radialProfile'
    f = open(outfile,'w')
    if (image2 == None):
        f.write('R(arcsec)  Intensity\n')
    elif (image3 == None):
        f.write('R(arcsec)  Real  Imag\n')
    else:
        f.write('R(arcsec)  Real  Imag  Amplitude\n')
    for i in range(len(x)):
        if (x[i] < maxradius):
            if (image2 == None):
                f.write('%f %f\n' % (x[i],y[i]))
            elif (image3 == None):
                f.write('%f %f %f\n' % (x[i],y[i],z[i]))
            else:
                f.write('%f %f %f %f\n' % (x[i],y[i],z[i],u[i]))
    f.close()
    if (showplot):
        pb.clf()
        adesc = pb.subplot(panels,1,1)
        pb.plot(x,y,'bo-')
        pb.title(os.path.basename(image1), size=12, color='b')
        if (image2 != None):
            pb.hold(True)
            pb.plot(x,z,'ro-')
            pb.text(0.0,1.045,os.path.basename(image2),transform=adesc.transAxes,
                    size=11,color='r')
        if (image3 != None):
            pb.hold(True)
            pb.plot(x,u,'go-')
            pb.text(0.0,1.08,os.path.basename(image3),transform=adesc.transAxes,
                    size=11,color='g')
        pb.ylabel('Relative intensity of Stokes '+stokes)
        pb.xlabel(xaxisLabel)
        if (xlimits != [0,0]):
            pb.xlim(xlimits)
        if (panels > 1):
            pb.subplot(panels,1,2)
            pb.plot(x,10*np.log10(y),'bo-')
            pb.xlabel(xaxisLabel)
        if (xlimits != [0,0]):
            pb.xlim(xlimits)
        pb.draw()
        if (plotfile != ''):
            pb.savefig(plotfile)
    return(x,y)

def azimuthalAverage(myimage, center=None, stddev=False, returnradii=False,
                     return_nr=False, binsize=0.5, weights=None, steps=False,
                     interpnan=False, left=None, right=None,
                     mask=None, axis3=0, axis4=0, interpolateToZero=False):
    """
    Calculate the azimuthally averaged radial profile.
    Originally taken from Adam Ginsburg's agpy, but expanded to have the
    parameters axis3, axis4 and interpolateToZero.

    myimage - filename of 2D, 3D or 4D image, with sky coords as the first 2 axes
    axis3 - which pixel to use on the 3rd axis (default=0)
    axis4 - which pixel to use on the 4th axis (default=0)
    center - The [x,y] pixel coordinates used as the center. The default is 
             None, which then uses the center of the image (including 
             fractional pixels).
    stddev - if specified, return the azimuthal st.dev. instead of the average
    returnradii - if specified, return (radii_array,radial_profile)
    return_nr   - if specified, return number of pixels per radius *and* radius
    binsize - size of the averaging bin.  Can lead to strange results if
        non-binsize factors are used to specify the center and the binsize is
        too large
    weights - can do a weighted average instead of a simple average if this
              keyword parameter is set.  weights.shape must = image.shape.
              weighted stddev is undefined, so don't set weights and stddev.
    steps - if specified, will return a double-length bin array and radial
        profile so you can plot a step-form radial profile (which more accurately
        represents what's going on)
    interpnan - Interpolate over NAN values, i.e. bins where there is no data?
        left,right - passed to interpnan; they set the extrapolated values
    mask - can supply a mask (boolean array same size as image with True for OK
           and False for not) to average over only select data.

    If a bin contains NO DATA, it will have a NAN value because of the
    divide-by-sum-of-weights component.  I think this is a useful way to denote
    lack of data, but users let me know if an alternative is preferred...
    """
    # Calculate the indices from the image
    myia = createCasaTool(iatool)
    myia.open(myimage)
    img = myia.getregion()
    if (len(img.shape) == 3):
        img = img[:,:,axis3]
    if (len(img.shape) == 4):
        img = img[:,:,axis3,axis4]
    myia.close()
    y,x = np.indices(img.shape)

    if center is None:
        center = np.array([(x.max()-x.min())/2.0, (y.max()-y.min())/2.0])

    r = np.hypot(x - center[0], y - center[1])

    if weights is None:
        weights = np.ones(img.shape)
    elif stddev:
        raise ValueError("Weighted standard deviation is not defined.")

    if mask is None:
        mask = np.ones(img.shape,dtype='bool')
    # obsolete elif len(mask.shape) > 1:
    # obsolete     mask = mask.ravel()

    # the 'bins' as initially defined are lower/upper bounds for each bin
    # so that values will be in [lower,upper)  
    nbins = int(np.round(r.max() / binsize)+1)
    maxbin = nbins * binsize
    bins = np.linspace(0,maxbin,nbins+1)
    # but we're probably more interested in the bin centers than their left
    # or right sides...
    bin_centers = (bins[1:]+bins[:-1])/2.0

    # how many per bin (i.e., histogram)?
    # there are never any in bin 0, because the lowest index returned by
    # digitize is 1
    #nr = np.bincount(whichbin)[1:]
    nr = np.histogram(r,bins)[0]

    # recall that bins are from 1 to nbins (which is expressed in array terms
    # by arange(nbins)+1 or xrange(1,nbins+1) )
    # radial_prof.shape = bin_centers.shape
    if stddev:
        # Find out which radial bin each point in the map belongs to
        whichbin = np.digitize(r.flat,bins)
        # This method is still very slow; is there a trick to do this with histograms? 
        radial_prof = np.array([img.flat[mask.flat*(whichbin==b)].std() for b in xrange(1,nbins+1)])
    else: 
        radial_prof = np.histogram(r, bins, weights=(img*weights*mask))[0] / np.histogram(r, bins, weights=(mask*weights))[0]

    if interpnan:
        radial_prof = np.interp(bin_centers,bin_centers[radial_prof==radial_prof],radial_prof[radial_prof==radial_prof],left=left,right=right)

    if steps:
        xarr = np.array(zip(bins[:-1],bins[1:])).ravel() 
        yarr = np.array(zip(radial_prof,radial_prof)).ravel() 
        return xarr,yarr
    elif returnradii:
        if (interpolateToZero and bin_centers[0] != 0):
            if (False):
                myspline = scipy.interpolate.UnivariateSpline(bin_centers[:4],radial_prof[:4],s=0)
                intercept = myspline(0.0)
                print "intercept = ", intercept
            else:
                slope = (radial_prof[1]-radial_prof[0]) / (bin_centers[1]-bin_centers[0])
                intercept = radial_prof[1] - slope*bin_centers[1]
                intercept = 0.5*(intercept + radial_prof[0])  # avg of 0th and 1st order extrapolation
            bin_centers = np.append(np.array([0.0]),bin_centers)
            radial_prof = np.append(np.array([intercept]), radial_prof)
        return bin_centers,radial_prof
    elif return_nr:
        return nr,bin_centers,radial_prof
    else:
        return radial_prof

def frames(velocity=286.7, datestring="2005/11/01/00:00:00",
           ra="05:35:28.105", dec="-069.16.10.99", equinox="J2000", 
           observatory="ALMA", prec=4):
    """
    Converts an optical velocity into barycentric, LSRK and TOPO frames.
    -Remy Indebetouw
    velocity: in km/s
    datestring:  "YYYY/MM/DD/HH:MM:SS"
    ra: "05:35:28.105"
    dec: "-069.16.10.99"
    equinox: "J2000" 
    observatory: "ALMA"
    prec: precision to display (digits to the right of the decimal point)
    - Todd Hunter
    """

    me = createCasaTool(metool)
    myqa = createCasaTool(qatool)
# CASA doesn't do Helio, but difference to Bary is hopefully small
    velOpt = create_casa_quantity(myqa,velocity,"km/s")

    position=me.direction(equinox, ra, dec)
    obstime=me.epoch('TAI', datestring)

    dopp = me.doppler("OPTICAL",velOpt)
    print "optical Doppler vel  = %.4f km/s" % velocity
    rvelOpt = me.toradialvelocity("BARY",dopp)

    me.doframe(position)
    me.doframe(me.observatory(observatory))
    me.doframe(obstime)
    me.showframe()

    rvelRad=me.measure(rvelOpt,'LSRK')
    doppRad=me.todoppler("RADIO",rvelRad)       

    print "optical BARY velocity = %s" % qa.tos(rvelOpt['m0'],prec=prec)
    print "radio LSRK  velocity  = %s" % qa.tos(rvelRad['m0'],prec=prec)
    print "radio LSRK doppshift  = %s" % qa.tos(doppRad['m0'],prec=prec)

    rvelTop=me.measure(rvelOpt,'TOPO')
    doppTop=me.todoppler("RADIO",rvelTop)       

    print "radio TOPO  velocity  = %s" % qa.tos(rvelTop['m0'],prec=prec)
    print "radio TOPO doppshift  = %s" % qa.tos(doppTop['m0'],prec=prec)

def airmassToElevation(airmass):
    """
    Converts airmass to elevation in degrees
    -Todd Hunter
    """
    return(180*math.asin(1.0/airmass)/np.pi)

def elevationToAirmass(elevation):
    """
    Converts elevation in degrees to airmass.
    -Todd Hunter
    """
    return(1/np.sin(elevation*np.pi/180.))

def visibleSky(latitude=ALMA_LATITUDE, elevation=15, airmass=None):
    """
    Computes the fraction of sky ever visible from a specified location 
    (latitude in degrees) above a specified horizon (elevation in degrees
    or airmass).
    Usage:  visibleSky(latitude=-23.0229, elevation=15, airmass=None)
    - Todd Hunter
    """
    if (airmass != None):
        elevation = airmassToElevation(airmass)
    else:
        airmass = elevationToAirmass(elevation)

    if (abs(latitude) > elevation):
        fraction = 0.5*(1+math.cos((np.abs(latitude)+elevation)*math.pi/180.))
    else:
        fraction = 0.5*(math.cos((np.abs(latitude)+elevation)*math.pi/180.)
                        +math.cos((elevation-np.abs(latitude))*math.pi/180.))
    print "At %.2f deg latitude, the sky fraction accessible is %.3f at airmass <%.2f (elev >%.2f)" % (latitude,fraction,airmass,elevation)
    return(fraction)

def create_casa_quantity(myqatool,value,unit):
    """
    A wrapper to handle the changing ways in which casa quantities are invoked.
    Todd Hunter
    """
    if (type(casac.Quantity) != type):  # casa 4.x
        myqa = myqatool.quantity(value, unit)
    else:  # casa 3.x
        myqa = casac.Quantity(value, unit)
    return(myqa)

def getAtmDetails(at):
    """
    A wrapper to handle the changing ways in which the at tool is accessed.
    Todd Hunter
    """
    if (type(casac.Quantity) == type):  # casa 3.x
        dry = np.array(at.getDryOpacitySpec(0)['dryOpacity'])
        wet = np.array(at.getWetOpacitySpec(0)['wetOpacity'].value)
        TebbSky = []
        n = at.getNumChan()
        for chan in range(n):  # do NOT use numchan here, use n
            TebbSky.append(at.getTebbSky(nc=chan, spwid=0).value)
        TebbSky = np.array(TebbSky)
        # readback the values to be sure they got set
        rf = at.getRefFreq().value
        cs = at.getChanSep().value
    else:  # casa 4.x
        dry = np.array(at.getDryOpacitySpec(0)[1])
        wet = np.array(at.getWetOpacitySpec(0)[1]['value'])
        TebbSky = at.getTebbSkySpec(spwid=0)[1]['value']
        # readback the values to be sure they got set
        rf = at.getRefFreq()['value']
        cs = at.getChanSep()['value']
    return(dry,wet,TebbSky,rf,cs)

def findNull(angularDiameter,amplitude=0, wavelength=None, frequency=None):
    """
    Given an amplitude on a scale of 0..1, and an angularDiameter in
    arcseconds, determine the corresponding radius of the Besinc
    function within the first null (in units of kilowavelength). This
    is the function that describes the visibility amplitude of a uniform
    disk.
    If the wavelength (in mm) or frequency (in GHz) is given, then
    report the value in meters.
    Todd Hunter
    """
    radians = angularDiameter/ARCSEC_PER_RAD
    for B in np.arange(500,5e7):  #B = baseline length in lambda
        x = 2*np.pi*B*radians/2.0
        I = 2*scipy.special.j1(x)/x
        if (I < amplitude):
            break
    if (wavelength != None):
        meters = B*wavelength*0.001
        if (amplitude == 0):
            print "first null occurs at %g meters" % (meters)
        else:
            print "amplitude is %g*peak at %g meters" % (amplitude,meters)
        return(meters) 
    elif (frequency != None):
        wavelength = 299.792458/frequency
        print "wavelength = %g mm" % (wavelength)
        meters = B*wavelength*0.001
        if (amplitude == 0):
            print "first null occurs at %g meters" % (meters)
        else:
            print "amplitude is %g*peak at %g meters" % (amplitude,meters)
        return(meters)
    else:
        if (amplitude == 0):
            print "first null occurs at %g kilolambda" % (B*0.001)
        else:
            print "amplitude is %g*peak at %g kilolambda" % (amplitude,B*0.001)
        return(B)

def polarizationUncertainty(I,Q,U,sigma):
    """
    Compute fractional polarization = sqrt(Q**2 + U**2) / I
    and the uncertainty follows by propagation of error formulae
    I, Q, U: flux density measurements for these 3 Stokes parameters
    sigma: uncertainty in the flux density measurements
    - Todd Hunter
    """
    sigma_U = sigma
    sigma_Q = sigma
    sigma_I = sigma
    r = 100*(Q**2+U**2)**0.5 / I
    sigma_r = r * ((sigma_I/I)**2 + 0.25*(  ((2*sigma_Q*Q)**2+(2*sigma_U*U)**2) / (Q**2+U**2)**2)) ** 0.5
    print "percentage polarization = %.3f%% +- %.3f%%" % (r, sigma_r)
    return(r)

def waitForPlotms():
    """
    The EVLA solution, from Claire, with some modifications by Todd.
    This will be obsoleted in casa 4.2 with the new options of plotms.
    """
    mylogfile = casalog.logfile()
    if (os.path.exists(mylogfile) == False):
        # someone may have deleted it
        println("waitForPlotms() is returning immediately because it cannot find the casa log file.")
        return
    countmax = 10
    countr = 0
    foundend = False
    searchText = 'End Task: plotms'
    # sometimes plotms never prints 'End Task: plotms', but instead prints 'END       Time:'
    # so also check for that string to signify the end of the process
    searchText2 = 'END       Time:'
    while not foundend and countr<countmax:
        timeUtilities.sleep(1)  
        #os.system('tail --lines=10 '+mylogfile)
        f = os.popen('tail --lines=10 '+mylogfile)
        fstrs = f.readlines()
        f.close()
        for fstr in fstrs:
            if (fstr.count(searchText)>0  or fstr.count(searchText2)>0):
                foundend=True
        if (foundend == False):
            println("Waiting for text: %s" % searchText)
        countr+=1
    return

def setScanNumbersToZero(vis):
    """
    Sets all scan numbers in a dataset to zero.
    -- Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    mytb.open(vis,nomodify=False)
    scans = mytb.getcol('SCAN_NUMBER')
    scans *= 0
    mytb.putcol('SCAN_NUMBER', scans)
    mytb.close()

def renameMsInCalTable(mytable, vis):
    """
    Change the name of the MSName keyword in the header of a caltable.
    -Todd Hunter
    """
    if (os.path.exists(mytable) == False):
        print "Could not find table = ", mytable
        return
    mytb = createCasaTool(tbtool)
    mytb.open(mytable, nomodify=False)
    msname = mytb.getkeyword('MSName')
    mytb.putkeyword('MSName',vis)
    mytb.close()
    
def fixScanNumbers(vis, update=True):
    """
    Detects times when the field name changes, and increments the scan number.
    Useful for SMA data converted with old version of sma2casa.  This uses a
    brute force row-by-row method. In this case, it's not clear if selecting
    by data descriptor would be much faster.
    -- Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    mytb.open(vis)
    fields = mytb.getcol('FIELD_ID')
    scans = mytb.getcol('SCAN_NUMBER')
    datetimes = mytb.getcol('TIME')
    dds = mytb.getcol('DATA_DESC_ID')
    mytb.close()
    uniqueDDs = np.unique(dds)
    scanChange = dict.fromkeys(uniqueDDs, [])
    print "initialized scanChange = ", scanChange
    nrows = len(fields)
    for mydd in uniqueDDs:
        previousField = None
        for f in range(nrows):
            if (dds[f] == mydd):
                # We have found a row for the current data descriptor
                if (previousField != None):
                    if (previousField != fields[f]):
#                        print "dd%d: Field change (%d to %d) at row %d" % (mydd,previousField,fields[f],f)
                        scanChange[mydd] = scanChange[mydd] + [f]
                previousField = fields[f]
        print "Found %d scan changes for dd%d" % (len(scanChange[mydd]), mydd)
                
    if (update):
        newDatetimes = datetimes
        mytb.open(vis, nomodify=False)
        for u in range(len(uniqueDDs)):
            mydd = uniqueDDs[u]
            # for each data descriptor, search through all rows
            n = 0
            for d in range(len(datetimes)):
                if (dds[d] == mydd):
                    if (n < len(scanChange[mydd])):
                        # We haven't seen all the field changes yet.
                        if (d >= scanChange[mydd][n]):
                            n += 1
                    scans[d] = n+1
            print "Done %d/%d: Setting scans = " % (u+1,len(uniqueDDs)), scans
        print "Updating measurement set..."
        mytb.putcol('SCAN_NUMBER', scans)
        mytb.close()

def plotObservatories(table='/usr/lib64/casapy/release/4.1.0/data/geodetic/Observatories',
                      hemisphere='north', list=False):
    """
    This function will plot a polar view of one or both hemisphere's worth of
    observatories with ITRF coordinates in the specified CASA repository table.
    The axes will be in XY coordinates, with latitude and longitude lines marked.
    The locations are first drawn in red, then in blue so that disagreements between
    the latitude/longitude and the XYZ in the table will be apparent.
    hemisphere: 'north', 'south', or 'both'
    list: print the longitude/latitude and XYZ values 
    -Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    mytb.open(table)
    X = mytb.getcol('X') * 0.001
    Y = mytb.getcol('Y') * 0.001
    Z = mytb.getcol('Z') * 0.001
    Long = mytb.getcol('Long') 
    Lat = mytb.getcol('Lat') 
    Type = mytb.getcol('Type')
    Name = mytb.getcol('Name')
    if (hemisphere == 'north'):
        indices1 = np.where(Z>=0)[0]
    elif (hemisphere == 'south'):
        indices1 = np.where(Z<=0)[0]
    elif (hemisphere == 'both'):
        indices1 = range(len(X))
    else:
        print "hemisphere must be 'north', 'south', or 'both'"
        return
    indices2 = np.where(Type == 'ITRF')[0]
    indices  = np.intersect1d(indices1, indices2)
    pb.close()
    pb.figure(1,(8,8)) # make square figure

    # First draw a point at the Lat/Long coordinates in red
    earthRadius = 6.378164e3
    radius = earthRadius*cos(Lat*np.pi/180.)
    x = radius*np.cos(Long*np.pi/180)
    y = radius*np.sin(Long*np.pi/180)
    namesDrawn = []
    xyDrawn = len(indices) * [[0,0]]
    for j in range(len(indices)):
        i = indices[j]
        notAtZeroZero = (Lat[i]**2)>1
        if (notAtZeroZero):
            pb.plot(x[i], y[i], 'o', color='r')
            if (list): print "%s: %f, %f deg" % (Name[i],Long[i],Lat[i])
        if (Name[i] != 'SAO SMA' and Name[i] not in namesDrawn and notAtZeroZero):
            pb.text(x[i], y[i], Name[i], size = 9, color='k', ha='center')
            namesDrawn.append(Name[i])
            xyDrawn[j] = [x[i],y[i]]
            
    if (list): print "------------------------------------------"
    # Now draw a point at the XYZ coordinates in blue
    pb.plot(X[indices], Y[indices],'o',color='b')
    namesDrawn = []
    for j in range(len(indices)):
        i = indices[j]
        notAtNorthPole = (X[i]**2+Y[i]**2)>1000
        if (Name[i] != 'SAO SMA' and Name[i] not in namesDrawn and notAtNorthPole):
            difference = ((xyDrawn[j][0]-X[i])**2+(xyDrawn[j][1]-Y[i])**2)**0.5
            if (difference > 50):  # don't re-label the same observatory again
                pb.text(X[i], Y[i], Name[i], size = 9, color='k', ha='center')
            namesDrawn.append(Name[i])
            if (list): print "%s: %f, %f, %f km" % (Name[i],X[i],Y[i],Z[i])
    pb.xlim([-6.4e3, 6.4e3])
    pb.ylim([-6.4e3, 6.4e3])
    pb.xlabel('X (km)')
    pb.ylabel('Y (km)')
    cir = pb.Circle((0,0), radius=earthRadius, facecolor='w')
    pb.gca().add_patch(cir)
    # draw latitude lines
    for i in range(15,90,15):
        cir = pb.Circle((0,0), radius=earthRadius*cos(i*np.pi/180.), facecolor='w', ls='dotted')
        pb.gca().add_patch(cir)
        pb.text(-earthRadius*cos(i*np.pi/180.)-200,0,str(i))
    # draw longitude lines
    labelRadius = earthRadius*cos(67*np.pi/180.)
    inc = 15
    for i in range(-180+inc,180,inc):
        x = earthRadius*cos(i*np.pi/180.)
        y = earthRadius*sin(i*np.pi/180.)
        pb.plot([0,x],[0,y],':',color='k')
        pb.text(labelRadius*cos(i*np.pi/180.), labelRadius*sin(i*np.pi/180.), str(i))
    if (hemisphere in ['north','south']):
        pb.title('%sern observatories with ITRF coordinates in CASA repository' % (hemisphere))
    else:
        pb.title('Observatories with ITRF coordinates in CASA repository')
    pb.text(0, 7000, 'Viewed from the celestial pole', ha='center')
    pb.draw()
    if (os.access('./',  os.W_OK)):
        png = 'plotObservatories_%s.png' % (hemisphere)
    else:
        png = '/tmp/plotObservatories_%s.png' % (hemisphere)
    pb.savefig(png)
    print "Figure saved in %s" % (png)
    
def flipSignOfPosition(table='/usr/lib64/casapy/release/4.1.0/data/geodetic/Observatories',
                       axis='Y',observatory='SMA'):
    """
    This function will flip the sign of one axis of the position of an observatory in
    the CASA Observatories table, for testing purposes.
    -Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    mytb.open(table, nomodify=False)
    Y=mytb.getcol(axis)
    Names=mytb.getcol('Name')
    index = numpy.where(Names==observatory)[0][0]
    Y[index] *= -1
    mytb.putcol(axis,Y)
    mytb.close()

def negateAntennaPosition(vis, column=1):
    """
    Negates one of the ITRF coordinate axes of the antenna positions.
    0=X, 1=Y, 2=Z
    Todd Hunter
    """
    mytb = createCasaTool(tbtool)
    mytb.open(vis+'/ANTENNA',nomodify=False)
    c = mytb.getcol('POSITION')
    c[column] *= -1
    mytb.putcol('POSITION', c)
    mytb.close()


def getListOfFilesFromFile(filename, appendms=True):
    """
    Reads a list of measurement set or asdm names from a text file, one per line,
    and return a list of measurement set names (with .ms appended if not present).
    Ignores lines containing beginning with a comment character (pound sign).
    Todd Hunter
    """
    fin = open(filename,'r')
    vislist = []
    for line in fin.readlines():
        if (line.find('#') == 0): continue
        myname = line.strip('\n').strip('\a').replace(':','_').replace('/','_').strip(' ')
        if (appendms):
            if (myname.find('.ms') < 0):
                myname += '.ms'
        vislist.append(myname)
    fin.close()
    return vislist

def checkDelaysForDatasets(vislist=[], intent='CALIBRATE_PHASE,CALIBRATE_BANDPASS',
                           outfile='delaySummary.txt', medianThreshold=0.2, minimumJump=1.0,
                           verbose=False, maxFiles=None, pdftk='pdftk', gs='/usr/bin/gs'):
    """
    Runs checkDelays.findDelayJumps on a list of datasets
    vislist: either a list of strings, or a single string specifying a filename from which to read the
       names of measurement sets on a line-by-line basis
    medianThreshold: value in nsec above which the median delay is considered to be large
    mininumJump: value in nsec above which outlier must be to be considered a jump
    -Todd Hunter
    """
    if (type(vislist) == str):
        vislist = getListOfFilesFromFile(vislist, appendms=True)
        vislistFile = vislist
    else:
        vislistFile = 'checkDelayForDatasets'
    f = open(outfile,'w')
    ctr = 0
    largeDelaysPdfnames = []
    delayJumpsPdfnames = []
    if (maxFiles == None):
        nfiles = len(vislist)
    else:
        nfiles = maxFiles
    for vis in vislist:
        ctr += 1
        if (maxFiles != None):
            if (ctr > maxFiles):
                break
        print "Working on vis %d/%d = %s" % (ctr,nfiles,vis)
        asdm = vis.strip('.ms')
        if (os.path.exists(vis) == False):
            if (os.path.exists(asdm) == False):
                print "Running asdmExport %s" % (asdm)
                os.system('asdmExport ' + asdm)
            print "Running importasdm('%s',asis='*')" % (asdm)
            importasdm(asdm,asis='*')
        if (os.path.exists(vis+'.listobs') == False):
            listobs(vis,listfile=vis+'.listobs')
        c = checkDelays(vis)
        delayJumps, delayLarge, delayJumpsPdfname, largeDelaysPdfname = c.findDelayJumps(intent=intent, medianThreshold=medianThreshold,
                                                                                         minimumJump=minimumJump)
        if (delayJumpsPdfname != ''):
            delayJumpsPdfnames.append(delayJumpsPdfname)
        if (largeDelaysPdfname != ''):
            largeDelaysPdfnames.append(largeDelaysPdfname)
        dateString = getObservationStartDate(vis)
        correlator = getCorrelatorName(asdm)
        f.write(vis + '    %s   %s\ndelayJumps: %s\ndelayLarge: %s\n\n' % (dateString,correlator,str(delayJumps), str(delayLarge)))
        f.flush()
    f.close()
    print "Results left in %s" % (outfile)
    if (len(largeDelaysPdfnames) > 0):
        mystatus = concatenatePDFs(' '.join(largeDelaysPdfnames), vislistFile+'.largeDelays.pdf', pdftk=pdftk, gs=gs, cleanup=True)
        print "Results left in %s" % (vislistFile+'.largeDelays.pdf')
    if (len(delayJumpsPdfnames) > 0):
        mystatus = concatenatePDFs(' '.join(delayJumpsPdfnames), vislistFile+'.delayJumps.pdf', pdftk=pdftk, gs=gs, cleanup=True)
        print "Results left in %s" % (vislistFile+'.delayJumps.pdf')

class checkDelays:
    """
    This class uses gaincal to search for delay jumps on an integration
    basis (or specified time interval).  
    If you already have a 'K' caltable, you can run checkDelaySolution,
    otherwise, use findDelayJumps which will run gaincal, and then
    checkDelaySolution.
    Todd Hunter
    """
    def __init__(self, vis, caltable=None, autorun=True, solint='',refant='0',field='',
                 intent='CALIBRATE_BANDPASS', spw='',sigma=5,edgeFraction=0.0625,
                 plotAll=False,phaseup_solint='',medianThreshold=0.2,
                 minimumJump=1.0, verbose=False, antenna='', scan=''):
        if (os.path.exists(vis) == False):
            print "Could not find MS"
            return
        if (os.path.exists(vis+'/table.dat') == False):
            print "No table.dat.  This does not appear to be an ms."
            return
        self.vis = vis
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(vis)
        antennas = range(mymsmd.nantennas())
        self.antennaIds = antennas  
        self.antennaNames = mymsmd.antennanames(antennas)
        mymsmd.close()
        if (autorun):
            if (caltable == None):
                self.findDelayJumps(solint,refant,field,intent,spw,sigma,caltable,edgeFraction,
                                    plotAll,
                                    phaseup_solint, medianThreshold,minimumJump,verbose)
            else:
                self.checkDelaySolution(caltable,antenna,spw,scan,sigma,verbose,plotAll,
                                        medianThreshold,minimumJump)
        
    def findDelayJumps(self, solint='', refant='0', field='', intent='CALIBRATE_BANDPASS',
                       spw='', sigma=5, caltable='', edgeFraction=0.0625, plotAll=False,
                       phaseup_solint='', medianThreshold=5.0, minimumJump=1.0, verbose=False):
        """
        Runs gaincal 'G' with calmode='p' to phase-up the array, followed by gaincal 'K'
        to find delay solutions, then calls checkDelaySolutions to check the resulting
        caltable for jumps.

        field: select a specific field name (or string ID) to check
        intent: select a specific intent to check (#ON_SOURCE is added to the end)
        sigma: threshold for declaring an outlier point (the value to multiply by the MAD)
        edgeFraction: the fraction of edge channels to avoid (on each side) in the solution
        phaseup_solint: the solution interval for the phase-up stage (default: 1 integration)
        solint: the solution interval for the 'K' solution (default: 1 integration)
        medianThreshold: value in nsec above which the median delay is considered to be large
        mininumJump: value in nsec above which outlier must be to be considered a jump

        Returns two dictionaries:
        1) delayJumps keyed by antenna, spw, scan, polarization ID, value = value in nsec
        2) delayMedian keyed by antenna, spw, polarization ID, value = value in nsec
        - Todd Hunter
        """
        if (refant not in self.antennaNames and str(refant) not in [str(id) for id in self.antennaIds]):
            print "Antenna %s is not in the dataset.  Available antennas = %s" % (refant, str(self.antennaNames))
            return
        if (caltable == '' or caltable==None):
            caltable = self.vis + '.K'
        mymsmd = createCasaTool(msmdtool)
        mymsmd.open(self.vis)
        if (intent != ''):
            intents = intent.split(',')
            intent = ''
            for myIntent in intents:
                if (myIntent != intents[0]): intent += ','
                intent += myIntent
                if (myIntent.find('#') < 0):
                    intent += '#ON_SOURCE'
            intents = intent.split(',')
            noData = True
            for myIntent in intents:
                if (myIntent not in mymsmd.intents()):
                    print "No data with intent = ", intent
                else:
                    noData = False
            if (noData):
                print "Available intents = %s" % str(mymsmd.intents())
                return
        if (spw == ''):
            if (casadef.subversion_revision >= casaRevisionWithAlmaspws):
                spwlist = mymsmd.almaspws(fdm=True,tdm=True)
            else:
                spwlist = np.setdiff1d(np.union1d(mymsmd.tdmspws(),mymsmd.fdmspws()), mymsmd.chanavgspws())
            if (intent != ''):
                intents = intent.split(',')
                spwsforintent = []
                for myIntent in intents:
                    spwsforintent += list(mymsmd.spwsforintent(myIntent))
                spwlist = np.intersect1d(spwlist,np.array(spwsforintent))
                if (len(spwlist) < 1):
                    print "No spws with intent = ", intent
                    return
            spw = ','.join([str(s) for s in spwlist])
            print "spws selected = ", spw
        myspw = int(spw.split(',')[0])
        idx1 = mymsmd.scansforspw(myspw)
        if (intent != ''):
            intents = intent.split(',')
            idx2 = []
            for myIntent in intents:
                idx2 += list(mymsmd.scansforintent(myIntent))
            firstScan = np.intersect1d(idx1,np.array(idx2))
        else:
            firstScan = idx1
        print "scans for spw%d = " % (myspw), firstScan
        if (len(firstScan) < 1):
            print "mismatch in spw/intent"
            return
        firstScan = firstScan[0]                
        if (solint == ''):
            print "Calling getIntegrationTime('%s',spw='%s', scan=%d, intent='%s')" % (self.vis,spw.split(',')[0],firstScan,intent)
            solint = getIntegrationTime(self.vis, spw=spw.split(',')[0], scan=firstScan, intent=intent)
            solint = '%.3fs' % (solint)
            print "Using solint = integration time for scan %d = %s" % (firstScan, solint)
        spwchan = ''
        spwList = spw.split(',')
        for s in spwList:
            nchan = mymsmd.nchan(int(s))
            startchan = int(nchan*edgeFraction)
            endchan = nchan-startchan
            spwchan += '%s:%d~%d' % (s,startchan,endchan)
            if (s != spwList[-1]): spwchan += ','
        mymsmd.close()
        if (os.path.exists(caltable)):
            print "Removing existing caltable = %s" % (caltable)
            os.system('rm -rf %s' % (caltable))
        
        print "Calling gaincal('%s',gaintype='G',solint='%s',field='%s',caltable='%s',refant='%s',intent='%s',spw='%s',selectdata=True)" % (self.vis,solint,field,caltable,refant,intent,spwchan)
        if (phaseup_solint == ''):
            phaseup_solint = '%.3fs' % (getIntegrationTime(self.vis, spw=spw.split(',')[0], scan=firstScan, intent=intent))
        gaincal(self.vis, gaintype='G', solint=phaseup_solint, field=field, caltable=caltable+'.phaseup',
                refant=refant, intent=intent, spw=spwchan, calmode='p', selectdata=True)
        print "Calling gaincal('%s',gaintype='K',solint='%s',field='%s',caltable='%s',refant='%s',intent='%s',spw='%s',gaintable='%s',selectdata=True)" % (self.vis,solint,field,caltable,refant,intent,spwchan,caltable+'.phaseup')
        gaincal(self.vis, gaintype='K', solint=solint, field=field, caltable=caltable,
                refant=refant, intent=intent, spw=spwchan, gaintable=caltable+'.phaseup',selectdata=True)
        result = self.checkDelaySolution(caltable, sigma=sigma, plotAll=plotAll,
                                             medianThreshold=medianThreshold,minimumJump=minimumJump,verbose=verbose)
        return(result)

    def checkDelaySolution(self, caltable='', antenna='', spw='', scan='', sigma=5,
                           verbose=False, plotAll=False, medianThreshold=5.0, minimumJump=1.0):
        """
        Takes a K solution caltable and looks for delay jumps, and large values of delay.
        caltable: the solution table
        antenna: limit the search to a list of antenna IDs
        spw: limit the search to a list of spws
        scan: limit the search to a list of scans
        sigma: threshold for declaring an outlier point (the value to multiply by the MAD)
        mininumJump: value in nsec above which outlier must be to be considered a jump
        medianThreshold: value in nsec above which the median delay is considered to be large
        plotAll: if True, produce a plot for each combination, even if there are no delay
                 jumps found

        Returns: 2 dictionaries, which are filled only for combinations that show a problem
        1) delayJumps keyed by antenna, spw, polarization ID
        2) delayMax keyed by antenna, spw, polarization ID
        3) The name of the PDF produced, if any
        """
        if (caltable == ''):
            caltable = self.vis + '.K'  # check for automatic name
        if (os.path.exists(caltable) == False):
            print "Could not find caltable: %s" % (caltable)
            return
        mytb = createCasaTool(tbtool)
        mytb.open(caltable)
        delays = mytb.getcol('FPARAM')
        spws = mytb.getcol('SPECTRAL_WINDOW_ID')
        antennas = mytb.getcol('ANTENNA1')
        scans = mytb.getcol('SCAN_NUMBER')
        fields = mytb.getcol('FIELD_ID')
        times = mytb.getcol('TIME')
        pols = range(len(delays))
        print "pols = ", pols
        mytb.close()
        uniqueAntennas = np.unique(antennas)
        uniqueSpws = np.unique(spws)
        uniqueScans = np.unique(scans)
        uniqueFields = np.unique(fields)
        uniqueTimes = np.unique(times)
        # loop over solutions
        if (antenna == ''): antenna = uniqueAntennas
        if (spw == ''): spw = uniqueSpws
        if (scan == ''): scan = uniqueScans
        delayJumps = {}
        delayMax = {}
        delayJumpPngs = []
        largeDelayPngs = []
        for a in antenna:
            if (verbose): print "working on antenna %d" % (a)
            for s in spw:
                if (verbose): print "working on spw %d" % (s)
                antSpwRows = []
                for sc in scan:
                    idx1 = np.where(antennas==a)[0]
                    idx2 = np.where(spws==s)[0]
                    idx3 = np.where(scans==sc)[0]
                    rows = np.intersect1d(np.intersect1d(idx1,idx2),idx3)
                    antSpwRows += list(rows)
                rows = antSpwRows[:]
                jumpSeen = False
                largeSeen = False
                for pol in pols:
                    if (verbose): print "shape(delays) = ", np.shape(delays)
                    if (verbose): print "shape(delays[pol]) = ", np.shape(delays[pol])
                    if (verbose): print "shape(delays[pol][0][rows]) = ", np.shape(delays[pol][0][rows])
                    if (verbose): print "delays[pol][0][rows] = %s" % (str(delays[pol][0][rows]))
                    if (verbose): print "rows = ", rows
                    delayMad = MAD(delays[pol][0][rows])
                    myMax = np.max(np.abs(delays[pol][0][rows]))
                    if (verbose): print "max= ", myMax
                    myDiff = delays[pol][0][rows] - myMax
                    outliers = np.where(myDiff > delayMad*sigma)[0]
                    outliers2 = np.where(myDiff > minimumJump)[0]
                    outliers = np.intersect1d(outliers,outliers2)
                    if (verbose): print "len(outliers) = %d" % (len(outliers))
                    nJumps = len(outliers)
                    if (fabs(myMax) > medianThreshold):
                        if (a not in delayMax.keys()): delayMax[a] = {}
                        if (s not in delayMax[a].keys()): delayMax[a][s] = {}
                        print "Ant%d=%s, spw%d, pol%d: found a large delay (nsec: %s)" % (a,self.antennaNames[a],s,pol,myMax)
                        delayMax[a][s][pol] = myMax
                        largeSeen = True
                    if (nJumps > 0):
                        if (a not in delayJumps.keys()): delayJumps[a] = {}
                        if (s not in delayJumps[a].keys()): delayJumps[a][s] = {}
                        delayJumps[a][s][pol] = nJumps
                        print "Ant%d=%s, spw%d, pol%d: found %d delay jumps (nsec: %s)" % (a,self.antennaNames[a],s,pol,nJumps,str(['%.1f'%(dd) for dd in myDiff[outliers]]))
                        jumpSeen = True
                if (jumpSeen or largeSeen or plotAll):
                    pb.clf()
                    adesc = pb.subplot(111)
                    timeStamps = pb.date2num(mjdSecondsListToDateTime(times[rows]))
                    c = ['black','red']
                    for pol in pols:
                        pb.plot_date(timeStamps, delays[pol][0][rows], 'o', color=c[pol])
                        pb.text(0.1,0.95-0.05*pol,'Pol '+str(pol),color=c[pol],transform=adesc.transAxes)
                        pb.hold(True)
                    if (np.max(times[rows]) - np.min(times[rows]) > 2000):
                        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,20)))
                        adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,10)))
                        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
                        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
                    elif (np.max(times[rows]) - np.min(times[rows]) > 200):
                        adesc.xaxis.set_major_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,3)))
                        adesc.xaxis.set_minor_locator(matplotlib.dates.MinuteLocator(byminute=range(0,60,1)))
                        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M'))
                        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M')
                    else:
                        adesc.xaxis.set_major_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,20)))
                        adesc.xaxis.set_minor_locator(matplotlib.dates.SecondLocator(bysecond=range(0,60,5)))
                        adesc.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%H:%M:%S'))
                        adesc.fmt_xdata = matplotlib.dates.DateFormatter('%H:%M:%S')
                    pb.xlabel('Universal Time on %s' % (mjdsecToUT(times[rows[0]]).split()[0]))
                    adesc.yaxis.set_major_formatter(ScalarFormatter(useOffset=False))
                    pb.ylabel('Delay (nsec)')
                    yFormatter = ScalarFormatter(useOffset=False)
                    if (jumpSeen):
                        details = '.%s.spw%02d.delayJump' % (self.antennaNames[a],s)
                    elif (largeSeen):
                        details = '.%s.spw%02d.largeDelay' % (self.antennaNames[a],s)
                    else:
                        details = '.%s.spw%02d' % (self.antennaNames[a],s)
                    pb.title(caltable + details.replace('.',' '))
                    png = caltable + details + '.png'
                    pb.savefig(png)
                    print "Figure saved to %s" % (png)
                    if (jumpSeen):
                        delayJumpPngs.append(png)
                    if (largeSeen):
                        largeDelayPngs.append(png)
            if (a in delayJumps.keys()):
                delayJumps[self.antennaNames[a]] = delayJumps[a]
            if (a in delayMax.keys()):
                delayMax[self.antennaNames[a]] = delayMax[a]
        delayJumpsPdfname = ''
        largeDelaysPdfname = ''
        if (len(delayJumpPngs) > 1):
            delayJumpsPdfname = caltable+'.delayJumps.pdf'
            print "running buildPdfFromPngs(%s, '%s')" % (str(delayJumpPngs),delayJumpsPdfname)
            buildPdfFromPngs(pnglist=delayJumpPngs, pdfname=delayJumpsPdfname)
        if (len(largeDelayPngs) > 1):
            largeDelaysPdfname = caltable+'.largeDelays.pdf'
            print "running buildPdfFromPngs(%s, '%s')" % (str(largeDelayPngs),largeDelaysPdfname)
            buildPdfFromPngs(pnglist=largeDelayPngs, pdfname=largeDelaysPdfname)
        return delayJumps, delayMax, delayJumpsPdfname, largeDelaysPdfname

def membrane(vis):
    """
    This function was meant to be used with bandpass stability analysis so that
    a script could know which antennas have the new membrane.  It is probably
    not currently up-to-date.
    -Todd Hunter
    """
    mymsmd = createCasaTool(msmdtool)
    mymsmd.open(vis)
    antennaNames = mymsmd.antennanames(range(mymsmd.nantennas()))
    mymsmd.close()
    membraneType = {  # from Dashboard on Oct 11, 2013
        'CM01':'Goretex',
        'CM02':'Goretex',
        'CM03':'Goretex',
        'CM04':'Goretex',
        'CM05':'Goretex',
        'CM06':'Goretex',
        'CM07':'Goretex',
        'CM08':'Goretex',
        'CM09':'Goretex',
        'CM10':'Goretex',
        'CM11':'Goretex',
        'CM12':'Goretex',
        'DA41':'Goretex',
        'DA42':'Goretex',
        'DA43':'Goretex',
        'DA44':'Goretex',
        'DA45':'Goretex',
        'DA46':'Goretex',
        'DA47':'Goretex',
        'DA48':'Goretex',
        'DA49':'FEP',
        'DA50':'Goretex',
        'DA51':'Goretex',
        'DA52':'Goretex',
        'DA53':'Goretex',
        'DA54':'FEP',
        'DA55':'FEP',
        'DA56':'FEP',
        'DA57':'FEP',
        'DA58':'FEP',
        'DA59':'FEP',
        'DA60':'FEP',
        'DA61':'FEP',
        'DA62':'FEP',
        'DA63':'FEP',
        'DA64':'FEP',
        'DA65':'FEP',
        'DV01':'Goretex',
        'DV02':'Goretex',
        'DV03':'Goretex',
        'DV04':'Goretex',
        'DV05':'Goretex',
        'DV06':'Goretex',
        'DV07':'Goretex',
        'DV08':'FEP',
        'DV09':'FEP',
        'DV10':'Goretex',
        'DV11':'Goretex',
        'DV12':'FEP',
        'DV13':'Goretex',
        'DV14':'Goretex',
        'DV15':'Goretex',
        'DV16':'Goretex',
        'DV17':'Goretex',
        'DV18':'Goretex',
        'DV19':'Goretex',
        'DV20':'Goretex',
        'DV21':'Goretex',
        'DV22':'Goretex',
        'DV23':'Goretex',
        'DV24': 'FEP',
        'DV25': 'FEP',
        'PM01': 'Goretex',
        'PM02': 'Goretex',
        'PM03': 'FEP',
        'PM04': 'FEP'
        }
    fep = 0; fep7m = 0; fep12m = 0
    goretex = 0; goretex7m = 0; goretex12m = 0
    mydict = {}
    for antenna in antennaNames:
        mytype = membraneType[antenna]
        mydict[antenna] = mytype
        if (mytype.find('FEP')==0):
            fep += 1
            if (antenna.find('CM')==0):
                fep7m += 1
            else:
                fep12m += 1
        elif (mytype.find('Goretex')==0):
            goretex += 1
            if (antenna.find('CM')==0):
                goretex7m += 1
            else:
                goretex12m += 1
        else:
            print "Error in dictionary"
            return
    print "%d FEP, %d Goretex" % (fep,goretex)
    print " 7m: %d FEP, %d Goretex" % (fep7m,goretex7m)
    print "12m: %d FEP, %d Goretex" % (fep12m,goretex12m)
    return(mydict)

def fixpointing(vis):
    """
    Script extracted from CSV-2878 to convert MS POINTING table from commanded to actual
    coordinates using the ASDM_POINTING table.  This should only be run if the ASDM was
    loaded without the --with-pointing-correction option added to the trunk on Oct 25, 2013.
    Takeshi Nakazato
    """
    mytb = createCasaTool(tbtool)
    mytb.open(vis)
    keyword_names = mytb.keywordnames()

    # check whether ASDM_POINTING exists or not
    if not 'ASDM_POINTING' in keyword_names:
        print 'fixpointing: ASDM_POINTING is needed. Please re-import ASDM with asis option'
        mytb.close()
        return

    # check number of antennas
    mytb.open(os.path.join(vis, 'ANTENNA'))
    num_antenna = mytb.nrows()
    mytb.close()

    # for each antenna
    for antenna in xrange(num_antenna):
        # retrieve correction term from ASDM_POINTING
        mytb.open(os.path.join(vis, 'ASDM_POINTING'))
        tsel = mytb.query('antennaId == "Antenna_%s"'%(antenna), sortlist='timeOrigin')
        tracking_error = [tsel.getcell('encoder', irow) - tsel.getcell('pointingDirection', irow) for irow in xrange(tsel.nrows())]
        num_rows = sum([len(chunk) for chunk in tracking_error])
        tsel.close()
        mytb.close()

        # apply correction term to MS/POINTING
        mytb.open(os.path.join(vis, 'POINTING'), nomodify=False)
        tsel = mytb.query('ANTENNA_ID == %s'%(antenna), sortlist='TIME')

        if num_rows != tsel.nrows():
            print 'Antenna %s: Number of data records mismatch!'%(antenna)
            tsel.close()
            mytb.close()

        irow = 0
        for chunk in tracking_error:
            for _error in chunk:
                direction = tsel.getcell('DIRECTION', irow)
                direction[0][0] += _error[0]
                direction[1][0] += _error[1]
                tsel.putcell('DIRECTION', irow, direction)
                irow += 1
        tsel.close()
        mytb.close()
